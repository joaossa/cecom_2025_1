
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Master
 * 
 */
export type Master = $Result.DefaultSelection<Prisma.$MasterPayload>
/**
 * Model Paciente
 * 
 */
export type Paciente = $Result.DefaultSelection<Prisma.$PacientePayload>
/**
 * Model Profissional
 * 
 */
export type Profissional = $Result.DefaultSelection<Prisma.$ProfissionalPayload>
/**
 * Model Endereco
 * 
 */
export type Endereco = $Result.DefaultSelection<Prisma.$EnderecoPayload>
/**
 * Model EnderecoPaciente
 * 
 */
export type EnderecoPaciente = $Result.DefaultSelection<Prisma.$EnderecoPacientePayload>
/**
 * Model EnderecoProfissional
 * 
 */
export type EnderecoProfissional = $Result.DefaultSelection<Prisma.$EnderecoProfissionalPayload>
/**
 * Model Contato
 * 
 */
export type Contato = $Result.DefaultSelection<Prisma.$ContatoPayload>
/**
 * Model ContatoPaciente
 * 
 */
export type ContatoPaciente = $Result.DefaultSelection<Prisma.$ContatoPacientePayload>
/**
 * Model ContatoProfissional
 * 
 */
export type ContatoProfissional = $Result.DefaultSelection<Prisma.$ContatoProfissionalPayload>
/**
 * Model Atendimento
 * 
 */
export type Atendimento = $Result.DefaultSelection<Prisma.$AtendimentoPayload>
/**
 * Model Evolucao
 * 
 */
export type Evolucao = $Result.DefaultSelection<Prisma.$EvolucaoPayload>
/**
 * Model PessoaRelacionada
 * 
 */
export type PessoaRelacionada = $Result.DefaultSelection<Prisma.$PessoaRelacionadaPayload>
/**
 * Model ParentescoPaciente
 * 
 */
export type ParentescoPaciente = $Result.DefaultSelection<Prisma.$ParentescoPacientePayload>
/**
 * Model Plano
 * 
 */
export type Plano = $Result.DefaultSelection<Prisma.$PlanoPayload>
/**
 * Model Motivo
 * 
 */
export type Motivo = $Result.DefaultSelection<Prisma.$MotivoPayload>
/**
 * Model TipoProcedimento
 * 
 */
export type TipoProcedimento = $Result.DefaultSelection<Prisma.$TipoProcedimentoPayload>
/**
 * Model TipoEvolucaoSimples
 * 
 */
export type TipoEvolucaoSimples = $Result.DefaultSelection<Prisma.$TipoEvolucaoSimplesPayload>
/**
 * Model Pais
 * 
 */
export type Pais = $Result.DefaultSelection<Prisma.$PaisPayload>
/**
 * Model UnidadeFederacao
 * 
 */
export type UnidadeFederacao = $Result.DefaultSelection<Prisma.$UnidadeFederacaoPayload>
/**
 * Model Cidade
 * 
 */
export type Cidade = $Result.DefaultSelection<Prisma.$CidadePayload>
/**
 * Model Escolaridade
 * 
 */
export type Escolaridade = $Result.DefaultSelection<Prisma.$EscolaridadePayload>
/**
 * Model Ocupacao
 * 
 */
export type Ocupacao = $Result.DefaultSelection<Prisma.$OcupacaoPayload>
/**
 * Model Distrito
 * 
 */
export type Distrito = $Result.DefaultSelection<Prisma.$DistritoPayload>
/**
 * Model Bairro
 * 
 */
export type Bairro = $Result.DefaultSelection<Prisma.$BairroPayload>
/**
 * Model EnderecoPessoaRelacionada
 * 
 */
export type EnderecoPessoaRelacionada = $Result.DefaultSelection<Prisma.$EnderecoPessoaRelacionadaPayload>
/**
 * Model Cid
 * 
 */
export type Cid = $Result.DefaultSelection<Prisma.$CidPayload>
/**
 * Model Dsm
 * 
 */
export type Dsm = $Result.DefaultSelection<Prisma.$DsmPayload>
/**
 * Model TipoEvolucaoClinica
 * 
 */
export type TipoEvolucaoClinica = $Result.DefaultSelection<Prisma.$TipoEvolucaoClinicaPayload>
/**
 * Model EvolucaoCid
 * 
 */
export type EvolucaoCid = $Result.DefaultSelection<Prisma.$EvolucaoCidPayload>
/**
 * Model EvolucaoDsm
 * 
 */
export type EvolucaoDsm = $Result.DefaultSelection<Prisma.$EvolucaoDsmPayload>
/**
 * Model SinaisVitais
 * 
 */
export type SinaisVitais = $Result.DefaultSelection<Prisma.$SinaisVitaisPayload>
/**
 * Model EscalaDor
 * 
 */
export type EscalaDor = $Result.DefaultSelection<Prisma.$EscalaDorPayload>
/**
 * Model Glasgow
 * 
 */
export type Glasgow = $Result.DefaultSelection<Prisma.$GlasgowPayload>
/**
 * Model AfericaoClinica
 * 
 */
export type AfericaoClinica = $Result.DefaultSelection<Prisma.$AfericaoClinicaPayload>
/**
 * Model EvaDor
 * 
 */
export type EvaDor = $Result.DefaultSelection<Prisma.$EvaDorPayload>
/**
 * Model UsuarioAuth
 * 
 */
export type UsuarioAuth = $Result.DefaultSelection<Prisma.$UsuarioAuthPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SimNao: {
  S: 'S',
  N: 'N'
};

export type SimNao = (typeof SimNao)[keyof typeof SimNao]


export const Sexo: {
  M: 'M',
  F: 'F',
  I: 'I'
};

export type Sexo = (typeof Sexo)[keyof typeof Sexo]


export const VersaoCid: {
  c9: 'c9',
  c10: 'c10'
};

export type VersaoCid = (typeof VersaoCid)[keyof typeof VersaoCid]


export const VersaoDsm: {
  d4: 'd4',
  d5: 'd5'
};

export type VersaoDsm = (typeof VersaoDsm)[keyof typeof VersaoDsm]


export const HumorIntensidade: {
  NIVEL_1: 'NIVEL_1',
  NIVEL_2: 'NIVEL_2',
  NIVEL_3: 'NIVEL_3',
  NIVEL_4: 'NIVEL_4',
  NIVEL_5: 'NIVEL_5'
};

export type HumorIntensidade = (typeof HumorIntensidade)[keyof typeof HumorIntensidade]


export const OrigemAfericao: {
  MANUAL: 'MANUAL',
  OXIMETRO: 'OXIMETRO',
  BALANCA: 'BALANCA',
  RELOGIO_INTELIGENTE: 'RELOGIO_INTELIGENTE',
  MONITOR_HOSPITALAR: 'MONITOR_HOSPITALAR'
};

export type OrigemAfericao = (typeof OrigemAfericao)[keyof typeof OrigemAfericao]


export const PosicaoPaciente: {
  SENTADO: 'SENTADO',
  DEITADO: 'DEITADO',
  ORTOSTATICO: 'ORTOSTATICO',
  EM_PE: 'EM_PE'
};

export type PosicaoPaciente = (typeof PosicaoPaciente)[keyof typeof PosicaoPaciente]


export const TipoFone: {
  R: 'R',
  T: 'T',
  C: 'C',
  P: 'P'
};

export type TipoFone = (typeof TipoFone)[keyof typeof TipoFone]


export const TipoParentesco: {
  P: 'P',
  M: 'M',
  T: 'T',
  F: 'F',
  C: 'C',
  O: 'O',
  R: 'R'
};

export type TipoParentesco = (typeof TipoParentesco)[keyof typeof TipoParentesco]


export const RoleAuth: {
  ADMIN: 'ADMIN',
  PROFISSIONAL: 'PROFISSIONAL',
  LEITURA: 'LEITURA'
};

export type RoleAuth = (typeof RoleAuth)[keyof typeof RoleAuth]

}

export type SimNao = $Enums.SimNao

export const SimNao: typeof $Enums.SimNao

export type Sexo = $Enums.Sexo

export const Sexo: typeof $Enums.Sexo

export type VersaoCid = $Enums.VersaoCid

export const VersaoCid: typeof $Enums.VersaoCid

export type VersaoDsm = $Enums.VersaoDsm

export const VersaoDsm: typeof $Enums.VersaoDsm

export type HumorIntensidade = $Enums.HumorIntensidade

export const HumorIntensidade: typeof $Enums.HumorIntensidade

export type OrigemAfericao = $Enums.OrigemAfericao

export const OrigemAfericao: typeof $Enums.OrigemAfericao

export type PosicaoPaciente = $Enums.PosicaoPaciente

export const PosicaoPaciente: typeof $Enums.PosicaoPaciente

export type TipoFone = $Enums.TipoFone

export const TipoFone: typeof $Enums.TipoFone

export type TipoParentesco = $Enums.TipoParentesco

export const TipoParentesco: typeof $Enums.TipoParentesco

export type RoleAuth = $Enums.RoleAuth

export const RoleAuth: typeof $Enums.RoleAuth

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Masters
 * const masters = await prisma.master.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Masters
   * const masters = await prisma.master.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.master`: Exposes CRUD operations for the **Master** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Masters
    * const masters = await prisma.master.findMany()
    * ```
    */
  get master(): Prisma.MasterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paciente`: Exposes CRUD operations for the **Paciente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pacientes
    * const pacientes = await prisma.paciente.findMany()
    * ```
    */
  get paciente(): Prisma.PacienteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profissional`: Exposes CRUD operations for the **Profissional** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profissionals
    * const profissionals = await prisma.profissional.findMany()
    * ```
    */
  get profissional(): Prisma.ProfissionalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.endereco`: Exposes CRUD operations for the **Endereco** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enderecos
    * const enderecos = await prisma.endereco.findMany()
    * ```
    */
  get endereco(): Prisma.EnderecoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enderecoPaciente`: Exposes CRUD operations for the **EnderecoPaciente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EnderecoPacientes
    * const enderecoPacientes = await prisma.enderecoPaciente.findMany()
    * ```
    */
  get enderecoPaciente(): Prisma.EnderecoPacienteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enderecoProfissional`: Exposes CRUD operations for the **EnderecoProfissional** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EnderecoProfissionals
    * const enderecoProfissionals = await prisma.enderecoProfissional.findMany()
    * ```
    */
  get enderecoProfissional(): Prisma.EnderecoProfissionalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contato`: Exposes CRUD operations for the **Contato** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contatoes
    * const contatoes = await prisma.contato.findMany()
    * ```
    */
  get contato(): Prisma.ContatoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contatoPaciente`: Exposes CRUD operations for the **ContatoPaciente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContatoPacientes
    * const contatoPacientes = await prisma.contatoPaciente.findMany()
    * ```
    */
  get contatoPaciente(): Prisma.ContatoPacienteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contatoProfissional`: Exposes CRUD operations for the **ContatoProfissional** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContatoProfissionals
    * const contatoProfissionals = await prisma.contatoProfissional.findMany()
    * ```
    */
  get contatoProfissional(): Prisma.ContatoProfissionalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.atendimento`: Exposes CRUD operations for the **Atendimento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Atendimentos
    * const atendimentos = await prisma.atendimento.findMany()
    * ```
    */
  get atendimento(): Prisma.AtendimentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evolucao`: Exposes CRUD operations for the **Evolucao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evolucaos
    * const evolucaos = await prisma.evolucao.findMany()
    * ```
    */
  get evolucao(): Prisma.EvolucaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pessoaRelacionada`: Exposes CRUD operations for the **PessoaRelacionada** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PessoaRelacionadas
    * const pessoaRelacionadas = await prisma.pessoaRelacionada.findMany()
    * ```
    */
  get pessoaRelacionada(): Prisma.PessoaRelacionadaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parentescoPaciente`: Exposes CRUD operations for the **ParentescoPaciente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParentescoPacientes
    * const parentescoPacientes = await prisma.parentescoPaciente.findMany()
    * ```
    */
  get parentescoPaciente(): Prisma.ParentescoPacienteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plano`: Exposes CRUD operations for the **Plano** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Planos
    * const planos = await prisma.plano.findMany()
    * ```
    */
  get plano(): Prisma.PlanoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.motivo`: Exposes CRUD operations for the **Motivo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Motivos
    * const motivos = await prisma.motivo.findMany()
    * ```
    */
  get motivo(): Prisma.MotivoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoProcedimento`: Exposes CRUD operations for the **TipoProcedimento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoProcedimentos
    * const tipoProcedimentos = await prisma.tipoProcedimento.findMany()
    * ```
    */
  get tipoProcedimento(): Prisma.TipoProcedimentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoEvolucaoSimples`: Exposes CRUD operations for the **TipoEvolucaoSimples** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoEvolucaoSimples
    * const tipoEvolucaoSimples = await prisma.tipoEvolucaoSimples.findMany()
    * ```
    */
  get tipoEvolucaoSimples(): Prisma.TipoEvolucaoSimplesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pais`: Exposes CRUD operations for the **Pais** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pais
    * const pais = await prisma.pais.findMany()
    * ```
    */
  get pais(): Prisma.PaisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unidadeFederacao`: Exposes CRUD operations for the **UnidadeFederacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnidadeFederacaos
    * const unidadeFederacaos = await prisma.unidadeFederacao.findMany()
    * ```
    */
  get unidadeFederacao(): Prisma.UnidadeFederacaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cidade`: Exposes CRUD operations for the **Cidade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cidades
    * const cidades = await prisma.cidade.findMany()
    * ```
    */
  get cidade(): Prisma.CidadeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.escolaridade`: Exposes CRUD operations for the **Escolaridade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Escolaridades
    * const escolaridades = await prisma.escolaridade.findMany()
    * ```
    */
  get escolaridade(): Prisma.EscolaridadeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ocupacao`: Exposes CRUD operations for the **Ocupacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ocupacaos
    * const ocupacaos = await prisma.ocupacao.findMany()
    * ```
    */
  get ocupacao(): Prisma.OcupacaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.distrito`: Exposes CRUD operations for the **Distrito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Distritos
    * const distritos = await prisma.distrito.findMany()
    * ```
    */
  get distrito(): Prisma.DistritoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bairro`: Exposes CRUD operations for the **Bairro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bairros
    * const bairros = await prisma.bairro.findMany()
    * ```
    */
  get bairro(): Prisma.BairroDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enderecoPessoaRelacionada`: Exposes CRUD operations for the **EnderecoPessoaRelacionada** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EnderecoPessoaRelacionadas
    * const enderecoPessoaRelacionadas = await prisma.enderecoPessoaRelacionada.findMany()
    * ```
    */
  get enderecoPessoaRelacionada(): Prisma.EnderecoPessoaRelacionadaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cid`: Exposes CRUD operations for the **Cid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cids
    * const cids = await prisma.cid.findMany()
    * ```
    */
  get cid(): Prisma.CidDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dsm`: Exposes CRUD operations for the **Dsm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dsms
    * const dsms = await prisma.dsm.findMany()
    * ```
    */
  get dsm(): Prisma.DsmDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoEvolucaoClinica`: Exposes CRUD operations for the **TipoEvolucaoClinica** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoEvolucaoClinicas
    * const tipoEvolucaoClinicas = await prisma.tipoEvolucaoClinica.findMany()
    * ```
    */
  get tipoEvolucaoClinica(): Prisma.TipoEvolucaoClinicaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evolucaoCid`: Exposes CRUD operations for the **EvolucaoCid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvolucaoCids
    * const evolucaoCids = await prisma.evolucaoCid.findMany()
    * ```
    */
  get evolucaoCid(): Prisma.EvolucaoCidDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evolucaoDsm`: Exposes CRUD operations for the **EvolucaoDsm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvolucaoDsms
    * const evolucaoDsms = await prisma.evolucaoDsm.findMany()
    * ```
    */
  get evolucaoDsm(): Prisma.EvolucaoDsmDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sinaisVitais`: Exposes CRUD operations for the **SinaisVitais** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SinaisVitais
    * const sinaisVitais = await prisma.sinaisVitais.findMany()
    * ```
    */
  get sinaisVitais(): Prisma.SinaisVitaisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.escalaDor`: Exposes CRUD operations for the **EscalaDor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EscalaDors
    * const escalaDors = await prisma.escalaDor.findMany()
    * ```
    */
  get escalaDor(): Prisma.EscalaDorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.glasgow`: Exposes CRUD operations for the **Glasgow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Glasgows
    * const glasgows = await prisma.glasgow.findMany()
    * ```
    */
  get glasgow(): Prisma.GlasgowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.afericaoClinica`: Exposes CRUD operations for the **AfericaoClinica** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AfericaoClinicas
    * const afericaoClinicas = await prisma.afericaoClinica.findMany()
    * ```
    */
  get afericaoClinica(): Prisma.AfericaoClinicaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evaDor`: Exposes CRUD operations for the **EvaDor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvaDors
    * const evaDors = await prisma.evaDor.findMany()
    * ```
    */
  get evaDor(): Prisma.EvaDorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuarioAuth`: Exposes CRUD operations for the **UsuarioAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsuarioAuths
    * const usuarioAuths = await prisma.usuarioAuth.findMany()
    * ```
    */
  get usuarioAuth(): Prisma.UsuarioAuthDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Master: 'Master',
    Paciente: 'Paciente',
    Profissional: 'Profissional',
    Endereco: 'Endereco',
    EnderecoPaciente: 'EnderecoPaciente',
    EnderecoProfissional: 'EnderecoProfissional',
    Contato: 'Contato',
    ContatoPaciente: 'ContatoPaciente',
    ContatoProfissional: 'ContatoProfissional',
    Atendimento: 'Atendimento',
    Evolucao: 'Evolucao',
    PessoaRelacionada: 'PessoaRelacionada',
    ParentescoPaciente: 'ParentescoPaciente',
    Plano: 'Plano',
    Motivo: 'Motivo',
    TipoProcedimento: 'TipoProcedimento',
    TipoEvolucaoSimples: 'TipoEvolucaoSimples',
    Pais: 'Pais',
    UnidadeFederacao: 'UnidadeFederacao',
    Cidade: 'Cidade',
    Escolaridade: 'Escolaridade',
    Ocupacao: 'Ocupacao',
    Distrito: 'Distrito',
    Bairro: 'Bairro',
    EnderecoPessoaRelacionada: 'EnderecoPessoaRelacionada',
    Cid: 'Cid',
    Dsm: 'Dsm',
    TipoEvolucaoClinica: 'TipoEvolucaoClinica',
    EvolucaoCid: 'EvolucaoCid',
    EvolucaoDsm: 'EvolucaoDsm',
    SinaisVitais: 'SinaisVitais',
    EscalaDor: 'EscalaDor',
    Glasgow: 'Glasgow',
    AfericaoClinica: 'AfericaoClinica',
    EvaDor: 'EvaDor',
    UsuarioAuth: 'UsuarioAuth'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "master" | "paciente" | "profissional" | "endereco" | "enderecoPaciente" | "enderecoProfissional" | "contato" | "contatoPaciente" | "contatoProfissional" | "atendimento" | "evolucao" | "pessoaRelacionada" | "parentescoPaciente" | "plano" | "motivo" | "tipoProcedimento" | "tipoEvolucaoSimples" | "pais" | "unidadeFederacao" | "cidade" | "escolaridade" | "ocupacao" | "distrito" | "bairro" | "enderecoPessoaRelacionada" | "cid" | "dsm" | "tipoEvolucaoClinica" | "evolucaoCid" | "evolucaoDsm" | "sinaisVitais" | "escalaDor" | "glasgow" | "afericaoClinica" | "evaDor" | "usuarioAuth"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Master: {
        payload: Prisma.$MasterPayload<ExtArgs>
        fields: Prisma.MasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterPayload>
          }
          findFirst: {
            args: Prisma.MasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterPayload>
          }
          findMany: {
            args: Prisma.MasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterPayload>[]
          }
          create: {
            args: Prisma.MasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterPayload>
          }
          createMany: {
            args: Prisma.MasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterPayload>[]
          }
          delete: {
            args: Prisma.MasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterPayload>
          }
          update: {
            args: Prisma.MasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterPayload>
          }
          deleteMany: {
            args: Prisma.MasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MasterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterPayload>[]
          }
          upsert: {
            args: Prisma.MasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterPayload>
          }
          aggregate: {
            args: Prisma.MasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaster>
          }
          groupBy: {
            args: Prisma.MasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<MasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.MasterCountArgs<ExtArgs>
            result: $Utils.Optional<MasterCountAggregateOutputType> | number
          }
        }
      }
      Paciente: {
        payload: Prisma.$PacientePayload<ExtArgs>
        fields: Prisma.PacienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PacienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PacienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>
          }
          findFirst: {
            args: Prisma.PacienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PacienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>
          }
          findMany: {
            args: Prisma.PacienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>[]
          }
          create: {
            args: Prisma.PacienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>
          }
          createMany: {
            args: Prisma.PacienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PacienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>[]
          }
          delete: {
            args: Prisma.PacienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>
          }
          update: {
            args: Prisma.PacienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>
          }
          deleteMany: {
            args: Prisma.PacienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PacienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PacienteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>[]
          }
          upsert: {
            args: Prisma.PacienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PacientePayload>
          }
          aggregate: {
            args: Prisma.PacienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaciente>
          }
          groupBy: {
            args: Prisma.PacienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PacienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.PacienteCountArgs<ExtArgs>
            result: $Utils.Optional<PacienteCountAggregateOutputType> | number
          }
        }
      }
      Profissional: {
        payload: Prisma.$ProfissionalPayload<ExtArgs>
        fields: Prisma.ProfissionalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfissionalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfissionalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>
          }
          findFirst: {
            args: Prisma.ProfissionalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfissionalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>
          }
          findMany: {
            args: Prisma.ProfissionalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>[]
          }
          create: {
            args: Prisma.ProfissionalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>
          }
          createMany: {
            args: Prisma.ProfissionalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfissionalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>[]
          }
          delete: {
            args: Prisma.ProfissionalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>
          }
          update: {
            args: Prisma.ProfissionalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>
          }
          deleteMany: {
            args: Prisma.ProfissionalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfissionalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfissionalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>[]
          }
          upsert: {
            args: Prisma.ProfissionalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>
          }
          aggregate: {
            args: Prisma.ProfissionalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfissional>
          }
          groupBy: {
            args: Prisma.ProfissionalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfissionalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfissionalCountArgs<ExtArgs>
            result: $Utils.Optional<ProfissionalCountAggregateOutputType> | number
          }
        }
      }
      Endereco: {
        payload: Prisma.$EnderecoPayload<ExtArgs>
        fields: Prisma.EnderecoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnderecoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnderecoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          findFirst: {
            args: Prisma.EnderecoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnderecoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          findMany: {
            args: Prisma.EnderecoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>[]
          }
          create: {
            args: Prisma.EnderecoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          createMany: {
            args: Prisma.EnderecoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnderecoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>[]
          }
          delete: {
            args: Prisma.EnderecoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          update: {
            args: Prisma.EnderecoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          deleteMany: {
            args: Prisma.EnderecoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnderecoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnderecoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>[]
          }
          upsert: {
            args: Prisma.EnderecoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          aggregate: {
            args: Prisma.EnderecoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEndereco>
          }
          groupBy: {
            args: Prisma.EnderecoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnderecoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnderecoCountArgs<ExtArgs>
            result: $Utils.Optional<EnderecoCountAggregateOutputType> | number
          }
        }
      }
      EnderecoPaciente: {
        payload: Prisma.$EnderecoPacientePayload<ExtArgs>
        fields: Prisma.EnderecoPacienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnderecoPacienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPacientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnderecoPacienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPacientePayload>
          }
          findFirst: {
            args: Prisma.EnderecoPacienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPacientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnderecoPacienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPacientePayload>
          }
          findMany: {
            args: Prisma.EnderecoPacienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPacientePayload>[]
          }
          create: {
            args: Prisma.EnderecoPacienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPacientePayload>
          }
          createMany: {
            args: Prisma.EnderecoPacienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnderecoPacienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPacientePayload>[]
          }
          delete: {
            args: Prisma.EnderecoPacienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPacientePayload>
          }
          update: {
            args: Prisma.EnderecoPacienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPacientePayload>
          }
          deleteMany: {
            args: Prisma.EnderecoPacienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnderecoPacienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnderecoPacienteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPacientePayload>[]
          }
          upsert: {
            args: Prisma.EnderecoPacienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPacientePayload>
          }
          aggregate: {
            args: Prisma.EnderecoPacienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnderecoPaciente>
          }
          groupBy: {
            args: Prisma.EnderecoPacienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnderecoPacienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnderecoPacienteCountArgs<ExtArgs>
            result: $Utils.Optional<EnderecoPacienteCountAggregateOutputType> | number
          }
        }
      }
      EnderecoProfissional: {
        payload: Prisma.$EnderecoProfissionalPayload<ExtArgs>
        fields: Prisma.EnderecoProfissionalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnderecoProfissionalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoProfissionalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnderecoProfissionalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoProfissionalPayload>
          }
          findFirst: {
            args: Prisma.EnderecoProfissionalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoProfissionalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnderecoProfissionalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoProfissionalPayload>
          }
          findMany: {
            args: Prisma.EnderecoProfissionalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoProfissionalPayload>[]
          }
          create: {
            args: Prisma.EnderecoProfissionalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoProfissionalPayload>
          }
          createMany: {
            args: Prisma.EnderecoProfissionalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnderecoProfissionalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoProfissionalPayload>[]
          }
          delete: {
            args: Prisma.EnderecoProfissionalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoProfissionalPayload>
          }
          update: {
            args: Prisma.EnderecoProfissionalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoProfissionalPayload>
          }
          deleteMany: {
            args: Prisma.EnderecoProfissionalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnderecoProfissionalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnderecoProfissionalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoProfissionalPayload>[]
          }
          upsert: {
            args: Prisma.EnderecoProfissionalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoProfissionalPayload>
          }
          aggregate: {
            args: Prisma.EnderecoProfissionalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnderecoProfissional>
          }
          groupBy: {
            args: Prisma.EnderecoProfissionalGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnderecoProfissionalGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnderecoProfissionalCountArgs<ExtArgs>
            result: $Utils.Optional<EnderecoProfissionalCountAggregateOutputType> | number
          }
        }
      }
      Contato: {
        payload: Prisma.$ContatoPayload<ExtArgs>
        fields: Prisma.ContatoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContatoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContatoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPayload>
          }
          findFirst: {
            args: Prisma.ContatoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContatoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPayload>
          }
          findMany: {
            args: Prisma.ContatoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPayload>[]
          }
          create: {
            args: Prisma.ContatoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPayload>
          }
          createMany: {
            args: Prisma.ContatoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContatoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPayload>[]
          }
          delete: {
            args: Prisma.ContatoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPayload>
          }
          update: {
            args: Prisma.ContatoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPayload>
          }
          deleteMany: {
            args: Prisma.ContatoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContatoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContatoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPayload>[]
          }
          upsert: {
            args: Prisma.ContatoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPayload>
          }
          aggregate: {
            args: Prisma.ContatoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContato>
          }
          groupBy: {
            args: Prisma.ContatoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContatoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContatoCountArgs<ExtArgs>
            result: $Utils.Optional<ContatoCountAggregateOutputType> | number
          }
        }
      }
      ContatoPaciente: {
        payload: Prisma.$ContatoPacientePayload<ExtArgs>
        fields: Prisma.ContatoPacienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContatoPacienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPacientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContatoPacienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPacientePayload>
          }
          findFirst: {
            args: Prisma.ContatoPacienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPacientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContatoPacienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPacientePayload>
          }
          findMany: {
            args: Prisma.ContatoPacienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPacientePayload>[]
          }
          create: {
            args: Prisma.ContatoPacienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPacientePayload>
          }
          createMany: {
            args: Prisma.ContatoPacienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContatoPacienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPacientePayload>[]
          }
          delete: {
            args: Prisma.ContatoPacienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPacientePayload>
          }
          update: {
            args: Prisma.ContatoPacienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPacientePayload>
          }
          deleteMany: {
            args: Prisma.ContatoPacienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContatoPacienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContatoPacienteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPacientePayload>[]
          }
          upsert: {
            args: Prisma.ContatoPacienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoPacientePayload>
          }
          aggregate: {
            args: Prisma.ContatoPacienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContatoPaciente>
          }
          groupBy: {
            args: Prisma.ContatoPacienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContatoPacienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContatoPacienteCountArgs<ExtArgs>
            result: $Utils.Optional<ContatoPacienteCountAggregateOutputType> | number
          }
        }
      }
      ContatoProfissional: {
        payload: Prisma.$ContatoProfissionalPayload<ExtArgs>
        fields: Prisma.ContatoProfissionalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContatoProfissionalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoProfissionalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContatoProfissionalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoProfissionalPayload>
          }
          findFirst: {
            args: Prisma.ContatoProfissionalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoProfissionalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContatoProfissionalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoProfissionalPayload>
          }
          findMany: {
            args: Prisma.ContatoProfissionalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoProfissionalPayload>[]
          }
          create: {
            args: Prisma.ContatoProfissionalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoProfissionalPayload>
          }
          createMany: {
            args: Prisma.ContatoProfissionalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContatoProfissionalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoProfissionalPayload>[]
          }
          delete: {
            args: Prisma.ContatoProfissionalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoProfissionalPayload>
          }
          update: {
            args: Prisma.ContatoProfissionalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoProfissionalPayload>
          }
          deleteMany: {
            args: Prisma.ContatoProfissionalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContatoProfissionalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContatoProfissionalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoProfissionalPayload>[]
          }
          upsert: {
            args: Prisma.ContatoProfissionalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContatoProfissionalPayload>
          }
          aggregate: {
            args: Prisma.ContatoProfissionalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContatoProfissional>
          }
          groupBy: {
            args: Prisma.ContatoProfissionalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContatoProfissionalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContatoProfissionalCountArgs<ExtArgs>
            result: $Utils.Optional<ContatoProfissionalCountAggregateOutputType> | number
          }
        }
      }
      Atendimento: {
        payload: Prisma.$AtendimentoPayload<ExtArgs>
        fields: Prisma.AtendimentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AtendimentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtendimentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AtendimentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtendimentoPayload>
          }
          findFirst: {
            args: Prisma.AtendimentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtendimentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AtendimentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtendimentoPayload>
          }
          findMany: {
            args: Prisma.AtendimentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtendimentoPayload>[]
          }
          create: {
            args: Prisma.AtendimentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtendimentoPayload>
          }
          createMany: {
            args: Prisma.AtendimentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AtendimentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtendimentoPayload>[]
          }
          delete: {
            args: Prisma.AtendimentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtendimentoPayload>
          }
          update: {
            args: Prisma.AtendimentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtendimentoPayload>
          }
          deleteMany: {
            args: Prisma.AtendimentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AtendimentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AtendimentoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtendimentoPayload>[]
          }
          upsert: {
            args: Prisma.AtendimentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AtendimentoPayload>
          }
          aggregate: {
            args: Prisma.AtendimentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAtendimento>
          }
          groupBy: {
            args: Prisma.AtendimentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AtendimentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AtendimentoCountArgs<ExtArgs>
            result: $Utils.Optional<AtendimentoCountAggregateOutputType> | number
          }
        }
      }
      Evolucao: {
        payload: Prisma.$EvolucaoPayload<ExtArgs>
        fields: Prisma.EvolucaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvolucaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvolucaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoPayload>
          }
          findFirst: {
            args: Prisma.EvolucaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvolucaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoPayload>
          }
          findMany: {
            args: Prisma.EvolucaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoPayload>[]
          }
          create: {
            args: Prisma.EvolucaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoPayload>
          }
          createMany: {
            args: Prisma.EvolucaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvolucaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoPayload>[]
          }
          delete: {
            args: Prisma.EvolucaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoPayload>
          }
          update: {
            args: Prisma.EvolucaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoPayload>
          }
          deleteMany: {
            args: Prisma.EvolucaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvolucaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvolucaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoPayload>[]
          }
          upsert: {
            args: Prisma.EvolucaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoPayload>
          }
          aggregate: {
            args: Prisma.EvolucaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvolucao>
          }
          groupBy: {
            args: Prisma.EvolucaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvolucaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvolucaoCountArgs<ExtArgs>
            result: $Utils.Optional<EvolucaoCountAggregateOutputType> | number
          }
        }
      }
      PessoaRelacionada: {
        payload: Prisma.$PessoaRelacionadaPayload<ExtArgs>
        fields: Prisma.PessoaRelacionadaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PessoaRelacionadaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaRelacionadaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PessoaRelacionadaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaRelacionadaPayload>
          }
          findFirst: {
            args: Prisma.PessoaRelacionadaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaRelacionadaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PessoaRelacionadaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaRelacionadaPayload>
          }
          findMany: {
            args: Prisma.PessoaRelacionadaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaRelacionadaPayload>[]
          }
          create: {
            args: Prisma.PessoaRelacionadaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaRelacionadaPayload>
          }
          createMany: {
            args: Prisma.PessoaRelacionadaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PessoaRelacionadaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaRelacionadaPayload>[]
          }
          delete: {
            args: Prisma.PessoaRelacionadaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaRelacionadaPayload>
          }
          update: {
            args: Prisma.PessoaRelacionadaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaRelacionadaPayload>
          }
          deleteMany: {
            args: Prisma.PessoaRelacionadaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PessoaRelacionadaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PessoaRelacionadaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaRelacionadaPayload>[]
          }
          upsert: {
            args: Prisma.PessoaRelacionadaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaRelacionadaPayload>
          }
          aggregate: {
            args: Prisma.PessoaRelacionadaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePessoaRelacionada>
          }
          groupBy: {
            args: Prisma.PessoaRelacionadaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PessoaRelacionadaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PessoaRelacionadaCountArgs<ExtArgs>
            result: $Utils.Optional<PessoaRelacionadaCountAggregateOutputType> | number
          }
        }
      }
      ParentescoPaciente: {
        payload: Prisma.$ParentescoPacientePayload<ExtArgs>
        fields: Prisma.ParentescoPacienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentescoPacienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentescoPacientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentescoPacienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentescoPacientePayload>
          }
          findFirst: {
            args: Prisma.ParentescoPacienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentescoPacientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentescoPacienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentescoPacientePayload>
          }
          findMany: {
            args: Prisma.ParentescoPacienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentescoPacientePayload>[]
          }
          create: {
            args: Prisma.ParentescoPacienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentescoPacientePayload>
          }
          createMany: {
            args: Prisma.ParentescoPacienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParentescoPacienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentescoPacientePayload>[]
          }
          delete: {
            args: Prisma.ParentescoPacienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentescoPacientePayload>
          }
          update: {
            args: Prisma.ParentescoPacienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentescoPacientePayload>
          }
          deleteMany: {
            args: Prisma.ParentescoPacienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentescoPacienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParentescoPacienteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentescoPacientePayload>[]
          }
          upsert: {
            args: Prisma.ParentescoPacienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentescoPacientePayload>
          }
          aggregate: {
            args: Prisma.ParentescoPacienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParentescoPaciente>
          }
          groupBy: {
            args: Prisma.ParentescoPacienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentescoPacienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentescoPacienteCountArgs<ExtArgs>
            result: $Utils.Optional<ParentescoPacienteCountAggregateOutputType> | number
          }
        }
      }
      Plano: {
        payload: Prisma.$PlanoPayload<ExtArgs>
        fields: Prisma.PlanoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoPayload>
          }
          findFirst: {
            args: Prisma.PlanoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoPayload>
          }
          findMany: {
            args: Prisma.PlanoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoPayload>[]
          }
          create: {
            args: Prisma.PlanoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoPayload>
          }
          createMany: {
            args: Prisma.PlanoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoPayload>[]
          }
          delete: {
            args: Prisma.PlanoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoPayload>
          }
          update: {
            args: Prisma.PlanoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoPayload>
          }
          deleteMany: {
            args: Prisma.PlanoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoPayload>[]
          }
          upsert: {
            args: Prisma.PlanoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanoPayload>
          }
          aggregate: {
            args: Prisma.PlanoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlano>
          }
          groupBy: {
            args: Prisma.PlanoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanoCountArgs<ExtArgs>
            result: $Utils.Optional<PlanoCountAggregateOutputType> | number
          }
        }
      }
      Motivo: {
        payload: Prisma.$MotivoPayload<ExtArgs>
        fields: Prisma.MotivoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MotivoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotivoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MotivoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotivoPayload>
          }
          findFirst: {
            args: Prisma.MotivoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotivoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MotivoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotivoPayload>
          }
          findMany: {
            args: Prisma.MotivoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotivoPayload>[]
          }
          create: {
            args: Prisma.MotivoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotivoPayload>
          }
          createMany: {
            args: Prisma.MotivoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MotivoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotivoPayload>[]
          }
          delete: {
            args: Prisma.MotivoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotivoPayload>
          }
          update: {
            args: Prisma.MotivoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotivoPayload>
          }
          deleteMany: {
            args: Prisma.MotivoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MotivoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MotivoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotivoPayload>[]
          }
          upsert: {
            args: Prisma.MotivoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotivoPayload>
          }
          aggregate: {
            args: Prisma.MotivoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMotivo>
          }
          groupBy: {
            args: Prisma.MotivoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MotivoGroupByOutputType>[]
          }
          count: {
            args: Prisma.MotivoCountArgs<ExtArgs>
            result: $Utils.Optional<MotivoCountAggregateOutputType> | number
          }
        }
      }
      TipoProcedimento: {
        payload: Prisma.$TipoProcedimentoPayload<ExtArgs>
        fields: Prisma.TipoProcedimentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoProcedimentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProcedimentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoProcedimentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProcedimentoPayload>
          }
          findFirst: {
            args: Prisma.TipoProcedimentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProcedimentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoProcedimentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProcedimentoPayload>
          }
          findMany: {
            args: Prisma.TipoProcedimentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProcedimentoPayload>[]
          }
          create: {
            args: Prisma.TipoProcedimentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProcedimentoPayload>
          }
          createMany: {
            args: Prisma.TipoProcedimentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoProcedimentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProcedimentoPayload>[]
          }
          delete: {
            args: Prisma.TipoProcedimentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProcedimentoPayload>
          }
          update: {
            args: Prisma.TipoProcedimentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProcedimentoPayload>
          }
          deleteMany: {
            args: Prisma.TipoProcedimentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoProcedimentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoProcedimentoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProcedimentoPayload>[]
          }
          upsert: {
            args: Prisma.TipoProcedimentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoProcedimentoPayload>
          }
          aggregate: {
            args: Prisma.TipoProcedimentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoProcedimento>
          }
          groupBy: {
            args: Prisma.TipoProcedimentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoProcedimentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoProcedimentoCountArgs<ExtArgs>
            result: $Utils.Optional<TipoProcedimentoCountAggregateOutputType> | number
          }
        }
      }
      TipoEvolucaoSimples: {
        payload: Prisma.$TipoEvolucaoSimplesPayload<ExtArgs>
        fields: Prisma.TipoEvolucaoSimplesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoEvolucaoSimplesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoSimplesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoEvolucaoSimplesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoSimplesPayload>
          }
          findFirst: {
            args: Prisma.TipoEvolucaoSimplesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoSimplesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoEvolucaoSimplesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoSimplesPayload>
          }
          findMany: {
            args: Prisma.TipoEvolucaoSimplesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoSimplesPayload>[]
          }
          create: {
            args: Prisma.TipoEvolucaoSimplesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoSimplesPayload>
          }
          createMany: {
            args: Prisma.TipoEvolucaoSimplesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoEvolucaoSimplesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoSimplesPayload>[]
          }
          delete: {
            args: Prisma.TipoEvolucaoSimplesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoSimplesPayload>
          }
          update: {
            args: Prisma.TipoEvolucaoSimplesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoSimplesPayload>
          }
          deleteMany: {
            args: Prisma.TipoEvolucaoSimplesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoEvolucaoSimplesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoEvolucaoSimplesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoSimplesPayload>[]
          }
          upsert: {
            args: Prisma.TipoEvolucaoSimplesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoSimplesPayload>
          }
          aggregate: {
            args: Prisma.TipoEvolucaoSimplesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoEvolucaoSimples>
          }
          groupBy: {
            args: Prisma.TipoEvolucaoSimplesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoEvolucaoSimplesGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoEvolucaoSimplesCountArgs<ExtArgs>
            result: $Utils.Optional<TipoEvolucaoSimplesCountAggregateOutputType> | number
          }
        }
      }
      Pais: {
        payload: Prisma.$PaisPayload<ExtArgs>
        fields: Prisma.PaisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaisPayload>
          }
          findFirst: {
            args: Prisma.PaisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaisPayload>
          }
          findMany: {
            args: Prisma.PaisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaisPayload>[]
          }
          create: {
            args: Prisma.PaisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaisPayload>
          }
          createMany: {
            args: Prisma.PaisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaisPayload>[]
          }
          delete: {
            args: Prisma.PaisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaisPayload>
          }
          update: {
            args: Prisma.PaisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaisPayload>
          }
          deleteMany: {
            args: Prisma.PaisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaisPayload>[]
          }
          upsert: {
            args: Prisma.PaisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaisPayload>
          }
          aggregate: {
            args: Prisma.PaisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePais>
          }
          groupBy: {
            args: Prisma.PaisGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaisGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaisCountArgs<ExtArgs>
            result: $Utils.Optional<PaisCountAggregateOutputType> | number
          }
        }
      }
      UnidadeFederacao: {
        payload: Prisma.$UnidadeFederacaoPayload<ExtArgs>
        fields: Prisma.UnidadeFederacaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnidadeFederacaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadeFederacaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnidadeFederacaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadeFederacaoPayload>
          }
          findFirst: {
            args: Prisma.UnidadeFederacaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadeFederacaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnidadeFederacaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadeFederacaoPayload>
          }
          findMany: {
            args: Prisma.UnidadeFederacaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadeFederacaoPayload>[]
          }
          create: {
            args: Prisma.UnidadeFederacaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadeFederacaoPayload>
          }
          createMany: {
            args: Prisma.UnidadeFederacaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnidadeFederacaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadeFederacaoPayload>[]
          }
          delete: {
            args: Prisma.UnidadeFederacaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadeFederacaoPayload>
          }
          update: {
            args: Prisma.UnidadeFederacaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadeFederacaoPayload>
          }
          deleteMany: {
            args: Prisma.UnidadeFederacaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnidadeFederacaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnidadeFederacaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadeFederacaoPayload>[]
          }
          upsert: {
            args: Prisma.UnidadeFederacaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnidadeFederacaoPayload>
          }
          aggregate: {
            args: Prisma.UnidadeFederacaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnidadeFederacao>
          }
          groupBy: {
            args: Prisma.UnidadeFederacaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnidadeFederacaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnidadeFederacaoCountArgs<ExtArgs>
            result: $Utils.Optional<UnidadeFederacaoCountAggregateOutputType> | number
          }
        }
      }
      Cidade: {
        payload: Prisma.$CidadePayload<ExtArgs>
        fields: Prisma.CidadeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CidadeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidadePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CidadeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidadePayload>
          }
          findFirst: {
            args: Prisma.CidadeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidadePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CidadeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidadePayload>
          }
          findMany: {
            args: Prisma.CidadeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidadePayload>[]
          }
          create: {
            args: Prisma.CidadeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidadePayload>
          }
          createMany: {
            args: Prisma.CidadeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CidadeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidadePayload>[]
          }
          delete: {
            args: Prisma.CidadeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidadePayload>
          }
          update: {
            args: Prisma.CidadeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidadePayload>
          }
          deleteMany: {
            args: Prisma.CidadeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CidadeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CidadeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidadePayload>[]
          }
          upsert: {
            args: Prisma.CidadeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidadePayload>
          }
          aggregate: {
            args: Prisma.CidadeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCidade>
          }
          groupBy: {
            args: Prisma.CidadeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CidadeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CidadeCountArgs<ExtArgs>
            result: $Utils.Optional<CidadeCountAggregateOutputType> | number
          }
        }
      }
      Escolaridade: {
        payload: Prisma.$EscolaridadePayload<ExtArgs>
        fields: Prisma.EscolaridadeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscolaridadeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaridadePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscolaridadeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaridadePayload>
          }
          findFirst: {
            args: Prisma.EscolaridadeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaridadePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscolaridadeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaridadePayload>
          }
          findMany: {
            args: Prisma.EscolaridadeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaridadePayload>[]
          }
          create: {
            args: Prisma.EscolaridadeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaridadePayload>
          }
          createMany: {
            args: Prisma.EscolaridadeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EscolaridadeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaridadePayload>[]
          }
          delete: {
            args: Prisma.EscolaridadeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaridadePayload>
          }
          update: {
            args: Prisma.EscolaridadeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaridadePayload>
          }
          deleteMany: {
            args: Prisma.EscolaridadeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EscolaridadeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EscolaridadeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaridadePayload>[]
          }
          upsert: {
            args: Prisma.EscolaridadeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscolaridadePayload>
          }
          aggregate: {
            args: Prisma.EscolaridadeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscolaridade>
          }
          groupBy: {
            args: Prisma.EscolaridadeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscolaridadeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscolaridadeCountArgs<ExtArgs>
            result: $Utils.Optional<EscolaridadeCountAggregateOutputType> | number
          }
        }
      }
      Ocupacao: {
        payload: Prisma.$OcupacaoPayload<ExtArgs>
        fields: Prisma.OcupacaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OcupacaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcupacaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OcupacaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcupacaoPayload>
          }
          findFirst: {
            args: Prisma.OcupacaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcupacaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OcupacaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcupacaoPayload>
          }
          findMany: {
            args: Prisma.OcupacaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcupacaoPayload>[]
          }
          create: {
            args: Prisma.OcupacaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcupacaoPayload>
          }
          createMany: {
            args: Prisma.OcupacaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OcupacaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcupacaoPayload>[]
          }
          delete: {
            args: Prisma.OcupacaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcupacaoPayload>
          }
          update: {
            args: Prisma.OcupacaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcupacaoPayload>
          }
          deleteMany: {
            args: Prisma.OcupacaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OcupacaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OcupacaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcupacaoPayload>[]
          }
          upsert: {
            args: Prisma.OcupacaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OcupacaoPayload>
          }
          aggregate: {
            args: Prisma.OcupacaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOcupacao>
          }
          groupBy: {
            args: Prisma.OcupacaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<OcupacaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.OcupacaoCountArgs<ExtArgs>
            result: $Utils.Optional<OcupacaoCountAggregateOutputType> | number
          }
        }
      }
      Distrito: {
        payload: Prisma.$DistritoPayload<ExtArgs>
        fields: Prisma.DistritoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistritoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistritoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>
          }
          findFirst: {
            args: Prisma.DistritoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistritoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>
          }
          findMany: {
            args: Prisma.DistritoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>[]
          }
          create: {
            args: Prisma.DistritoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>
          }
          createMany: {
            args: Prisma.DistritoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DistritoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>[]
          }
          delete: {
            args: Prisma.DistritoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>
          }
          update: {
            args: Prisma.DistritoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>
          }
          deleteMany: {
            args: Prisma.DistritoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DistritoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DistritoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>[]
          }
          upsert: {
            args: Prisma.DistritoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistritoPayload>
          }
          aggregate: {
            args: Prisma.DistritoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistrito>
          }
          groupBy: {
            args: Prisma.DistritoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistritoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistritoCountArgs<ExtArgs>
            result: $Utils.Optional<DistritoCountAggregateOutputType> | number
          }
        }
      }
      Bairro: {
        payload: Prisma.$BairroPayload<ExtArgs>
        fields: Prisma.BairroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BairroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BairroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPayload>
          }
          findFirst: {
            args: Prisma.BairroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BairroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPayload>
          }
          findMany: {
            args: Prisma.BairroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPayload>[]
          }
          create: {
            args: Prisma.BairroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPayload>
          }
          createMany: {
            args: Prisma.BairroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BairroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPayload>[]
          }
          delete: {
            args: Prisma.BairroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPayload>
          }
          update: {
            args: Prisma.BairroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPayload>
          }
          deleteMany: {
            args: Prisma.BairroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BairroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BairroUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPayload>[]
          }
          upsert: {
            args: Prisma.BairroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BairroPayload>
          }
          aggregate: {
            args: Prisma.BairroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBairro>
          }
          groupBy: {
            args: Prisma.BairroGroupByArgs<ExtArgs>
            result: $Utils.Optional<BairroGroupByOutputType>[]
          }
          count: {
            args: Prisma.BairroCountArgs<ExtArgs>
            result: $Utils.Optional<BairroCountAggregateOutputType> | number
          }
        }
      }
      EnderecoPessoaRelacionada: {
        payload: Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>
        fields: Prisma.EnderecoPessoaRelacionadaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnderecoPessoaRelacionadaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPessoaRelacionadaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnderecoPessoaRelacionadaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPessoaRelacionadaPayload>
          }
          findFirst: {
            args: Prisma.EnderecoPessoaRelacionadaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPessoaRelacionadaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnderecoPessoaRelacionadaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPessoaRelacionadaPayload>
          }
          findMany: {
            args: Prisma.EnderecoPessoaRelacionadaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPessoaRelacionadaPayload>[]
          }
          create: {
            args: Prisma.EnderecoPessoaRelacionadaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPessoaRelacionadaPayload>
          }
          createMany: {
            args: Prisma.EnderecoPessoaRelacionadaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnderecoPessoaRelacionadaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPessoaRelacionadaPayload>[]
          }
          delete: {
            args: Prisma.EnderecoPessoaRelacionadaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPessoaRelacionadaPayload>
          }
          update: {
            args: Prisma.EnderecoPessoaRelacionadaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPessoaRelacionadaPayload>
          }
          deleteMany: {
            args: Prisma.EnderecoPessoaRelacionadaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnderecoPessoaRelacionadaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnderecoPessoaRelacionadaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPessoaRelacionadaPayload>[]
          }
          upsert: {
            args: Prisma.EnderecoPessoaRelacionadaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPessoaRelacionadaPayload>
          }
          aggregate: {
            args: Prisma.EnderecoPessoaRelacionadaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnderecoPessoaRelacionada>
          }
          groupBy: {
            args: Prisma.EnderecoPessoaRelacionadaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnderecoPessoaRelacionadaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnderecoPessoaRelacionadaCountArgs<ExtArgs>
            result: $Utils.Optional<EnderecoPessoaRelacionadaCountAggregateOutputType> | number
          }
        }
      }
      Cid: {
        payload: Prisma.$CidPayload<ExtArgs>
        fields: Prisma.CidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CidFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CidFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidPayload>
          }
          findFirst: {
            args: Prisma.CidFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CidFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidPayload>
          }
          findMany: {
            args: Prisma.CidFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidPayload>[]
          }
          create: {
            args: Prisma.CidCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidPayload>
          }
          createMany: {
            args: Prisma.CidCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CidCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidPayload>[]
          }
          delete: {
            args: Prisma.CidDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidPayload>
          }
          update: {
            args: Prisma.CidUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidPayload>
          }
          deleteMany: {
            args: Prisma.CidDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CidUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CidUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidPayload>[]
          }
          upsert: {
            args: Prisma.CidUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CidPayload>
          }
          aggregate: {
            args: Prisma.CidAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCid>
          }
          groupBy: {
            args: Prisma.CidGroupByArgs<ExtArgs>
            result: $Utils.Optional<CidGroupByOutputType>[]
          }
          count: {
            args: Prisma.CidCountArgs<ExtArgs>
            result: $Utils.Optional<CidCountAggregateOutputType> | number
          }
        }
      }
      Dsm: {
        payload: Prisma.$DsmPayload<ExtArgs>
        fields: Prisma.DsmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DsmFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DsmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DsmFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DsmPayload>
          }
          findFirst: {
            args: Prisma.DsmFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DsmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DsmFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DsmPayload>
          }
          findMany: {
            args: Prisma.DsmFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DsmPayload>[]
          }
          create: {
            args: Prisma.DsmCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DsmPayload>
          }
          createMany: {
            args: Prisma.DsmCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DsmCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DsmPayload>[]
          }
          delete: {
            args: Prisma.DsmDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DsmPayload>
          }
          update: {
            args: Prisma.DsmUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DsmPayload>
          }
          deleteMany: {
            args: Prisma.DsmDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DsmUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DsmUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DsmPayload>[]
          }
          upsert: {
            args: Prisma.DsmUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DsmPayload>
          }
          aggregate: {
            args: Prisma.DsmAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDsm>
          }
          groupBy: {
            args: Prisma.DsmGroupByArgs<ExtArgs>
            result: $Utils.Optional<DsmGroupByOutputType>[]
          }
          count: {
            args: Prisma.DsmCountArgs<ExtArgs>
            result: $Utils.Optional<DsmCountAggregateOutputType> | number
          }
        }
      }
      TipoEvolucaoClinica: {
        payload: Prisma.$TipoEvolucaoClinicaPayload<ExtArgs>
        fields: Prisma.TipoEvolucaoClinicaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoEvolucaoClinicaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoClinicaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoEvolucaoClinicaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoClinicaPayload>
          }
          findFirst: {
            args: Prisma.TipoEvolucaoClinicaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoClinicaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoEvolucaoClinicaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoClinicaPayload>
          }
          findMany: {
            args: Prisma.TipoEvolucaoClinicaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoClinicaPayload>[]
          }
          create: {
            args: Prisma.TipoEvolucaoClinicaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoClinicaPayload>
          }
          createMany: {
            args: Prisma.TipoEvolucaoClinicaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoEvolucaoClinicaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoClinicaPayload>[]
          }
          delete: {
            args: Prisma.TipoEvolucaoClinicaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoClinicaPayload>
          }
          update: {
            args: Prisma.TipoEvolucaoClinicaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoClinicaPayload>
          }
          deleteMany: {
            args: Prisma.TipoEvolucaoClinicaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoEvolucaoClinicaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoEvolucaoClinicaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoClinicaPayload>[]
          }
          upsert: {
            args: Prisma.TipoEvolucaoClinicaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEvolucaoClinicaPayload>
          }
          aggregate: {
            args: Prisma.TipoEvolucaoClinicaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoEvolucaoClinica>
          }
          groupBy: {
            args: Prisma.TipoEvolucaoClinicaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoEvolucaoClinicaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoEvolucaoClinicaCountArgs<ExtArgs>
            result: $Utils.Optional<TipoEvolucaoClinicaCountAggregateOutputType> | number
          }
        }
      }
      EvolucaoCid: {
        payload: Prisma.$EvolucaoCidPayload<ExtArgs>
        fields: Prisma.EvolucaoCidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvolucaoCidFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoCidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvolucaoCidFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoCidPayload>
          }
          findFirst: {
            args: Prisma.EvolucaoCidFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoCidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvolucaoCidFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoCidPayload>
          }
          findMany: {
            args: Prisma.EvolucaoCidFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoCidPayload>[]
          }
          create: {
            args: Prisma.EvolucaoCidCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoCidPayload>
          }
          createMany: {
            args: Prisma.EvolucaoCidCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvolucaoCidCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoCidPayload>[]
          }
          delete: {
            args: Prisma.EvolucaoCidDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoCidPayload>
          }
          update: {
            args: Prisma.EvolucaoCidUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoCidPayload>
          }
          deleteMany: {
            args: Prisma.EvolucaoCidDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvolucaoCidUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvolucaoCidUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoCidPayload>[]
          }
          upsert: {
            args: Prisma.EvolucaoCidUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoCidPayload>
          }
          aggregate: {
            args: Prisma.EvolucaoCidAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvolucaoCid>
          }
          groupBy: {
            args: Prisma.EvolucaoCidGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvolucaoCidGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvolucaoCidCountArgs<ExtArgs>
            result: $Utils.Optional<EvolucaoCidCountAggregateOutputType> | number
          }
        }
      }
      EvolucaoDsm: {
        payload: Prisma.$EvolucaoDsmPayload<ExtArgs>
        fields: Prisma.EvolucaoDsmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvolucaoDsmFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoDsmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvolucaoDsmFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoDsmPayload>
          }
          findFirst: {
            args: Prisma.EvolucaoDsmFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoDsmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvolucaoDsmFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoDsmPayload>
          }
          findMany: {
            args: Prisma.EvolucaoDsmFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoDsmPayload>[]
          }
          create: {
            args: Prisma.EvolucaoDsmCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoDsmPayload>
          }
          createMany: {
            args: Prisma.EvolucaoDsmCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvolucaoDsmCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoDsmPayload>[]
          }
          delete: {
            args: Prisma.EvolucaoDsmDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoDsmPayload>
          }
          update: {
            args: Prisma.EvolucaoDsmUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoDsmPayload>
          }
          deleteMany: {
            args: Prisma.EvolucaoDsmDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvolucaoDsmUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvolucaoDsmUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoDsmPayload>[]
          }
          upsert: {
            args: Prisma.EvolucaoDsmUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolucaoDsmPayload>
          }
          aggregate: {
            args: Prisma.EvolucaoDsmAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvolucaoDsm>
          }
          groupBy: {
            args: Prisma.EvolucaoDsmGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvolucaoDsmGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvolucaoDsmCountArgs<ExtArgs>
            result: $Utils.Optional<EvolucaoDsmCountAggregateOutputType> | number
          }
        }
      }
      SinaisVitais: {
        payload: Prisma.$SinaisVitaisPayload<ExtArgs>
        fields: Prisma.SinaisVitaisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SinaisVitaisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SinaisVitaisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SinaisVitaisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SinaisVitaisPayload>
          }
          findFirst: {
            args: Prisma.SinaisVitaisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SinaisVitaisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SinaisVitaisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SinaisVitaisPayload>
          }
          findMany: {
            args: Prisma.SinaisVitaisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SinaisVitaisPayload>[]
          }
          create: {
            args: Prisma.SinaisVitaisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SinaisVitaisPayload>
          }
          createMany: {
            args: Prisma.SinaisVitaisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SinaisVitaisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SinaisVitaisPayload>[]
          }
          delete: {
            args: Prisma.SinaisVitaisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SinaisVitaisPayload>
          }
          update: {
            args: Prisma.SinaisVitaisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SinaisVitaisPayload>
          }
          deleteMany: {
            args: Prisma.SinaisVitaisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SinaisVitaisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SinaisVitaisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SinaisVitaisPayload>[]
          }
          upsert: {
            args: Prisma.SinaisVitaisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SinaisVitaisPayload>
          }
          aggregate: {
            args: Prisma.SinaisVitaisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSinaisVitais>
          }
          groupBy: {
            args: Prisma.SinaisVitaisGroupByArgs<ExtArgs>
            result: $Utils.Optional<SinaisVitaisGroupByOutputType>[]
          }
          count: {
            args: Prisma.SinaisVitaisCountArgs<ExtArgs>
            result: $Utils.Optional<SinaisVitaisCountAggregateOutputType> | number
          }
        }
      }
      EscalaDor: {
        payload: Prisma.$EscalaDorPayload<ExtArgs>
        fields: Prisma.EscalaDorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscalaDorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaDorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscalaDorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaDorPayload>
          }
          findFirst: {
            args: Prisma.EscalaDorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaDorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscalaDorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaDorPayload>
          }
          findMany: {
            args: Prisma.EscalaDorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaDorPayload>[]
          }
          create: {
            args: Prisma.EscalaDorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaDorPayload>
          }
          createMany: {
            args: Prisma.EscalaDorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EscalaDorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaDorPayload>[]
          }
          delete: {
            args: Prisma.EscalaDorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaDorPayload>
          }
          update: {
            args: Prisma.EscalaDorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaDorPayload>
          }
          deleteMany: {
            args: Prisma.EscalaDorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EscalaDorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EscalaDorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaDorPayload>[]
          }
          upsert: {
            args: Prisma.EscalaDorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EscalaDorPayload>
          }
          aggregate: {
            args: Prisma.EscalaDorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscalaDor>
          }
          groupBy: {
            args: Prisma.EscalaDorGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscalaDorGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscalaDorCountArgs<ExtArgs>
            result: $Utils.Optional<EscalaDorCountAggregateOutputType> | number
          }
        }
      }
      Glasgow: {
        payload: Prisma.$GlasgowPayload<ExtArgs>
        fields: Prisma.GlasgowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GlasgowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlasgowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GlasgowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlasgowPayload>
          }
          findFirst: {
            args: Prisma.GlasgowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlasgowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GlasgowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlasgowPayload>
          }
          findMany: {
            args: Prisma.GlasgowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlasgowPayload>[]
          }
          create: {
            args: Prisma.GlasgowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlasgowPayload>
          }
          createMany: {
            args: Prisma.GlasgowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GlasgowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlasgowPayload>[]
          }
          delete: {
            args: Prisma.GlasgowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlasgowPayload>
          }
          update: {
            args: Prisma.GlasgowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlasgowPayload>
          }
          deleteMany: {
            args: Prisma.GlasgowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GlasgowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GlasgowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlasgowPayload>[]
          }
          upsert: {
            args: Prisma.GlasgowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlasgowPayload>
          }
          aggregate: {
            args: Prisma.GlasgowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGlasgow>
          }
          groupBy: {
            args: Prisma.GlasgowGroupByArgs<ExtArgs>
            result: $Utils.Optional<GlasgowGroupByOutputType>[]
          }
          count: {
            args: Prisma.GlasgowCountArgs<ExtArgs>
            result: $Utils.Optional<GlasgowCountAggregateOutputType> | number
          }
        }
      }
      AfericaoClinica: {
        payload: Prisma.$AfericaoClinicaPayload<ExtArgs>
        fields: Prisma.AfericaoClinicaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AfericaoClinicaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfericaoClinicaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AfericaoClinicaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfericaoClinicaPayload>
          }
          findFirst: {
            args: Prisma.AfericaoClinicaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfericaoClinicaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AfericaoClinicaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfericaoClinicaPayload>
          }
          findMany: {
            args: Prisma.AfericaoClinicaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfericaoClinicaPayload>[]
          }
          create: {
            args: Prisma.AfericaoClinicaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfericaoClinicaPayload>
          }
          createMany: {
            args: Prisma.AfericaoClinicaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AfericaoClinicaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfericaoClinicaPayload>[]
          }
          delete: {
            args: Prisma.AfericaoClinicaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfericaoClinicaPayload>
          }
          update: {
            args: Prisma.AfericaoClinicaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfericaoClinicaPayload>
          }
          deleteMany: {
            args: Prisma.AfericaoClinicaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AfericaoClinicaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AfericaoClinicaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfericaoClinicaPayload>[]
          }
          upsert: {
            args: Prisma.AfericaoClinicaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfericaoClinicaPayload>
          }
          aggregate: {
            args: Prisma.AfericaoClinicaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAfericaoClinica>
          }
          groupBy: {
            args: Prisma.AfericaoClinicaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AfericaoClinicaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AfericaoClinicaCountArgs<ExtArgs>
            result: $Utils.Optional<AfericaoClinicaCountAggregateOutputType> | number
          }
        }
      }
      EvaDor: {
        payload: Prisma.$EvaDorPayload<ExtArgs>
        fields: Prisma.EvaDorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaDorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaDorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaDorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaDorPayload>
          }
          findFirst: {
            args: Prisma.EvaDorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaDorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaDorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaDorPayload>
          }
          findMany: {
            args: Prisma.EvaDorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaDorPayload>[]
          }
          create: {
            args: Prisma.EvaDorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaDorPayload>
          }
          createMany: {
            args: Prisma.EvaDorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaDorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaDorPayload>[]
          }
          delete: {
            args: Prisma.EvaDorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaDorPayload>
          }
          update: {
            args: Prisma.EvaDorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaDorPayload>
          }
          deleteMany: {
            args: Prisma.EvaDorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaDorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvaDorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaDorPayload>[]
          }
          upsert: {
            args: Prisma.EvaDorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaDorPayload>
          }
          aggregate: {
            args: Prisma.EvaDorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaDor>
          }
          groupBy: {
            args: Prisma.EvaDorGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaDorGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaDorCountArgs<ExtArgs>
            result: $Utils.Optional<EvaDorCountAggregateOutputType> | number
          }
        }
      }
      UsuarioAuth: {
        payload: Prisma.$UsuarioAuthPayload<ExtArgs>
        fields: Prisma.UsuarioAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioAuthPayload>
          }
          findFirst: {
            args: Prisma.UsuarioAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioAuthPayload>
          }
          findMany: {
            args: Prisma.UsuarioAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioAuthPayload>[]
          }
          create: {
            args: Prisma.UsuarioAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioAuthPayload>
          }
          createMany: {
            args: Prisma.UsuarioAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioAuthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioAuthPayload>[]
          }
          delete: {
            args: Prisma.UsuarioAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioAuthPayload>
          }
          update: {
            args: Prisma.UsuarioAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioAuthPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuarioAuthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioAuthPayload>[]
          }
          upsert: {
            args: Prisma.UsuarioAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioAuthPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuarioAuth>
          }
          groupBy: {
            args: Prisma.UsuarioAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioAuthCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioAuthCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    master?: MasterOmit
    paciente?: PacienteOmit
    profissional?: ProfissionalOmit
    endereco?: EnderecoOmit
    enderecoPaciente?: EnderecoPacienteOmit
    enderecoProfissional?: EnderecoProfissionalOmit
    contato?: ContatoOmit
    contatoPaciente?: ContatoPacienteOmit
    contatoProfissional?: ContatoProfissionalOmit
    atendimento?: AtendimentoOmit
    evolucao?: EvolucaoOmit
    pessoaRelacionada?: PessoaRelacionadaOmit
    parentescoPaciente?: ParentescoPacienteOmit
    plano?: PlanoOmit
    motivo?: MotivoOmit
    tipoProcedimento?: TipoProcedimentoOmit
    tipoEvolucaoSimples?: TipoEvolucaoSimplesOmit
    pais?: PaisOmit
    unidadeFederacao?: UnidadeFederacaoOmit
    cidade?: CidadeOmit
    escolaridade?: EscolaridadeOmit
    ocupacao?: OcupacaoOmit
    distrito?: DistritoOmit
    bairro?: BairroOmit
    enderecoPessoaRelacionada?: EnderecoPessoaRelacionadaOmit
    cid?: CidOmit
    dsm?: DsmOmit
    tipoEvolucaoClinica?: TipoEvolucaoClinicaOmit
    evolucaoCid?: EvolucaoCidOmit
    evolucaoDsm?: EvolucaoDsmOmit
    sinaisVitais?: SinaisVitaisOmit
    escalaDor?: EscalaDorOmit
    glasgow?: GlasgowOmit
    afericaoClinica?: AfericaoClinicaOmit
    evaDor?: EvaDorOmit
    usuarioAuth?: UsuarioAuthOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MasterCountOutputType
   */

  export type MasterCountOutputType = {
    pacientes: number
    profissionais: number
    usuarioAuths: number
  }

  export type MasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pacientes?: boolean | MasterCountOutputTypeCountPacientesArgs
    profissionais?: boolean | MasterCountOutputTypeCountProfissionaisArgs
    usuarioAuths?: boolean | MasterCountOutputTypeCountUsuarioAuthsArgs
  }

  // Custom InputTypes
  /**
   * MasterCountOutputType without action
   */
  export type MasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterCountOutputType
     */
    select?: MasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MasterCountOutputType without action
   */
  export type MasterCountOutputTypeCountPacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PacienteWhereInput
  }

  /**
   * MasterCountOutputType without action
   */
  export type MasterCountOutputTypeCountProfissionaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfissionalWhereInput
  }

  /**
   * MasterCountOutputType without action
   */
  export type MasterCountOutputTypeCountUsuarioAuthsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioAuthWhereInput
  }


  /**
   * Count Type PacienteCountOutputType
   */

  export type PacienteCountOutputType = {
    atendimentos: number
    contatos: number
    enderecos: number
    evolucoes: number
    parentescoPacientes: number
    usuarioAuths: number
  }

  export type PacienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimentos?: boolean | PacienteCountOutputTypeCountAtendimentosArgs
    contatos?: boolean | PacienteCountOutputTypeCountContatosArgs
    enderecos?: boolean | PacienteCountOutputTypeCountEnderecosArgs
    evolucoes?: boolean | PacienteCountOutputTypeCountEvolucoesArgs
    parentescoPacientes?: boolean | PacienteCountOutputTypeCountParentescoPacientesArgs
    usuarioAuths?: boolean | PacienteCountOutputTypeCountUsuarioAuthsArgs
  }

  // Custom InputTypes
  /**
   * PacienteCountOutputType without action
   */
  export type PacienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PacienteCountOutputType
     */
    select?: PacienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PacienteCountOutputType without action
   */
  export type PacienteCountOutputTypeCountAtendimentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AtendimentoWhereInput
  }

  /**
   * PacienteCountOutputType without action
   */
  export type PacienteCountOutputTypeCountContatosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContatoPacienteWhereInput
  }

  /**
   * PacienteCountOutputType without action
   */
  export type PacienteCountOutputTypeCountEnderecosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnderecoPacienteWhereInput
  }

  /**
   * PacienteCountOutputType without action
   */
  export type PacienteCountOutputTypeCountEvolucoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolucaoWhereInput
  }

  /**
   * PacienteCountOutputType without action
   */
  export type PacienteCountOutputTypeCountParentescoPacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentescoPacienteWhereInput
  }

  /**
   * PacienteCountOutputType without action
   */
  export type PacienteCountOutputTypeCountUsuarioAuthsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioAuthWhereInput
  }


  /**
   * Count Type ProfissionalCountOutputType
   */

  export type ProfissionalCountOutputType = {
    afericoesClinicas: number
    atendimentos: number
    contatos: number
    enderecos: number
    evaDores: number
    evolucoes: number
    glasgows: number
    usuarioAuths: number
  }

  export type ProfissionalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    afericoesClinicas?: boolean | ProfissionalCountOutputTypeCountAfericoesClinicasArgs
    atendimentos?: boolean | ProfissionalCountOutputTypeCountAtendimentosArgs
    contatos?: boolean | ProfissionalCountOutputTypeCountContatosArgs
    enderecos?: boolean | ProfissionalCountOutputTypeCountEnderecosArgs
    evaDores?: boolean | ProfissionalCountOutputTypeCountEvaDoresArgs
    evolucoes?: boolean | ProfissionalCountOutputTypeCountEvolucoesArgs
    glasgows?: boolean | ProfissionalCountOutputTypeCountGlasgowsArgs
    usuarioAuths?: boolean | ProfissionalCountOutputTypeCountUsuarioAuthsArgs
  }

  // Custom InputTypes
  /**
   * ProfissionalCountOutputType without action
   */
  export type ProfissionalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfissionalCountOutputType
     */
    select?: ProfissionalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfissionalCountOutputType without action
   */
  export type ProfissionalCountOutputTypeCountAfericoesClinicasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AfericaoClinicaWhereInput
  }

  /**
   * ProfissionalCountOutputType without action
   */
  export type ProfissionalCountOutputTypeCountAtendimentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AtendimentoWhereInput
  }

  /**
   * ProfissionalCountOutputType without action
   */
  export type ProfissionalCountOutputTypeCountContatosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContatoProfissionalWhereInput
  }

  /**
   * ProfissionalCountOutputType without action
   */
  export type ProfissionalCountOutputTypeCountEnderecosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnderecoProfissionalWhereInput
  }

  /**
   * ProfissionalCountOutputType without action
   */
  export type ProfissionalCountOutputTypeCountEvaDoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaDorWhereInput
  }

  /**
   * ProfissionalCountOutputType without action
   */
  export type ProfissionalCountOutputTypeCountEvolucoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolucaoWhereInput
  }

  /**
   * ProfissionalCountOutputType without action
   */
  export type ProfissionalCountOutputTypeCountGlasgowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlasgowWhereInput
  }

  /**
   * ProfissionalCountOutputType without action
   */
  export type ProfissionalCountOutputTypeCountUsuarioAuthsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioAuthWhereInput
  }


  /**
   * Count Type EnderecoCountOutputType
   */

  export type EnderecoCountOutputType = {
    pacientes: number
    enderecoPessoaRelacionadas: number
    profissionais: number
  }

  export type EnderecoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pacientes?: boolean | EnderecoCountOutputTypeCountPacientesArgs
    enderecoPessoaRelacionadas?: boolean | EnderecoCountOutputTypeCountEnderecoPessoaRelacionadasArgs
    profissionais?: boolean | EnderecoCountOutputTypeCountProfissionaisArgs
  }

  // Custom InputTypes
  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoCountOutputType
     */
    select?: EnderecoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeCountPacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnderecoPacienteWhereInput
  }

  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeCountEnderecoPessoaRelacionadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnderecoPessoaRelacionadaWhereInput
  }

  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeCountProfissionaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnderecoProfissionalWhereInput
  }


  /**
   * Count Type ContatoCountOutputType
   */

  export type ContatoCountOutputType = {
    pacientes: number
    profissionais: number
  }

  export type ContatoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pacientes?: boolean | ContatoCountOutputTypeCountPacientesArgs
    profissionais?: boolean | ContatoCountOutputTypeCountProfissionaisArgs
  }

  // Custom InputTypes
  /**
   * ContatoCountOutputType without action
   */
  export type ContatoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoCountOutputType
     */
    select?: ContatoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContatoCountOutputType without action
   */
  export type ContatoCountOutputTypeCountPacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContatoPacienteWhereInput
  }

  /**
   * ContatoCountOutputType without action
   */
  export type ContatoCountOutputTypeCountProfissionaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContatoProfissionalWhereInput
  }


  /**
   * Count Type AtendimentoCountOutputType
   */

  export type AtendimentoCountOutputType = {
    afericoesClinicas: number
    evaDores: number
    evolucoes: number
    glasgows: number
    sinaisVitais: number
  }

  export type AtendimentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    afericoesClinicas?: boolean | AtendimentoCountOutputTypeCountAfericoesClinicasArgs
    evaDores?: boolean | AtendimentoCountOutputTypeCountEvaDoresArgs
    evolucoes?: boolean | AtendimentoCountOutputTypeCountEvolucoesArgs
    glasgows?: boolean | AtendimentoCountOutputTypeCountGlasgowsArgs
    sinaisVitais?: boolean | AtendimentoCountOutputTypeCountSinaisVitaisArgs
  }

  // Custom InputTypes
  /**
   * AtendimentoCountOutputType without action
   */
  export type AtendimentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AtendimentoCountOutputType
     */
    select?: AtendimentoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AtendimentoCountOutputType without action
   */
  export type AtendimentoCountOutputTypeCountAfericoesClinicasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AfericaoClinicaWhereInput
  }

  /**
   * AtendimentoCountOutputType without action
   */
  export type AtendimentoCountOutputTypeCountEvaDoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaDorWhereInput
  }

  /**
   * AtendimentoCountOutputType without action
   */
  export type AtendimentoCountOutputTypeCountEvolucoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolucaoWhereInput
  }

  /**
   * AtendimentoCountOutputType without action
   */
  export type AtendimentoCountOutputTypeCountGlasgowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlasgowWhereInput
  }

  /**
   * AtendimentoCountOutputType without action
   */
  export type AtendimentoCountOutputTypeCountSinaisVitaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SinaisVitaisWhereInput
  }


  /**
   * Count Type EvolucaoCountOutputType
   */

  export type EvolucaoCountOutputType = {
    cid: number
    dsm: number
  }

  export type EvolucaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cid?: boolean | EvolucaoCountOutputTypeCountCidArgs
    dsm?: boolean | EvolucaoCountOutputTypeCountDsmArgs
  }

  // Custom InputTypes
  /**
   * EvolucaoCountOutputType without action
   */
  export type EvolucaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoCountOutputType
     */
    select?: EvolucaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvolucaoCountOutputType without action
   */
  export type EvolucaoCountOutputTypeCountCidArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolucaoCidWhereInput
  }

  /**
   * EvolucaoCountOutputType without action
   */
  export type EvolucaoCountOutputTypeCountDsmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolucaoDsmWhereInput
  }


  /**
   * Count Type PessoaRelacionadaCountOutputType
   */

  export type PessoaRelacionadaCountOutputType = {
    enderecos: number
    parentescos: number
  }

  export type PessoaRelacionadaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enderecos?: boolean | PessoaRelacionadaCountOutputTypeCountEnderecosArgs
    parentescos?: boolean | PessoaRelacionadaCountOutputTypeCountParentescosArgs
  }

  // Custom InputTypes
  /**
   * PessoaRelacionadaCountOutputType without action
   */
  export type PessoaRelacionadaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaRelacionadaCountOutputType
     */
    select?: PessoaRelacionadaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PessoaRelacionadaCountOutputType without action
   */
  export type PessoaRelacionadaCountOutputTypeCountEnderecosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnderecoPessoaRelacionadaWhereInput
  }

  /**
   * PessoaRelacionadaCountOutputType without action
   */
  export type PessoaRelacionadaCountOutputTypeCountParentescosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentescoPacienteWhereInput
  }


  /**
   * Count Type PaisCountOutputType
   */

  export type PaisCountOutputType = {
    cidades: number
  }

  export type PaisCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cidades?: boolean | PaisCountOutputTypeCountCidadesArgs
  }

  // Custom InputTypes
  /**
   * PaisCountOutputType without action
   */
  export type PaisCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaisCountOutputType
     */
    select?: PaisCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaisCountOutputType without action
   */
  export type PaisCountOutputTypeCountCidadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CidadeWhereInput
  }


  /**
   * Count Type UnidadeFederacaoCountOutputType
   */

  export type UnidadeFederacaoCountOutputType = {
    cidades: number
  }

  export type UnidadeFederacaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cidades?: boolean | UnidadeFederacaoCountOutputTypeCountCidadesArgs
  }

  // Custom InputTypes
  /**
   * UnidadeFederacaoCountOutputType without action
   */
  export type UnidadeFederacaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadeFederacaoCountOutputType
     */
    select?: UnidadeFederacaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnidadeFederacaoCountOutputType without action
   */
  export type UnidadeFederacaoCountOutputTypeCountCidadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CidadeWhereInput
  }


  /**
   * Count Type CidadeCountOutputType
   */

  export type CidadeCountOutputType = {
    bairros: number
    distritos: number
    enderecos: number
  }

  export type CidadeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bairros?: boolean | CidadeCountOutputTypeCountBairrosArgs
    distritos?: boolean | CidadeCountOutputTypeCountDistritosArgs
    enderecos?: boolean | CidadeCountOutputTypeCountEnderecosArgs
  }

  // Custom InputTypes
  /**
   * CidadeCountOutputType without action
   */
  export type CidadeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CidadeCountOutputType
     */
    select?: CidadeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CidadeCountOutputType without action
   */
  export type CidadeCountOutputTypeCountBairrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BairroWhereInput
  }

  /**
   * CidadeCountOutputType without action
   */
  export type CidadeCountOutputTypeCountDistritosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistritoWhereInput
  }

  /**
   * CidadeCountOutputType without action
   */
  export type CidadeCountOutputTypeCountEnderecosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnderecoWhereInput
  }


  /**
   * Count Type EscolaridadeCountOutputType
   */

  export type EscolaridadeCountOutputType = {
    pacientes: number
  }

  export type EscolaridadeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pacientes?: boolean | EscolaridadeCountOutputTypeCountPacientesArgs
  }

  // Custom InputTypes
  /**
   * EscolaridadeCountOutputType without action
   */
  export type EscolaridadeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaridadeCountOutputType
     */
    select?: EscolaridadeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EscolaridadeCountOutputType without action
   */
  export type EscolaridadeCountOutputTypeCountPacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PacienteWhereInput
  }


  /**
   * Count Type OcupacaoCountOutputType
   */

  export type OcupacaoCountOutputType = {
    pacientes: number
    profissionals: number
  }

  export type OcupacaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pacientes?: boolean | OcupacaoCountOutputTypeCountPacientesArgs
    profissionals?: boolean | OcupacaoCountOutputTypeCountProfissionalsArgs
  }

  // Custom InputTypes
  /**
   * OcupacaoCountOutputType without action
   */
  export type OcupacaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OcupacaoCountOutputType
     */
    select?: OcupacaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OcupacaoCountOutputType without action
   */
  export type OcupacaoCountOutputTypeCountPacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PacienteWhereInput
  }

  /**
   * OcupacaoCountOutputType without action
   */
  export type OcupacaoCountOutputTypeCountProfissionalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfissionalWhereInput
  }


  /**
   * Count Type DistritoCountOutputType
   */

  export type DistritoCountOutputType = {
    bairros: number
  }

  export type DistritoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bairros?: boolean | DistritoCountOutputTypeCountBairrosArgs
  }

  // Custom InputTypes
  /**
   * DistritoCountOutputType without action
   */
  export type DistritoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistritoCountOutputType
     */
    select?: DistritoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DistritoCountOutputType without action
   */
  export type DistritoCountOutputTypeCountBairrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BairroWhereInput
  }


  /**
   * Count Type BairroCountOutputType
   */

  export type BairroCountOutputType = {
    enderecos: number
  }

  export type BairroCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enderecos?: boolean | BairroCountOutputTypeCountEnderecosArgs
  }

  // Custom InputTypes
  /**
   * BairroCountOutputType without action
   */
  export type BairroCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BairroCountOutputType
     */
    select?: BairroCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BairroCountOutputType without action
   */
  export type BairroCountOutputTypeCountEnderecosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnderecoWhereInput
  }


  /**
   * Count Type CidCountOutputType
   */

  export type CidCountOutputType = {
    evolucaoCids: number
  }

  export type CidCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evolucaoCids?: boolean | CidCountOutputTypeCountEvolucaoCidsArgs
  }

  // Custom InputTypes
  /**
   * CidCountOutputType without action
   */
  export type CidCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CidCountOutputType
     */
    select?: CidCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CidCountOutputType without action
   */
  export type CidCountOutputTypeCountEvolucaoCidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolucaoCidWhereInput
  }


  /**
   * Count Type DsmCountOutputType
   */

  export type DsmCountOutputType = {
    evolucaoDsms: number
  }

  export type DsmCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evolucaoDsms?: boolean | DsmCountOutputTypeCountEvolucaoDsmsArgs
  }

  // Custom InputTypes
  /**
   * DsmCountOutputType without action
   */
  export type DsmCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DsmCountOutputType
     */
    select?: DsmCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DsmCountOutputType without action
   */
  export type DsmCountOutputTypeCountEvolucaoDsmsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolucaoDsmWhereInput
  }


  /**
   * Count Type TipoEvolucaoClinicaCountOutputType
   */

  export type TipoEvolucaoClinicaCountOutputType = {
    evolucaos: number
  }

  export type TipoEvolucaoClinicaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evolucaos?: boolean | TipoEvolucaoClinicaCountOutputTypeCountEvolucaosArgs
  }

  // Custom InputTypes
  /**
   * TipoEvolucaoClinicaCountOutputType without action
   */
  export type TipoEvolucaoClinicaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoClinicaCountOutputType
     */
    select?: TipoEvolucaoClinicaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoEvolucaoClinicaCountOutputType without action
   */
  export type TipoEvolucaoClinicaCountOutputTypeCountEvolucaosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolucaoWhereInput
  }


  /**
   * Count Type EscalaDorCountOutputType
   */

  export type EscalaDorCountOutputType = {
    sinaisVitais: number
  }

  export type EscalaDorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sinaisVitais?: boolean | EscalaDorCountOutputTypeCountSinaisVitaisArgs
  }

  // Custom InputTypes
  /**
   * EscalaDorCountOutputType without action
   */
  export type EscalaDorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscalaDorCountOutputType
     */
    select?: EscalaDorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EscalaDorCountOutputType without action
   */
  export type EscalaDorCountOutputTypeCountSinaisVitaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SinaisVitaisWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Master
   */

  export type AggregateMaster = {
    _count: MasterCountAggregateOutputType | null
    _avg: MasterAvgAggregateOutputType | null
    _sum: MasterSumAggregateOutputType | null
    _min: MasterMinAggregateOutputType | null
    _max: MasterMaxAggregateOutputType | null
  }

  export type MasterAvgAggregateOutputType = {
    id: number | null
  }

  export type MasterSumAggregateOutputType = {
    id: number | null
  }

  export type MasterMinAggregateOutputType = {
    id: number | null
    nome: string | null
    dtCadastro: Date | null
    stInativo: $Enums.SimNao | null
  }

  export type MasterMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    dtCadastro: Date | null
    stInativo: $Enums.SimNao | null
  }

  export type MasterCountAggregateOutputType = {
    id: number
    nome: number
    dtCadastro: number
    stInativo: number
    _all: number
  }


  export type MasterAvgAggregateInputType = {
    id?: true
  }

  export type MasterSumAggregateInputType = {
    id?: true
  }

  export type MasterMinAggregateInputType = {
    id?: true
    nome?: true
    dtCadastro?: true
    stInativo?: true
  }

  export type MasterMaxAggregateInputType = {
    id?: true
    nome?: true
    dtCadastro?: true
    stInativo?: true
  }

  export type MasterCountAggregateInputType = {
    id?: true
    nome?: true
    dtCadastro?: true
    stInativo?: true
    _all?: true
  }

  export type MasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Master to aggregate.
     */
    where?: MasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Masters to fetch.
     */
    orderBy?: MasterOrderByWithRelationInput | MasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Masters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Masters
    **/
    _count?: true | MasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterMaxAggregateInputType
  }

  export type GetMasterAggregateType<T extends MasterAggregateArgs> = {
        [P in keyof T & keyof AggregateMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaster[P]>
      : GetScalarType<T[P], AggregateMaster[P]>
  }




  export type MasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MasterWhereInput
    orderBy?: MasterOrderByWithAggregationInput | MasterOrderByWithAggregationInput[]
    by: MasterScalarFieldEnum[] | MasterScalarFieldEnum
    having?: MasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterCountAggregateInputType | true
    _avg?: MasterAvgAggregateInputType
    _sum?: MasterSumAggregateInputType
    _min?: MasterMinAggregateInputType
    _max?: MasterMaxAggregateInputType
  }

  export type MasterGroupByOutputType = {
    id: number
    nome: string
    dtCadastro: Date
    stInativo: $Enums.SimNao | null
    _count: MasterCountAggregateOutputType | null
    _avg: MasterAvgAggregateOutputType | null
    _sum: MasterSumAggregateOutputType | null
    _min: MasterMinAggregateOutputType | null
    _max: MasterMaxAggregateOutputType | null
  }

  type GetMasterGroupByPayload<T extends MasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterGroupByOutputType[P]>
            : GetScalarType<T[P], MasterGroupByOutputType[P]>
        }
      >
    >


  export type MasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    dtCadastro?: boolean
    stInativo?: boolean
    pacientes?: boolean | Master$pacientesArgs<ExtArgs>
    profissionais?: boolean | Master$profissionaisArgs<ExtArgs>
    usuarioAuths?: boolean | Master$usuarioAuthsArgs<ExtArgs>
    _count?: boolean | MasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["master"]>

  export type MasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    dtCadastro?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["master"]>

  export type MasterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    dtCadastro?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["master"]>

  export type MasterSelectScalar = {
    id?: boolean
    nome?: boolean
    dtCadastro?: boolean
    stInativo?: boolean
  }

  export type MasterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "dtCadastro" | "stInativo", ExtArgs["result"]["master"]>
  export type MasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pacientes?: boolean | Master$pacientesArgs<ExtArgs>
    profissionais?: boolean | Master$profissionaisArgs<ExtArgs>
    usuarioAuths?: boolean | Master$usuarioAuthsArgs<ExtArgs>
    _count?: boolean | MasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MasterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Master"
    objects: {
      pacientes: Prisma.$PacientePayload<ExtArgs>[]
      profissionais: Prisma.$ProfissionalPayload<ExtArgs>[]
      usuarioAuths: Prisma.$UsuarioAuthPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      dtCadastro: Date
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["master"]>
    composites: {}
  }

  type MasterGetPayload<S extends boolean | null | undefined | MasterDefaultArgs> = $Result.GetResult<Prisma.$MasterPayload, S>

  type MasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MasterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MasterCountAggregateInputType | true
    }

  export interface MasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Master'], meta: { name: 'Master' } }
    /**
     * Find zero or one Master that matches the filter.
     * @param {MasterFindUniqueArgs} args - Arguments to find a Master
     * @example
     * // Get one Master
     * const master = await prisma.master.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MasterFindUniqueArgs>(args: SelectSubset<T, MasterFindUniqueArgs<ExtArgs>>): Prisma__MasterClient<$Result.GetResult<Prisma.$MasterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Master that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MasterFindUniqueOrThrowArgs} args - Arguments to find a Master
     * @example
     * // Get one Master
     * const master = await prisma.master.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MasterFindUniqueOrThrowArgs>(args: SelectSubset<T, MasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MasterClient<$Result.GetResult<Prisma.$MasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Master that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterFindFirstArgs} args - Arguments to find a Master
     * @example
     * // Get one Master
     * const master = await prisma.master.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MasterFindFirstArgs>(args?: SelectSubset<T, MasterFindFirstArgs<ExtArgs>>): Prisma__MasterClient<$Result.GetResult<Prisma.$MasterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Master that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterFindFirstOrThrowArgs} args - Arguments to find a Master
     * @example
     * // Get one Master
     * const master = await prisma.master.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MasterFindFirstOrThrowArgs>(args?: SelectSubset<T, MasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__MasterClient<$Result.GetResult<Prisma.$MasterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Masters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Masters
     * const masters = await prisma.master.findMany()
     * 
     * // Get first 10 Masters
     * const masters = await prisma.master.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterWithIdOnly = await prisma.master.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MasterFindManyArgs>(args?: SelectSubset<T, MasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Master.
     * @param {MasterCreateArgs} args - Arguments to create a Master.
     * @example
     * // Create one Master
     * const Master = await prisma.master.create({
     *   data: {
     *     // ... data to create a Master
     *   }
     * })
     * 
     */
    create<T extends MasterCreateArgs>(args: SelectSubset<T, MasterCreateArgs<ExtArgs>>): Prisma__MasterClient<$Result.GetResult<Prisma.$MasterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Masters.
     * @param {MasterCreateManyArgs} args - Arguments to create many Masters.
     * @example
     * // Create many Masters
     * const master = await prisma.master.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MasterCreateManyArgs>(args?: SelectSubset<T, MasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Masters and returns the data saved in the database.
     * @param {MasterCreateManyAndReturnArgs} args - Arguments to create many Masters.
     * @example
     * // Create many Masters
     * const master = await prisma.master.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Masters and only return the `id`
     * const masterWithIdOnly = await prisma.master.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MasterCreateManyAndReturnArgs>(args?: SelectSubset<T, MasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Master.
     * @param {MasterDeleteArgs} args - Arguments to delete one Master.
     * @example
     * // Delete one Master
     * const Master = await prisma.master.delete({
     *   where: {
     *     // ... filter to delete one Master
     *   }
     * })
     * 
     */
    delete<T extends MasterDeleteArgs>(args: SelectSubset<T, MasterDeleteArgs<ExtArgs>>): Prisma__MasterClient<$Result.GetResult<Prisma.$MasterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Master.
     * @param {MasterUpdateArgs} args - Arguments to update one Master.
     * @example
     * // Update one Master
     * const master = await prisma.master.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MasterUpdateArgs>(args: SelectSubset<T, MasterUpdateArgs<ExtArgs>>): Prisma__MasterClient<$Result.GetResult<Prisma.$MasterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Masters.
     * @param {MasterDeleteManyArgs} args - Arguments to filter Masters to delete.
     * @example
     * // Delete a few Masters
     * const { count } = await prisma.master.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MasterDeleteManyArgs>(args?: SelectSubset<T, MasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Masters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Masters
     * const master = await prisma.master.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MasterUpdateManyArgs>(args: SelectSubset<T, MasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Masters and returns the data updated in the database.
     * @param {MasterUpdateManyAndReturnArgs} args - Arguments to update many Masters.
     * @example
     * // Update many Masters
     * const master = await prisma.master.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Masters and only return the `id`
     * const masterWithIdOnly = await prisma.master.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MasterUpdateManyAndReturnArgs>(args: SelectSubset<T, MasterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Master.
     * @param {MasterUpsertArgs} args - Arguments to update or create a Master.
     * @example
     * // Update or create a Master
     * const master = await prisma.master.upsert({
     *   create: {
     *     // ... data to create a Master
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Master we want to update
     *   }
     * })
     */
    upsert<T extends MasterUpsertArgs>(args: SelectSubset<T, MasterUpsertArgs<ExtArgs>>): Prisma__MasterClient<$Result.GetResult<Prisma.$MasterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Masters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterCountArgs} args - Arguments to filter Masters to count.
     * @example
     * // Count the number of Masters
     * const count = await prisma.master.count({
     *   where: {
     *     // ... the filter for the Masters we want to count
     *   }
     * })
    **/
    count<T extends MasterCountArgs>(
      args?: Subset<T, MasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Master.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterAggregateArgs>(args: Subset<T, MasterAggregateArgs>): Prisma.PrismaPromise<GetMasterAggregateType<T>>

    /**
     * Group by Master.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterGroupByArgs['orderBy'] }
        : { orderBy?: MasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Master model
   */
  readonly fields: MasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Master.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pacientes<T extends Master$pacientesArgs<ExtArgs> = {}>(args?: Subset<T, Master$pacientesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profissionais<T extends Master$profissionaisArgs<ExtArgs> = {}>(args?: Subset<T, Master$profissionaisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usuarioAuths<T extends Master$usuarioAuthsArgs<ExtArgs> = {}>(args?: Subset<T, Master$usuarioAuthsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Master model
   */
  interface MasterFieldRefs {
    readonly id: FieldRef<"Master", 'Int'>
    readonly nome: FieldRef<"Master", 'String'>
    readonly dtCadastro: FieldRef<"Master", 'DateTime'>
    readonly stInativo: FieldRef<"Master", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * Master findUnique
   */
  export type MasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Master
     */
    select?: MasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Master
     */
    omit?: MasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterInclude<ExtArgs> | null
    /**
     * Filter, which Master to fetch.
     */
    where: MasterWhereUniqueInput
  }

  /**
   * Master findUniqueOrThrow
   */
  export type MasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Master
     */
    select?: MasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Master
     */
    omit?: MasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterInclude<ExtArgs> | null
    /**
     * Filter, which Master to fetch.
     */
    where: MasterWhereUniqueInput
  }

  /**
   * Master findFirst
   */
  export type MasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Master
     */
    select?: MasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Master
     */
    omit?: MasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterInclude<ExtArgs> | null
    /**
     * Filter, which Master to fetch.
     */
    where?: MasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Masters to fetch.
     */
    orderBy?: MasterOrderByWithRelationInput | MasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Masters.
     */
    cursor?: MasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Masters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Masters.
     */
    distinct?: MasterScalarFieldEnum | MasterScalarFieldEnum[]
  }

  /**
   * Master findFirstOrThrow
   */
  export type MasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Master
     */
    select?: MasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Master
     */
    omit?: MasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterInclude<ExtArgs> | null
    /**
     * Filter, which Master to fetch.
     */
    where?: MasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Masters to fetch.
     */
    orderBy?: MasterOrderByWithRelationInput | MasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Masters.
     */
    cursor?: MasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Masters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Masters.
     */
    distinct?: MasterScalarFieldEnum | MasterScalarFieldEnum[]
  }

  /**
   * Master findMany
   */
  export type MasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Master
     */
    select?: MasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Master
     */
    omit?: MasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterInclude<ExtArgs> | null
    /**
     * Filter, which Masters to fetch.
     */
    where?: MasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Masters to fetch.
     */
    orderBy?: MasterOrderByWithRelationInput | MasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Masters.
     */
    cursor?: MasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Masters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Masters.
     */
    skip?: number
    distinct?: MasterScalarFieldEnum | MasterScalarFieldEnum[]
  }

  /**
   * Master create
   */
  export type MasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Master
     */
    select?: MasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Master
     */
    omit?: MasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterInclude<ExtArgs> | null
    /**
     * The data needed to create a Master.
     */
    data: XOR<MasterCreateInput, MasterUncheckedCreateInput>
  }

  /**
   * Master createMany
   */
  export type MasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Masters.
     */
    data: MasterCreateManyInput | MasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Master createManyAndReturn
   */
  export type MasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Master
     */
    select?: MasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Master
     */
    omit?: MasterOmit<ExtArgs> | null
    /**
     * The data used to create many Masters.
     */
    data: MasterCreateManyInput | MasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Master update
   */
  export type MasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Master
     */
    select?: MasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Master
     */
    omit?: MasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterInclude<ExtArgs> | null
    /**
     * The data needed to update a Master.
     */
    data: XOR<MasterUpdateInput, MasterUncheckedUpdateInput>
    /**
     * Choose, which Master to update.
     */
    where: MasterWhereUniqueInput
  }

  /**
   * Master updateMany
   */
  export type MasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Masters.
     */
    data: XOR<MasterUpdateManyMutationInput, MasterUncheckedUpdateManyInput>
    /**
     * Filter which Masters to update
     */
    where?: MasterWhereInput
    /**
     * Limit how many Masters to update.
     */
    limit?: number
  }

  /**
   * Master updateManyAndReturn
   */
  export type MasterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Master
     */
    select?: MasterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Master
     */
    omit?: MasterOmit<ExtArgs> | null
    /**
     * The data used to update Masters.
     */
    data: XOR<MasterUpdateManyMutationInput, MasterUncheckedUpdateManyInput>
    /**
     * Filter which Masters to update
     */
    where?: MasterWhereInput
    /**
     * Limit how many Masters to update.
     */
    limit?: number
  }

  /**
   * Master upsert
   */
  export type MasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Master
     */
    select?: MasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Master
     */
    omit?: MasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterInclude<ExtArgs> | null
    /**
     * The filter to search for the Master to update in case it exists.
     */
    where: MasterWhereUniqueInput
    /**
     * In case the Master found by the `where` argument doesn't exist, create a new Master with this data.
     */
    create: XOR<MasterCreateInput, MasterUncheckedCreateInput>
    /**
     * In case the Master was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterUpdateInput, MasterUncheckedUpdateInput>
  }

  /**
   * Master delete
   */
  export type MasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Master
     */
    select?: MasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Master
     */
    omit?: MasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterInclude<ExtArgs> | null
    /**
     * Filter which Master to delete.
     */
    where: MasterWhereUniqueInput
  }

  /**
   * Master deleteMany
   */
  export type MasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Masters to delete
     */
    where?: MasterWhereInput
    /**
     * Limit how many Masters to delete.
     */
    limit?: number
  }

  /**
   * Master.pacientes
   */
  export type Master$pacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    where?: PacienteWhereInput
    orderBy?: PacienteOrderByWithRelationInput | PacienteOrderByWithRelationInput[]
    cursor?: PacienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PacienteScalarFieldEnum | PacienteScalarFieldEnum[]
  }

  /**
   * Master.profissionais
   */
  export type Master$profissionaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    where?: ProfissionalWhereInput
    orderBy?: ProfissionalOrderByWithRelationInput | ProfissionalOrderByWithRelationInput[]
    cursor?: ProfissionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfissionalScalarFieldEnum | ProfissionalScalarFieldEnum[]
  }

  /**
   * Master.usuarioAuths
   */
  export type Master$usuarioAuthsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioAuth
     */
    select?: UsuarioAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioAuth
     */
    omit?: UsuarioAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioAuthInclude<ExtArgs> | null
    where?: UsuarioAuthWhereInput
    orderBy?: UsuarioAuthOrderByWithRelationInput | UsuarioAuthOrderByWithRelationInput[]
    cursor?: UsuarioAuthWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioAuthScalarFieldEnum | UsuarioAuthScalarFieldEnum[]
  }

  /**
   * Master without action
   */
  export type MasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Master
     */
    select?: MasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Master
     */
    omit?: MasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterInclude<ExtArgs> | null
  }


  /**
   * Model Paciente
   */

  export type AggregatePaciente = {
    _count: PacienteCountAggregateOutputType | null
    _avg: PacienteAvgAggregateOutputType | null
    _sum: PacienteSumAggregateOutputType | null
    _min: PacienteMinAggregateOutputType | null
    _max: PacienteMaxAggregateOutputType | null
  }

  export type PacienteAvgAggregateOutputType = {
    cdMaster: number | null
    cdPaciente: number | null
    cdEscolaridade: number | null
    cdOcupacao: number | null
  }

  export type PacienteSumAggregateOutputType = {
    cdMaster: number | null
    cdPaciente: number | null
    cdEscolaridade: number | null
    cdOcupacao: number | null
  }

  export type PacienteMinAggregateOutputType = {
    cdMaster: number | null
    cdPaciente: number | null
    nome: string | null
    sexo: $Enums.Sexo | null
    dtNascimento: Date | null
    stInativo: $Enums.SimNao | null
    cdEscolaridade: number | null
    cdOcupacao: number | null
  }

  export type PacienteMaxAggregateOutputType = {
    cdMaster: number | null
    cdPaciente: number | null
    nome: string | null
    sexo: $Enums.Sexo | null
    dtNascimento: Date | null
    stInativo: $Enums.SimNao | null
    cdEscolaridade: number | null
    cdOcupacao: number | null
  }

  export type PacienteCountAggregateOutputType = {
    cdMaster: number
    cdPaciente: number
    nome: number
    sexo: number
    dtNascimento: number
    stInativo: number
    cdEscolaridade: number
    cdOcupacao: number
    _all: number
  }


  export type PacienteAvgAggregateInputType = {
    cdMaster?: true
    cdPaciente?: true
    cdEscolaridade?: true
    cdOcupacao?: true
  }

  export type PacienteSumAggregateInputType = {
    cdMaster?: true
    cdPaciente?: true
    cdEscolaridade?: true
    cdOcupacao?: true
  }

  export type PacienteMinAggregateInputType = {
    cdMaster?: true
    cdPaciente?: true
    nome?: true
    sexo?: true
    dtNascimento?: true
    stInativo?: true
    cdEscolaridade?: true
    cdOcupacao?: true
  }

  export type PacienteMaxAggregateInputType = {
    cdMaster?: true
    cdPaciente?: true
    nome?: true
    sexo?: true
    dtNascimento?: true
    stInativo?: true
    cdEscolaridade?: true
    cdOcupacao?: true
  }

  export type PacienteCountAggregateInputType = {
    cdMaster?: true
    cdPaciente?: true
    nome?: true
    sexo?: true
    dtNascimento?: true
    stInativo?: true
    cdEscolaridade?: true
    cdOcupacao?: true
    _all?: true
  }

  export type PacienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paciente to aggregate.
     */
    where?: PacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pacientes to fetch.
     */
    orderBy?: PacienteOrderByWithRelationInput | PacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pacientes
    **/
    _count?: true | PacienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PacienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PacienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PacienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PacienteMaxAggregateInputType
  }

  export type GetPacienteAggregateType<T extends PacienteAggregateArgs> = {
        [P in keyof T & keyof AggregatePaciente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaciente[P]>
      : GetScalarType<T[P], AggregatePaciente[P]>
  }




  export type PacienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PacienteWhereInput
    orderBy?: PacienteOrderByWithAggregationInput | PacienteOrderByWithAggregationInput[]
    by: PacienteScalarFieldEnum[] | PacienteScalarFieldEnum
    having?: PacienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PacienteCountAggregateInputType | true
    _avg?: PacienteAvgAggregateInputType
    _sum?: PacienteSumAggregateInputType
    _min?: PacienteMinAggregateInputType
    _max?: PacienteMaxAggregateInputType
  }

  export type PacienteGroupByOutputType = {
    cdMaster: number
    cdPaciente: number
    nome: string
    sexo: $Enums.Sexo | null
    dtNascimento: Date | null
    stInativo: $Enums.SimNao | null
    cdEscolaridade: number | null
    cdOcupacao: number | null
    _count: PacienteCountAggregateOutputType | null
    _avg: PacienteAvgAggregateOutputType | null
    _sum: PacienteSumAggregateOutputType | null
    _min: PacienteMinAggregateOutputType | null
    _max: PacienteMaxAggregateOutputType | null
  }

  type GetPacienteGroupByPayload<T extends PacienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PacienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PacienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PacienteGroupByOutputType[P]>
            : GetScalarType<T[P], PacienteGroupByOutputType[P]>
        }
      >
    >


  export type PacienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cdMaster?: boolean
    cdPaciente?: boolean
    nome?: boolean
    sexo?: boolean
    dtNascimento?: boolean
    stInativo?: boolean
    cdEscolaridade?: boolean
    cdOcupacao?: boolean
    atendimentos?: boolean | Paciente$atendimentosArgs<ExtArgs>
    contatos?: boolean | Paciente$contatosArgs<ExtArgs>
    enderecos?: boolean | Paciente$enderecosArgs<ExtArgs>
    evolucoes?: boolean | Paciente$evolucoesArgs<ExtArgs>
    escolaridade?: boolean | Paciente$escolaridadeArgs<ExtArgs>
    master?: boolean | MasterDefaultArgs<ExtArgs>
    ocupacao?: boolean | Paciente$ocupacaoArgs<ExtArgs>
    parentescoPacientes?: boolean | Paciente$parentescoPacientesArgs<ExtArgs>
    usuarioAuths?: boolean | Paciente$usuarioAuthsArgs<ExtArgs>
    _count?: boolean | PacienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paciente"]>

  export type PacienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cdMaster?: boolean
    cdPaciente?: boolean
    nome?: boolean
    sexo?: boolean
    dtNascimento?: boolean
    stInativo?: boolean
    cdEscolaridade?: boolean
    cdOcupacao?: boolean
    escolaridade?: boolean | Paciente$escolaridadeArgs<ExtArgs>
    master?: boolean | MasterDefaultArgs<ExtArgs>
    ocupacao?: boolean | Paciente$ocupacaoArgs<ExtArgs>
  }, ExtArgs["result"]["paciente"]>

  export type PacienteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cdMaster?: boolean
    cdPaciente?: boolean
    nome?: boolean
    sexo?: boolean
    dtNascimento?: boolean
    stInativo?: boolean
    cdEscolaridade?: boolean
    cdOcupacao?: boolean
    escolaridade?: boolean | Paciente$escolaridadeArgs<ExtArgs>
    master?: boolean | MasterDefaultArgs<ExtArgs>
    ocupacao?: boolean | Paciente$ocupacaoArgs<ExtArgs>
  }, ExtArgs["result"]["paciente"]>

  export type PacienteSelectScalar = {
    cdMaster?: boolean
    cdPaciente?: boolean
    nome?: boolean
    sexo?: boolean
    dtNascimento?: boolean
    stInativo?: boolean
    cdEscolaridade?: boolean
    cdOcupacao?: boolean
  }

  export type PacienteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cdMaster" | "cdPaciente" | "nome" | "sexo" | "dtNascimento" | "stInativo" | "cdEscolaridade" | "cdOcupacao", ExtArgs["result"]["paciente"]>
  export type PacienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimentos?: boolean | Paciente$atendimentosArgs<ExtArgs>
    contatos?: boolean | Paciente$contatosArgs<ExtArgs>
    enderecos?: boolean | Paciente$enderecosArgs<ExtArgs>
    evolucoes?: boolean | Paciente$evolucoesArgs<ExtArgs>
    escolaridade?: boolean | Paciente$escolaridadeArgs<ExtArgs>
    master?: boolean | MasterDefaultArgs<ExtArgs>
    ocupacao?: boolean | Paciente$ocupacaoArgs<ExtArgs>
    parentescoPacientes?: boolean | Paciente$parentescoPacientesArgs<ExtArgs>
    usuarioAuths?: boolean | Paciente$usuarioAuthsArgs<ExtArgs>
    _count?: boolean | PacienteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PacienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escolaridade?: boolean | Paciente$escolaridadeArgs<ExtArgs>
    master?: boolean | MasterDefaultArgs<ExtArgs>
    ocupacao?: boolean | Paciente$ocupacaoArgs<ExtArgs>
  }
  export type PacienteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escolaridade?: boolean | Paciente$escolaridadeArgs<ExtArgs>
    master?: boolean | MasterDefaultArgs<ExtArgs>
    ocupacao?: boolean | Paciente$ocupacaoArgs<ExtArgs>
  }

  export type $PacientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Paciente"
    objects: {
      atendimentos: Prisma.$AtendimentoPayload<ExtArgs>[]
      contatos: Prisma.$ContatoPacientePayload<ExtArgs>[]
      enderecos: Prisma.$EnderecoPacientePayload<ExtArgs>[]
      evolucoes: Prisma.$EvolucaoPayload<ExtArgs>[]
      escolaridade: Prisma.$EscolaridadePayload<ExtArgs> | null
      master: Prisma.$MasterPayload<ExtArgs>
      ocupacao: Prisma.$OcupacaoPayload<ExtArgs> | null
      parentescoPacientes: Prisma.$ParentescoPacientePayload<ExtArgs>[]
      usuarioAuths: Prisma.$UsuarioAuthPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      cdMaster: number
      cdPaciente: number
      nome: string
      sexo: $Enums.Sexo | null
      dtNascimento: Date | null
      stInativo: $Enums.SimNao | null
      cdEscolaridade: number | null
      cdOcupacao: number | null
    }, ExtArgs["result"]["paciente"]>
    composites: {}
  }

  type PacienteGetPayload<S extends boolean | null | undefined | PacienteDefaultArgs> = $Result.GetResult<Prisma.$PacientePayload, S>

  type PacienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PacienteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PacienteCountAggregateInputType | true
    }

  export interface PacienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Paciente'], meta: { name: 'Paciente' } }
    /**
     * Find zero or one Paciente that matches the filter.
     * @param {PacienteFindUniqueArgs} args - Arguments to find a Paciente
     * @example
     * // Get one Paciente
     * const paciente = await prisma.paciente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PacienteFindUniqueArgs>(args: SelectSubset<T, PacienteFindUniqueArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Paciente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PacienteFindUniqueOrThrowArgs} args - Arguments to find a Paciente
     * @example
     * // Get one Paciente
     * const paciente = await prisma.paciente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PacienteFindUniqueOrThrowArgs>(args: SelectSubset<T, PacienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paciente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacienteFindFirstArgs} args - Arguments to find a Paciente
     * @example
     * // Get one Paciente
     * const paciente = await prisma.paciente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PacienteFindFirstArgs>(args?: SelectSubset<T, PacienteFindFirstArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paciente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacienteFindFirstOrThrowArgs} args - Arguments to find a Paciente
     * @example
     * // Get one Paciente
     * const paciente = await prisma.paciente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PacienteFindFirstOrThrowArgs>(args?: SelectSubset<T, PacienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pacientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pacientes
     * const pacientes = await prisma.paciente.findMany()
     * 
     * // Get first 10 Pacientes
     * const pacientes = await prisma.paciente.findMany({ take: 10 })
     * 
     * // Only select the `cdMaster`
     * const pacienteWithCdMasterOnly = await prisma.paciente.findMany({ select: { cdMaster: true } })
     * 
     */
    findMany<T extends PacienteFindManyArgs>(args?: SelectSubset<T, PacienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Paciente.
     * @param {PacienteCreateArgs} args - Arguments to create a Paciente.
     * @example
     * // Create one Paciente
     * const Paciente = await prisma.paciente.create({
     *   data: {
     *     // ... data to create a Paciente
     *   }
     * })
     * 
     */
    create<T extends PacienteCreateArgs>(args: SelectSubset<T, PacienteCreateArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pacientes.
     * @param {PacienteCreateManyArgs} args - Arguments to create many Pacientes.
     * @example
     * // Create many Pacientes
     * const paciente = await prisma.paciente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PacienteCreateManyArgs>(args?: SelectSubset<T, PacienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pacientes and returns the data saved in the database.
     * @param {PacienteCreateManyAndReturnArgs} args - Arguments to create many Pacientes.
     * @example
     * // Create many Pacientes
     * const paciente = await prisma.paciente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pacientes and only return the `cdMaster`
     * const pacienteWithCdMasterOnly = await prisma.paciente.createManyAndReturn({
     *   select: { cdMaster: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PacienteCreateManyAndReturnArgs>(args?: SelectSubset<T, PacienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Paciente.
     * @param {PacienteDeleteArgs} args - Arguments to delete one Paciente.
     * @example
     * // Delete one Paciente
     * const Paciente = await prisma.paciente.delete({
     *   where: {
     *     // ... filter to delete one Paciente
     *   }
     * })
     * 
     */
    delete<T extends PacienteDeleteArgs>(args: SelectSubset<T, PacienteDeleteArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Paciente.
     * @param {PacienteUpdateArgs} args - Arguments to update one Paciente.
     * @example
     * // Update one Paciente
     * const paciente = await prisma.paciente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PacienteUpdateArgs>(args: SelectSubset<T, PacienteUpdateArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pacientes.
     * @param {PacienteDeleteManyArgs} args - Arguments to filter Pacientes to delete.
     * @example
     * // Delete a few Pacientes
     * const { count } = await prisma.paciente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PacienteDeleteManyArgs>(args?: SelectSubset<T, PacienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pacientes
     * const paciente = await prisma.paciente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PacienteUpdateManyArgs>(args: SelectSubset<T, PacienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pacientes and returns the data updated in the database.
     * @param {PacienteUpdateManyAndReturnArgs} args - Arguments to update many Pacientes.
     * @example
     * // Update many Pacientes
     * const paciente = await prisma.paciente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pacientes and only return the `cdMaster`
     * const pacienteWithCdMasterOnly = await prisma.paciente.updateManyAndReturn({
     *   select: { cdMaster: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PacienteUpdateManyAndReturnArgs>(args: SelectSubset<T, PacienteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Paciente.
     * @param {PacienteUpsertArgs} args - Arguments to update or create a Paciente.
     * @example
     * // Update or create a Paciente
     * const paciente = await prisma.paciente.upsert({
     *   create: {
     *     // ... data to create a Paciente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paciente we want to update
     *   }
     * })
     */
    upsert<T extends PacienteUpsertArgs>(args: SelectSubset<T, PacienteUpsertArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacienteCountArgs} args - Arguments to filter Pacientes to count.
     * @example
     * // Count the number of Pacientes
     * const count = await prisma.paciente.count({
     *   where: {
     *     // ... the filter for the Pacientes we want to count
     *   }
     * })
    **/
    count<T extends PacienteCountArgs>(
      args?: Subset<T, PacienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PacienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paciente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PacienteAggregateArgs>(args: Subset<T, PacienteAggregateArgs>): Prisma.PrismaPromise<GetPacienteAggregateType<T>>

    /**
     * Group by Paciente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PacienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PacienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PacienteGroupByArgs['orderBy'] }
        : { orderBy?: PacienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PacienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPacienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Paciente model
   */
  readonly fields: PacienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Paciente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PacienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    atendimentos<T extends Paciente$atendimentosArgs<ExtArgs> = {}>(args?: Subset<T, Paciente$atendimentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contatos<T extends Paciente$contatosArgs<ExtArgs> = {}>(args?: Subset<T, Paciente$contatosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContatoPacientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enderecos<T extends Paciente$enderecosArgs<ExtArgs> = {}>(args?: Subset<T, Paciente$enderecosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPacientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evolucoes<T extends Paciente$evolucoesArgs<ExtArgs> = {}>(args?: Subset<T, Paciente$evolucoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    escolaridade<T extends Paciente$escolaridadeArgs<ExtArgs> = {}>(args?: Subset<T, Paciente$escolaridadeArgs<ExtArgs>>): Prisma__EscolaridadeClient<$Result.GetResult<Prisma.$EscolaridadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    master<T extends MasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MasterDefaultArgs<ExtArgs>>): Prisma__MasterClient<$Result.GetResult<Prisma.$MasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ocupacao<T extends Paciente$ocupacaoArgs<ExtArgs> = {}>(args?: Subset<T, Paciente$ocupacaoArgs<ExtArgs>>): Prisma__OcupacaoClient<$Result.GetResult<Prisma.$OcupacaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parentescoPacientes<T extends Paciente$parentescoPacientesArgs<ExtArgs> = {}>(args?: Subset<T, Paciente$parentescoPacientesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentescoPacientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usuarioAuths<T extends Paciente$usuarioAuthsArgs<ExtArgs> = {}>(args?: Subset<T, Paciente$usuarioAuthsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Paciente model
   */
  interface PacienteFieldRefs {
    readonly cdMaster: FieldRef<"Paciente", 'Int'>
    readonly cdPaciente: FieldRef<"Paciente", 'Int'>
    readonly nome: FieldRef<"Paciente", 'String'>
    readonly sexo: FieldRef<"Paciente", 'Sexo'>
    readonly dtNascimento: FieldRef<"Paciente", 'DateTime'>
    readonly stInativo: FieldRef<"Paciente", 'SimNao'>
    readonly cdEscolaridade: FieldRef<"Paciente", 'Int'>
    readonly cdOcupacao: FieldRef<"Paciente", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Paciente findUnique
   */
  export type PacienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * Filter, which Paciente to fetch.
     */
    where: PacienteWhereUniqueInput
  }

  /**
   * Paciente findUniqueOrThrow
   */
  export type PacienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * Filter, which Paciente to fetch.
     */
    where: PacienteWhereUniqueInput
  }

  /**
   * Paciente findFirst
   */
  export type PacienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * Filter, which Paciente to fetch.
     */
    where?: PacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pacientes to fetch.
     */
    orderBy?: PacienteOrderByWithRelationInput | PacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pacientes.
     */
    cursor?: PacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pacientes.
     */
    distinct?: PacienteScalarFieldEnum | PacienteScalarFieldEnum[]
  }

  /**
   * Paciente findFirstOrThrow
   */
  export type PacienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * Filter, which Paciente to fetch.
     */
    where?: PacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pacientes to fetch.
     */
    orderBy?: PacienteOrderByWithRelationInput | PacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pacientes.
     */
    cursor?: PacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pacientes.
     */
    distinct?: PacienteScalarFieldEnum | PacienteScalarFieldEnum[]
  }

  /**
   * Paciente findMany
   */
  export type PacienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * Filter, which Pacientes to fetch.
     */
    where?: PacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pacientes to fetch.
     */
    orderBy?: PacienteOrderByWithRelationInput | PacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pacientes.
     */
    cursor?: PacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pacientes.
     */
    skip?: number
    distinct?: PacienteScalarFieldEnum | PacienteScalarFieldEnum[]
  }

  /**
   * Paciente create
   */
  export type PacienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * The data needed to create a Paciente.
     */
    data: XOR<PacienteCreateInput, PacienteUncheckedCreateInput>
  }

  /**
   * Paciente createMany
   */
  export type PacienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pacientes.
     */
    data: PacienteCreateManyInput | PacienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Paciente createManyAndReturn
   */
  export type PacienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * The data used to create many Pacientes.
     */
    data: PacienteCreateManyInput | PacienteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Paciente update
   */
  export type PacienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * The data needed to update a Paciente.
     */
    data: XOR<PacienteUpdateInput, PacienteUncheckedUpdateInput>
    /**
     * Choose, which Paciente to update.
     */
    where: PacienteWhereUniqueInput
  }

  /**
   * Paciente updateMany
   */
  export type PacienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pacientes.
     */
    data: XOR<PacienteUpdateManyMutationInput, PacienteUncheckedUpdateManyInput>
    /**
     * Filter which Pacientes to update
     */
    where?: PacienteWhereInput
    /**
     * Limit how many Pacientes to update.
     */
    limit?: number
  }

  /**
   * Paciente updateManyAndReturn
   */
  export type PacienteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * The data used to update Pacientes.
     */
    data: XOR<PacienteUpdateManyMutationInput, PacienteUncheckedUpdateManyInput>
    /**
     * Filter which Pacientes to update
     */
    where?: PacienteWhereInput
    /**
     * Limit how many Pacientes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Paciente upsert
   */
  export type PacienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * The filter to search for the Paciente to update in case it exists.
     */
    where: PacienteWhereUniqueInput
    /**
     * In case the Paciente found by the `where` argument doesn't exist, create a new Paciente with this data.
     */
    create: XOR<PacienteCreateInput, PacienteUncheckedCreateInput>
    /**
     * In case the Paciente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PacienteUpdateInput, PacienteUncheckedUpdateInput>
  }

  /**
   * Paciente delete
   */
  export type PacienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    /**
     * Filter which Paciente to delete.
     */
    where: PacienteWhereUniqueInput
  }

  /**
   * Paciente deleteMany
   */
  export type PacienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pacientes to delete
     */
    where?: PacienteWhereInput
    /**
     * Limit how many Pacientes to delete.
     */
    limit?: number
  }

  /**
   * Paciente.atendimentos
   */
  export type Paciente$atendimentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atendimento
     */
    select?: AtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atendimento
     */
    omit?: AtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtendimentoInclude<ExtArgs> | null
    where?: AtendimentoWhereInput
    orderBy?: AtendimentoOrderByWithRelationInput | AtendimentoOrderByWithRelationInput[]
    cursor?: AtendimentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AtendimentoScalarFieldEnum | AtendimentoScalarFieldEnum[]
  }

  /**
   * Paciente.contatos
   */
  export type Paciente$contatosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoPaciente
     */
    select?: ContatoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoPaciente
     */
    omit?: ContatoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoPacienteInclude<ExtArgs> | null
    where?: ContatoPacienteWhereInput
    orderBy?: ContatoPacienteOrderByWithRelationInput | ContatoPacienteOrderByWithRelationInput[]
    cursor?: ContatoPacienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContatoPacienteScalarFieldEnum | ContatoPacienteScalarFieldEnum[]
  }

  /**
   * Paciente.enderecos
   */
  export type Paciente$enderecosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPaciente
     */
    select?: EnderecoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPaciente
     */
    omit?: EnderecoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPacienteInclude<ExtArgs> | null
    where?: EnderecoPacienteWhereInput
    orderBy?: EnderecoPacienteOrderByWithRelationInput | EnderecoPacienteOrderByWithRelationInput[]
    cursor?: EnderecoPacienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnderecoPacienteScalarFieldEnum | EnderecoPacienteScalarFieldEnum[]
  }

  /**
   * Paciente.evolucoes
   */
  export type Paciente$evolucoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoInclude<ExtArgs> | null
    where?: EvolucaoWhereInput
    orderBy?: EvolucaoOrderByWithRelationInput | EvolucaoOrderByWithRelationInput[]
    cursor?: EvolucaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvolucaoScalarFieldEnum | EvolucaoScalarFieldEnum[]
  }

  /**
   * Paciente.escolaridade
   */
  export type Paciente$escolaridadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escolaridade
     */
    select?: EscolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escolaridade
     */
    omit?: EscolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaridadeInclude<ExtArgs> | null
    where?: EscolaridadeWhereInput
  }

  /**
   * Paciente.ocupacao
   */
  export type Paciente$ocupacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ocupacao
     */
    select?: OcupacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ocupacao
     */
    omit?: OcupacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcupacaoInclude<ExtArgs> | null
    where?: OcupacaoWhereInput
  }

  /**
   * Paciente.parentescoPacientes
   */
  export type Paciente$parentescoPacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentescoPaciente
     */
    select?: ParentescoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentescoPaciente
     */
    omit?: ParentescoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentescoPacienteInclude<ExtArgs> | null
    where?: ParentescoPacienteWhereInput
    orderBy?: ParentescoPacienteOrderByWithRelationInput | ParentescoPacienteOrderByWithRelationInput[]
    cursor?: ParentescoPacienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentescoPacienteScalarFieldEnum | ParentescoPacienteScalarFieldEnum[]
  }

  /**
   * Paciente.usuarioAuths
   */
  export type Paciente$usuarioAuthsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioAuth
     */
    select?: UsuarioAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioAuth
     */
    omit?: UsuarioAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioAuthInclude<ExtArgs> | null
    where?: UsuarioAuthWhereInput
    orderBy?: UsuarioAuthOrderByWithRelationInput | UsuarioAuthOrderByWithRelationInput[]
    cursor?: UsuarioAuthWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioAuthScalarFieldEnum | UsuarioAuthScalarFieldEnum[]
  }

  /**
   * Paciente without action
   */
  export type PacienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
  }


  /**
   * Model Profissional
   */

  export type AggregateProfissional = {
    _count: ProfissionalCountAggregateOutputType | null
    _avg: ProfissionalAvgAggregateOutputType | null
    _sum: ProfissionalSumAggregateOutputType | null
    _min: ProfissionalMinAggregateOutputType | null
    _max: ProfissionalMaxAggregateOutputType | null
  }

  export type ProfissionalAvgAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdOcupacao: number | null
  }

  export type ProfissionalSumAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdOcupacao: number | null
  }

  export type ProfissionalMinAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    nome: string | null
    sexo: $Enums.Sexo | null
    conselho: string | null
    stInativo: $Enums.SimNao | null
    cdOcupacao: number | null
  }

  export type ProfissionalMaxAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    nome: string | null
    sexo: $Enums.Sexo | null
    conselho: string | null
    stInativo: $Enums.SimNao | null
    cdOcupacao: number | null
  }

  export type ProfissionalCountAggregateOutputType = {
    id: number
    cdMaster: number
    nome: number
    sexo: number
    conselho: number
    stInativo: number
    cdOcupacao: number
    _all: number
  }


  export type ProfissionalAvgAggregateInputType = {
    id?: true
    cdMaster?: true
    cdOcupacao?: true
  }

  export type ProfissionalSumAggregateInputType = {
    id?: true
    cdMaster?: true
    cdOcupacao?: true
  }

  export type ProfissionalMinAggregateInputType = {
    id?: true
    cdMaster?: true
    nome?: true
    sexo?: true
    conselho?: true
    stInativo?: true
    cdOcupacao?: true
  }

  export type ProfissionalMaxAggregateInputType = {
    id?: true
    cdMaster?: true
    nome?: true
    sexo?: true
    conselho?: true
    stInativo?: true
    cdOcupacao?: true
  }

  export type ProfissionalCountAggregateInputType = {
    id?: true
    cdMaster?: true
    nome?: true
    sexo?: true
    conselho?: true
    stInativo?: true
    cdOcupacao?: true
    _all?: true
  }

  export type ProfissionalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profissional to aggregate.
     */
    where?: ProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profissionals to fetch.
     */
    orderBy?: ProfissionalOrderByWithRelationInput | ProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profissionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profissionals
    **/
    _count?: true | ProfissionalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfissionalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfissionalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfissionalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfissionalMaxAggregateInputType
  }

  export type GetProfissionalAggregateType<T extends ProfissionalAggregateArgs> = {
        [P in keyof T & keyof AggregateProfissional]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfissional[P]>
      : GetScalarType<T[P], AggregateProfissional[P]>
  }




  export type ProfissionalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfissionalWhereInput
    orderBy?: ProfissionalOrderByWithAggregationInput | ProfissionalOrderByWithAggregationInput[]
    by: ProfissionalScalarFieldEnum[] | ProfissionalScalarFieldEnum
    having?: ProfissionalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfissionalCountAggregateInputType | true
    _avg?: ProfissionalAvgAggregateInputType
    _sum?: ProfissionalSumAggregateInputType
    _min?: ProfissionalMinAggregateInputType
    _max?: ProfissionalMaxAggregateInputType
  }

  export type ProfissionalGroupByOutputType = {
    id: number
    cdMaster: number
    nome: string
    sexo: $Enums.Sexo | null
    conselho: string | null
    stInativo: $Enums.SimNao | null
    cdOcupacao: number | null
    _count: ProfissionalCountAggregateOutputType | null
    _avg: ProfissionalAvgAggregateOutputType | null
    _sum: ProfissionalSumAggregateOutputType | null
    _min: ProfissionalMinAggregateOutputType | null
    _max: ProfissionalMaxAggregateOutputType | null
  }

  type GetProfissionalGroupByPayload<T extends ProfissionalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfissionalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfissionalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfissionalGroupByOutputType[P]>
            : GetScalarType<T[P], ProfissionalGroupByOutputType[P]>
        }
      >
    >


  export type ProfissionalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    nome?: boolean
    sexo?: boolean
    conselho?: boolean
    stInativo?: boolean
    cdOcupacao?: boolean
    afericoesClinicas?: boolean | Profissional$afericoesClinicasArgs<ExtArgs>
    atendimentos?: boolean | Profissional$atendimentosArgs<ExtArgs>
    contatos?: boolean | Profissional$contatosArgs<ExtArgs>
    enderecos?: boolean | Profissional$enderecosArgs<ExtArgs>
    evaDores?: boolean | Profissional$evaDoresArgs<ExtArgs>
    evolucoes?: boolean | Profissional$evolucoesArgs<ExtArgs>
    glasgows?: boolean | Profissional$glasgowsArgs<ExtArgs>
    master?: boolean | MasterDefaultArgs<ExtArgs>
    ocupacao?: boolean | Profissional$ocupacaoArgs<ExtArgs>
    usuarioAuths?: boolean | Profissional$usuarioAuthsArgs<ExtArgs>
    _count?: boolean | ProfissionalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profissional"]>

  export type ProfissionalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    nome?: boolean
    sexo?: boolean
    conselho?: boolean
    stInativo?: boolean
    cdOcupacao?: boolean
    master?: boolean | MasterDefaultArgs<ExtArgs>
    ocupacao?: boolean | Profissional$ocupacaoArgs<ExtArgs>
  }, ExtArgs["result"]["profissional"]>

  export type ProfissionalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    nome?: boolean
    sexo?: boolean
    conselho?: boolean
    stInativo?: boolean
    cdOcupacao?: boolean
    master?: boolean | MasterDefaultArgs<ExtArgs>
    ocupacao?: boolean | Profissional$ocupacaoArgs<ExtArgs>
  }, ExtArgs["result"]["profissional"]>

  export type ProfissionalSelectScalar = {
    id?: boolean
    cdMaster?: boolean
    nome?: boolean
    sexo?: boolean
    conselho?: boolean
    stInativo?: boolean
    cdOcupacao?: boolean
  }

  export type ProfissionalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdMaster" | "nome" | "sexo" | "conselho" | "stInativo" | "cdOcupacao", ExtArgs["result"]["profissional"]>
  export type ProfissionalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    afericoesClinicas?: boolean | Profissional$afericoesClinicasArgs<ExtArgs>
    atendimentos?: boolean | Profissional$atendimentosArgs<ExtArgs>
    contatos?: boolean | Profissional$contatosArgs<ExtArgs>
    enderecos?: boolean | Profissional$enderecosArgs<ExtArgs>
    evaDores?: boolean | Profissional$evaDoresArgs<ExtArgs>
    evolucoes?: boolean | Profissional$evolucoesArgs<ExtArgs>
    glasgows?: boolean | Profissional$glasgowsArgs<ExtArgs>
    master?: boolean | MasterDefaultArgs<ExtArgs>
    ocupacao?: boolean | Profissional$ocupacaoArgs<ExtArgs>
    usuarioAuths?: boolean | Profissional$usuarioAuthsArgs<ExtArgs>
    _count?: boolean | ProfissionalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfissionalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    master?: boolean | MasterDefaultArgs<ExtArgs>
    ocupacao?: boolean | Profissional$ocupacaoArgs<ExtArgs>
  }
  export type ProfissionalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    master?: boolean | MasterDefaultArgs<ExtArgs>
    ocupacao?: boolean | Profissional$ocupacaoArgs<ExtArgs>
  }

  export type $ProfissionalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profissional"
    objects: {
      afericoesClinicas: Prisma.$AfericaoClinicaPayload<ExtArgs>[]
      atendimentos: Prisma.$AtendimentoPayload<ExtArgs>[]
      contatos: Prisma.$ContatoProfissionalPayload<ExtArgs>[]
      enderecos: Prisma.$EnderecoProfissionalPayload<ExtArgs>[]
      evaDores: Prisma.$EvaDorPayload<ExtArgs>[]
      evolucoes: Prisma.$EvolucaoPayload<ExtArgs>[]
      glasgows: Prisma.$GlasgowPayload<ExtArgs>[]
      master: Prisma.$MasterPayload<ExtArgs>
      ocupacao: Prisma.$OcupacaoPayload<ExtArgs> | null
      usuarioAuths: Prisma.$UsuarioAuthPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdMaster: number
      nome: string
      sexo: $Enums.Sexo | null
      conselho: string | null
      stInativo: $Enums.SimNao | null
      cdOcupacao: number | null
    }, ExtArgs["result"]["profissional"]>
    composites: {}
  }

  type ProfissionalGetPayload<S extends boolean | null | undefined | ProfissionalDefaultArgs> = $Result.GetResult<Prisma.$ProfissionalPayload, S>

  type ProfissionalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfissionalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfissionalCountAggregateInputType | true
    }

  export interface ProfissionalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profissional'], meta: { name: 'Profissional' } }
    /**
     * Find zero or one Profissional that matches the filter.
     * @param {ProfissionalFindUniqueArgs} args - Arguments to find a Profissional
     * @example
     * // Get one Profissional
     * const profissional = await prisma.profissional.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfissionalFindUniqueArgs>(args: SelectSubset<T, ProfissionalFindUniqueArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profissional that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfissionalFindUniqueOrThrowArgs} args - Arguments to find a Profissional
     * @example
     * // Get one Profissional
     * const profissional = await prisma.profissional.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfissionalFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfissionalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profissional that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfissionalFindFirstArgs} args - Arguments to find a Profissional
     * @example
     * // Get one Profissional
     * const profissional = await prisma.profissional.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfissionalFindFirstArgs>(args?: SelectSubset<T, ProfissionalFindFirstArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profissional that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfissionalFindFirstOrThrowArgs} args - Arguments to find a Profissional
     * @example
     * // Get one Profissional
     * const profissional = await prisma.profissional.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfissionalFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfissionalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profissionals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfissionalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profissionals
     * const profissionals = await prisma.profissional.findMany()
     * 
     * // Get first 10 Profissionals
     * const profissionals = await prisma.profissional.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profissionalWithIdOnly = await prisma.profissional.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfissionalFindManyArgs>(args?: SelectSubset<T, ProfissionalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profissional.
     * @param {ProfissionalCreateArgs} args - Arguments to create a Profissional.
     * @example
     * // Create one Profissional
     * const Profissional = await prisma.profissional.create({
     *   data: {
     *     // ... data to create a Profissional
     *   }
     * })
     * 
     */
    create<T extends ProfissionalCreateArgs>(args: SelectSubset<T, ProfissionalCreateArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profissionals.
     * @param {ProfissionalCreateManyArgs} args - Arguments to create many Profissionals.
     * @example
     * // Create many Profissionals
     * const profissional = await prisma.profissional.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfissionalCreateManyArgs>(args?: SelectSubset<T, ProfissionalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profissionals and returns the data saved in the database.
     * @param {ProfissionalCreateManyAndReturnArgs} args - Arguments to create many Profissionals.
     * @example
     * // Create many Profissionals
     * const profissional = await prisma.profissional.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profissionals and only return the `id`
     * const profissionalWithIdOnly = await prisma.profissional.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfissionalCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfissionalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profissional.
     * @param {ProfissionalDeleteArgs} args - Arguments to delete one Profissional.
     * @example
     * // Delete one Profissional
     * const Profissional = await prisma.profissional.delete({
     *   where: {
     *     // ... filter to delete one Profissional
     *   }
     * })
     * 
     */
    delete<T extends ProfissionalDeleteArgs>(args: SelectSubset<T, ProfissionalDeleteArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profissional.
     * @param {ProfissionalUpdateArgs} args - Arguments to update one Profissional.
     * @example
     * // Update one Profissional
     * const profissional = await prisma.profissional.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfissionalUpdateArgs>(args: SelectSubset<T, ProfissionalUpdateArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profissionals.
     * @param {ProfissionalDeleteManyArgs} args - Arguments to filter Profissionals to delete.
     * @example
     * // Delete a few Profissionals
     * const { count } = await prisma.profissional.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfissionalDeleteManyArgs>(args?: SelectSubset<T, ProfissionalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profissionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfissionalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profissionals
     * const profissional = await prisma.profissional.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfissionalUpdateManyArgs>(args: SelectSubset<T, ProfissionalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profissionals and returns the data updated in the database.
     * @param {ProfissionalUpdateManyAndReturnArgs} args - Arguments to update many Profissionals.
     * @example
     * // Update many Profissionals
     * const profissional = await prisma.profissional.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profissionals and only return the `id`
     * const profissionalWithIdOnly = await prisma.profissional.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfissionalUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfissionalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profissional.
     * @param {ProfissionalUpsertArgs} args - Arguments to update or create a Profissional.
     * @example
     * // Update or create a Profissional
     * const profissional = await prisma.profissional.upsert({
     *   create: {
     *     // ... data to create a Profissional
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profissional we want to update
     *   }
     * })
     */
    upsert<T extends ProfissionalUpsertArgs>(args: SelectSubset<T, ProfissionalUpsertArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profissionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfissionalCountArgs} args - Arguments to filter Profissionals to count.
     * @example
     * // Count the number of Profissionals
     * const count = await prisma.profissional.count({
     *   where: {
     *     // ... the filter for the Profissionals we want to count
     *   }
     * })
    **/
    count<T extends ProfissionalCountArgs>(
      args?: Subset<T, ProfissionalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfissionalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profissional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfissionalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfissionalAggregateArgs>(args: Subset<T, ProfissionalAggregateArgs>): Prisma.PrismaPromise<GetProfissionalAggregateType<T>>

    /**
     * Group by Profissional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfissionalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfissionalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfissionalGroupByArgs['orderBy'] }
        : { orderBy?: ProfissionalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfissionalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfissionalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profissional model
   */
  readonly fields: ProfissionalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profissional.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfissionalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    afericoesClinicas<T extends Profissional$afericoesClinicasArgs<ExtArgs> = {}>(args?: Subset<T, Profissional$afericoesClinicasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AfericaoClinicaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    atendimentos<T extends Profissional$atendimentosArgs<ExtArgs> = {}>(args?: Subset<T, Profissional$atendimentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contatos<T extends Profissional$contatosArgs<ExtArgs> = {}>(args?: Subset<T, Profissional$contatosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContatoProfissionalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enderecos<T extends Profissional$enderecosArgs<ExtArgs> = {}>(args?: Subset<T, Profissional$enderecosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoProfissionalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evaDores<T extends Profissional$evaDoresArgs<ExtArgs> = {}>(args?: Subset<T, Profissional$evaDoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaDorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evolucoes<T extends Profissional$evolucoesArgs<ExtArgs> = {}>(args?: Subset<T, Profissional$evolucoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    glasgows<T extends Profissional$glasgowsArgs<ExtArgs> = {}>(args?: Subset<T, Profissional$glasgowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlasgowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    master<T extends MasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MasterDefaultArgs<ExtArgs>>): Prisma__MasterClient<$Result.GetResult<Prisma.$MasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ocupacao<T extends Profissional$ocupacaoArgs<ExtArgs> = {}>(args?: Subset<T, Profissional$ocupacaoArgs<ExtArgs>>): Prisma__OcupacaoClient<$Result.GetResult<Prisma.$OcupacaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    usuarioAuths<T extends Profissional$usuarioAuthsArgs<ExtArgs> = {}>(args?: Subset<T, Profissional$usuarioAuthsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profissional model
   */
  interface ProfissionalFieldRefs {
    readonly id: FieldRef<"Profissional", 'Int'>
    readonly cdMaster: FieldRef<"Profissional", 'Int'>
    readonly nome: FieldRef<"Profissional", 'String'>
    readonly sexo: FieldRef<"Profissional", 'Sexo'>
    readonly conselho: FieldRef<"Profissional", 'String'>
    readonly stInativo: FieldRef<"Profissional", 'SimNao'>
    readonly cdOcupacao: FieldRef<"Profissional", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Profissional findUnique
   */
  export type ProfissionalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which Profissional to fetch.
     */
    where: ProfissionalWhereUniqueInput
  }

  /**
   * Profissional findUniqueOrThrow
   */
  export type ProfissionalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which Profissional to fetch.
     */
    where: ProfissionalWhereUniqueInput
  }

  /**
   * Profissional findFirst
   */
  export type ProfissionalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which Profissional to fetch.
     */
    where?: ProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profissionals to fetch.
     */
    orderBy?: ProfissionalOrderByWithRelationInput | ProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profissionals.
     */
    cursor?: ProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profissionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profissionals.
     */
    distinct?: ProfissionalScalarFieldEnum | ProfissionalScalarFieldEnum[]
  }

  /**
   * Profissional findFirstOrThrow
   */
  export type ProfissionalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which Profissional to fetch.
     */
    where?: ProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profissionals to fetch.
     */
    orderBy?: ProfissionalOrderByWithRelationInput | ProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profissionals.
     */
    cursor?: ProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profissionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profissionals.
     */
    distinct?: ProfissionalScalarFieldEnum | ProfissionalScalarFieldEnum[]
  }

  /**
   * Profissional findMany
   */
  export type ProfissionalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which Profissionals to fetch.
     */
    where?: ProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profissionals to fetch.
     */
    orderBy?: ProfissionalOrderByWithRelationInput | ProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profissionals.
     */
    cursor?: ProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profissionals.
     */
    skip?: number
    distinct?: ProfissionalScalarFieldEnum | ProfissionalScalarFieldEnum[]
  }

  /**
   * Profissional create
   */
  export type ProfissionalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * The data needed to create a Profissional.
     */
    data: XOR<ProfissionalCreateInput, ProfissionalUncheckedCreateInput>
  }

  /**
   * Profissional createMany
   */
  export type ProfissionalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profissionals.
     */
    data: ProfissionalCreateManyInput | ProfissionalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profissional createManyAndReturn
   */
  export type ProfissionalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * The data used to create many Profissionals.
     */
    data: ProfissionalCreateManyInput | ProfissionalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profissional update
   */
  export type ProfissionalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * The data needed to update a Profissional.
     */
    data: XOR<ProfissionalUpdateInput, ProfissionalUncheckedUpdateInput>
    /**
     * Choose, which Profissional to update.
     */
    where: ProfissionalWhereUniqueInput
  }

  /**
   * Profissional updateMany
   */
  export type ProfissionalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profissionals.
     */
    data: XOR<ProfissionalUpdateManyMutationInput, ProfissionalUncheckedUpdateManyInput>
    /**
     * Filter which Profissionals to update
     */
    where?: ProfissionalWhereInput
    /**
     * Limit how many Profissionals to update.
     */
    limit?: number
  }

  /**
   * Profissional updateManyAndReturn
   */
  export type ProfissionalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * The data used to update Profissionals.
     */
    data: XOR<ProfissionalUpdateManyMutationInput, ProfissionalUncheckedUpdateManyInput>
    /**
     * Filter which Profissionals to update
     */
    where?: ProfissionalWhereInput
    /**
     * Limit how many Profissionals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profissional upsert
   */
  export type ProfissionalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * The filter to search for the Profissional to update in case it exists.
     */
    where: ProfissionalWhereUniqueInput
    /**
     * In case the Profissional found by the `where` argument doesn't exist, create a new Profissional with this data.
     */
    create: XOR<ProfissionalCreateInput, ProfissionalUncheckedCreateInput>
    /**
     * In case the Profissional was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfissionalUpdateInput, ProfissionalUncheckedUpdateInput>
  }

  /**
   * Profissional delete
   */
  export type ProfissionalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * Filter which Profissional to delete.
     */
    where: ProfissionalWhereUniqueInput
  }

  /**
   * Profissional deleteMany
   */
  export type ProfissionalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profissionals to delete
     */
    where?: ProfissionalWhereInput
    /**
     * Limit how many Profissionals to delete.
     */
    limit?: number
  }

  /**
   * Profissional.afericoesClinicas
   */
  export type Profissional$afericoesClinicasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfericaoClinica
     */
    select?: AfericaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfericaoClinica
     */
    omit?: AfericaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfericaoClinicaInclude<ExtArgs> | null
    where?: AfericaoClinicaWhereInput
    orderBy?: AfericaoClinicaOrderByWithRelationInput | AfericaoClinicaOrderByWithRelationInput[]
    cursor?: AfericaoClinicaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AfericaoClinicaScalarFieldEnum | AfericaoClinicaScalarFieldEnum[]
  }

  /**
   * Profissional.atendimentos
   */
  export type Profissional$atendimentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atendimento
     */
    select?: AtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atendimento
     */
    omit?: AtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtendimentoInclude<ExtArgs> | null
    where?: AtendimentoWhereInput
    orderBy?: AtendimentoOrderByWithRelationInput | AtendimentoOrderByWithRelationInput[]
    cursor?: AtendimentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AtendimentoScalarFieldEnum | AtendimentoScalarFieldEnum[]
  }

  /**
   * Profissional.contatos
   */
  export type Profissional$contatosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoProfissional
     */
    select?: ContatoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoProfissional
     */
    omit?: ContatoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoProfissionalInclude<ExtArgs> | null
    where?: ContatoProfissionalWhereInput
    orderBy?: ContatoProfissionalOrderByWithRelationInput | ContatoProfissionalOrderByWithRelationInput[]
    cursor?: ContatoProfissionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContatoProfissionalScalarFieldEnum | ContatoProfissionalScalarFieldEnum[]
  }

  /**
   * Profissional.enderecos
   */
  export type Profissional$enderecosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoProfissional
     */
    select?: EnderecoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoProfissional
     */
    omit?: EnderecoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoProfissionalInclude<ExtArgs> | null
    where?: EnderecoProfissionalWhereInput
    orderBy?: EnderecoProfissionalOrderByWithRelationInput | EnderecoProfissionalOrderByWithRelationInput[]
    cursor?: EnderecoProfissionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnderecoProfissionalScalarFieldEnum | EnderecoProfissionalScalarFieldEnum[]
  }

  /**
   * Profissional.evaDores
   */
  export type Profissional$evaDoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaDor
     */
    select?: EvaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaDor
     */
    omit?: EvaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaDorInclude<ExtArgs> | null
    where?: EvaDorWhereInput
    orderBy?: EvaDorOrderByWithRelationInput | EvaDorOrderByWithRelationInput[]
    cursor?: EvaDorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaDorScalarFieldEnum | EvaDorScalarFieldEnum[]
  }

  /**
   * Profissional.evolucoes
   */
  export type Profissional$evolucoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoInclude<ExtArgs> | null
    where?: EvolucaoWhereInput
    orderBy?: EvolucaoOrderByWithRelationInput | EvolucaoOrderByWithRelationInput[]
    cursor?: EvolucaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvolucaoScalarFieldEnum | EvolucaoScalarFieldEnum[]
  }

  /**
   * Profissional.glasgows
   */
  export type Profissional$glasgowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Glasgow
     */
    select?: GlasgowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Glasgow
     */
    omit?: GlasgowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlasgowInclude<ExtArgs> | null
    where?: GlasgowWhereInput
    orderBy?: GlasgowOrderByWithRelationInput | GlasgowOrderByWithRelationInput[]
    cursor?: GlasgowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GlasgowScalarFieldEnum | GlasgowScalarFieldEnum[]
  }

  /**
   * Profissional.ocupacao
   */
  export type Profissional$ocupacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ocupacao
     */
    select?: OcupacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ocupacao
     */
    omit?: OcupacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcupacaoInclude<ExtArgs> | null
    where?: OcupacaoWhereInput
  }

  /**
   * Profissional.usuarioAuths
   */
  export type Profissional$usuarioAuthsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioAuth
     */
    select?: UsuarioAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioAuth
     */
    omit?: UsuarioAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioAuthInclude<ExtArgs> | null
    where?: UsuarioAuthWhereInput
    orderBy?: UsuarioAuthOrderByWithRelationInput | UsuarioAuthOrderByWithRelationInput[]
    cursor?: UsuarioAuthWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioAuthScalarFieldEnum | UsuarioAuthScalarFieldEnum[]
  }

  /**
   * Profissional without action
   */
  export type ProfissionalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
  }


  /**
   * Model Endereco
   */

  export type AggregateEndereco = {
    _count: EnderecoCountAggregateOutputType | null
    _avg: EnderecoAvgAggregateOutputType | null
    _sum: EnderecoSumAggregateOutputType | null
    _min: EnderecoMinAggregateOutputType | null
    _max: EnderecoMaxAggregateOutputType | null
  }

  export type EnderecoAvgAggregateOutputType = {
    id: number | null
    cdBairro: number | null
    cdCidade: number | null
  }

  export type EnderecoSumAggregateOutputType = {
    id: number | null
    cdBairro: number | null
    cdCidade: number | null
  }

  export type EnderecoMinAggregateOutputType = {
    id: number | null
    logradouro: string | null
    numero: string | null
    complemento: string | null
    cdBairro: number | null
    cdCidade: number | null
    cep: string | null
    stInativo: $Enums.SimNao | null
  }

  export type EnderecoMaxAggregateOutputType = {
    id: number | null
    logradouro: string | null
    numero: string | null
    complemento: string | null
    cdBairro: number | null
    cdCidade: number | null
    cep: string | null
    stInativo: $Enums.SimNao | null
  }

  export type EnderecoCountAggregateOutputType = {
    id: number
    logradouro: number
    numero: number
    complemento: number
    cdBairro: number
    cdCidade: number
    cep: number
    stInativo: number
    _all: number
  }


  export type EnderecoAvgAggregateInputType = {
    id?: true
    cdBairro?: true
    cdCidade?: true
  }

  export type EnderecoSumAggregateInputType = {
    id?: true
    cdBairro?: true
    cdCidade?: true
  }

  export type EnderecoMinAggregateInputType = {
    id?: true
    logradouro?: true
    numero?: true
    complemento?: true
    cdBairro?: true
    cdCidade?: true
    cep?: true
    stInativo?: true
  }

  export type EnderecoMaxAggregateInputType = {
    id?: true
    logradouro?: true
    numero?: true
    complemento?: true
    cdBairro?: true
    cdCidade?: true
    cep?: true
    stInativo?: true
  }

  export type EnderecoCountAggregateInputType = {
    id?: true
    logradouro?: true
    numero?: true
    complemento?: true
    cdBairro?: true
    cdCidade?: true
    cep?: true
    stInativo?: true
    _all?: true
  }

  export type EnderecoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Endereco to aggregate.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enderecos
    **/
    _count?: true | EnderecoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnderecoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnderecoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnderecoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnderecoMaxAggregateInputType
  }

  export type GetEnderecoAggregateType<T extends EnderecoAggregateArgs> = {
        [P in keyof T & keyof AggregateEndereco]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEndereco[P]>
      : GetScalarType<T[P], AggregateEndereco[P]>
  }




  export type EnderecoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnderecoWhereInput
    orderBy?: EnderecoOrderByWithAggregationInput | EnderecoOrderByWithAggregationInput[]
    by: EnderecoScalarFieldEnum[] | EnderecoScalarFieldEnum
    having?: EnderecoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnderecoCountAggregateInputType | true
    _avg?: EnderecoAvgAggregateInputType
    _sum?: EnderecoSumAggregateInputType
    _min?: EnderecoMinAggregateInputType
    _max?: EnderecoMaxAggregateInputType
  }

  export type EnderecoGroupByOutputType = {
    id: number
    logradouro: string
    numero: string | null
    complemento: string | null
    cdBairro: number
    cdCidade: number
    cep: string
    stInativo: $Enums.SimNao | null
    _count: EnderecoCountAggregateOutputType | null
    _avg: EnderecoAvgAggregateOutputType | null
    _sum: EnderecoSumAggregateOutputType | null
    _min: EnderecoMinAggregateOutputType | null
    _max: EnderecoMaxAggregateOutputType | null
  }

  type GetEnderecoGroupByPayload<T extends EnderecoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnderecoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnderecoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnderecoGroupByOutputType[P]>
            : GetScalarType<T[P], EnderecoGroupByOutputType[P]>
        }
      >
    >


  export type EnderecoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logradouro?: boolean
    numero?: boolean
    complemento?: boolean
    cdBairro?: boolean
    cdCidade?: boolean
    cep?: boolean
    stInativo?: boolean
    bairro?: boolean | BairroDefaultArgs<ExtArgs>
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
    pacientes?: boolean | Endereco$pacientesArgs<ExtArgs>
    enderecoPessoaRelacionadas?: boolean | Endereco$enderecoPessoaRelacionadasArgs<ExtArgs>
    profissionais?: boolean | Endereco$profissionaisArgs<ExtArgs>
    _count?: boolean | EnderecoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["endereco"]>

  export type EnderecoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logradouro?: boolean
    numero?: boolean
    complemento?: boolean
    cdBairro?: boolean
    cdCidade?: boolean
    cep?: boolean
    stInativo?: boolean
    bairro?: boolean | BairroDefaultArgs<ExtArgs>
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["endereco"]>

  export type EnderecoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logradouro?: boolean
    numero?: boolean
    complemento?: boolean
    cdBairro?: boolean
    cdCidade?: boolean
    cep?: boolean
    stInativo?: boolean
    bairro?: boolean | BairroDefaultArgs<ExtArgs>
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["endereco"]>

  export type EnderecoSelectScalar = {
    id?: boolean
    logradouro?: boolean
    numero?: boolean
    complemento?: boolean
    cdBairro?: boolean
    cdCidade?: boolean
    cep?: boolean
    stInativo?: boolean
  }

  export type EnderecoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "logradouro" | "numero" | "complemento" | "cdBairro" | "cdCidade" | "cep" | "stInativo", ExtArgs["result"]["endereco"]>
  export type EnderecoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bairro?: boolean | BairroDefaultArgs<ExtArgs>
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
    pacientes?: boolean | Endereco$pacientesArgs<ExtArgs>
    enderecoPessoaRelacionadas?: boolean | Endereco$enderecoPessoaRelacionadasArgs<ExtArgs>
    profissionais?: boolean | Endereco$profissionaisArgs<ExtArgs>
    _count?: boolean | EnderecoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EnderecoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bairro?: boolean | BairroDefaultArgs<ExtArgs>
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
  }
  export type EnderecoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bairro?: boolean | BairroDefaultArgs<ExtArgs>
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
  }

  export type $EnderecoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Endereco"
    objects: {
      bairro: Prisma.$BairroPayload<ExtArgs>
      cidade: Prisma.$CidadePayload<ExtArgs>
      pacientes: Prisma.$EnderecoPacientePayload<ExtArgs>[]
      enderecoPessoaRelacionadas: Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>[]
      profissionais: Prisma.$EnderecoProfissionalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      logradouro: string
      numero: string | null
      complemento: string | null
      cdBairro: number
      cdCidade: number
      cep: string
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["endereco"]>
    composites: {}
  }

  type EnderecoGetPayload<S extends boolean | null | undefined | EnderecoDefaultArgs> = $Result.GetResult<Prisma.$EnderecoPayload, S>

  type EnderecoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnderecoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnderecoCountAggregateInputType | true
    }

  export interface EnderecoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Endereco'], meta: { name: 'Endereco' } }
    /**
     * Find zero or one Endereco that matches the filter.
     * @param {EnderecoFindUniqueArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnderecoFindUniqueArgs>(args: SelectSubset<T, EnderecoFindUniqueArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Endereco that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnderecoFindUniqueOrThrowArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnderecoFindUniqueOrThrowArgs>(args: SelectSubset<T, EnderecoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Endereco that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoFindFirstArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnderecoFindFirstArgs>(args?: SelectSubset<T, EnderecoFindFirstArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Endereco that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoFindFirstOrThrowArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnderecoFindFirstOrThrowArgs>(args?: SelectSubset<T, EnderecoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enderecos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enderecos
     * const enderecos = await prisma.endereco.findMany()
     * 
     * // Get first 10 Enderecos
     * const enderecos = await prisma.endereco.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enderecoWithIdOnly = await prisma.endereco.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnderecoFindManyArgs>(args?: SelectSubset<T, EnderecoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Endereco.
     * @param {EnderecoCreateArgs} args - Arguments to create a Endereco.
     * @example
     * // Create one Endereco
     * const Endereco = await prisma.endereco.create({
     *   data: {
     *     // ... data to create a Endereco
     *   }
     * })
     * 
     */
    create<T extends EnderecoCreateArgs>(args: SelectSubset<T, EnderecoCreateArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enderecos.
     * @param {EnderecoCreateManyArgs} args - Arguments to create many Enderecos.
     * @example
     * // Create many Enderecos
     * const endereco = await prisma.endereco.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnderecoCreateManyArgs>(args?: SelectSubset<T, EnderecoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enderecos and returns the data saved in the database.
     * @param {EnderecoCreateManyAndReturnArgs} args - Arguments to create many Enderecos.
     * @example
     * // Create many Enderecos
     * const endereco = await prisma.endereco.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enderecos and only return the `id`
     * const enderecoWithIdOnly = await prisma.endereco.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnderecoCreateManyAndReturnArgs>(args?: SelectSubset<T, EnderecoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Endereco.
     * @param {EnderecoDeleteArgs} args - Arguments to delete one Endereco.
     * @example
     * // Delete one Endereco
     * const Endereco = await prisma.endereco.delete({
     *   where: {
     *     // ... filter to delete one Endereco
     *   }
     * })
     * 
     */
    delete<T extends EnderecoDeleteArgs>(args: SelectSubset<T, EnderecoDeleteArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Endereco.
     * @param {EnderecoUpdateArgs} args - Arguments to update one Endereco.
     * @example
     * // Update one Endereco
     * const endereco = await prisma.endereco.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnderecoUpdateArgs>(args: SelectSubset<T, EnderecoUpdateArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enderecos.
     * @param {EnderecoDeleteManyArgs} args - Arguments to filter Enderecos to delete.
     * @example
     * // Delete a few Enderecos
     * const { count } = await prisma.endereco.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnderecoDeleteManyArgs>(args?: SelectSubset<T, EnderecoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enderecos
     * const endereco = await prisma.endereco.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnderecoUpdateManyArgs>(args: SelectSubset<T, EnderecoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enderecos and returns the data updated in the database.
     * @param {EnderecoUpdateManyAndReturnArgs} args - Arguments to update many Enderecos.
     * @example
     * // Update many Enderecos
     * const endereco = await prisma.endereco.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enderecos and only return the `id`
     * const enderecoWithIdOnly = await prisma.endereco.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnderecoUpdateManyAndReturnArgs>(args: SelectSubset<T, EnderecoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Endereco.
     * @param {EnderecoUpsertArgs} args - Arguments to update or create a Endereco.
     * @example
     * // Update or create a Endereco
     * const endereco = await prisma.endereco.upsert({
     *   create: {
     *     // ... data to create a Endereco
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Endereco we want to update
     *   }
     * })
     */
    upsert<T extends EnderecoUpsertArgs>(args: SelectSubset<T, EnderecoUpsertArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoCountArgs} args - Arguments to filter Enderecos to count.
     * @example
     * // Count the number of Enderecos
     * const count = await prisma.endereco.count({
     *   where: {
     *     // ... the filter for the Enderecos we want to count
     *   }
     * })
    **/
    count<T extends EnderecoCountArgs>(
      args?: Subset<T, EnderecoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnderecoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Endereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnderecoAggregateArgs>(args: Subset<T, EnderecoAggregateArgs>): Prisma.PrismaPromise<GetEnderecoAggregateType<T>>

    /**
     * Group by Endereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnderecoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnderecoGroupByArgs['orderBy'] }
        : { orderBy?: EnderecoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnderecoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnderecoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Endereco model
   */
  readonly fields: EnderecoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Endereco.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnderecoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bairro<T extends BairroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BairroDefaultArgs<ExtArgs>>): Prisma__BairroClient<$Result.GetResult<Prisma.$BairroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cidade<T extends CidadeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CidadeDefaultArgs<ExtArgs>>): Prisma__CidadeClient<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pacientes<T extends Endereco$pacientesArgs<ExtArgs> = {}>(args?: Subset<T, Endereco$pacientesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPacientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enderecoPessoaRelacionadas<T extends Endereco$enderecoPessoaRelacionadasArgs<ExtArgs> = {}>(args?: Subset<T, Endereco$enderecoPessoaRelacionadasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profissionais<T extends Endereco$profissionaisArgs<ExtArgs> = {}>(args?: Subset<T, Endereco$profissionaisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoProfissionalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Endereco model
   */
  interface EnderecoFieldRefs {
    readonly id: FieldRef<"Endereco", 'Int'>
    readonly logradouro: FieldRef<"Endereco", 'String'>
    readonly numero: FieldRef<"Endereco", 'String'>
    readonly complemento: FieldRef<"Endereco", 'String'>
    readonly cdBairro: FieldRef<"Endereco", 'Int'>
    readonly cdCidade: FieldRef<"Endereco", 'Int'>
    readonly cep: FieldRef<"Endereco", 'String'>
    readonly stInativo: FieldRef<"Endereco", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * Endereco findUnique
   */
  export type EnderecoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where: EnderecoWhereUniqueInput
  }

  /**
   * Endereco findUniqueOrThrow
   */
  export type EnderecoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where: EnderecoWhereUniqueInput
  }

  /**
   * Endereco findFirst
   */
  export type EnderecoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enderecos.
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enderecos.
     */
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * Endereco findFirstOrThrow
   */
  export type EnderecoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enderecos.
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enderecos.
     */
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * Endereco findMany
   */
  export type EnderecoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Enderecos to fetch.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enderecos.
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * Endereco create
   */
  export type EnderecoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * The data needed to create a Endereco.
     */
    data: XOR<EnderecoCreateInput, EnderecoUncheckedCreateInput>
  }

  /**
   * Endereco createMany
   */
  export type EnderecoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enderecos.
     */
    data: EnderecoCreateManyInput | EnderecoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Endereco createManyAndReturn
   */
  export type EnderecoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * The data used to create many Enderecos.
     */
    data: EnderecoCreateManyInput | EnderecoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Endereco update
   */
  export type EnderecoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * The data needed to update a Endereco.
     */
    data: XOR<EnderecoUpdateInput, EnderecoUncheckedUpdateInput>
    /**
     * Choose, which Endereco to update.
     */
    where: EnderecoWhereUniqueInput
  }

  /**
   * Endereco updateMany
   */
  export type EnderecoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enderecos.
     */
    data: XOR<EnderecoUpdateManyMutationInput, EnderecoUncheckedUpdateManyInput>
    /**
     * Filter which Enderecos to update
     */
    where?: EnderecoWhereInput
    /**
     * Limit how many Enderecos to update.
     */
    limit?: number
  }

  /**
   * Endereco updateManyAndReturn
   */
  export type EnderecoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * The data used to update Enderecos.
     */
    data: XOR<EnderecoUpdateManyMutationInput, EnderecoUncheckedUpdateManyInput>
    /**
     * Filter which Enderecos to update
     */
    where?: EnderecoWhereInput
    /**
     * Limit how many Enderecos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Endereco upsert
   */
  export type EnderecoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * The filter to search for the Endereco to update in case it exists.
     */
    where: EnderecoWhereUniqueInput
    /**
     * In case the Endereco found by the `where` argument doesn't exist, create a new Endereco with this data.
     */
    create: XOR<EnderecoCreateInput, EnderecoUncheckedCreateInput>
    /**
     * In case the Endereco was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnderecoUpdateInput, EnderecoUncheckedUpdateInput>
  }

  /**
   * Endereco delete
   */
  export type EnderecoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter which Endereco to delete.
     */
    where: EnderecoWhereUniqueInput
  }

  /**
   * Endereco deleteMany
   */
  export type EnderecoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enderecos to delete
     */
    where?: EnderecoWhereInput
    /**
     * Limit how many Enderecos to delete.
     */
    limit?: number
  }

  /**
   * Endereco.pacientes
   */
  export type Endereco$pacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPaciente
     */
    select?: EnderecoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPaciente
     */
    omit?: EnderecoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPacienteInclude<ExtArgs> | null
    where?: EnderecoPacienteWhereInput
    orderBy?: EnderecoPacienteOrderByWithRelationInput | EnderecoPacienteOrderByWithRelationInput[]
    cursor?: EnderecoPacienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnderecoPacienteScalarFieldEnum | EnderecoPacienteScalarFieldEnum[]
  }

  /**
   * Endereco.enderecoPessoaRelacionadas
   */
  export type Endereco$enderecoPessoaRelacionadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPessoaRelacionada
     */
    select?: EnderecoPessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPessoaRelacionada
     */
    omit?: EnderecoPessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPessoaRelacionadaInclude<ExtArgs> | null
    where?: EnderecoPessoaRelacionadaWhereInput
    orderBy?: EnderecoPessoaRelacionadaOrderByWithRelationInput | EnderecoPessoaRelacionadaOrderByWithRelationInput[]
    cursor?: EnderecoPessoaRelacionadaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnderecoPessoaRelacionadaScalarFieldEnum | EnderecoPessoaRelacionadaScalarFieldEnum[]
  }

  /**
   * Endereco.profissionais
   */
  export type Endereco$profissionaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoProfissional
     */
    select?: EnderecoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoProfissional
     */
    omit?: EnderecoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoProfissionalInclude<ExtArgs> | null
    where?: EnderecoProfissionalWhereInput
    orderBy?: EnderecoProfissionalOrderByWithRelationInput | EnderecoProfissionalOrderByWithRelationInput[]
    cursor?: EnderecoProfissionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnderecoProfissionalScalarFieldEnum | EnderecoProfissionalScalarFieldEnum[]
  }

  /**
   * Endereco without action
   */
  export type EnderecoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
  }


  /**
   * Model EnderecoPaciente
   */

  export type AggregateEnderecoPaciente = {
    _count: EnderecoPacienteCountAggregateOutputType | null
    _avg: EnderecoPacienteAvgAggregateOutputType | null
    _sum: EnderecoPacienteSumAggregateOutputType | null
    _min: EnderecoPacienteMinAggregateOutputType | null
    _max: EnderecoPacienteMaxAggregateOutputType | null
  }

  export type EnderecoPacienteAvgAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdEndereco: number | null
  }

  export type EnderecoPacienteSumAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdEndereco: number | null
  }

  export type EnderecoPacienteMinAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdEndereco: number | null
  }

  export type EnderecoPacienteMaxAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdEndereco: number | null
  }

  export type EnderecoPacienteCountAggregateOutputType = {
    id: number
    cdMaster: number
    cdPaciente: number
    cdEndereco: number
    _all: number
  }


  export type EnderecoPacienteAvgAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdEndereco?: true
  }

  export type EnderecoPacienteSumAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdEndereco?: true
  }

  export type EnderecoPacienteMinAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdEndereco?: true
  }

  export type EnderecoPacienteMaxAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdEndereco?: true
  }

  export type EnderecoPacienteCountAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdEndereco?: true
    _all?: true
  }

  export type EnderecoPacienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnderecoPaciente to aggregate.
     */
    where?: EnderecoPacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnderecoPacientes to fetch.
     */
    orderBy?: EnderecoPacienteOrderByWithRelationInput | EnderecoPacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnderecoPacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnderecoPacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnderecoPacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EnderecoPacientes
    **/
    _count?: true | EnderecoPacienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnderecoPacienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnderecoPacienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnderecoPacienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnderecoPacienteMaxAggregateInputType
  }

  export type GetEnderecoPacienteAggregateType<T extends EnderecoPacienteAggregateArgs> = {
        [P in keyof T & keyof AggregateEnderecoPaciente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnderecoPaciente[P]>
      : GetScalarType<T[P], AggregateEnderecoPaciente[P]>
  }




  export type EnderecoPacienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnderecoPacienteWhereInput
    orderBy?: EnderecoPacienteOrderByWithAggregationInput | EnderecoPacienteOrderByWithAggregationInput[]
    by: EnderecoPacienteScalarFieldEnum[] | EnderecoPacienteScalarFieldEnum
    having?: EnderecoPacienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnderecoPacienteCountAggregateInputType | true
    _avg?: EnderecoPacienteAvgAggregateInputType
    _sum?: EnderecoPacienteSumAggregateInputType
    _min?: EnderecoPacienteMinAggregateInputType
    _max?: EnderecoPacienteMaxAggregateInputType
  }

  export type EnderecoPacienteGroupByOutputType = {
    id: number
    cdMaster: number
    cdPaciente: number
    cdEndereco: number
    _count: EnderecoPacienteCountAggregateOutputType | null
    _avg: EnderecoPacienteAvgAggregateOutputType | null
    _sum: EnderecoPacienteSumAggregateOutputType | null
    _min: EnderecoPacienteMinAggregateOutputType | null
    _max: EnderecoPacienteMaxAggregateOutputType | null
  }

  type GetEnderecoPacienteGroupByPayload<T extends EnderecoPacienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnderecoPacienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnderecoPacienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnderecoPacienteGroupByOutputType[P]>
            : GetScalarType<T[P], EnderecoPacienteGroupByOutputType[P]>
        }
      >
    >


  export type EnderecoPacienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdEndereco?: boolean
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enderecoPaciente"]>

  export type EnderecoPacienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdEndereco?: boolean
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enderecoPaciente"]>

  export type EnderecoPacienteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdEndereco?: boolean
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enderecoPaciente"]>

  export type EnderecoPacienteSelectScalar = {
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdEndereco?: boolean
  }

  export type EnderecoPacienteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdMaster" | "cdPaciente" | "cdEndereco", ExtArgs["result"]["enderecoPaciente"]>
  export type EnderecoPacienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
  }
  export type EnderecoPacienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
  }
  export type EnderecoPacienteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
  }

  export type $EnderecoPacientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EnderecoPaciente"
    objects: {
      endereco: Prisma.$EnderecoPayload<ExtArgs>
      paciente: Prisma.$PacientePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdMaster: number
      cdPaciente: number
      cdEndereco: number
    }, ExtArgs["result"]["enderecoPaciente"]>
    composites: {}
  }

  type EnderecoPacienteGetPayload<S extends boolean | null | undefined | EnderecoPacienteDefaultArgs> = $Result.GetResult<Prisma.$EnderecoPacientePayload, S>

  type EnderecoPacienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnderecoPacienteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnderecoPacienteCountAggregateInputType | true
    }

  export interface EnderecoPacienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EnderecoPaciente'], meta: { name: 'EnderecoPaciente' } }
    /**
     * Find zero or one EnderecoPaciente that matches the filter.
     * @param {EnderecoPacienteFindUniqueArgs} args - Arguments to find a EnderecoPaciente
     * @example
     * // Get one EnderecoPaciente
     * const enderecoPaciente = await prisma.enderecoPaciente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnderecoPacienteFindUniqueArgs>(args: SelectSubset<T, EnderecoPacienteFindUniqueArgs<ExtArgs>>): Prisma__EnderecoPacienteClient<$Result.GetResult<Prisma.$EnderecoPacientePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EnderecoPaciente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnderecoPacienteFindUniqueOrThrowArgs} args - Arguments to find a EnderecoPaciente
     * @example
     * // Get one EnderecoPaciente
     * const enderecoPaciente = await prisma.enderecoPaciente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnderecoPacienteFindUniqueOrThrowArgs>(args: SelectSubset<T, EnderecoPacienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnderecoPacienteClient<$Result.GetResult<Prisma.$EnderecoPacientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnderecoPaciente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoPacienteFindFirstArgs} args - Arguments to find a EnderecoPaciente
     * @example
     * // Get one EnderecoPaciente
     * const enderecoPaciente = await prisma.enderecoPaciente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnderecoPacienteFindFirstArgs>(args?: SelectSubset<T, EnderecoPacienteFindFirstArgs<ExtArgs>>): Prisma__EnderecoPacienteClient<$Result.GetResult<Prisma.$EnderecoPacientePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnderecoPaciente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoPacienteFindFirstOrThrowArgs} args - Arguments to find a EnderecoPaciente
     * @example
     * // Get one EnderecoPaciente
     * const enderecoPaciente = await prisma.enderecoPaciente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnderecoPacienteFindFirstOrThrowArgs>(args?: SelectSubset<T, EnderecoPacienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnderecoPacienteClient<$Result.GetResult<Prisma.$EnderecoPacientePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EnderecoPacientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoPacienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EnderecoPacientes
     * const enderecoPacientes = await prisma.enderecoPaciente.findMany()
     * 
     * // Get first 10 EnderecoPacientes
     * const enderecoPacientes = await prisma.enderecoPaciente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enderecoPacienteWithIdOnly = await prisma.enderecoPaciente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnderecoPacienteFindManyArgs>(args?: SelectSubset<T, EnderecoPacienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPacientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EnderecoPaciente.
     * @param {EnderecoPacienteCreateArgs} args - Arguments to create a EnderecoPaciente.
     * @example
     * // Create one EnderecoPaciente
     * const EnderecoPaciente = await prisma.enderecoPaciente.create({
     *   data: {
     *     // ... data to create a EnderecoPaciente
     *   }
     * })
     * 
     */
    create<T extends EnderecoPacienteCreateArgs>(args: SelectSubset<T, EnderecoPacienteCreateArgs<ExtArgs>>): Prisma__EnderecoPacienteClient<$Result.GetResult<Prisma.$EnderecoPacientePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EnderecoPacientes.
     * @param {EnderecoPacienteCreateManyArgs} args - Arguments to create many EnderecoPacientes.
     * @example
     * // Create many EnderecoPacientes
     * const enderecoPaciente = await prisma.enderecoPaciente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnderecoPacienteCreateManyArgs>(args?: SelectSubset<T, EnderecoPacienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EnderecoPacientes and returns the data saved in the database.
     * @param {EnderecoPacienteCreateManyAndReturnArgs} args - Arguments to create many EnderecoPacientes.
     * @example
     * // Create many EnderecoPacientes
     * const enderecoPaciente = await prisma.enderecoPaciente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EnderecoPacientes and only return the `id`
     * const enderecoPacienteWithIdOnly = await prisma.enderecoPaciente.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnderecoPacienteCreateManyAndReturnArgs>(args?: SelectSubset<T, EnderecoPacienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPacientePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EnderecoPaciente.
     * @param {EnderecoPacienteDeleteArgs} args - Arguments to delete one EnderecoPaciente.
     * @example
     * // Delete one EnderecoPaciente
     * const EnderecoPaciente = await prisma.enderecoPaciente.delete({
     *   where: {
     *     // ... filter to delete one EnderecoPaciente
     *   }
     * })
     * 
     */
    delete<T extends EnderecoPacienteDeleteArgs>(args: SelectSubset<T, EnderecoPacienteDeleteArgs<ExtArgs>>): Prisma__EnderecoPacienteClient<$Result.GetResult<Prisma.$EnderecoPacientePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EnderecoPaciente.
     * @param {EnderecoPacienteUpdateArgs} args - Arguments to update one EnderecoPaciente.
     * @example
     * // Update one EnderecoPaciente
     * const enderecoPaciente = await prisma.enderecoPaciente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnderecoPacienteUpdateArgs>(args: SelectSubset<T, EnderecoPacienteUpdateArgs<ExtArgs>>): Prisma__EnderecoPacienteClient<$Result.GetResult<Prisma.$EnderecoPacientePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EnderecoPacientes.
     * @param {EnderecoPacienteDeleteManyArgs} args - Arguments to filter EnderecoPacientes to delete.
     * @example
     * // Delete a few EnderecoPacientes
     * const { count } = await prisma.enderecoPaciente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnderecoPacienteDeleteManyArgs>(args?: SelectSubset<T, EnderecoPacienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnderecoPacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoPacienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EnderecoPacientes
     * const enderecoPaciente = await prisma.enderecoPaciente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnderecoPacienteUpdateManyArgs>(args: SelectSubset<T, EnderecoPacienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnderecoPacientes and returns the data updated in the database.
     * @param {EnderecoPacienteUpdateManyAndReturnArgs} args - Arguments to update many EnderecoPacientes.
     * @example
     * // Update many EnderecoPacientes
     * const enderecoPaciente = await prisma.enderecoPaciente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EnderecoPacientes and only return the `id`
     * const enderecoPacienteWithIdOnly = await prisma.enderecoPaciente.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnderecoPacienteUpdateManyAndReturnArgs>(args: SelectSubset<T, EnderecoPacienteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPacientePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EnderecoPaciente.
     * @param {EnderecoPacienteUpsertArgs} args - Arguments to update or create a EnderecoPaciente.
     * @example
     * // Update or create a EnderecoPaciente
     * const enderecoPaciente = await prisma.enderecoPaciente.upsert({
     *   create: {
     *     // ... data to create a EnderecoPaciente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EnderecoPaciente we want to update
     *   }
     * })
     */
    upsert<T extends EnderecoPacienteUpsertArgs>(args: SelectSubset<T, EnderecoPacienteUpsertArgs<ExtArgs>>): Prisma__EnderecoPacienteClient<$Result.GetResult<Prisma.$EnderecoPacientePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EnderecoPacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoPacienteCountArgs} args - Arguments to filter EnderecoPacientes to count.
     * @example
     * // Count the number of EnderecoPacientes
     * const count = await prisma.enderecoPaciente.count({
     *   where: {
     *     // ... the filter for the EnderecoPacientes we want to count
     *   }
     * })
    **/
    count<T extends EnderecoPacienteCountArgs>(
      args?: Subset<T, EnderecoPacienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnderecoPacienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EnderecoPaciente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoPacienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnderecoPacienteAggregateArgs>(args: Subset<T, EnderecoPacienteAggregateArgs>): Prisma.PrismaPromise<GetEnderecoPacienteAggregateType<T>>

    /**
     * Group by EnderecoPaciente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoPacienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnderecoPacienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnderecoPacienteGroupByArgs['orderBy'] }
        : { orderBy?: EnderecoPacienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnderecoPacienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnderecoPacienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EnderecoPaciente model
   */
  readonly fields: EnderecoPacienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EnderecoPaciente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnderecoPacienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    endereco<T extends EnderecoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnderecoDefaultArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paciente<T extends PacienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PacienteDefaultArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EnderecoPaciente model
   */
  interface EnderecoPacienteFieldRefs {
    readonly id: FieldRef<"EnderecoPaciente", 'Int'>
    readonly cdMaster: FieldRef<"EnderecoPaciente", 'Int'>
    readonly cdPaciente: FieldRef<"EnderecoPaciente", 'Int'>
    readonly cdEndereco: FieldRef<"EnderecoPaciente", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EnderecoPaciente findUnique
   */
  export type EnderecoPacienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPaciente
     */
    select?: EnderecoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPaciente
     */
    omit?: EnderecoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPacienteInclude<ExtArgs> | null
    /**
     * Filter, which EnderecoPaciente to fetch.
     */
    where: EnderecoPacienteWhereUniqueInput
  }

  /**
   * EnderecoPaciente findUniqueOrThrow
   */
  export type EnderecoPacienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPaciente
     */
    select?: EnderecoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPaciente
     */
    omit?: EnderecoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPacienteInclude<ExtArgs> | null
    /**
     * Filter, which EnderecoPaciente to fetch.
     */
    where: EnderecoPacienteWhereUniqueInput
  }

  /**
   * EnderecoPaciente findFirst
   */
  export type EnderecoPacienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPaciente
     */
    select?: EnderecoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPaciente
     */
    omit?: EnderecoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPacienteInclude<ExtArgs> | null
    /**
     * Filter, which EnderecoPaciente to fetch.
     */
    where?: EnderecoPacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnderecoPacientes to fetch.
     */
    orderBy?: EnderecoPacienteOrderByWithRelationInput | EnderecoPacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnderecoPacientes.
     */
    cursor?: EnderecoPacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnderecoPacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnderecoPacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnderecoPacientes.
     */
    distinct?: EnderecoPacienteScalarFieldEnum | EnderecoPacienteScalarFieldEnum[]
  }

  /**
   * EnderecoPaciente findFirstOrThrow
   */
  export type EnderecoPacienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPaciente
     */
    select?: EnderecoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPaciente
     */
    omit?: EnderecoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPacienteInclude<ExtArgs> | null
    /**
     * Filter, which EnderecoPaciente to fetch.
     */
    where?: EnderecoPacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnderecoPacientes to fetch.
     */
    orderBy?: EnderecoPacienteOrderByWithRelationInput | EnderecoPacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnderecoPacientes.
     */
    cursor?: EnderecoPacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnderecoPacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnderecoPacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnderecoPacientes.
     */
    distinct?: EnderecoPacienteScalarFieldEnum | EnderecoPacienteScalarFieldEnum[]
  }

  /**
   * EnderecoPaciente findMany
   */
  export type EnderecoPacienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPaciente
     */
    select?: EnderecoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPaciente
     */
    omit?: EnderecoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPacienteInclude<ExtArgs> | null
    /**
     * Filter, which EnderecoPacientes to fetch.
     */
    where?: EnderecoPacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnderecoPacientes to fetch.
     */
    orderBy?: EnderecoPacienteOrderByWithRelationInput | EnderecoPacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EnderecoPacientes.
     */
    cursor?: EnderecoPacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnderecoPacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnderecoPacientes.
     */
    skip?: number
    distinct?: EnderecoPacienteScalarFieldEnum | EnderecoPacienteScalarFieldEnum[]
  }

  /**
   * EnderecoPaciente create
   */
  export type EnderecoPacienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPaciente
     */
    select?: EnderecoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPaciente
     */
    omit?: EnderecoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPacienteInclude<ExtArgs> | null
    /**
     * The data needed to create a EnderecoPaciente.
     */
    data: XOR<EnderecoPacienteCreateInput, EnderecoPacienteUncheckedCreateInput>
  }

  /**
   * EnderecoPaciente createMany
   */
  export type EnderecoPacienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EnderecoPacientes.
     */
    data: EnderecoPacienteCreateManyInput | EnderecoPacienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EnderecoPaciente createManyAndReturn
   */
  export type EnderecoPacienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPaciente
     */
    select?: EnderecoPacienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPaciente
     */
    omit?: EnderecoPacienteOmit<ExtArgs> | null
    /**
     * The data used to create many EnderecoPacientes.
     */
    data: EnderecoPacienteCreateManyInput | EnderecoPacienteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPacienteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnderecoPaciente update
   */
  export type EnderecoPacienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPaciente
     */
    select?: EnderecoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPaciente
     */
    omit?: EnderecoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPacienteInclude<ExtArgs> | null
    /**
     * The data needed to update a EnderecoPaciente.
     */
    data: XOR<EnderecoPacienteUpdateInput, EnderecoPacienteUncheckedUpdateInput>
    /**
     * Choose, which EnderecoPaciente to update.
     */
    where: EnderecoPacienteWhereUniqueInput
  }

  /**
   * EnderecoPaciente updateMany
   */
  export type EnderecoPacienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EnderecoPacientes.
     */
    data: XOR<EnderecoPacienteUpdateManyMutationInput, EnderecoPacienteUncheckedUpdateManyInput>
    /**
     * Filter which EnderecoPacientes to update
     */
    where?: EnderecoPacienteWhereInput
    /**
     * Limit how many EnderecoPacientes to update.
     */
    limit?: number
  }

  /**
   * EnderecoPaciente updateManyAndReturn
   */
  export type EnderecoPacienteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPaciente
     */
    select?: EnderecoPacienteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPaciente
     */
    omit?: EnderecoPacienteOmit<ExtArgs> | null
    /**
     * The data used to update EnderecoPacientes.
     */
    data: XOR<EnderecoPacienteUpdateManyMutationInput, EnderecoPacienteUncheckedUpdateManyInput>
    /**
     * Filter which EnderecoPacientes to update
     */
    where?: EnderecoPacienteWhereInput
    /**
     * Limit how many EnderecoPacientes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPacienteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnderecoPaciente upsert
   */
  export type EnderecoPacienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPaciente
     */
    select?: EnderecoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPaciente
     */
    omit?: EnderecoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPacienteInclude<ExtArgs> | null
    /**
     * The filter to search for the EnderecoPaciente to update in case it exists.
     */
    where: EnderecoPacienteWhereUniqueInput
    /**
     * In case the EnderecoPaciente found by the `where` argument doesn't exist, create a new EnderecoPaciente with this data.
     */
    create: XOR<EnderecoPacienteCreateInput, EnderecoPacienteUncheckedCreateInput>
    /**
     * In case the EnderecoPaciente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnderecoPacienteUpdateInput, EnderecoPacienteUncheckedUpdateInput>
  }

  /**
   * EnderecoPaciente delete
   */
  export type EnderecoPacienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPaciente
     */
    select?: EnderecoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPaciente
     */
    omit?: EnderecoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPacienteInclude<ExtArgs> | null
    /**
     * Filter which EnderecoPaciente to delete.
     */
    where: EnderecoPacienteWhereUniqueInput
  }

  /**
   * EnderecoPaciente deleteMany
   */
  export type EnderecoPacienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnderecoPacientes to delete
     */
    where?: EnderecoPacienteWhereInput
    /**
     * Limit how many EnderecoPacientes to delete.
     */
    limit?: number
  }

  /**
   * EnderecoPaciente without action
   */
  export type EnderecoPacienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPaciente
     */
    select?: EnderecoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPaciente
     */
    omit?: EnderecoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPacienteInclude<ExtArgs> | null
  }


  /**
   * Model EnderecoProfissional
   */

  export type AggregateEnderecoProfissional = {
    _count: EnderecoProfissionalCountAggregateOutputType | null
    _avg: EnderecoProfissionalAvgAggregateOutputType | null
    _sum: EnderecoProfissionalSumAggregateOutputType | null
    _min: EnderecoProfissionalMinAggregateOutputType | null
    _max: EnderecoProfissionalMaxAggregateOutputType | null
  }

  export type EnderecoProfissionalAvgAggregateOutputType = {
    id: number | null
    cdProf: number | null
    cdEndereco: number | null
  }

  export type EnderecoProfissionalSumAggregateOutputType = {
    id: number | null
    cdProf: number | null
    cdEndereco: number | null
  }

  export type EnderecoProfissionalMinAggregateOutputType = {
    id: number | null
    cdProf: number | null
    cdEndereco: number | null
  }

  export type EnderecoProfissionalMaxAggregateOutputType = {
    id: number | null
    cdProf: number | null
    cdEndereco: number | null
  }

  export type EnderecoProfissionalCountAggregateOutputType = {
    id: number
    cdProf: number
    cdEndereco: number
    _all: number
  }


  export type EnderecoProfissionalAvgAggregateInputType = {
    id?: true
    cdProf?: true
    cdEndereco?: true
  }

  export type EnderecoProfissionalSumAggregateInputType = {
    id?: true
    cdProf?: true
    cdEndereco?: true
  }

  export type EnderecoProfissionalMinAggregateInputType = {
    id?: true
    cdProf?: true
    cdEndereco?: true
  }

  export type EnderecoProfissionalMaxAggregateInputType = {
    id?: true
    cdProf?: true
    cdEndereco?: true
  }

  export type EnderecoProfissionalCountAggregateInputType = {
    id?: true
    cdProf?: true
    cdEndereco?: true
    _all?: true
  }

  export type EnderecoProfissionalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnderecoProfissional to aggregate.
     */
    where?: EnderecoProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnderecoProfissionals to fetch.
     */
    orderBy?: EnderecoProfissionalOrderByWithRelationInput | EnderecoProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnderecoProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnderecoProfissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnderecoProfissionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EnderecoProfissionals
    **/
    _count?: true | EnderecoProfissionalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnderecoProfissionalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnderecoProfissionalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnderecoProfissionalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnderecoProfissionalMaxAggregateInputType
  }

  export type GetEnderecoProfissionalAggregateType<T extends EnderecoProfissionalAggregateArgs> = {
        [P in keyof T & keyof AggregateEnderecoProfissional]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnderecoProfissional[P]>
      : GetScalarType<T[P], AggregateEnderecoProfissional[P]>
  }




  export type EnderecoProfissionalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnderecoProfissionalWhereInput
    orderBy?: EnderecoProfissionalOrderByWithAggregationInput | EnderecoProfissionalOrderByWithAggregationInput[]
    by: EnderecoProfissionalScalarFieldEnum[] | EnderecoProfissionalScalarFieldEnum
    having?: EnderecoProfissionalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnderecoProfissionalCountAggregateInputType | true
    _avg?: EnderecoProfissionalAvgAggregateInputType
    _sum?: EnderecoProfissionalSumAggregateInputType
    _min?: EnderecoProfissionalMinAggregateInputType
    _max?: EnderecoProfissionalMaxAggregateInputType
  }

  export type EnderecoProfissionalGroupByOutputType = {
    id: number
    cdProf: number
    cdEndereco: number
    _count: EnderecoProfissionalCountAggregateOutputType | null
    _avg: EnderecoProfissionalAvgAggregateOutputType | null
    _sum: EnderecoProfissionalSumAggregateOutputType | null
    _min: EnderecoProfissionalMinAggregateOutputType | null
    _max: EnderecoProfissionalMaxAggregateOutputType | null
  }

  type GetEnderecoProfissionalGroupByPayload<T extends EnderecoProfissionalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnderecoProfissionalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnderecoProfissionalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnderecoProfissionalGroupByOutputType[P]>
            : GetScalarType<T[P], EnderecoProfissionalGroupByOutputType[P]>
        }
      >
    >


  export type EnderecoProfissionalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdProf?: boolean
    cdEndereco?: boolean
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enderecoProfissional"]>

  export type EnderecoProfissionalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdProf?: boolean
    cdEndereco?: boolean
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enderecoProfissional"]>

  export type EnderecoProfissionalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdProf?: boolean
    cdEndereco?: boolean
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enderecoProfissional"]>

  export type EnderecoProfissionalSelectScalar = {
    id?: boolean
    cdProf?: boolean
    cdEndereco?: boolean
  }

  export type EnderecoProfissionalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdProf" | "cdEndereco", ExtArgs["result"]["enderecoProfissional"]>
  export type EnderecoProfissionalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }
  export type EnderecoProfissionalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }
  export type EnderecoProfissionalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }

  export type $EnderecoProfissionalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EnderecoProfissional"
    objects: {
      endereco: Prisma.$EnderecoPayload<ExtArgs>
      profissional: Prisma.$ProfissionalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdProf: number
      cdEndereco: number
    }, ExtArgs["result"]["enderecoProfissional"]>
    composites: {}
  }

  type EnderecoProfissionalGetPayload<S extends boolean | null | undefined | EnderecoProfissionalDefaultArgs> = $Result.GetResult<Prisma.$EnderecoProfissionalPayload, S>

  type EnderecoProfissionalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnderecoProfissionalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnderecoProfissionalCountAggregateInputType | true
    }

  export interface EnderecoProfissionalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EnderecoProfissional'], meta: { name: 'EnderecoProfissional' } }
    /**
     * Find zero or one EnderecoProfissional that matches the filter.
     * @param {EnderecoProfissionalFindUniqueArgs} args - Arguments to find a EnderecoProfissional
     * @example
     * // Get one EnderecoProfissional
     * const enderecoProfissional = await prisma.enderecoProfissional.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnderecoProfissionalFindUniqueArgs>(args: SelectSubset<T, EnderecoProfissionalFindUniqueArgs<ExtArgs>>): Prisma__EnderecoProfissionalClient<$Result.GetResult<Prisma.$EnderecoProfissionalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EnderecoProfissional that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnderecoProfissionalFindUniqueOrThrowArgs} args - Arguments to find a EnderecoProfissional
     * @example
     * // Get one EnderecoProfissional
     * const enderecoProfissional = await prisma.enderecoProfissional.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnderecoProfissionalFindUniqueOrThrowArgs>(args: SelectSubset<T, EnderecoProfissionalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnderecoProfissionalClient<$Result.GetResult<Prisma.$EnderecoProfissionalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnderecoProfissional that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoProfissionalFindFirstArgs} args - Arguments to find a EnderecoProfissional
     * @example
     * // Get one EnderecoProfissional
     * const enderecoProfissional = await prisma.enderecoProfissional.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnderecoProfissionalFindFirstArgs>(args?: SelectSubset<T, EnderecoProfissionalFindFirstArgs<ExtArgs>>): Prisma__EnderecoProfissionalClient<$Result.GetResult<Prisma.$EnderecoProfissionalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnderecoProfissional that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoProfissionalFindFirstOrThrowArgs} args - Arguments to find a EnderecoProfissional
     * @example
     * // Get one EnderecoProfissional
     * const enderecoProfissional = await prisma.enderecoProfissional.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnderecoProfissionalFindFirstOrThrowArgs>(args?: SelectSubset<T, EnderecoProfissionalFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnderecoProfissionalClient<$Result.GetResult<Prisma.$EnderecoProfissionalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EnderecoProfissionals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoProfissionalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EnderecoProfissionals
     * const enderecoProfissionals = await prisma.enderecoProfissional.findMany()
     * 
     * // Get first 10 EnderecoProfissionals
     * const enderecoProfissionals = await prisma.enderecoProfissional.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enderecoProfissionalWithIdOnly = await prisma.enderecoProfissional.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnderecoProfissionalFindManyArgs>(args?: SelectSubset<T, EnderecoProfissionalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoProfissionalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EnderecoProfissional.
     * @param {EnderecoProfissionalCreateArgs} args - Arguments to create a EnderecoProfissional.
     * @example
     * // Create one EnderecoProfissional
     * const EnderecoProfissional = await prisma.enderecoProfissional.create({
     *   data: {
     *     // ... data to create a EnderecoProfissional
     *   }
     * })
     * 
     */
    create<T extends EnderecoProfissionalCreateArgs>(args: SelectSubset<T, EnderecoProfissionalCreateArgs<ExtArgs>>): Prisma__EnderecoProfissionalClient<$Result.GetResult<Prisma.$EnderecoProfissionalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EnderecoProfissionals.
     * @param {EnderecoProfissionalCreateManyArgs} args - Arguments to create many EnderecoProfissionals.
     * @example
     * // Create many EnderecoProfissionals
     * const enderecoProfissional = await prisma.enderecoProfissional.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnderecoProfissionalCreateManyArgs>(args?: SelectSubset<T, EnderecoProfissionalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EnderecoProfissionals and returns the data saved in the database.
     * @param {EnderecoProfissionalCreateManyAndReturnArgs} args - Arguments to create many EnderecoProfissionals.
     * @example
     * // Create many EnderecoProfissionals
     * const enderecoProfissional = await prisma.enderecoProfissional.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EnderecoProfissionals and only return the `id`
     * const enderecoProfissionalWithIdOnly = await prisma.enderecoProfissional.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnderecoProfissionalCreateManyAndReturnArgs>(args?: SelectSubset<T, EnderecoProfissionalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoProfissionalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EnderecoProfissional.
     * @param {EnderecoProfissionalDeleteArgs} args - Arguments to delete one EnderecoProfissional.
     * @example
     * // Delete one EnderecoProfissional
     * const EnderecoProfissional = await prisma.enderecoProfissional.delete({
     *   where: {
     *     // ... filter to delete one EnderecoProfissional
     *   }
     * })
     * 
     */
    delete<T extends EnderecoProfissionalDeleteArgs>(args: SelectSubset<T, EnderecoProfissionalDeleteArgs<ExtArgs>>): Prisma__EnderecoProfissionalClient<$Result.GetResult<Prisma.$EnderecoProfissionalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EnderecoProfissional.
     * @param {EnderecoProfissionalUpdateArgs} args - Arguments to update one EnderecoProfissional.
     * @example
     * // Update one EnderecoProfissional
     * const enderecoProfissional = await prisma.enderecoProfissional.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnderecoProfissionalUpdateArgs>(args: SelectSubset<T, EnderecoProfissionalUpdateArgs<ExtArgs>>): Prisma__EnderecoProfissionalClient<$Result.GetResult<Prisma.$EnderecoProfissionalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EnderecoProfissionals.
     * @param {EnderecoProfissionalDeleteManyArgs} args - Arguments to filter EnderecoProfissionals to delete.
     * @example
     * // Delete a few EnderecoProfissionals
     * const { count } = await prisma.enderecoProfissional.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnderecoProfissionalDeleteManyArgs>(args?: SelectSubset<T, EnderecoProfissionalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnderecoProfissionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoProfissionalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EnderecoProfissionals
     * const enderecoProfissional = await prisma.enderecoProfissional.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnderecoProfissionalUpdateManyArgs>(args: SelectSubset<T, EnderecoProfissionalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnderecoProfissionals and returns the data updated in the database.
     * @param {EnderecoProfissionalUpdateManyAndReturnArgs} args - Arguments to update many EnderecoProfissionals.
     * @example
     * // Update many EnderecoProfissionals
     * const enderecoProfissional = await prisma.enderecoProfissional.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EnderecoProfissionals and only return the `id`
     * const enderecoProfissionalWithIdOnly = await prisma.enderecoProfissional.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnderecoProfissionalUpdateManyAndReturnArgs>(args: SelectSubset<T, EnderecoProfissionalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoProfissionalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EnderecoProfissional.
     * @param {EnderecoProfissionalUpsertArgs} args - Arguments to update or create a EnderecoProfissional.
     * @example
     * // Update or create a EnderecoProfissional
     * const enderecoProfissional = await prisma.enderecoProfissional.upsert({
     *   create: {
     *     // ... data to create a EnderecoProfissional
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EnderecoProfissional we want to update
     *   }
     * })
     */
    upsert<T extends EnderecoProfissionalUpsertArgs>(args: SelectSubset<T, EnderecoProfissionalUpsertArgs<ExtArgs>>): Prisma__EnderecoProfissionalClient<$Result.GetResult<Prisma.$EnderecoProfissionalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EnderecoProfissionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoProfissionalCountArgs} args - Arguments to filter EnderecoProfissionals to count.
     * @example
     * // Count the number of EnderecoProfissionals
     * const count = await prisma.enderecoProfissional.count({
     *   where: {
     *     // ... the filter for the EnderecoProfissionals we want to count
     *   }
     * })
    **/
    count<T extends EnderecoProfissionalCountArgs>(
      args?: Subset<T, EnderecoProfissionalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnderecoProfissionalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EnderecoProfissional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoProfissionalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnderecoProfissionalAggregateArgs>(args: Subset<T, EnderecoProfissionalAggregateArgs>): Prisma.PrismaPromise<GetEnderecoProfissionalAggregateType<T>>

    /**
     * Group by EnderecoProfissional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoProfissionalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnderecoProfissionalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnderecoProfissionalGroupByArgs['orderBy'] }
        : { orderBy?: EnderecoProfissionalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnderecoProfissionalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnderecoProfissionalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EnderecoProfissional model
   */
  readonly fields: EnderecoProfissionalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EnderecoProfissional.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnderecoProfissionalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    endereco<T extends EnderecoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnderecoDefaultArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profissional<T extends ProfissionalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfissionalDefaultArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EnderecoProfissional model
   */
  interface EnderecoProfissionalFieldRefs {
    readonly id: FieldRef<"EnderecoProfissional", 'Int'>
    readonly cdProf: FieldRef<"EnderecoProfissional", 'Int'>
    readonly cdEndereco: FieldRef<"EnderecoProfissional", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EnderecoProfissional findUnique
   */
  export type EnderecoProfissionalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoProfissional
     */
    select?: EnderecoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoProfissional
     */
    omit?: EnderecoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which EnderecoProfissional to fetch.
     */
    where: EnderecoProfissionalWhereUniqueInput
  }

  /**
   * EnderecoProfissional findUniqueOrThrow
   */
  export type EnderecoProfissionalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoProfissional
     */
    select?: EnderecoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoProfissional
     */
    omit?: EnderecoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which EnderecoProfissional to fetch.
     */
    where: EnderecoProfissionalWhereUniqueInput
  }

  /**
   * EnderecoProfissional findFirst
   */
  export type EnderecoProfissionalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoProfissional
     */
    select?: EnderecoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoProfissional
     */
    omit?: EnderecoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which EnderecoProfissional to fetch.
     */
    where?: EnderecoProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnderecoProfissionals to fetch.
     */
    orderBy?: EnderecoProfissionalOrderByWithRelationInput | EnderecoProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnderecoProfissionals.
     */
    cursor?: EnderecoProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnderecoProfissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnderecoProfissionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnderecoProfissionals.
     */
    distinct?: EnderecoProfissionalScalarFieldEnum | EnderecoProfissionalScalarFieldEnum[]
  }

  /**
   * EnderecoProfissional findFirstOrThrow
   */
  export type EnderecoProfissionalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoProfissional
     */
    select?: EnderecoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoProfissional
     */
    omit?: EnderecoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which EnderecoProfissional to fetch.
     */
    where?: EnderecoProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnderecoProfissionals to fetch.
     */
    orderBy?: EnderecoProfissionalOrderByWithRelationInput | EnderecoProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnderecoProfissionals.
     */
    cursor?: EnderecoProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnderecoProfissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnderecoProfissionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnderecoProfissionals.
     */
    distinct?: EnderecoProfissionalScalarFieldEnum | EnderecoProfissionalScalarFieldEnum[]
  }

  /**
   * EnderecoProfissional findMany
   */
  export type EnderecoProfissionalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoProfissional
     */
    select?: EnderecoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoProfissional
     */
    omit?: EnderecoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which EnderecoProfissionals to fetch.
     */
    where?: EnderecoProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnderecoProfissionals to fetch.
     */
    orderBy?: EnderecoProfissionalOrderByWithRelationInput | EnderecoProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EnderecoProfissionals.
     */
    cursor?: EnderecoProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnderecoProfissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnderecoProfissionals.
     */
    skip?: number
    distinct?: EnderecoProfissionalScalarFieldEnum | EnderecoProfissionalScalarFieldEnum[]
  }

  /**
   * EnderecoProfissional create
   */
  export type EnderecoProfissionalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoProfissional
     */
    select?: EnderecoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoProfissional
     */
    omit?: EnderecoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoProfissionalInclude<ExtArgs> | null
    /**
     * The data needed to create a EnderecoProfissional.
     */
    data: XOR<EnderecoProfissionalCreateInput, EnderecoProfissionalUncheckedCreateInput>
  }

  /**
   * EnderecoProfissional createMany
   */
  export type EnderecoProfissionalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EnderecoProfissionals.
     */
    data: EnderecoProfissionalCreateManyInput | EnderecoProfissionalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EnderecoProfissional createManyAndReturn
   */
  export type EnderecoProfissionalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoProfissional
     */
    select?: EnderecoProfissionalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoProfissional
     */
    omit?: EnderecoProfissionalOmit<ExtArgs> | null
    /**
     * The data used to create many EnderecoProfissionals.
     */
    data: EnderecoProfissionalCreateManyInput | EnderecoProfissionalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoProfissionalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnderecoProfissional update
   */
  export type EnderecoProfissionalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoProfissional
     */
    select?: EnderecoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoProfissional
     */
    omit?: EnderecoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoProfissionalInclude<ExtArgs> | null
    /**
     * The data needed to update a EnderecoProfissional.
     */
    data: XOR<EnderecoProfissionalUpdateInput, EnderecoProfissionalUncheckedUpdateInput>
    /**
     * Choose, which EnderecoProfissional to update.
     */
    where: EnderecoProfissionalWhereUniqueInput
  }

  /**
   * EnderecoProfissional updateMany
   */
  export type EnderecoProfissionalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EnderecoProfissionals.
     */
    data: XOR<EnderecoProfissionalUpdateManyMutationInput, EnderecoProfissionalUncheckedUpdateManyInput>
    /**
     * Filter which EnderecoProfissionals to update
     */
    where?: EnderecoProfissionalWhereInput
    /**
     * Limit how many EnderecoProfissionals to update.
     */
    limit?: number
  }

  /**
   * EnderecoProfissional updateManyAndReturn
   */
  export type EnderecoProfissionalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoProfissional
     */
    select?: EnderecoProfissionalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoProfissional
     */
    omit?: EnderecoProfissionalOmit<ExtArgs> | null
    /**
     * The data used to update EnderecoProfissionals.
     */
    data: XOR<EnderecoProfissionalUpdateManyMutationInput, EnderecoProfissionalUncheckedUpdateManyInput>
    /**
     * Filter which EnderecoProfissionals to update
     */
    where?: EnderecoProfissionalWhereInput
    /**
     * Limit how many EnderecoProfissionals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoProfissionalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnderecoProfissional upsert
   */
  export type EnderecoProfissionalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoProfissional
     */
    select?: EnderecoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoProfissional
     */
    omit?: EnderecoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoProfissionalInclude<ExtArgs> | null
    /**
     * The filter to search for the EnderecoProfissional to update in case it exists.
     */
    where: EnderecoProfissionalWhereUniqueInput
    /**
     * In case the EnderecoProfissional found by the `where` argument doesn't exist, create a new EnderecoProfissional with this data.
     */
    create: XOR<EnderecoProfissionalCreateInput, EnderecoProfissionalUncheckedCreateInput>
    /**
     * In case the EnderecoProfissional was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnderecoProfissionalUpdateInput, EnderecoProfissionalUncheckedUpdateInput>
  }

  /**
   * EnderecoProfissional delete
   */
  export type EnderecoProfissionalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoProfissional
     */
    select?: EnderecoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoProfissional
     */
    omit?: EnderecoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoProfissionalInclude<ExtArgs> | null
    /**
     * Filter which EnderecoProfissional to delete.
     */
    where: EnderecoProfissionalWhereUniqueInput
  }

  /**
   * EnderecoProfissional deleteMany
   */
  export type EnderecoProfissionalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnderecoProfissionals to delete
     */
    where?: EnderecoProfissionalWhereInput
    /**
     * Limit how many EnderecoProfissionals to delete.
     */
    limit?: number
  }

  /**
   * EnderecoProfissional without action
   */
  export type EnderecoProfissionalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoProfissional
     */
    select?: EnderecoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoProfissional
     */
    omit?: EnderecoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoProfissionalInclude<ExtArgs> | null
  }


  /**
   * Model Contato
   */

  export type AggregateContato = {
    _count: ContatoCountAggregateOutputType | null
    _avg: ContatoAvgAggregateOutputType | null
    _sum: ContatoSumAggregateOutputType | null
    _min: ContatoMinAggregateOutputType | null
    _max: ContatoMaxAggregateOutputType | null
  }

  export type ContatoAvgAggregateOutputType = {
    id: number | null
  }

  export type ContatoSumAggregateOutputType = {
    id: number | null
  }

  export type ContatoMinAggregateOutputType = {
    id: number | null
    tipo: $Enums.TipoFone | null
    numero: string | null
    stInativo: $Enums.SimNao | null
  }

  export type ContatoMaxAggregateOutputType = {
    id: number | null
    tipo: $Enums.TipoFone | null
    numero: string | null
    stInativo: $Enums.SimNao | null
  }

  export type ContatoCountAggregateOutputType = {
    id: number
    tipo: number
    numero: number
    stInativo: number
    _all: number
  }


  export type ContatoAvgAggregateInputType = {
    id?: true
  }

  export type ContatoSumAggregateInputType = {
    id?: true
  }

  export type ContatoMinAggregateInputType = {
    id?: true
    tipo?: true
    numero?: true
    stInativo?: true
  }

  export type ContatoMaxAggregateInputType = {
    id?: true
    tipo?: true
    numero?: true
    stInativo?: true
  }

  export type ContatoCountAggregateInputType = {
    id?: true
    tipo?: true
    numero?: true
    stInativo?: true
    _all?: true
  }

  export type ContatoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contato to aggregate.
     */
    where?: ContatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contatoes to fetch.
     */
    orderBy?: ContatoOrderByWithRelationInput | ContatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contatoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contatoes
    **/
    _count?: true | ContatoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContatoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContatoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContatoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContatoMaxAggregateInputType
  }

  export type GetContatoAggregateType<T extends ContatoAggregateArgs> = {
        [P in keyof T & keyof AggregateContato]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContato[P]>
      : GetScalarType<T[P], AggregateContato[P]>
  }




  export type ContatoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContatoWhereInput
    orderBy?: ContatoOrderByWithAggregationInput | ContatoOrderByWithAggregationInput[]
    by: ContatoScalarFieldEnum[] | ContatoScalarFieldEnum
    having?: ContatoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContatoCountAggregateInputType | true
    _avg?: ContatoAvgAggregateInputType
    _sum?: ContatoSumAggregateInputType
    _min?: ContatoMinAggregateInputType
    _max?: ContatoMaxAggregateInputType
  }

  export type ContatoGroupByOutputType = {
    id: number
    tipo: $Enums.TipoFone
    numero: string
    stInativo: $Enums.SimNao | null
    _count: ContatoCountAggregateOutputType | null
    _avg: ContatoAvgAggregateOutputType | null
    _sum: ContatoSumAggregateOutputType | null
    _min: ContatoMinAggregateOutputType | null
    _max: ContatoMaxAggregateOutputType | null
  }

  type GetContatoGroupByPayload<T extends ContatoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContatoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContatoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContatoGroupByOutputType[P]>
            : GetScalarType<T[P], ContatoGroupByOutputType[P]>
        }
      >
    >


  export type ContatoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    numero?: boolean
    stInativo?: boolean
    pacientes?: boolean | Contato$pacientesArgs<ExtArgs>
    profissionais?: boolean | Contato$profissionaisArgs<ExtArgs>
    _count?: boolean | ContatoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contato"]>

  export type ContatoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    numero?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["contato"]>

  export type ContatoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    numero?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["contato"]>

  export type ContatoSelectScalar = {
    id?: boolean
    tipo?: boolean
    numero?: boolean
    stInativo?: boolean
  }

  export type ContatoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipo" | "numero" | "stInativo", ExtArgs["result"]["contato"]>
  export type ContatoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pacientes?: boolean | Contato$pacientesArgs<ExtArgs>
    profissionais?: boolean | Contato$profissionaisArgs<ExtArgs>
    _count?: boolean | ContatoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContatoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ContatoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContatoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contato"
    objects: {
      pacientes: Prisma.$ContatoPacientePayload<ExtArgs>[]
      profissionais: Prisma.$ContatoProfissionalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipo: $Enums.TipoFone
      numero: string
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["contato"]>
    composites: {}
  }

  type ContatoGetPayload<S extends boolean | null | undefined | ContatoDefaultArgs> = $Result.GetResult<Prisma.$ContatoPayload, S>

  type ContatoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContatoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContatoCountAggregateInputType | true
    }

  export interface ContatoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contato'], meta: { name: 'Contato' } }
    /**
     * Find zero or one Contato that matches the filter.
     * @param {ContatoFindUniqueArgs} args - Arguments to find a Contato
     * @example
     * // Get one Contato
     * const contato = await prisma.contato.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContatoFindUniqueArgs>(args: SelectSubset<T, ContatoFindUniqueArgs<ExtArgs>>): Prisma__ContatoClient<$Result.GetResult<Prisma.$ContatoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contato that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContatoFindUniqueOrThrowArgs} args - Arguments to find a Contato
     * @example
     * // Get one Contato
     * const contato = await prisma.contato.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContatoFindUniqueOrThrowArgs>(args: SelectSubset<T, ContatoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContatoClient<$Result.GetResult<Prisma.$ContatoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contato that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoFindFirstArgs} args - Arguments to find a Contato
     * @example
     * // Get one Contato
     * const contato = await prisma.contato.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContatoFindFirstArgs>(args?: SelectSubset<T, ContatoFindFirstArgs<ExtArgs>>): Prisma__ContatoClient<$Result.GetResult<Prisma.$ContatoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contato that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoFindFirstOrThrowArgs} args - Arguments to find a Contato
     * @example
     * // Get one Contato
     * const contato = await prisma.contato.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContatoFindFirstOrThrowArgs>(args?: SelectSubset<T, ContatoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContatoClient<$Result.GetResult<Prisma.$ContatoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contatoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contatoes
     * const contatoes = await prisma.contato.findMany()
     * 
     * // Get first 10 Contatoes
     * const contatoes = await prisma.contato.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contatoWithIdOnly = await prisma.contato.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContatoFindManyArgs>(args?: SelectSubset<T, ContatoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContatoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contato.
     * @param {ContatoCreateArgs} args - Arguments to create a Contato.
     * @example
     * // Create one Contato
     * const Contato = await prisma.contato.create({
     *   data: {
     *     // ... data to create a Contato
     *   }
     * })
     * 
     */
    create<T extends ContatoCreateArgs>(args: SelectSubset<T, ContatoCreateArgs<ExtArgs>>): Prisma__ContatoClient<$Result.GetResult<Prisma.$ContatoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contatoes.
     * @param {ContatoCreateManyArgs} args - Arguments to create many Contatoes.
     * @example
     * // Create many Contatoes
     * const contato = await prisma.contato.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContatoCreateManyArgs>(args?: SelectSubset<T, ContatoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contatoes and returns the data saved in the database.
     * @param {ContatoCreateManyAndReturnArgs} args - Arguments to create many Contatoes.
     * @example
     * // Create many Contatoes
     * const contato = await prisma.contato.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contatoes and only return the `id`
     * const contatoWithIdOnly = await prisma.contato.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContatoCreateManyAndReturnArgs>(args?: SelectSubset<T, ContatoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContatoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contato.
     * @param {ContatoDeleteArgs} args - Arguments to delete one Contato.
     * @example
     * // Delete one Contato
     * const Contato = await prisma.contato.delete({
     *   where: {
     *     // ... filter to delete one Contato
     *   }
     * })
     * 
     */
    delete<T extends ContatoDeleteArgs>(args: SelectSubset<T, ContatoDeleteArgs<ExtArgs>>): Prisma__ContatoClient<$Result.GetResult<Prisma.$ContatoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contato.
     * @param {ContatoUpdateArgs} args - Arguments to update one Contato.
     * @example
     * // Update one Contato
     * const contato = await prisma.contato.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContatoUpdateArgs>(args: SelectSubset<T, ContatoUpdateArgs<ExtArgs>>): Prisma__ContatoClient<$Result.GetResult<Prisma.$ContatoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contatoes.
     * @param {ContatoDeleteManyArgs} args - Arguments to filter Contatoes to delete.
     * @example
     * // Delete a few Contatoes
     * const { count } = await prisma.contato.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContatoDeleteManyArgs>(args?: SelectSubset<T, ContatoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contatoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contatoes
     * const contato = await prisma.contato.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContatoUpdateManyArgs>(args: SelectSubset<T, ContatoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contatoes and returns the data updated in the database.
     * @param {ContatoUpdateManyAndReturnArgs} args - Arguments to update many Contatoes.
     * @example
     * // Update many Contatoes
     * const contato = await prisma.contato.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contatoes and only return the `id`
     * const contatoWithIdOnly = await prisma.contato.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContatoUpdateManyAndReturnArgs>(args: SelectSubset<T, ContatoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContatoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contato.
     * @param {ContatoUpsertArgs} args - Arguments to update or create a Contato.
     * @example
     * // Update or create a Contato
     * const contato = await prisma.contato.upsert({
     *   create: {
     *     // ... data to create a Contato
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contato we want to update
     *   }
     * })
     */
    upsert<T extends ContatoUpsertArgs>(args: SelectSubset<T, ContatoUpsertArgs<ExtArgs>>): Prisma__ContatoClient<$Result.GetResult<Prisma.$ContatoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contatoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoCountArgs} args - Arguments to filter Contatoes to count.
     * @example
     * // Count the number of Contatoes
     * const count = await prisma.contato.count({
     *   where: {
     *     // ... the filter for the Contatoes we want to count
     *   }
     * })
    **/
    count<T extends ContatoCountArgs>(
      args?: Subset<T, ContatoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContatoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContatoAggregateArgs>(args: Subset<T, ContatoAggregateArgs>): Prisma.PrismaPromise<GetContatoAggregateType<T>>

    /**
     * Group by Contato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContatoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContatoGroupByArgs['orderBy'] }
        : { orderBy?: ContatoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContatoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContatoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contato model
   */
  readonly fields: ContatoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contato.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContatoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pacientes<T extends Contato$pacientesArgs<ExtArgs> = {}>(args?: Subset<T, Contato$pacientesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContatoPacientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profissionais<T extends Contato$profissionaisArgs<ExtArgs> = {}>(args?: Subset<T, Contato$profissionaisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContatoProfissionalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contato model
   */
  interface ContatoFieldRefs {
    readonly id: FieldRef<"Contato", 'Int'>
    readonly tipo: FieldRef<"Contato", 'TipoFone'>
    readonly numero: FieldRef<"Contato", 'String'>
    readonly stInativo: FieldRef<"Contato", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * Contato findUnique
   */
  export type ContatoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contato
     */
    omit?: ContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoInclude<ExtArgs> | null
    /**
     * Filter, which Contato to fetch.
     */
    where: ContatoWhereUniqueInput
  }

  /**
   * Contato findUniqueOrThrow
   */
  export type ContatoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contato
     */
    omit?: ContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoInclude<ExtArgs> | null
    /**
     * Filter, which Contato to fetch.
     */
    where: ContatoWhereUniqueInput
  }

  /**
   * Contato findFirst
   */
  export type ContatoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contato
     */
    omit?: ContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoInclude<ExtArgs> | null
    /**
     * Filter, which Contato to fetch.
     */
    where?: ContatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contatoes to fetch.
     */
    orderBy?: ContatoOrderByWithRelationInput | ContatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contatoes.
     */
    cursor?: ContatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contatoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contatoes.
     */
    distinct?: ContatoScalarFieldEnum | ContatoScalarFieldEnum[]
  }

  /**
   * Contato findFirstOrThrow
   */
  export type ContatoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contato
     */
    omit?: ContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoInclude<ExtArgs> | null
    /**
     * Filter, which Contato to fetch.
     */
    where?: ContatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contatoes to fetch.
     */
    orderBy?: ContatoOrderByWithRelationInput | ContatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contatoes.
     */
    cursor?: ContatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contatoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contatoes.
     */
    distinct?: ContatoScalarFieldEnum | ContatoScalarFieldEnum[]
  }

  /**
   * Contato findMany
   */
  export type ContatoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contato
     */
    omit?: ContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoInclude<ExtArgs> | null
    /**
     * Filter, which Contatoes to fetch.
     */
    where?: ContatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contatoes to fetch.
     */
    orderBy?: ContatoOrderByWithRelationInput | ContatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contatoes.
     */
    cursor?: ContatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contatoes.
     */
    skip?: number
    distinct?: ContatoScalarFieldEnum | ContatoScalarFieldEnum[]
  }

  /**
   * Contato create
   */
  export type ContatoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contato
     */
    omit?: ContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoInclude<ExtArgs> | null
    /**
     * The data needed to create a Contato.
     */
    data: XOR<ContatoCreateInput, ContatoUncheckedCreateInput>
  }

  /**
   * Contato createMany
   */
  export type ContatoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contatoes.
     */
    data: ContatoCreateManyInput | ContatoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contato createManyAndReturn
   */
  export type ContatoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contato
     */
    omit?: ContatoOmit<ExtArgs> | null
    /**
     * The data used to create many Contatoes.
     */
    data: ContatoCreateManyInput | ContatoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contato update
   */
  export type ContatoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contato
     */
    omit?: ContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoInclude<ExtArgs> | null
    /**
     * The data needed to update a Contato.
     */
    data: XOR<ContatoUpdateInput, ContatoUncheckedUpdateInput>
    /**
     * Choose, which Contato to update.
     */
    where: ContatoWhereUniqueInput
  }

  /**
   * Contato updateMany
   */
  export type ContatoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contatoes.
     */
    data: XOR<ContatoUpdateManyMutationInput, ContatoUncheckedUpdateManyInput>
    /**
     * Filter which Contatoes to update
     */
    where?: ContatoWhereInput
    /**
     * Limit how many Contatoes to update.
     */
    limit?: number
  }

  /**
   * Contato updateManyAndReturn
   */
  export type ContatoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contato
     */
    omit?: ContatoOmit<ExtArgs> | null
    /**
     * The data used to update Contatoes.
     */
    data: XOR<ContatoUpdateManyMutationInput, ContatoUncheckedUpdateManyInput>
    /**
     * Filter which Contatoes to update
     */
    where?: ContatoWhereInput
    /**
     * Limit how many Contatoes to update.
     */
    limit?: number
  }

  /**
   * Contato upsert
   */
  export type ContatoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contato
     */
    omit?: ContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoInclude<ExtArgs> | null
    /**
     * The filter to search for the Contato to update in case it exists.
     */
    where: ContatoWhereUniqueInput
    /**
     * In case the Contato found by the `where` argument doesn't exist, create a new Contato with this data.
     */
    create: XOR<ContatoCreateInput, ContatoUncheckedCreateInput>
    /**
     * In case the Contato was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContatoUpdateInput, ContatoUncheckedUpdateInput>
  }

  /**
   * Contato delete
   */
  export type ContatoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contato
     */
    omit?: ContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoInclude<ExtArgs> | null
    /**
     * Filter which Contato to delete.
     */
    where: ContatoWhereUniqueInput
  }

  /**
   * Contato deleteMany
   */
  export type ContatoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contatoes to delete
     */
    where?: ContatoWhereInput
    /**
     * Limit how many Contatoes to delete.
     */
    limit?: number
  }

  /**
   * Contato.pacientes
   */
  export type Contato$pacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoPaciente
     */
    select?: ContatoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoPaciente
     */
    omit?: ContatoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoPacienteInclude<ExtArgs> | null
    where?: ContatoPacienteWhereInput
    orderBy?: ContatoPacienteOrderByWithRelationInput | ContatoPacienteOrderByWithRelationInput[]
    cursor?: ContatoPacienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContatoPacienteScalarFieldEnum | ContatoPacienteScalarFieldEnum[]
  }

  /**
   * Contato.profissionais
   */
  export type Contato$profissionaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoProfissional
     */
    select?: ContatoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoProfissional
     */
    omit?: ContatoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoProfissionalInclude<ExtArgs> | null
    where?: ContatoProfissionalWhereInput
    orderBy?: ContatoProfissionalOrderByWithRelationInput | ContatoProfissionalOrderByWithRelationInput[]
    cursor?: ContatoProfissionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContatoProfissionalScalarFieldEnum | ContatoProfissionalScalarFieldEnum[]
  }

  /**
   * Contato without action
   */
  export type ContatoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contato
     */
    select?: ContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contato
     */
    omit?: ContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoInclude<ExtArgs> | null
  }


  /**
   * Model ContatoPaciente
   */

  export type AggregateContatoPaciente = {
    _count: ContatoPacienteCountAggregateOutputType | null
    _avg: ContatoPacienteAvgAggregateOutputType | null
    _sum: ContatoPacienteSumAggregateOutputType | null
    _min: ContatoPacienteMinAggregateOutputType | null
    _max: ContatoPacienteMaxAggregateOutputType | null
  }

  export type ContatoPacienteAvgAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdContato: number | null
  }

  export type ContatoPacienteSumAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdContato: number | null
  }

  export type ContatoPacienteMinAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdContato: number | null
  }

  export type ContatoPacienteMaxAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdContato: number | null
  }

  export type ContatoPacienteCountAggregateOutputType = {
    id: number
    cdMaster: number
    cdPaciente: number
    cdContato: number
    _all: number
  }


  export type ContatoPacienteAvgAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdContato?: true
  }

  export type ContatoPacienteSumAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdContato?: true
  }

  export type ContatoPacienteMinAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdContato?: true
  }

  export type ContatoPacienteMaxAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdContato?: true
  }

  export type ContatoPacienteCountAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdContato?: true
    _all?: true
  }

  export type ContatoPacienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContatoPaciente to aggregate.
     */
    where?: ContatoPacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContatoPacientes to fetch.
     */
    orderBy?: ContatoPacienteOrderByWithRelationInput | ContatoPacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContatoPacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContatoPacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContatoPacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContatoPacientes
    **/
    _count?: true | ContatoPacienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContatoPacienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContatoPacienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContatoPacienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContatoPacienteMaxAggregateInputType
  }

  export type GetContatoPacienteAggregateType<T extends ContatoPacienteAggregateArgs> = {
        [P in keyof T & keyof AggregateContatoPaciente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContatoPaciente[P]>
      : GetScalarType<T[P], AggregateContatoPaciente[P]>
  }




  export type ContatoPacienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContatoPacienteWhereInput
    orderBy?: ContatoPacienteOrderByWithAggregationInput | ContatoPacienteOrderByWithAggregationInput[]
    by: ContatoPacienteScalarFieldEnum[] | ContatoPacienteScalarFieldEnum
    having?: ContatoPacienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContatoPacienteCountAggregateInputType | true
    _avg?: ContatoPacienteAvgAggregateInputType
    _sum?: ContatoPacienteSumAggregateInputType
    _min?: ContatoPacienteMinAggregateInputType
    _max?: ContatoPacienteMaxAggregateInputType
  }

  export type ContatoPacienteGroupByOutputType = {
    id: number
    cdMaster: number
    cdPaciente: number
    cdContato: number
    _count: ContatoPacienteCountAggregateOutputType | null
    _avg: ContatoPacienteAvgAggregateOutputType | null
    _sum: ContatoPacienteSumAggregateOutputType | null
    _min: ContatoPacienteMinAggregateOutputType | null
    _max: ContatoPacienteMaxAggregateOutputType | null
  }

  type GetContatoPacienteGroupByPayload<T extends ContatoPacienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContatoPacienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContatoPacienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContatoPacienteGroupByOutputType[P]>
            : GetScalarType<T[P], ContatoPacienteGroupByOutputType[P]>
        }
      >
    >


  export type ContatoPacienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdContato?: boolean
    contato?: boolean | ContatoDefaultArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contatoPaciente"]>

  export type ContatoPacienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdContato?: boolean
    contato?: boolean | ContatoDefaultArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contatoPaciente"]>

  export type ContatoPacienteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdContato?: boolean
    contato?: boolean | ContatoDefaultArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contatoPaciente"]>

  export type ContatoPacienteSelectScalar = {
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdContato?: boolean
  }

  export type ContatoPacienteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdMaster" | "cdPaciente" | "cdContato", ExtArgs["result"]["contatoPaciente"]>
  export type ContatoPacienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contato?: boolean | ContatoDefaultArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
  }
  export type ContatoPacienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contato?: boolean | ContatoDefaultArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
  }
  export type ContatoPacienteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contato?: boolean | ContatoDefaultArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
  }

  export type $ContatoPacientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContatoPaciente"
    objects: {
      contato: Prisma.$ContatoPayload<ExtArgs>
      paciente: Prisma.$PacientePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdMaster: number
      cdPaciente: number
      cdContato: number
    }, ExtArgs["result"]["contatoPaciente"]>
    composites: {}
  }

  type ContatoPacienteGetPayload<S extends boolean | null | undefined | ContatoPacienteDefaultArgs> = $Result.GetResult<Prisma.$ContatoPacientePayload, S>

  type ContatoPacienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContatoPacienteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContatoPacienteCountAggregateInputType | true
    }

  export interface ContatoPacienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContatoPaciente'], meta: { name: 'ContatoPaciente' } }
    /**
     * Find zero or one ContatoPaciente that matches the filter.
     * @param {ContatoPacienteFindUniqueArgs} args - Arguments to find a ContatoPaciente
     * @example
     * // Get one ContatoPaciente
     * const contatoPaciente = await prisma.contatoPaciente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContatoPacienteFindUniqueArgs>(args: SelectSubset<T, ContatoPacienteFindUniqueArgs<ExtArgs>>): Prisma__ContatoPacienteClient<$Result.GetResult<Prisma.$ContatoPacientePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContatoPaciente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContatoPacienteFindUniqueOrThrowArgs} args - Arguments to find a ContatoPaciente
     * @example
     * // Get one ContatoPaciente
     * const contatoPaciente = await prisma.contatoPaciente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContatoPacienteFindUniqueOrThrowArgs>(args: SelectSubset<T, ContatoPacienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContatoPacienteClient<$Result.GetResult<Prisma.$ContatoPacientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContatoPaciente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoPacienteFindFirstArgs} args - Arguments to find a ContatoPaciente
     * @example
     * // Get one ContatoPaciente
     * const contatoPaciente = await prisma.contatoPaciente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContatoPacienteFindFirstArgs>(args?: SelectSubset<T, ContatoPacienteFindFirstArgs<ExtArgs>>): Prisma__ContatoPacienteClient<$Result.GetResult<Prisma.$ContatoPacientePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContatoPaciente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoPacienteFindFirstOrThrowArgs} args - Arguments to find a ContatoPaciente
     * @example
     * // Get one ContatoPaciente
     * const contatoPaciente = await prisma.contatoPaciente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContatoPacienteFindFirstOrThrowArgs>(args?: SelectSubset<T, ContatoPacienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContatoPacienteClient<$Result.GetResult<Prisma.$ContatoPacientePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContatoPacientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoPacienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContatoPacientes
     * const contatoPacientes = await prisma.contatoPaciente.findMany()
     * 
     * // Get first 10 ContatoPacientes
     * const contatoPacientes = await prisma.contatoPaciente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contatoPacienteWithIdOnly = await prisma.contatoPaciente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContatoPacienteFindManyArgs>(args?: SelectSubset<T, ContatoPacienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContatoPacientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContatoPaciente.
     * @param {ContatoPacienteCreateArgs} args - Arguments to create a ContatoPaciente.
     * @example
     * // Create one ContatoPaciente
     * const ContatoPaciente = await prisma.contatoPaciente.create({
     *   data: {
     *     // ... data to create a ContatoPaciente
     *   }
     * })
     * 
     */
    create<T extends ContatoPacienteCreateArgs>(args: SelectSubset<T, ContatoPacienteCreateArgs<ExtArgs>>): Prisma__ContatoPacienteClient<$Result.GetResult<Prisma.$ContatoPacientePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContatoPacientes.
     * @param {ContatoPacienteCreateManyArgs} args - Arguments to create many ContatoPacientes.
     * @example
     * // Create many ContatoPacientes
     * const contatoPaciente = await prisma.contatoPaciente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContatoPacienteCreateManyArgs>(args?: SelectSubset<T, ContatoPacienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContatoPacientes and returns the data saved in the database.
     * @param {ContatoPacienteCreateManyAndReturnArgs} args - Arguments to create many ContatoPacientes.
     * @example
     * // Create many ContatoPacientes
     * const contatoPaciente = await prisma.contatoPaciente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContatoPacientes and only return the `id`
     * const contatoPacienteWithIdOnly = await prisma.contatoPaciente.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContatoPacienteCreateManyAndReturnArgs>(args?: SelectSubset<T, ContatoPacienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContatoPacientePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContatoPaciente.
     * @param {ContatoPacienteDeleteArgs} args - Arguments to delete one ContatoPaciente.
     * @example
     * // Delete one ContatoPaciente
     * const ContatoPaciente = await prisma.contatoPaciente.delete({
     *   where: {
     *     // ... filter to delete one ContatoPaciente
     *   }
     * })
     * 
     */
    delete<T extends ContatoPacienteDeleteArgs>(args: SelectSubset<T, ContatoPacienteDeleteArgs<ExtArgs>>): Prisma__ContatoPacienteClient<$Result.GetResult<Prisma.$ContatoPacientePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContatoPaciente.
     * @param {ContatoPacienteUpdateArgs} args - Arguments to update one ContatoPaciente.
     * @example
     * // Update one ContatoPaciente
     * const contatoPaciente = await prisma.contatoPaciente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContatoPacienteUpdateArgs>(args: SelectSubset<T, ContatoPacienteUpdateArgs<ExtArgs>>): Prisma__ContatoPacienteClient<$Result.GetResult<Prisma.$ContatoPacientePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContatoPacientes.
     * @param {ContatoPacienteDeleteManyArgs} args - Arguments to filter ContatoPacientes to delete.
     * @example
     * // Delete a few ContatoPacientes
     * const { count } = await prisma.contatoPaciente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContatoPacienteDeleteManyArgs>(args?: SelectSubset<T, ContatoPacienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContatoPacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoPacienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContatoPacientes
     * const contatoPaciente = await prisma.contatoPaciente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContatoPacienteUpdateManyArgs>(args: SelectSubset<T, ContatoPacienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContatoPacientes and returns the data updated in the database.
     * @param {ContatoPacienteUpdateManyAndReturnArgs} args - Arguments to update many ContatoPacientes.
     * @example
     * // Update many ContatoPacientes
     * const contatoPaciente = await prisma.contatoPaciente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContatoPacientes and only return the `id`
     * const contatoPacienteWithIdOnly = await prisma.contatoPaciente.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContatoPacienteUpdateManyAndReturnArgs>(args: SelectSubset<T, ContatoPacienteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContatoPacientePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContatoPaciente.
     * @param {ContatoPacienteUpsertArgs} args - Arguments to update or create a ContatoPaciente.
     * @example
     * // Update or create a ContatoPaciente
     * const contatoPaciente = await prisma.contatoPaciente.upsert({
     *   create: {
     *     // ... data to create a ContatoPaciente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContatoPaciente we want to update
     *   }
     * })
     */
    upsert<T extends ContatoPacienteUpsertArgs>(args: SelectSubset<T, ContatoPacienteUpsertArgs<ExtArgs>>): Prisma__ContatoPacienteClient<$Result.GetResult<Prisma.$ContatoPacientePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContatoPacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoPacienteCountArgs} args - Arguments to filter ContatoPacientes to count.
     * @example
     * // Count the number of ContatoPacientes
     * const count = await prisma.contatoPaciente.count({
     *   where: {
     *     // ... the filter for the ContatoPacientes we want to count
     *   }
     * })
    **/
    count<T extends ContatoPacienteCountArgs>(
      args?: Subset<T, ContatoPacienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContatoPacienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContatoPaciente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoPacienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContatoPacienteAggregateArgs>(args: Subset<T, ContatoPacienteAggregateArgs>): Prisma.PrismaPromise<GetContatoPacienteAggregateType<T>>

    /**
     * Group by ContatoPaciente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoPacienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContatoPacienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContatoPacienteGroupByArgs['orderBy'] }
        : { orderBy?: ContatoPacienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContatoPacienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContatoPacienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContatoPaciente model
   */
  readonly fields: ContatoPacienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContatoPaciente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContatoPacienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contato<T extends ContatoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContatoDefaultArgs<ExtArgs>>): Prisma__ContatoClient<$Result.GetResult<Prisma.$ContatoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paciente<T extends PacienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PacienteDefaultArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContatoPaciente model
   */
  interface ContatoPacienteFieldRefs {
    readonly id: FieldRef<"ContatoPaciente", 'Int'>
    readonly cdMaster: FieldRef<"ContatoPaciente", 'Int'>
    readonly cdPaciente: FieldRef<"ContatoPaciente", 'Int'>
    readonly cdContato: FieldRef<"ContatoPaciente", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContatoPaciente findUnique
   */
  export type ContatoPacienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoPaciente
     */
    select?: ContatoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoPaciente
     */
    omit?: ContatoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoPacienteInclude<ExtArgs> | null
    /**
     * Filter, which ContatoPaciente to fetch.
     */
    where: ContatoPacienteWhereUniqueInput
  }

  /**
   * ContatoPaciente findUniqueOrThrow
   */
  export type ContatoPacienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoPaciente
     */
    select?: ContatoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoPaciente
     */
    omit?: ContatoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoPacienteInclude<ExtArgs> | null
    /**
     * Filter, which ContatoPaciente to fetch.
     */
    where: ContatoPacienteWhereUniqueInput
  }

  /**
   * ContatoPaciente findFirst
   */
  export type ContatoPacienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoPaciente
     */
    select?: ContatoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoPaciente
     */
    omit?: ContatoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoPacienteInclude<ExtArgs> | null
    /**
     * Filter, which ContatoPaciente to fetch.
     */
    where?: ContatoPacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContatoPacientes to fetch.
     */
    orderBy?: ContatoPacienteOrderByWithRelationInput | ContatoPacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContatoPacientes.
     */
    cursor?: ContatoPacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContatoPacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContatoPacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContatoPacientes.
     */
    distinct?: ContatoPacienteScalarFieldEnum | ContatoPacienteScalarFieldEnum[]
  }

  /**
   * ContatoPaciente findFirstOrThrow
   */
  export type ContatoPacienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoPaciente
     */
    select?: ContatoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoPaciente
     */
    omit?: ContatoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoPacienteInclude<ExtArgs> | null
    /**
     * Filter, which ContatoPaciente to fetch.
     */
    where?: ContatoPacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContatoPacientes to fetch.
     */
    orderBy?: ContatoPacienteOrderByWithRelationInput | ContatoPacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContatoPacientes.
     */
    cursor?: ContatoPacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContatoPacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContatoPacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContatoPacientes.
     */
    distinct?: ContatoPacienteScalarFieldEnum | ContatoPacienteScalarFieldEnum[]
  }

  /**
   * ContatoPaciente findMany
   */
  export type ContatoPacienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoPaciente
     */
    select?: ContatoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoPaciente
     */
    omit?: ContatoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoPacienteInclude<ExtArgs> | null
    /**
     * Filter, which ContatoPacientes to fetch.
     */
    where?: ContatoPacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContatoPacientes to fetch.
     */
    orderBy?: ContatoPacienteOrderByWithRelationInput | ContatoPacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContatoPacientes.
     */
    cursor?: ContatoPacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContatoPacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContatoPacientes.
     */
    skip?: number
    distinct?: ContatoPacienteScalarFieldEnum | ContatoPacienteScalarFieldEnum[]
  }

  /**
   * ContatoPaciente create
   */
  export type ContatoPacienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoPaciente
     */
    select?: ContatoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoPaciente
     */
    omit?: ContatoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoPacienteInclude<ExtArgs> | null
    /**
     * The data needed to create a ContatoPaciente.
     */
    data: XOR<ContatoPacienteCreateInput, ContatoPacienteUncheckedCreateInput>
  }

  /**
   * ContatoPaciente createMany
   */
  export type ContatoPacienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContatoPacientes.
     */
    data: ContatoPacienteCreateManyInput | ContatoPacienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContatoPaciente createManyAndReturn
   */
  export type ContatoPacienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoPaciente
     */
    select?: ContatoPacienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoPaciente
     */
    omit?: ContatoPacienteOmit<ExtArgs> | null
    /**
     * The data used to create many ContatoPacientes.
     */
    data: ContatoPacienteCreateManyInput | ContatoPacienteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoPacienteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContatoPaciente update
   */
  export type ContatoPacienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoPaciente
     */
    select?: ContatoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoPaciente
     */
    omit?: ContatoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoPacienteInclude<ExtArgs> | null
    /**
     * The data needed to update a ContatoPaciente.
     */
    data: XOR<ContatoPacienteUpdateInput, ContatoPacienteUncheckedUpdateInput>
    /**
     * Choose, which ContatoPaciente to update.
     */
    where: ContatoPacienteWhereUniqueInput
  }

  /**
   * ContatoPaciente updateMany
   */
  export type ContatoPacienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContatoPacientes.
     */
    data: XOR<ContatoPacienteUpdateManyMutationInput, ContatoPacienteUncheckedUpdateManyInput>
    /**
     * Filter which ContatoPacientes to update
     */
    where?: ContatoPacienteWhereInput
    /**
     * Limit how many ContatoPacientes to update.
     */
    limit?: number
  }

  /**
   * ContatoPaciente updateManyAndReturn
   */
  export type ContatoPacienteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoPaciente
     */
    select?: ContatoPacienteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoPaciente
     */
    omit?: ContatoPacienteOmit<ExtArgs> | null
    /**
     * The data used to update ContatoPacientes.
     */
    data: XOR<ContatoPacienteUpdateManyMutationInput, ContatoPacienteUncheckedUpdateManyInput>
    /**
     * Filter which ContatoPacientes to update
     */
    where?: ContatoPacienteWhereInput
    /**
     * Limit how many ContatoPacientes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoPacienteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContatoPaciente upsert
   */
  export type ContatoPacienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoPaciente
     */
    select?: ContatoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoPaciente
     */
    omit?: ContatoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoPacienteInclude<ExtArgs> | null
    /**
     * The filter to search for the ContatoPaciente to update in case it exists.
     */
    where: ContatoPacienteWhereUniqueInput
    /**
     * In case the ContatoPaciente found by the `where` argument doesn't exist, create a new ContatoPaciente with this data.
     */
    create: XOR<ContatoPacienteCreateInput, ContatoPacienteUncheckedCreateInput>
    /**
     * In case the ContatoPaciente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContatoPacienteUpdateInput, ContatoPacienteUncheckedUpdateInput>
  }

  /**
   * ContatoPaciente delete
   */
  export type ContatoPacienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoPaciente
     */
    select?: ContatoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoPaciente
     */
    omit?: ContatoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoPacienteInclude<ExtArgs> | null
    /**
     * Filter which ContatoPaciente to delete.
     */
    where: ContatoPacienteWhereUniqueInput
  }

  /**
   * ContatoPaciente deleteMany
   */
  export type ContatoPacienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContatoPacientes to delete
     */
    where?: ContatoPacienteWhereInput
    /**
     * Limit how many ContatoPacientes to delete.
     */
    limit?: number
  }

  /**
   * ContatoPaciente without action
   */
  export type ContatoPacienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoPaciente
     */
    select?: ContatoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoPaciente
     */
    omit?: ContatoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoPacienteInclude<ExtArgs> | null
  }


  /**
   * Model ContatoProfissional
   */

  export type AggregateContatoProfissional = {
    _count: ContatoProfissionalCountAggregateOutputType | null
    _avg: ContatoProfissionalAvgAggregateOutputType | null
    _sum: ContatoProfissionalSumAggregateOutputType | null
    _min: ContatoProfissionalMinAggregateOutputType | null
    _max: ContatoProfissionalMaxAggregateOutputType | null
  }

  export type ContatoProfissionalAvgAggregateOutputType = {
    id: number | null
    cdProf: number | null
    cdContato: number | null
  }

  export type ContatoProfissionalSumAggregateOutputType = {
    id: number | null
    cdProf: number | null
    cdContato: number | null
  }

  export type ContatoProfissionalMinAggregateOutputType = {
    id: number | null
    cdProf: number | null
    cdContato: number | null
  }

  export type ContatoProfissionalMaxAggregateOutputType = {
    id: number | null
    cdProf: number | null
    cdContato: number | null
  }

  export type ContatoProfissionalCountAggregateOutputType = {
    id: number
    cdProf: number
    cdContato: number
    _all: number
  }


  export type ContatoProfissionalAvgAggregateInputType = {
    id?: true
    cdProf?: true
    cdContato?: true
  }

  export type ContatoProfissionalSumAggregateInputType = {
    id?: true
    cdProf?: true
    cdContato?: true
  }

  export type ContatoProfissionalMinAggregateInputType = {
    id?: true
    cdProf?: true
    cdContato?: true
  }

  export type ContatoProfissionalMaxAggregateInputType = {
    id?: true
    cdProf?: true
    cdContato?: true
  }

  export type ContatoProfissionalCountAggregateInputType = {
    id?: true
    cdProf?: true
    cdContato?: true
    _all?: true
  }

  export type ContatoProfissionalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContatoProfissional to aggregate.
     */
    where?: ContatoProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContatoProfissionals to fetch.
     */
    orderBy?: ContatoProfissionalOrderByWithRelationInput | ContatoProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContatoProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContatoProfissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContatoProfissionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContatoProfissionals
    **/
    _count?: true | ContatoProfissionalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContatoProfissionalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContatoProfissionalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContatoProfissionalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContatoProfissionalMaxAggregateInputType
  }

  export type GetContatoProfissionalAggregateType<T extends ContatoProfissionalAggregateArgs> = {
        [P in keyof T & keyof AggregateContatoProfissional]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContatoProfissional[P]>
      : GetScalarType<T[P], AggregateContatoProfissional[P]>
  }




  export type ContatoProfissionalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContatoProfissionalWhereInput
    orderBy?: ContatoProfissionalOrderByWithAggregationInput | ContatoProfissionalOrderByWithAggregationInput[]
    by: ContatoProfissionalScalarFieldEnum[] | ContatoProfissionalScalarFieldEnum
    having?: ContatoProfissionalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContatoProfissionalCountAggregateInputType | true
    _avg?: ContatoProfissionalAvgAggregateInputType
    _sum?: ContatoProfissionalSumAggregateInputType
    _min?: ContatoProfissionalMinAggregateInputType
    _max?: ContatoProfissionalMaxAggregateInputType
  }

  export type ContatoProfissionalGroupByOutputType = {
    id: number
    cdProf: number
    cdContato: number
    _count: ContatoProfissionalCountAggregateOutputType | null
    _avg: ContatoProfissionalAvgAggregateOutputType | null
    _sum: ContatoProfissionalSumAggregateOutputType | null
    _min: ContatoProfissionalMinAggregateOutputType | null
    _max: ContatoProfissionalMaxAggregateOutputType | null
  }

  type GetContatoProfissionalGroupByPayload<T extends ContatoProfissionalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContatoProfissionalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContatoProfissionalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContatoProfissionalGroupByOutputType[P]>
            : GetScalarType<T[P], ContatoProfissionalGroupByOutputType[P]>
        }
      >
    >


  export type ContatoProfissionalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdProf?: boolean
    cdContato?: boolean
    contato?: boolean | ContatoDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contatoProfissional"]>

  export type ContatoProfissionalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdProf?: boolean
    cdContato?: boolean
    contato?: boolean | ContatoDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contatoProfissional"]>

  export type ContatoProfissionalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdProf?: boolean
    cdContato?: boolean
    contato?: boolean | ContatoDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contatoProfissional"]>

  export type ContatoProfissionalSelectScalar = {
    id?: boolean
    cdProf?: boolean
    cdContato?: boolean
  }

  export type ContatoProfissionalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdProf" | "cdContato", ExtArgs["result"]["contatoProfissional"]>
  export type ContatoProfissionalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contato?: boolean | ContatoDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }
  export type ContatoProfissionalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contato?: boolean | ContatoDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }
  export type ContatoProfissionalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contato?: boolean | ContatoDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }

  export type $ContatoProfissionalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContatoProfissional"
    objects: {
      contato: Prisma.$ContatoPayload<ExtArgs>
      profissional: Prisma.$ProfissionalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdProf: number
      cdContato: number
    }, ExtArgs["result"]["contatoProfissional"]>
    composites: {}
  }

  type ContatoProfissionalGetPayload<S extends boolean | null | undefined | ContatoProfissionalDefaultArgs> = $Result.GetResult<Prisma.$ContatoProfissionalPayload, S>

  type ContatoProfissionalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContatoProfissionalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContatoProfissionalCountAggregateInputType | true
    }

  export interface ContatoProfissionalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContatoProfissional'], meta: { name: 'ContatoProfissional' } }
    /**
     * Find zero or one ContatoProfissional that matches the filter.
     * @param {ContatoProfissionalFindUniqueArgs} args - Arguments to find a ContatoProfissional
     * @example
     * // Get one ContatoProfissional
     * const contatoProfissional = await prisma.contatoProfissional.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContatoProfissionalFindUniqueArgs>(args: SelectSubset<T, ContatoProfissionalFindUniqueArgs<ExtArgs>>): Prisma__ContatoProfissionalClient<$Result.GetResult<Prisma.$ContatoProfissionalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContatoProfissional that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContatoProfissionalFindUniqueOrThrowArgs} args - Arguments to find a ContatoProfissional
     * @example
     * // Get one ContatoProfissional
     * const contatoProfissional = await prisma.contatoProfissional.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContatoProfissionalFindUniqueOrThrowArgs>(args: SelectSubset<T, ContatoProfissionalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContatoProfissionalClient<$Result.GetResult<Prisma.$ContatoProfissionalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContatoProfissional that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoProfissionalFindFirstArgs} args - Arguments to find a ContatoProfissional
     * @example
     * // Get one ContatoProfissional
     * const contatoProfissional = await prisma.contatoProfissional.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContatoProfissionalFindFirstArgs>(args?: SelectSubset<T, ContatoProfissionalFindFirstArgs<ExtArgs>>): Prisma__ContatoProfissionalClient<$Result.GetResult<Prisma.$ContatoProfissionalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContatoProfissional that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoProfissionalFindFirstOrThrowArgs} args - Arguments to find a ContatoProfissional
     * @example
     * // Get one ContatoProfissional
     * const contatoProfissional = await prisma.contatoProfissional.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContatoProfissionalFindFirstOrThrowArgs>(args?: SelectSubset<T, ContatoProfissionalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContatoProfissionalClient<$Result.GetResult<Prisma.$ContatoProfissionalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContatoProfissionals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoProfissionalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContatoProfissionals
     * const contatoProfissionals = await prisma.contatoProfissional.findMany()
     * 
     * // Get first 10 ContatoProfissionals
     * const contatoProfissionals = await prisma.contatoProfissional.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contatoProfissionalWithIdOnly = await prisma.contatoProfissional.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContatoProfissionalFindManyArgs>(args?: SelectSubset<T, ContatoProfissionalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContatoProfissionalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContatoProfissional.
     * @param {ContatoProfissionalCreateArgs} args - Arguments to create a ContatoProfissional.
     * @example
     * // Create one ContatoProfissional
     * const ContatoProfissional = await prisma.contatoProfissional.create({
     *   data: {
     *     // ... data to create a ContatoProfissional
     *   }
     * })
     * 
     */
    create<T extends ContatoProfissionalCreateArgs>(args: SelectSubset<T, ContatoProfissionalCreateArgs<ExtArgs>>): Prisma__ContatoProfissionalClient<$Result.GetResult<Prisma.$ContatoProfissionalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContatoProfissionals.
     * @param {ContatoProfissionalCreateManyArgs} args - Arguments to create many ContatoProfissionals.
     * @example
     * // Create many ContatoProfissionals
     * const contatoProfissional = await prisma.contatoProfissional.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContatoProfissionalCreateManyArgs>(args?: SelectSubset<T, ContatoProfissionalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContatoProfissionals and returns the data saved in the database.
     * @param {ContatoProfissionalCreateManyAndReturnArgs} args - Arguments to create many ContatoProfissionals.
     * @example
     * // Create many ContatoProfissionals
     * const contatoProfissional = await prisma.contatoProfissional.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContatoProfissionals and only return the `id`
     * const contatoProfissionalWithIdOnly = await prisma.contatoProfissional.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContatoProfissionalCreateManyAndReturnArgs>(args?: SelectSubset<T, ContatoProfissionalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContatoProfissionalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContatoProfissional.
     * @param {ContatoProfissionalDeleteArgs} args - Arguments to delete one ContatoProfissional.
     * @example
     * // Delete one ContatoProfissional
     * const ContatoProfissional = await prisma.contatoProfissional.delete({
     *   where: {
     *     // ... filter to delete one ContatoProfissional
     *   }
     * })
     * 
     */
    delete<T extends ContatoProfissionalDeleteArgs>(args: SelectSubset<T, ContatoProfissionalDeleteArgs<ExtArgs>>): Prisma__ContatoProfissionalClient<$Result.GetResult<Prisma.$ContatoProfissionalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContatoProfissional.
     * @param {ContatoProfissionalUpdateArgs} args - Arguments to update one ContatoProfissional.
     * @example
     * // Update one ContatoProfissional
     * const contatoProfissional = await prisma.contatoProfissional.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContatoProfissionalUpdateArgs>(args: SelectSubset<T, ContatoProfissionalUpdateArgs<ExtArgs>>): Prisma__ContatoProfissionalClient<$Result.GetResult<Prisma.$ContatoProfissionalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContatoProfissionals.
     * @param {ContatoProfissionalDeleteManyArgs} args - Arguments to filter ContatoProfissionals to delete.
     * @example
     * // Delete a few ContatoProfissionals
     * const { count } = await prisma.contatoProfissional.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContatoProfissionalDeleteManyArgs>(args?: SelectSubset<T, ContatoProfissionalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContatoProfissionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoProfissionalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContatoProfissionals
     * const contatoProfissional = await prisma.contatoProfissional.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContatoProfissionalUpdateManyArgs>(args: SelectSubset<T, ContatoProfissionalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContatoProfissionals and returns the data updated in the database.
     * @param {ContatoProfissionalUpdateManyAndReturnArgs} args - Arguments to update many ContatoProfissionals.
     * @example
     * // Update many ContatoProfissionals
     * const contatoProfissional = await prisma.contatoProfissional.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContatoProfissionals and only return the `id`
     * const contatoProfissionalWithIdOnly = await prisma.contatoProfissional.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContatoProfissionalUpdateManyAndReturnArgs>(args: SelectSubset<T, ContatoProfissionalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContatoProfissionalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContatoProfissional.
     * @param {ContatoProfissionalUpsertArgs} args - Arguments to update or create a ContatoProfissional.
     * @example
     * // Update or create a ContatoProfissional
     * const contatoProfissional = await prisma.contatoProfissional.upsert({
     *   create: {
     *     // ... data to create a ContatoProfissional
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContatoProfissional we want to update
     *   }
     * })
     */
    upsert<T extends ContatoProfissionalUpsertArgs>(args: SelectSubset<T, ContatoProfissionalUpsertArgs<ExtArgs>>): Prisma__ContatoProfissionalClient<$Result.GetResult<Prisma.$ContatoProfissionalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContatoProfissionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoProfissionalCountArgs} args - Arguments to filter ContatoProfissionals to count.
     * @example
     * // Count the number of ContatoProfissionals
     * const count = await prisma.contatoProfissional.count({
     *   where: {
     *     // ... the filter for the ContatoProfissionals we want to count
     *   }
     * })
    **/
    count<T extends ContatoProfissionalCountArgs>(
      args?: Subset<T, ContatoProfissionalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContatoProfissionalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContatoProfissional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoProfissionalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContatoProfissionalAggregateArgs>(args: Subset<T, ContatoProfissionalAggregateArgs>): Prisma.PrismaPromise<GetContatoProfissionalAggregateType<T>>

    /**
     * Group by ContatoProfissional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContatoProfissionalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContatoProfissionalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContatoProfissionalGroupByArgs['orderBy'] }
        : { orderBy?: ContatoProfissionalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContatoProfissionalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContatoProfissionalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContatoProfissional model
   */
  readonly fields: ContatoProfissionalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContatoProfissional.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContatoProfissionalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contato<T extends ContatoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContatoDefaultArgs<ExtArgs>>): Prisma__ContatoClient<$Result.GetResult<Prisma.$ContatoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profissional<T extends ProfissionalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfissionalDefaultArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContatoProfissional model
   */
  interface ContatoProfissionalFieldRefs {
    readonly id: FieldRef<"ContatoProfissional", 'Int'>
    readonly cdProf: FieldRef<"ContatoProfissional", 'Int'>
    readonly cdContato: FieldRef<"ContatoProfissional", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContatoProfissional findUnique
   */
  export type ContatoProfissionalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoProfissional
     */
    select?: ContatoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoProfissional
     */
    omit?: ContatoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which ContatoProfissional to fetch.
     */
    where: ContatoProfissionalWhereUniqueInput
  }

  /**
   * ContatoProfissional findUniqueOrThrow
   */
  export type ContatoProfissionalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoProfissional
     */
    select?: ContatoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoProfissional
     */
    omit?: ContatoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which ContatoProfissional to fetch.
     */
    where: ContatoProfissionalWhereUniqueInput
  }

  /**
   * ContatoProfissional findFirst
   */
  export type ContatoProfissionalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoProfissional
     */
    select?: ContatoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoProfissional
     */
    omit?: ContatoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which ContatoProfissional to fetch.
     */
    where?: ContatoProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContatoProfissionals to fetch.
     */
    orderBy?: ContatoProfissionalOrderByWithRelationInput | ContatoProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContatoProfissionals.
     */
    cursor?: ContatoProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContatoProfissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContatoProfissionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContatoProfissionals.
     */
    distinct?: ContatoProfissionalScalarFieldEnum | ContatoProfissionalScalarFieldEnum[]
  }

  /**
   * ContatoProfissional findFirstOrThrow
   */
  export type ContatoProfissionalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoProfissional
     */
    select?: ContatoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoProfissional
     */
    omit?: ContatoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which ContatoProfissional to fetch.
     */
    where?: ContatoProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContatoProfissionals to fetch.
     */
    orderBy?: ContatoProfissionalOrderByWithRelationInput | ContatoProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContatoProfissionals.
     */
    cursor?: ContatoProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContatoProfissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContatoProfissionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContatoProfissionals.
     */
    distinct?: ContatoProfissionalScalarFieldEnum | ContatoProfissionalScalarFieldEnum[]
  }

  /**
   * ContatoProfissional findMany
   */
  export type ContatoProfissionalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoProfissional
     */
    select?: ContatoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoProfissional
     */
    omit?: ContatoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which ContatoProfissionals to fetch.
     */
    where?: ContatoProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContatoProfissionals to fetch.
     */
    orderBy?: ContatoProfissionalOrderByWithRelationInput | ContatoProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContatoProfissionals.
     */
    cursor?: ContatoProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContatoProfissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContatoProfissionals.
     */
    skip?: number
    distinct?: ContatoProfissionalScalarFieldEnum | ContatoProfissionalScalarFieldEnum[]
  }

  /**
   * ContatoProfissional create
   */
  export type ContatoProfissionalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoProfissional
     */
    select?: ContatoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoProfissional
     */
    omit?: ContatoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoProfissionalInclude<ExtArgs> | null
    /**
     * The data needed to create a ContatoProfissional.
     */
    data: XOR<ContatoProfissionalCreateInput, ContatoProfissionalUncheckedCreateInput>
  }

  /**
   * ContatoProfissional createMany
   */
  export type ContatoProfissionalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContatoProfissionals.
     */
    data: ContatoProfissionalCreateManyInput | ContatoProfissionalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContatoProfissional createManyAndReturn
   */
  export type ContatoProfissionalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoProfissional
     */
    select?: ContatoProfissionalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoProfissional
     */
    omit?: ContatoProfissionalOmit<ExtArgs> | null
    /**
     * The data used to create many ContatoProfissionals.
     */
    data: ContatoProfissionalCreateManyInput | ContatoProfissionalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoProfissionalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContatoProfissional update
   */
  export type ContatoProfissionalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoProfissional
     */
    select?: ContatoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoProfissional
     */
    omit?: ContatoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoProfissionalInclude<ExtArgs> | null
    /**
     * The data needed to update a ContatoProfissional.
     */
    data: XOR<ContatoProfissionalUpdateInput, ContatoProfissionalUncheckedUpdateInput>
    /**
     * Choose, which ContatoProfissional to update.
     */
    where: ContatoProfissionalWhereUniqueInput
  }

  /**
   * ContatoProfissional updateMany
   */
  export type ContatoProfissionalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContatoProfissionals.
     */
    data: XOR<ContatoProfissionalUpdateManyMutationInput, ContatoProfissionalUncheckedUpdateManyInput>
    /**
     * Filter which ContatoProfissionals to update
     */
    where?: ContatoProfissionalWhereInput
    /**
     * Limit how many ContatoProfissionals to update.
     */
    limit?: number
  }

  /**
   * ContatoProfissional updateManyAndReturn
   */
  export type ContatoProfissionalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoProfissional
     */
    select?: ContatoProfissionalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoProfissional
     */
    omit?: ContatoProfissionalOmit<ExtArgs> | null
    /**
     * The data used to update ContatoProfissionals.
     */
    data: XOR<ContatoProfissionalUpdateManyMutationInput, ContatoProfissionalUncheckedUpdateManyInput>
    /**
     * Filter which ContatoProfissionals to update
     */
    where?: ContatoProfissionalWhereInput
    /**
     * Limit how many ContatoProfissionals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoProfissionalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContatoProfissional upsert
   */
  export type ContatoProfissionalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoProfissional
     */
    select?: ContatoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoProfissional
     */
    omit?: ContatoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoProfissionalInclude<ExtArgs> | null
    /**
     * The filter to search for the ContatoProfissional to update in case it exists.
     */
    where: ContatoProfissionalWhereUniqueInput
    /**
     * In case the ContatoProfissional found by the `where` argument doesn't exist, create a new ContatoProfissional with this data.
     */
    create: XOR<ContatoProfissionalCreateInput, ContatoProfissionalUncheckedCreateInput>
    /**
     * In case the ContatoProfissional was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContatoProfissionalUpdateInput, ContatoProfissionalUncheckedUpdateInput>
  }

  /**
   * ContatoProfissional delete
   */
  export type ContatoProfissionalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoProfissional
     */
    select?: ContatoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoProfissional
     */
    omit?: ContatoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoProfissionalInclude<ExtArgs> | null
    /**
     * Filter which ContatoProfissional to delete.
     */
    where: ContatoProfissionalWhereUniqueInput
  }

  /**
   * ContatoProfissional deleteMany
   */
  export type ContatoProfissionalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContatoProfissionals to delete
     */
    where?: ContatoProfissionalWhereInput
    /**
     * Limit how many ContatoProfissionals to delete.
     */
    limit?: number
  }

  /**
   * ContatoProfissional without action
   */
  export type ContatoProfissionalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContatoProfissional
     */
    select?: ContatoProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContatoProfissional
     */
    omit?: ContatoProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContatoProfissionalInclude<ExtArgs> | null
  }


  /**
   * Model Atendimento
   */

  export type AggregateAtendimento = {
    _count: AtendimentoCountAggregateOutputType | null
    _avg: AtendimentoAvgAggregateOutputType | null
    _sum: AtendimentoSumAggregateOutputType | null
    _min: AtendimentoMinAggregateOutputType | null
    _max: AtendimentoMaxAggregateOutputType | null
  }

  export type AtendimentoAvgAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdProfissional: number | null
  }

  export type AtendimentoSumAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdProfissional: number | null
  }

  export type AtendimentoMinAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdProfissional: number | null
    data: Date | null
    observacao: string | null
  }

  export type AtendimentoMaxAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdProfissional: number | null
    data: Date | null
    observacao: string | null
  }

  export type AtendimentoCountAggregateOutputType = {
    id: number
    cdMaster: number
    cdPaciente: number
    cdProfissional: number
    data: number
    observacao: number
    _all: number
  }


  export type AtendimentoAvgAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdProfissional?: true
  }

  export type AtendimentoSumAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdProfissional?: true
  }

  export type AtendimentoMinAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdProfissional?: true
    data?: true
    observacao?: true
  }

  export type AtendimentoMaxAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdProfissional?: true
    data?: true
    observacao?: true
  }

  export type AtendimentoCountAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdProfissional?: true
    data?: true
    observacao?: true
    _all?: true
  }

  export type AtendimentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Atendimento to aggregate.
     */
    where?: AtendimentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Atendimentos to fetch.
     */
    orderBy?: AtendimentoOrderByWithRelationInput | AtendimentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AtendimentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Atendimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Atendimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Atendimentos
    **/
    _count?: true | AtendimentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AtendimentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AtendimentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AtendimentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AtendimentoMaxAggregateInputType
  }

  export type GetAtendimentoAggregateType<T extends AtendimentoAggregateArgs> = {
        [P in keyof T & keyof AggregateAtendimento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtendimento[P]>
      : GetScalarType<T[P], AggregateAtendimento[P]>
  }




  export type AtendimentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AtendimentoWhereInput
    orderBy?: AtendimentoOrderByWithAggregationInput | AtendimentoOrderByWithAggregationInput[]
    by: AtendimentoScalarFieldEnum[] | AtendimentoScalarFieldEnum
    having?: AtendimentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AtendimentoCountAggregateInputType | true
    _avg?: AtendimentoAvgAggregateInputType
    _sum?: AtendimentoSumAggregateInputType
    _min?: AtendimentoMinAggregateInputType
    _max?: AtendimentoMaxAggregateInputType
  }

  export type AtendimentoGroupByOutputType = {
    id: number
    cdMaster: number
    cdPaciente: number
    cdProfissional: number
    data: Date
    observacao: string | null
    _count: AtendimentoCountAggregateOutputType | null
    _avg: AtendimentoAvgAggregateOutputType | null
    _sum: AtendimentoSumAggregateOutputType | null
    _min: AtendimentoMinAggregateOutputType | null
    _max: AtendimentoMaxAggregateOutputType | null
  }

  type GetAtendimentoGroupByPayload<T extends AtendimentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AtendimentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AtendimentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AtendimentoGroupByOutputType[P]>
            : GetScalarType<T[P], AtendimentoGroupByOutputType[P]>
        }
      >
    >


  export type AtendimentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdProfissional?: boolean
    data?: boolean
    observacao?: boolean
    afericoesClinicas?: boolean | Atendimento$afericoesClinicasArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
    evaDores?: boolean | Atendimento$evaDoresArgs<ExtArgs>
    evolucoes?: boolean | Atendimento$evolucoesArgs<ExtArgs>
    glasgows?: boolean | Atendimento$glasgowsArgs<ExtArgs>
    sinaisVitais?: boolean | Atendimento$sinaisVitaisArgs<ExtArgs>
    _count?: boolean | AtendimentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["atendimento"]>

  export type AtendimentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdProfissional?: boolean
    data?: boolean
    observacao?: boolean
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["atendimento"]>

  export type AtendimentoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdProfissional?: boolean
    data?: boolean
    observacao?: boolean
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["atendimento"]>

  export type AtendimentoSelectScalar = {
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdProfissional?: boolean
    data?: boolean
    observacao?: boolean
  }

  export type AtendimentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdMaster" | "cdPaciente" | "cdProfissional" | "data" | "observacao", ExtArgs["result"]["atendimento"]>
  export type AtendimentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    afericoesClinicas?: boolean | Atendimento$afericoesClinicasArgs<ExtArgs>
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
    evaDores?: boolean | Atendimento$evaDoresArgs<ExtArgs>
    evolucoes?: boolean | Atendimento$evolucoesArgs<ExtArgs>
    glasgows?: boolean | Atendimento$glasgowsArgs<ExtArgs>
    sinaisVitais?: boolean | Atendimento$sinaisVitaisArgs<ExtArgs>
    _count?: boolean | AtendimentoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AtendimentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }
  export type AtendimentoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
    profissional?: boolean | ProfissionalDefaultArgs<ExtArgs>
  }

  export type $AtendimentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Atendimento"
    objects: {
      afericoesClinicas: Prisma.$AfericaoClinicaPayload<ExtArgs>[]
      paciente: Prisma.$PacientePayload<ExtArgs>
      profissional: Prisma.$ProfissionalPayload<ExtArgs>
      evaDores: Prisma.$EvaDorPayload<ExtArgs>[]
      evolucoes: Prisma.$EvolucaoPayload<ExtArgs>[]
      glasgows: Prisma.$GlasgowPayload<ExtArgs>[]
      sinaisVitais: Prisma.$SinaisVitaisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdMaster: number
      cdPaciente: number
      cdProfissional: number
      data: Date
      observacao: string | null
    }, ExtArgs["result"]["atendimento"]>
    composites: {}
  }

  type AtendimentoGetPayload<S extends boolean | null | undefined | AtendimentoDefaultArgs> = $Result.GetResult<Prisma.$AtendimentoPayload, S>

  type AtendimentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AtendimentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AtendimentoCountAggregateInputType | true
    }

  export interface AtendimentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Atendimento'], meta: { name: 'Atendimento' } }
    /**
     * Find zero or one Atendimento that matches the filter.
     * @param {AtendimentoFindUniqueArgs} args - Arguments to find a Atendimento
     * @example
     * // Get one Atendimento
     * const atendimento = await prisma.atendimento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AtendimentoFindUniqueArgs>(args: SelectSubset<T, AtendimentoFindUniqueArgs<ExtArgs>>): Prisma__AtendimentoClient<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Atendimento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AtendimentoFindUniqueOrThrowArgs} args - Arguments to find a Atendimento
     * @example
     * // Get one Atendimento
     * const atendimento = await prisma.atendimento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AtendimentoFindUniqueOrThrowArgs>(args: SelectSubset<T, AtendimentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AtendimentoClient<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Atendimento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtendimentoFindFirstArgs} args - Arguments to find a Atendimento
     * @example
     * // Get one Atendimento
     * const atendimento = await prisma.atendimento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AtendimentoFindFirstArgs>(args?: SelectSubset<T, AtendimentoFindFirstArgs<ExtArgs>>): Prisma__AtendimentoClient<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Atendimento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtendimentoFindFirstOrThrowArgs} args - Arguments to find a Atendimento
     * @example
     * // Get one Atendimento
     * const atendimento = await prisma.atendimento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AtendimentoFindFirstOrThrowArgs>(args?: SelectSubset<T, AtendimentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AtendimentoClient<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Atendimentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtendimentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Atendimentos
     * const atendimentos = await prisma.atendimento.findMany()
     * 
     * // Get first 10 Atendimentos
     * const atendimentos = await prisma.atendimento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const atendimentoWithIdOnly = await prisma.atendimento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AtendimentoFindManyArgs>(args?: SelectSubset<T, AtendimentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Atendimento.
     * @param {AtendimentoCreateArgs} args - Arguments to create a Atendimento.
     * @example
     * // Create one Atendimento
     * const Atendimento = await prisma.atendimento.create({
     *   data: {
     *     // ... data to create a Atendimento
     *   }
     * })
     * 
     */
    create<T extends AtendimentoCreateArgs>(args: SelectSubset<T, AtendimentoCreateArgs<ExtArgs>>): Prisma__AtendimentoClient<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Atendimentos.
     * @param {AtendimentoCreateManyArgs} args - Arguments to create many Atendimentos.
     * @example
     * // Create many Atendimentos
     * const atendimento = await prisma.atendimento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AtendimentoCreateManyArgs>(args?: SelectSubset<T, AtendimentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Atendimentos and returns the data saved in the database.
     * @param {AtendimentoCreateManyAndReturnArgs} args - Arguments to create many Atendimentos.
     * @example
     * // Create many Atendimentos
     * const atendimento = await prisma.atendimento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Atendimentos and only return the `id`
     * const atendimentoWithIdOnly = await prisma.atendimento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AtendimentoCreateManyAndReturnArgs>(args?: SelectSubset<T, AtendimentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Atendimento.
     * @param {AtendimentoDeleteArgs} args - Arguments to delete one Atendimento.
     * @example
     * // Delete one Atendimento
     * const Atendimento = await prisma.atendimento.delete({
     *   where: {
     *     // ... filter to delete one Atendimento
     *   }
     * })
     * 
     */
    delete<T extends AtendimentoDeleteArgs>(args: SelectSubset<T, AtendimentoDeleteArgs<ExtArgs>>): Prisma__AtendimentoClient<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Atendimento.
     * @param {AtendimentoUpdateArgs} args - Arguments to update one Atendimento.
     * @example
     * // Update one Atendimento
     * const atendimento = await prisma.atendimento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AtendimentoUpdateArgs>(args: SelectSubset<T, AtendimentoUpdateArgs<ExtArgs>>): Prisma__AtendimentoClient<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Atendimentos.
     * @param {AtendimentoDeleteManyArgs} args - Arguments to filter Atendimentos to delete.
     * @example
     * // Delete a few Atendimentos
     * const { count } = await prisma.atendimento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AtendimentoDeleteManyArgs>(args?: SelectSubset<T, AtendimentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Atendimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtendimentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Atendimentos
     * const atendimento = await prisma.atendimento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AtendimentoUpdateManyArgs>(args: SelectSubset<T, AtendimentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Atendimentos and returns the data updated in the database.
     * @param {AtendimentoUpdateManyAndReturnArgs} args - Arguments to update many Atendimentos.
     * @example
     * // Update many Atendimentos
     * const atendimento = await prisma.atendimento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Atendimentos and only return the `id`
     * const atendimentoWithIdOnly = await prisma.atendimento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AtendimentoUpdateManyAndReturnArgs>(args: SelectSubset<T, AtendimentoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Atendimento.
     * @param {AtendimentoUpsertArgs} args - Arguments to update or create a Atendimento.
     * @example
     * // Update or create a Atendimento
     * const atendimento = await prisma.atendimento.upsert({
     *   create: {
     *     // ... data to create a Atendimento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Atendimento we want to update
     *   }
     * })
     */
    upsert<T extends AtendimentoUpsertArgs>(args: SelectSubset<T, AtendimentoUpsertArgs<ExtArgs>>): Prisma__AtendimentoClient<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Atendimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtendimentoCountArgs} args - Arguments to filter Atendimentos to count.
     * @example
     * // Count the number of Atendimentos
     * const count = await prisma.atendimento.count({
     *   where: {
     *     // ... the filter for the Atendimentos we want to count
     *   }
     * })
    **/
    count<T extends AtendimentoCountArgs>(
      args?: Subset<T, AtendimentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AtendimentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Atendimento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtendimentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AtendimentoAggregateArgs>(args: Subset<T, AtendimentoAggregateArgs>): Prisma.PrismaPromise<GetAtendimentoAggregateType<T>>

    /**
     * Group by Atendimento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtendimentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AtendimentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AtendimentoGroupByArgs['orderBy'] }
        : { orderBy?: AtendimentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AtendimentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtendimentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Atendimento model
   */
  readonly fields: AtendimentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Atendimento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AtendimentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    afericoesClinicas<T extends Atendimento$afericoesClinicasArgs<ExtArgs> = {}>(args?: Subset<T, Atendimento$afericoesClinicasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AfericaoClinicaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paciente<T extends PacienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PacienteDefaultArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profissional<T extends ProfissionalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfissionalDefaultArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    evaDores<T extends Atendimento$evaDoresArgs<ExtArgs> = {}>(args?: Subset<T, Atendimento$evaDoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaDorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evolucoes<T extends Atendimento$evolucoesArgs<ExtArgs> = {}>(args?: Subset<T, Atendimento$evolucoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    glasgows<T extends Atendimento$glasgowsArgs<ExtArgs> = {}>(args?: Subset<T, Atendimento$glasgowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlasgowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sinaisVitais<T extends Atendimento$sinaisVitaisArgs<ExtArgs> = {}>(args?: Subset<T, Atendimento$sinaisVitaisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SinaisVitaisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Atendimento model
   */
  interface AtendimentoFieldRefs {
    readonly id: FieldRef<"Atendimento", 'Int'>
    readonly cdMaster: FieldRef<"Atendimento", 'Int'>
    readonly cdPaciente: FieldRef<"Atendimento", 'Int'>
    readonly cdProfissional: FieldRef<"Atendimento", 'Int'>
    readonly data: FieldRef<"Atendimento", 'DateTime'>
    readonly observacao: FieldRef<"Atendimento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Atendimento findUnique
   */
  export type AtendimentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atendimento
     */
    select?: AtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atendimento
     */
    omit?: AtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtendimentoInclude<ExtArgs> | null
    /**
     * Filter, which Atendimento to fetch.
     */
    where: AtendimentoWhereUniqueInput
  }

  /**
   * Atendimento findUniqueOrThrow
   */
  export type AtendimentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atendimento
     */
    select?: AtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atendimento
     */
    omit?: AtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtendimentoInclude<ExtArgs> | null
    /**
     * Filter, which Atendimento to fetch.
     */
    where: AtendimentoWhereUniqueInput
  }

  /**
   * Atendimento findFirst
   */
  export type AtendimentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atendimento
     */
    select?: AtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atendimento
     */
    omit?: AtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtendimentoInclude<ExtArgs> | null
    /**
     * Filter, which Atendimento to fetch.
     */
    where?: AtendimentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Atendimentos to fetch.
     */
    orderBy?: AtendimentoOrderByWithRelationInput | AtendimentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Atendimentos.
     */
    cursor?: AtendimentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Atendimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Atendimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Atendimentos.
     */
    distinct?: AtendimentoScalarFieldEnum | AtendimentoScalarFieldEnum[]
  }

  /**
   * Atendimento findFirstOrThrow
   */
  export type AtendimentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atendimento
     */
    select?: AtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atendimento
     */
    omit?: AtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtendimentoInclude<ExtArgs> | null
    /**
     * Filter, which Atendimento to fetch.
     */
    where?: AtendimentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Atendimentos to fetch.
     */
    orderBy?: AtendimentoOrderByWithRelationInput | AtendimentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Atendimentos.
     */
    cursor?: AtendimentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Atendimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Atendimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Atendimentos.
     */
    distinct?: AtendimentoScalarFieldEnum | AtendimentoScalarFieldEnum[]
  }

  /**
   * Atendimento findMany
   */
  export type AtendimentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atendimento
     */
    select?: AtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atendimento
     */
    omit?: AtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtendimentoInclude<ExtArgs> | null
    /**
     * Filter, which Atendimentos to fetch.
     */
    where?: AtendimentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Atendimentos to fetch.
     */
    orderBy?: AtendimentoOrderByWithRelationInput | AtendimentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Atendimentos.
     */
    cursor?: AtendimentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Atendimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Atendimentos.
     */
    skip?: number
    distinct?: AtendimentoScalarFieldEnum | AtendimentoScalarFieldEnum[]
  }

  /**
   * Atendimento create
   */
  export type AtendimentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atendimento
     */
    select?: AtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atendimento
     */
    omit?: AtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtendimentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Atendimento.
     */
    data: XOR<AtendimentoCreateInput, AtendimentoUncheckedCreateInput>
  }

  /**
   * Atendimento createMany
   */
  export type AtendimentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Atendimentos.
     */
    data: AtendimentoCreateManyInput | AtendimentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Atendimento createManyAndReturn
   */
  export type AtendimentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atendimento
     */
    select?: AtendimentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Atendimento
     */
    omit?: AtendimentoOmit<ExtArgs> | null
    /**
     * The data used to create many Atendimentos.
     */
    data: AtendimentoCreateManyInput | AtendimentoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtendimentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Atendimento update
   */
  export type AtendimentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atendimento
     */
    select?: AtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atendimento
     */
    omit?: AtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtendimentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Atendimento.
     */
    data: XOR<AtendimentoUpdateInput, AtendimentoUncheckedUpdateInput>
    /**
     * Choose, which Atendimento to update.
     */
    where: AtendimentoWhereUniqueInput
  }

  /**
   * Atendimento updateMany
   */
  export type AtendimentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Atendimentos.
     */
    data: XOR<AtendimentoUpdateManyMutationInput, AtendimentoUncheckedUpdateManyInput>
    /**
     * Filter which Atendimentos to update
     */
    where?: AtendimentoWhereInput
    /**
     * Limit how many Atendimentos to update.
     */
    limit?: number
  }

  /**
   * Atendimento updateManyAndReturn
   */
  export type AtendimentoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atendimento
     */
    select?: AtendimentoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Atendimento
     */
    omit?: AtendimentoOmit<ExtArgs> | null
    /**
     * The data used to update Atendimentos.
     */
    data: XOR<AtendimentoUpdateManyMutationInput, AtendimentoUncheckedUpdateManyInput>
    /**
     * Filter which Atendimentos to update
     */
    where?: AtendimentoWhereInput
    /**
     * Limit how many Atendimentos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtendimentoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Atendimento upsert
   */
  export type AtendimentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atendimento
     */
    select?: AtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atendimento
     */
    omit?: AtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtendimentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Atendimento to update in case it exists.
     */
    where: AtendimentoWhereUniqueInput
    /**
     * In case the Atendimento found by the `where` argument doesn't exist, create a new Atendimento with this data.
     */
    create: XOR<AtendimentoCreateInput, AtendimentoUncheckedCreateInput>
    /**
     * In case the Atendimento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AtendimentoUpdateInput, AtendimentoUncheckedUpdateInput>
  }

  /**
   * Atendimento delete
   */
  export type AtendimentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atendimento
     */
    select?: AtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atendimento
     */
    omit?: AtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtendimentoInclude<ExtArgs> | null
    /**
     * Filter which Atendimento to delete.
     */
    where: AtendimentoWhereUniqueInput
  }

  /**
   * Atendimento deleteMany
   */
  export type AtendimentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Atendimentos to delete
     */
    where?: AtendimentoWhereInput
    /**
     * Limit how many Atendimentos to delete.
     */
    limit?: number
  }

  /**
   * Atendimento.afericoesClinicas
   */
  export type Atendimento$afericoesClinicasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfericaoClinica
     */
    select?: AfericaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfericaoClinica
     */
    omit?: AfericaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfericaoClinicaInclude<ExtArgs> | null
    where?: AfericaoClinicaWhereInput
    orderBy?: AfericaoClinicaOrderByWithRelationInput | AfericaoClinicaOrderByWithRelationInput[]
    cursor?: AfericaoClinicaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AfericaoClinicaScalarFieldEnum | AfericaoClinicaScalarFieldEnum[]
  }

  /**
   * Atendimento.evaDores
   */
  export type Atendimento$evaDoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaDor
     */
    select?: EvaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaDor
     */
    omit?: EvaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaDorInclude<ExtArgs> | null
    where?: EvaDorWhereInput
    orderBy?: EvaDorOrderByWithRelationInput | EvaDorOrderByWithRelationInput[]
    cursor?: EvaDorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaDorScalarFieldEnum | EvaDorScalarFieldEnum[]
  }

  /**
   * Atendimento.evolucoes
   */
  export type Atendimento$evolucoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoInclude<ExtArgs> | null
    where?: EvolucaoWhereInput
    orderBy?: EvolucaoOrderByWithRelationInput | EvolucaoOrderByWithRelationInput[]
    cursor?: EvolucaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvolucaoScalarFieldEnum | EvolucaoScalarFieldEnum[]
  }

  /**
   * Atendimento.glasgows
   */
  export type Atendimento$glasgowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Glasgow
     */
    select?: GlasgowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Glasgow
     */
    omit?: GlasgowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlasgowInclude<ExtArgs> | null
    where?: GlasgowWhereInput
    orderBy?: GlasgowOrderByWithRelationInput | GlasgowOrderByWithRelationInput[]
    cursor?: GlasgowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GlasgowScalarFieldEnum | GlasgowScalarFieldEnum[]
  }

  /**
   * Atendimento.sinaisVitais
   */
  export type Atendimento$sinaisVitaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SinaisVitais
     */
    select?: SinaisVitaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SinaisVitais
     */
    omit?: SinaisVitaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SinaisVitaisInclude<ExtArgs> | null
    where?: SinaisVitaisWhereInput
    orderBy?: SinaisVitaisOrderByWithRelationInput | SinaisVitaisOrderByWithRelationInput[]
    cursor?: SinaisVitaisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SinaisVitaisScalarFieldEnum | SinaisVitaisScalarFieldEnum[]
  }

  /**
   * Atendimento without action
   */
  export type AtendimentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atendimento
     */
    select?: AtendimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Atendimento
     */
    omit?: AtendimentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AtendimentoInclude<ExtArgs> | null
  }


  /**
   * Model Evolucao
   */

  export type AggregateEvolucao = {
    _count: EvolucaoCountAggregateOutputType | null
    _avg: EvolucaoAvgAggregateOutputType | null
    _sum: EvolucaoSumAggregateOutputType | null
    _min: EvolucaoMinAggregateOutputType | null
    _max: EvolucaoMaxAggregateOutputType | null
  }

  export type EvolucaoAvgAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    pacienteCdMaster: number | null
    pacienteCdPaciente: number | null
    tipoEvolucaoClinicaId: number | null
  }

  export type EvolucaoSumAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    pacienteCdMaster: number | null
    pacienteCdPaciente: number | null
    tipoEvolucaoClinicaId: number | null
  }

  export type EvolucaoMinAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    data: Date | null
    texto: string | null
    pacienteCdMaster: number | null
    pacienteCdPaciente: number | null
    tipoEvolucaoClinicaId: number | null
  }

  export type EvolucaoMaxAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    data: Date | null
    texto: string | null
    pacienteCdMaster: number | null
    pacienteCdPaciente: number | null
    tipoEvolucaoClinicaId: number | null
  }

  export type EvolucaoCountAggregateOutputType = {
    id: number
    cdAtendimento: number
    cdProfissional: number
    data: number
    texto: number
    pacienteCdMaster: number
    pacienteCdPaciente: number
    tipoEvolucaoClinicaId: number
    _all: number
  }


  export type EvolucaoAvgAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    pacienteCdMaster?: true
    pacienteCdPaciente?: true
    tipoEvolucaoClinicaId?: true
  }

  export type EvolucaoSumAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    pacienteCdMaster?: true
    pacienteCdPaciente?: true
    tipoEvolucaoClinicaId?: true
  }

  export type EvolucaoMinAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    data?: true
    texto?: true
    pacienteCdMaster?: true
    pacienteCdPaciente?: true
    tipoEvolucaoClinicaId?: true
  }

  export type EvolucaoMaxAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    data?: true
    texto?: true
    pacienteCdMaster?: true
    pacienteCdPaciente?: true
    tipoEvolucaoClinicaId?: true
  }

  export type EvolucaoCountAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    data?: true
    texto?: true
    pacienteCdMaster?: true
    pacienteCdPaciente?: true
    tipoEvolucaoClinicaId?: true
    _all?: true
  }

  export type EvolucaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evolucao to aggregate.
     */
    where?: EvolucaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evolucaos to fetch.
     */
    orderBy?: EvolucaoOrderByWithRelationInput | EvolucaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvolucaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evolucaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evolucaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evolucaos
    **/
    _count?: true | EvolucaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvolucaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvolucaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvolucaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvolucaoMaxAggregateInputType
  }

  export type GetEvolucaoAggregateType<T extends EvolucaoAggregateArgs> = {
        [P in keyof T & keyof AggregateEvolucao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvolucao[P]>
      : GetScalarType<T[P], AggregateEvolucao[P]>
  }




  export type EvolucaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolucaoWhereInput
    orderBy?: EvolucaoOrderByWithAggregationInput | EvolucaoOrderByWithAggregationInput[]
    by: EvolucaoScalarFieldEnum[] | EvolucaoScalarFieldEnum
    having?: EvolucaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvolucaoCountAggregateInputType | true
    _avg?: EvolucaoAvgAggregateInputType
    _sum?: EvolucaoSumAggregateInputType
    _min?: EvolucaoMinAggregateInputType
    _max?: EvolucaoMaxAggregateInputType
  }

  export type EvolucaoGroupByOutputType = {
    id: number
    cdAtendimento: number
    cdProfissional: number | null
    data: Date
    texto: string
    pacienteCdMaster: number | null
    pacienteCdPaciente: number | null
    tipoEvolucaoClinicaId: number | null
    _count: EvolucaoCountAggregateOutputType | null
    _avg: EvolucaoAvgAggregateOutputType | null
    _sum: EvolucaoSumAggregateOutputType | null
    _min: EvolucaoMinAggregateOutputType | null
    _max: EvolucaoMaxAggregateOutputType | null
  }

  type GetEvolucaoGroupByPayload<T extends EvolucaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvolucaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvolucaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvolucaoGroupByOutputType[P]>
            : GetScalarType<T[P], EvolucaoGroupByOutputType[P]>
        }
      >
    >


  export type EvolucaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    data?: boolean
    texto?: boolean
    pacienteCdMaster?: boolean
    pacienteCdPaciente?: boolean
    tipoEvolucaoClinicaId?: boolean
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | Evolucao$profissionalArgs<ExtArgs>
    paciente?: boolean | Evolucao$pacienteArgs<ExtArgs>
    tipoEvolucaoClinica?: boolean | Evolucao$tipoEvolucaoClinicaArgs<ExtArgs>
    cid?: boolean | Evolucao$cidArgs<ExtArgs>
    dsm?: boolean | Evolucao$dsmArgs<ExtArgs>
    _count?: boolean | EvolucaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evolucao"]>

  export type EvolucaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    data?: boolean
    texto?: boolean
    pacienteCdMaster?: boolean
    pacienteCdPaciente?: boolean
    tipoEvolucaoClinicaId?: boolean
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | Evolucao$profissionalArgs<ExtArgs>
    paciente?: boolean | Evolucao$pacienteArgs<ExtArgs>
    tipoEvolucaoClinica?: boolean | Evolucao$tipoEvolucaoClinicaArgs<ExtArgs>
  }, ExtArgs["result"]["evolucao"]>

  export type EvolucaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    data?: boolean
    texto?: boolean
    pacienteCdMaster?: boolean
    pacienteCdPaciente?: boolean
    tipoEvolucaoClinicaId?: boolean
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | Evolucao$profissionalArgs<ExtArgs>
    paciente?: boolean | Evolucao$pacienteArgs<ExtArgs>
    tipoEvolucaoClinica?: boolean | Evolucao$tipoEvolucaoClinicaArgs<ExtArgs>
  }, ExtArgs["result"]["evolucao"]>

  export type EvolucaoSelectScalar = {
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    data?: boolean
    texto?: boolean
    pacienteCdMaster?: boolean
    pacienteCdPaciente?: boolean
    tipoEvolucaoClinicaId?: boolean
  }

  export type EvolucaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdAtendimento" | "cdProfissional" | "data" | "texto" | "pacienteCdMaster" | "pacienteCdPaciente" | "tipoEvolucaoClinicaId", ExtArgs["result"]["evolucao"]>
  export type EvolucaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | Evolucao$profissionalArgs<ExtArgs>
    paciente?: boolean | Evolucao$pacienteArgs<ExtArgs>
    tipoEvolucaoClinica?: boolean | Evolucao$tipoEvolucaoClinicaArgs<ExtArgs>
    cid?: boolean | Evolucao$cidArgs<ExtArgs>
    dsm?: boolean | Evolucao$dsmArgs<ExtArgs>
    _count?: boolean | EvolucaoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EvolucaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | Evolucao$profissionalArgs<ExtArgs>
    paciente?: boolean | Evolucao$pacienteArgs<ExtArgs>
    tipoEvolucaoClinica?: boolean | Evolucao$tipoEvolucaoClinicaArgs<ExtArgs>
  }
  export type EvolucaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | Evolucao$profissionalArgs<ExtArgs>
    paciente?: boolean | Evolucao$pacienteArgs<ExtArgs>
    tipoEvolucaoClinica?: boolean | Evolucao$tipoEvolucaoClinicaArgs<ExtArgs>
  }

  export type $EvolucaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evolucao"
    objects: {
      atendimento: Prisma.$AtendimentoPayload<ExtArgs>
      profissional: Prisma.$ProfissionalPayload<ExtArgs> | null
      paciente: Prisma.$PacientePayload<ExtArgs> | null
      tipoEvolucaoClinica: Prisma.$TipoEvolucaoClinicaPayload<ExtArgs> | null
      cid: Prisma.$EvolucaoCidPayload<ExtArgs>[]
      dsm: Prisma.$EvolucaoDsmPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdAtendimento: number
      cdProfissional: number | null
      data: Date
      texto: string
      pacienteCdMaster: number | null
      pacienteCdPaciente: number | null
      tipoEvolucaoClinicaId: number | null
    }, ExtArgs["result"]["evolucao"]>
    composites: {}
  }

  type EvolucaoGetPayload<S extends boolean | null | undefined | EvolucaoDefaultArgs> = $Result.GetResult<Prisma.$EvolucaoPayload, S>

  type EvolucaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvolucaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvolucaoCountAggregateInputType | true
    }

  export interface EvolucaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evolucao'], meta: { name: 'Evolucao' } }
    /**
     * Find zero or one Evolucao that matches the filter.
     * @param {EvolucaoFindUniqueArgs} args - Arguments to find a Evolucao
     * @example
     * // Get one Evolucao
     * const evolucao = await prisma.evolucao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvolucaoFindUniqueArgs>(args: SelectSubset<T, EvolucaoFindUniqueArgs<ExtArgs>>): Prisma__EvolucaoClient<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Evolucao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvolucaoFindUniqueOrThrowArgs} args - Arguments to find a Evolucao
     * @example
     * // Get one Evolucao
     * const evolucao = await prisma.evolucao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvolucaoFindUniqueOrThrowArgs>(args: SelectSubset<T, EvolucaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvolucaoClient<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evolucao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoFindFirstArgs} args - Arguments to find a Evolucao
     * @example
     * // Get one Evolucao
     * const evolucao = await prisma.evolucao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvolucaoFindFirstArgs>(args?: SelectSubset<T, EvolucaoFindFirstArgs<ExtArgs>>): Prisma__EvolucaoClient<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evolucao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoFindFirstOrThrowArgs} args - Arguments to find a Evolucao
     * @example
     * // Get one Evolucao
     * const evolucao = await prisma.evolucao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvolucaoFindFirstOrThrowArgs>(args?: SelectSubset<T, EvolucaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvolucaoClient<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Evolucaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evolucaos
     * const evolucaos = await prisma.evolucao.findMany()
     * 
     * // Get first 10 Evolucaos
     * const evolucaos = await prisma.evolucao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evolucaoWithIdOnly = await prisma.evolucao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvolucaoFindManyArgs>(args?: SelectSubset<T, EvolucaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Evolucao.
     * @param {EvolucaoCreateArgs} args - Arguments to create a Evolucao.
     * @example
     * // Create one Evolucao
     * const Evolucao = await prisma.evolucao.create({
     *   data: {
     *     // ... data to create a Evolucao
     *   }
     * })
     * 
     */
    create<T extends EvolucaoCreateArgs>(args: SelectSubset<T, EvolucaoCreateArgs<ExtArgs>>): Prisma__EvolucaoClient<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Evolucaos.
     * @param {EvolucaoCreateManyArgs} args - Arguments to create many Evolucaos.
     * @example
     * // Create many Evolucaos
     * const evolucao = await prisma.evolucao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvolucaoCreateManyArgs>(args?: SelectSubset<T, EvolucaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evolucaos and returns the data saved in the database.
     * @param {EvolucaoCreateManyAndReturnArgs} args - Arguments to create many Evolucaos.
     * @example
     * // Create many Evolucaos
     * const evolucao = await prisma.evolucao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evolucaos and only return the `id`
     * const evolucaoWithIdOnly = await prisma.evolucao.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvolucaoCreateManyAndReturnArgs>(args?: SelectSubset<T, EvolucaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Evolucao.
     * @param {EvolucaoDeleteArgs} args - Arguments to delete one Evolucao.
     * @example
     * // Delete one Evolucao
     * const Evolucao = await prisma.evolucao.delete({
     *   where: {
     *     // ... filter to delete one Evolucao
     *   }
     * })
     * 
     */
    delete<T extends EvolucaoDeleteArgs>(args: SelectSubset<T, EvolucaoDeleteArgs<ExtArgs>>): Prisma__EvolucaoClient<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Evolucao.
     * @param {EvolucaoUpdateArgs} args - Arguments to update one Evolucao.
     * @example
     * // Update one Evolucao
     * const evolucao = await prisma.evolucao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvolucaoUpdateArgs>(args: SelectSubset<T, EvolucaoUpdateArgs<ExtArgs>>): Prisma__EvolucaoClient<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Evolucaos.
     * @param {EvolucaoDeleteManyArgs} args - Arguments to filter Evolucaos to delete.
     * @example
     * // Delete a few Evolucaos
     * const { count } = await prisma.evolucao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvolucaoDeleteManyArgs>(args?: SelectSubset<T, EvolucaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evolucaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evolucaos
     * const evolucao = await prisma.evolucao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvolucaoUpdateManyArgs>(args: SelectSubset<T, EvolucaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evolucaos and returns the data updated in the database.
     * @param {EvolucaoUpdateManyAndReturnArgs} args - Arguments to update many Evolucaos.
     * @example
     * // Update many Evolucaos
     * const evolucao = await prisma.evolucao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Evolucaos and only return the `id`
     * const evolucaoWithIdOnly = await prisma.evolucao.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvolucaoUpdateManyAndReturnArgs>(args: SelectSubset<T, EvolucaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Evolucao.
     * @param {EvolucaoUpsertArgs} args - Arguments to update or create a Evolucao.
     * @example
     * // Update or create a Evolucao
     * const evolucao = await prisma.evolucao.upsert({
     *   create: {
     *     // ... data to create a Evolucao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evolucao we want to update
     *   }
     * })
     */
    upsert<T extends EvolucaoUpsertArgs>(args: SelectSubset<T, EvolucaoUpsertArgs<ExtArgs>>): Prisma__EvolucaoClient<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Evolucaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoCountArgs} args - Arguments to filter Evolucaos to count.
     * @example
     * // Count the number of Evolucaos
     * const count = await prisma.evolucao.count({
     *   where: {
     *     // ... the filter for the Evolucaos we want to count
     *   }
     * })
    **/
    count<T extends EvolucaoCountArgs>(
      args?: Subset<T, EvolucaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvolucaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evolucao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvolucaoAggregateArgs>(args: Subset<T, EvolucaoAggregateArgs>): Prisma.PrismaPromise<GetEvolucaoAggregateType<T>>

    /**
     * Group by Evolucao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvolucaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvolucaoGroupByArgs['orderBy'] }
        : { orderBy?: EvolucaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvolucaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvolucaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evolucao model
   */
  readonly fields: EvolucaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evolucao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvolucaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    atendimento<T extends AtendimentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AtendimentoDefaultArgs<ExtArgs>>): Prisma__AtendimentoClient<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profissional<T extends Evolucao$profissionalArgs<ExtArgs> = {}>(args?: Subset<T, Evolucao$profissionalArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    paciente<T extends Evolucao$pacienteArgs<ExtArgs> = {}>(args?: Subset<T, Evolucao$pacienteArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tipoEvolucaoClinica<T extends Evolucao$tipoEvolucaoClinicaArgs<ExtArgs> = {}>(args?: Subset<T, Evolucao$tipoEvolucaoClinicaArgs<ExtArgs>>): Prisma__TipoEvolucaoClinicaClient<$Result.GetResult<Prisma.$TipoEvolucaoClinicaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cid<T extends Evolucao$cidArgs<ExtArgs> = {}>(args?: Subset<T, Evolucao$cidArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoCidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dsm<T extends Evolucao$dsmArgs<ExtArgs> = {}>(args?: Subset<T, Evolucao$dsmArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoDsmPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evolucao model
   */
  interface EvolucaoFieldRefs {
    readonly id: FieldRef<"Evolucao", 'Int'>
    readonly cdAtendimento: FieldRef<"Evolucao", 'Int'>
    readonly cdProfissional: FieldRef<"Evolucao", 'Int'>
    readonly data: FieldRef<"Evolucao", 'DateTime'>
    readonly texto: FieldRef<"Evolucao", 'String'>
    readonly pacienteCdMaster: FieldRef<"Evolucao", 'Int'>
    readonly pacienteCdPaciente: FieldRef<"Evolucao", 'Int'>
    readonly tipoEvolucaoClinicaId: FieldRef<"Evolucao", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Evolucao findUnique
   */
  export type EvolucaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoInclude<ExtArgs> | null
    /**
     * Filter, which Evolucao to fetch.
     */
    where: EvolucaoWhereUniqueInput
  }

  /**
   * Evolucao findUniqueOrThrow
   */
  export type EvolucaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoInclude<ExtArgs> | null
    /**
     * Filter, which Evolucao to fetch.
     */
    where: EvolucaoWhereUniqueInput
  }

  /**
   * Evolucao findFirst
   */
  export type EvolucaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoInclude<ExtArgs> | null
    /**
     * Filter, which Evolucao to fetch.
     */
    where?: EvolucaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evolucaos to fetch.
     */
    orderBy?: EvolucaoOrderByWithRelationInput | EvolucaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evolucaos.
     */
    cursor?: EvolucaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evolucaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evolucaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evolucaos.
     */
    distinct?: EvolucaoScalarFieldEnum | EvolucaoScalarFieldEnum[]
  }

  /**
   * Evolucao findFirstOrThrow
   */
  export type EvolucaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoInclude<ExtArgs> | null
    /**
     * Filter, which Evolucao to fetch.
     */
    where?: EvolucaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evolucaos to fetch.
     */
    orderBy?: EvolucaoOrderByWithRelationInput | EvolucaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evolucaos.
     */
    cursor?: EvolucaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evolucaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evolucaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evolucaos.
     */
    distinct?: EvolucaoScalarFieldEnum | EvolucaoScalarFieldEnum[]
  }

  /**
   * Evolucao findMany
   */
  export type EvolucaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoInclude<ExtArgs> | null
    /**
     * Filter, which Evolucaos to fetch.
     */
    where?: EvolucaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evolucaos to fetch.
     */
    orderBy?: EvolucaoOrderByWithRelationInput | EvolucaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evolucaos.
     */
    cursor?: EvolucaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evolucaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evolucaos.
     */
    skip?: number
    distinct?: EvolucaoScalarFieldEnum | EvolucaoScalarFieldEnum[]
  }

  /**
   * Evolucao create
   */
  export type EvolucaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Evolucao.
     */
    data: XOR<EvolucaoCreateInput, EvolucaoUncheckedCreateInput>
  }

  /**
   * Evolucao createMany
   */
  export type EvolucaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evolucaos.
     */
    data: EvolucaoCreateManyInput | EvolucaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evolucao createManyAndReturn
   */
  export type EvolucaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * The data used to create many Evolucaos.
     */
    data: EvolucaoCreateManyInput | EvolucaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evolucao update
   */
  export type EvolucaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Evolucao.
     */
    data: XOR<EvolucaoUpdateInput, EvolucaoUncheckedUpdateInput>
    /**
     * Choose, which Evolucao to update.
     */
    where: EvolucaoWhereUniqueInput
  }

  /**
   * Evolucao updateMany
   */
  export type EvolucaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evolucaos.
     */
    data: XOR<EvolucaoUpdateManyMutationInput, EvolucaoUncheckedUpdateManyInput>
    /**
     * Filter which Evolucaos to update
     */
    where?: EvolucaoWhereInput
    /**
     * Limit how many Evolucaos to update.
     */
    limit?: number
  }

  /**
   * Evolucao updateManyAndReturn
   */
  export type EvolucaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * The data used to update Evolucaos.
     */
    data: XOR<EvolucaoUpdateManyMutationInput, EvolucaoUncheckedUpdateManyInput>
    /**
     * Filter which Evolucaos to update
     */
    where?: EvolucaoWhereInput
    /**
     * Limit how many Evolucaos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evolucao upsert
   */
  export type EvolucaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Evolucao to update in case it exists.
     */
    where: EvolucaoWhereUniqueInput
    /**
     * In case the Evolucao found by the `where` argument doesn't exist, create a new Evolucao with this data.
     */
    create: XOR<EvolucaoCreateInput, EvolucaoUncheckedCreateInput>
    /**
     * In case the Evolucao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvolucaoUpdateInput, EvolucaoUncheckedUpdateInput>
  }

  /**
   * Evolucao delete
   */
  export type EvolucaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoInclude<ExtArgs> | null
    /**
     * Filter which Evolucao to delete.
     */
    where: EvolucaoWhereUniqueInput
  }

  /**
   * Evolucao deleteMany
   */
  export type EvolucaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evolucaos to delete
     */
    where?: EvolucaoWhereInput
    /**
     * Limit how many Evolucaos to delete.
     */
    limit?: number
  }

  /**
   * Evolucao.profissional
   */
  export type Evolucao$profissionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    where?: ProfissionalWhereInput
  }

  /**
   * Evolucao.paciente
   */
  export type Evolucao$pacienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    where?: PacienteWhereInput
  }

  /**
   * Evolucao.tipoEvolucaoClinica
   */
  export type Evolucao$tipoEvolucaoClinicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoClinica
     */
    select?: TipoEvolucaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoClinica
     */
    omit?: TipoEvolucaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEvolucaoClinicaInclude<ExtArgs> | null
    where?: TipoEvolucaoClinicaWhereInput
  }

  /**
   * Evolucao.cid
   */
  export type Evolucao$cidArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoCid
     */
    select?: EvolucaoCidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoCid
     */
    omit?: EvolucaoCidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoCidInclude<ExtArgs> | null
    where?: EvolucaoCidWhereInput
    orderBy?: EvolucaoCidOrderByWithRelationInput | EvolucaoCidOrderByWithRelationInput[]
    cursor?: EvolucaoCidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvolucaoCidScalarFieldEnum | EvolucaoCidScalarFieldEnum[]
  }

  /**
   * Evolucao.dsm
   */
  export type Evolucao$dsmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoDsm
     */
    select?: EvolucaoDsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoDsm
     */
    omit?: EvolucaoDsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoDsmInclude<ExtArgs> | null
    where?: EvolucaoDsmWhereInput
    orderBy?: EvolucaoDsmOrderByWithRelationInput | EvolucaoDsmOrderByWithRelationInput[]
    cursor?: EvolucaoDsmWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvolucaoDsmScalarFieldEnum | EvolucaoDsmScalarFieldEnum[]
  }

  /**
   * Evolucao without action
   */
  export type EvolucaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoInclude<ExtArgs> | null
  }


  /**
   * Model PessoaRelacionada
   */

  export type AggregatePessoaRelacionada = {
    _count: PessoaRelacionadaCountAggregateOutputType | null
    _avg: PessoaRelacionadaAvgAggregateOutputType | null
    _sum: PessoaRelacionadaSumAggregateOutputType | null
    _min: PessoaRelacionadaMinAggregateOutputType | null
    _max: PessoaRelacionadaMaxAggregateOutputType | null
  }

  export type PessoaRelacionadaAvgAggregateOutputType = {
    id: number | null
  }

  export type PessoaRelacionadaSumAggregateOutputType = {
    id: number | null
  }

  export type PessoaRelacionadaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    telefone: string | null
    stInativo: $Enums.SimNao | null
  }

  export type PessoaRelacionadaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    telefone: string | null
    stInativo: $Enums.SimNao | null
  }

  export type PessoaRelacionadaCountAggregateOutputType = {
    id: number
    nome: number
    telefone: number
    stInativo: number
    _all: number
  }


  export type PessoaRelacionadaAvgAggregateInputType = {
    id?: true
  }

  export type PessoaRelacionadaSumAggregateInputType = {
    id?: true
  }

  export type PessoaRelacionadaMinAggregateInputType = {
    id?: true
    nome?: true
    telefone?: true
    stInativo?: true
  }

  export type PessoaRelacionadaMaxAggregateInputType = {
    id?: true
    nome?: true
    telefone?: true
    stInativo?: true
  }

  export type PessoaRelacionadaCountAggregateInputType = {
    id?: true
    nome?: true
    telefone?: true
    stInativo?: true
    _all?: true
  }

  export type PessoaRelacionadaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PessoaRelacionada to aggregate.
     */
    where?: PessoaRelacionadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PessoaRelacionadas to fetch.
     */
    orderBy?: PessoaRelacionadaOrderByWithRelationInput | PessoaRelacionadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PessoaRelacionadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PessoaRelacionadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PessoaRelacionadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PessoaRelacionadas
    **/
    _count?: true | PessoaRelacionadaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PessoaRelacionadaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PessoaRelacionadaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaRelacionadaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaRelacionadaMaxAggregateInputType
  }

  export type GetPessoaRelacionadaAggregateType<T extends PessoaRelacionadaAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoaRelacionada]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoaRelacionada[P]>
      : GetScalarType<T[P], AggregatePessoaRelacionada[P]>
  }




  export type PessoaRelacionadaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PessoaRelacionadaWhereInput
    orderBy?: PessoaRelacionadaOrderByWithAggregationInput | PessoaRelacionadaOrderByWithAggregationInput[]
    by: PessoaRelacionadaScalarFieldEnum[] | PessoaRelacionadaScalarFieldEnum
    having?: PessoaRelacionadaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaRelacionadaCountAggregateInputType | true
    _avg?: PessoaRelacionadaAvgAggregateInputType
    _sum?: PessoaRelacionadaSumAggregateInputType
    _min?: PessoaRelacionadaMinAggregateInputType
    _max?: PessoaRelacionadaMaxAggregateInputType
  }

  export type PessoaRelacionadaGroupByOutputType = {
    id: number
    nome: string
    telefone: string | null
    stInativo: $Enums.SimNao | null
    _count: PessoaRelacionadaCountAggregateOutputType | null
    _avg: PessoaRelacionadaAvgAggregateOutputType | null
    _sum: PessoaRelacionadaSumAggregateOutputType | null
    _min: PessoaRelacionadaMinAggregateOutputType | null
    _max: PessoaRelacionadaMaxAggregateOutputType | null
  }

  type GetPessoaRelacionadaGroupByPayload<T extends PessoaRelacionadaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PessoaRelacionadaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaRelacionadaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaRelacionadaGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaRelacionadaGroupByOutputType[P]>
        }
      >
    >


  export type PessoaRelacionadaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    telefone?: boolean
    stInativo?: boolean
    enderecos?: boolean | PessoaRelacionada$enderecosArgs<ExtArgs>
    parentescos?: boolean | PessoaRelacionada$parentescosArgs<ExtArgs>
    _count?: boolean | PessoaRelacionadaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoaRelacionada"]>

  export type PessoaRelacionadaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    telefone?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["pessoaRelacionada"]>

  export type PessoaRelacionadaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    telefone?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["pessoaRelacionada"]>

  export type PessoaRelacionadaSelectScalar = {
    id?: boolean
    nome?: boolean
    telefone?: boolean
    stInativo?: boolean
  }

  export type PessoaRelacionadaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "telefone" | "stInativo", ExtArgs["result"]["pessoaRelacionada"]>
  export type PessoaRelacionadaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enderecos?: boolean | PessoaRelacionada$enderecosArgs<ExtArgs>
    parentescos?: boolean | PessoaRelacionada$parentescosArgs<ExtArgs>
    _count?: boolean | PessoaRelacionadaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PessoaRelacionadaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PessoaRelacionadaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PessoaRelacionadaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PessoaRelacionada"
    objects: {
      enderecos: Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>[]
      parentescos: Prisma.$ParentescoPacientePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      telefone: string | null
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["pessoaRelacionada"]>
    composites: {}
  }

  type PessoaRelacionadaGetPayload<S extends boolean | null | undefined | PessoaRelacionadaDefaultArgs> = $Result.GetResult<Prisma.$PessoaRelacionadaPayload, S>

  type PessoaRelacionadaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PessoaRelacionadaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PessoaRelacionadaCountAggregateInputType | true
    }

  export interface PessoaRelacionadaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PessoaRelacionada'], meta: { name: 'PessoaRelacionada' } }
    /**
     * Find zero or one PessoaRelacionada that matches the filter.
     * @param {PessoaRelacionadaFindUniqueArgs} args - Arguments to find a PessoaRelacionada
     * @example
     * // Get one PessoaRelacionada
     * const pessoaRelacionada = await prisma.pessoaRelacionada.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PessoaRelacionadaFindUniqueArgs>(args: SelectSubset<T, PessoaRelacionadaFindUniqueArgs<ExtArgs>>): Prisma__PessoaRelacionadaClient<$Result.GetResult<Prisma.$PessoaRelacionadaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PessoaRelacionada that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PessoaRelacionadaFindUniqueOrThrowArgs} args - Arguments to find a PessoaRelacionada
     * @example
     * // Get one PessoaRelacionada
     * const pessoaRelacionada = await prisma.pessoaRelacionada.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PessoaRelacionadaFindUniqueOrThrowArgs>(args: SelectSubset<T, PessoaRelacionadaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PessoaRelacionadaClient<$Result.GetResult<Prisma.$PessoaRelacionadaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PessoaRelacionada that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaRelacionadaFindFirstArgs} args - Arguments to find a PessoaRelacionada
     * @example
     * // Get one PessoaRelacionada
     * const pessoaRelacionada = await prisma.pessoaRelacionada.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PessoaRelacionadaFindFirstArgs>(args?: SelectSubset<T, PessoaRelacionadaFindFirstArgs<ExtArgs>>): Prisma__PessoaRelacionadaClient<$Result.GetResult<Prisma.$PessoaRelacionadaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PessoaRelacionada that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaRelacionadaFindFirstOrThrowArgs} args - Arguments to find a PessoaRelacionada
     * @example
     * // Get one PessoaRelacionada
     * const pessoaRelacionada = await prisma.pessoaRelacionada.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PessoaRelacionadaFindFirstOrThrowArgs>(args?: SelectSubset<T, PessoaRelacionadaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PessoaRelacionadaClient<$Result.GetResult<Prisma.$PessoaRelacionadaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PessoaRelacionadas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaRelacionadaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PessoaRelacionadas
     * const pessoaRelacionadas = await prisma.pessoaRelacionada.findMany()
     * 
     * // Get first 10 PessoaRelacionadas
     * const pessoaRelacionadas = await prisma.pessoaRelacionada.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pessoaRelacionadaWithIdOnly = await prisma.pessoaRelacionada.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PessoaRelacionadaFindManyArgs>(args?: SelectSubset<T, PessoaRelacionadaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PessoaRelacionadaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PessoaRelacionada.
     * @param {PessoaRelacionadaCreateArgs} args - Arguments to create a PessoaRelacionada.
     * @example
     * // Create one PessoaRelacionada
     * const PessoaRelacionada = await prisma.pessoaRelacionada.create({
     *   data: {
     *     // ... data to create a PessoaRelacionada
     *   }
     * })
     * 
     */
    create<T extends PessoaRelacionadaCreateArgs>(args: SelectSubset<T, PessoaRelacionadaCreateArgs<ExtArgs>>): Prisma__PessoaRelacionadaClient<$Result.GetResult<Prisma.$PessoaRelacionadaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PessoaRelacionadas.
     * @param {PessoaRelacionadaCreateManyArgs} args - Arguments to create many PessoaRelacionadas.
     * @example
     * // Create many PessoaRelacionadas
     * const pessoaRelacionada = await prisma.pessoaRelacionada.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PessoaRelacionadaCreateManyArgs>(args?: SelectSubset<T, PessoaRelacionadaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PessoaRelacionadas and returns the data saved in the database.
     * @param {PessoaRelacionadaCreateManyAndReturnArgs} args - Arguments to create many PessoaRelacionadas.
     * @example
     * // Create many PessoaRelacionadas
     * const pessoaRelacionada = await prisma.pessoaRelacionada.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PessoaRelacionadas and only return the `id`
     * const pessoaRelacionadaWithIdOnly = await prisma.pessoaRelacionada.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PessoaRelacionadaCreateManyAndReturnArgs>(args?: SelectSubset<T, PessoaRelacionadaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PessoaRelacionadaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PessoaRelacionada.
     * @param {PessoaRelacionadaDeleteArgs} args - Arguments to delete one PessoaRelacionada.
     * @example
     * // Delete one PessoaRelacionada
     * const PessoaRelacionada = await prisma.pessoaRelacionada.delete({
     *   where: {
     *     // ... filter to delete one PessoaRelacionada
     *   }
     * })
     * 
     */
    delete<T extends PessoaRelacionadaDeleteArgs>(args: SelectSubset<T, PessoaRelacionadaDeleteArgs<ExtArgs>>): Prisma__PessoaRelacionadaClient<$Result.GetResult<Prisma.$PessoaRelacionadaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PessoaRelacionada.
     * @param {PessoaRelacionadaUpdateArgs} args - Arguments to update one PessoaRelacionada.
     * @example
     * // Update one PessoaRelacionada
     * const pessoaRelacionada = await prisma.pessoaRelacionada.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PessoaRelacionadaUpdateArgs>(args: SelectSubset<T, PessoaRelacionadaUpdateArgs<ExtArgs>>): Prisma__PessoaRelacionadaClient<$Result.GetResult<Prisma.$PessoaRelacionadaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PessoaRelacionadas.
     * @param {PessoaRelacionadaDeleteManyArgs} args - Arguments to filter PessoaRelacionadas to delete.
     * @example
     * // Delete a few PessoaRelacionadas
     * const { count } = await prisma.pessoaRelacionada.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PessoaRelacionadaDeleteManyArgs>(args?: SelectSubset<T, PessoaRelacionadaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PessoaRelacionadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaRelacionadaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PessoaRelacionadas
     * const pessoaRelacionada = await prisma.pessoaRelacionada.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PessoaRelacionadaUpdateManyArgs>(args: SelectSubset<T, PessoaRelacionadaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PessoaRelacionadas and returns the data updated in the database.
     * @param {PessoaRelacionadaUpdateManyAndReturnArgs} args - Arguments to update many PessoaRelacionadas.
     * @example
     * // Update many PessoaRelacionadas
     * const pessoaRelacionada = await prisma.pessoaRelacionada.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PessoaRelacionadas and only return the `id`
     * const pessoaRelacionadaWithIdOnly = await prisma.pessoaRelacionada.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PessoaRelacionadaUpdateManyAndReturnArgs>(args: SelectSubset<T, PessoaRelacionadaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PessoaRelacionadaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PessoaRelacionada.
     * @param {PessoaRelacionadaUpsertArgs} args - Arguments to update or create a PessoaRelacionada.
     * @example
     * // Update or create a PessoaRelacionada
     * const pessoaRelacionada = await prisma.pessoaRelacionada.upsert({
     *   create: {
     *     // ... data to create a PessoaRelacionada
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PessoaRelacionada we want to update
     *   }
     * })
     */
    upsert<T extends PessoaRelacionadaUpsertArgs>(args: SelectSubset<T, PessoaRelacionadaUpsertArgs<ExtArgs>>): Prisma__PessoaRelacionadaClient<$Result.GetResult<Prisma.$PessoaRelacionadaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PessoaRelacionadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaRelacionadaCountArgs} args - Arguments to filter PessoaRelacionadas to count.
     * @example
     * // Count the number of PessoaRelacionadas
     * const count = await prisma.pessoaRelacionada.count({
     *   where: {
     *     // ... the filter for the PessoaRelacionadas we want to count
     *   }
     * })
    **/
    count<T extends PessoaRelacionadaCountArgs>(
      args?: Subset<T, PessoaRelacionadaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaRelacionadaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PessoaRelacionada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaRelacionadaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaRelacionadaAggregateArgs>(args: Subset<T, PessoaRelacionadaAggregateArgs>): Prisma.PrismaPromise<GetPessoaRelacionadaAggregateType<T>>

    /**
     * Group by PessoaRelacionada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaRelacionadaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PessoaRelacionadaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PessoaRelacionadaGroupByArgs['orderBy'] }
        : { orderBy?: PessoaRelacionadaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PessoaRelacionadaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaRelacionadaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PessoaRelacionada model
   */
  readonly fields: PessoaRelacionadaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PessoaRelacionada.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PessoaRelacionadaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enderecos<T extends PessoaRelacionada$enderecosArgs<ExtArgs> = {}>(args?: Subset<T, PessoaRelacionada$enderecosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parentescos<T extends PessoaRelacionada$parentescosArgs<ExtArgs> = {}>(args?: Subset<T, PessoaRelacionada$parentescosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentescoPacientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PessoaRelacionada model
   */
  interface PessoaRelacionadaFieldRefs {
    readonly id: FieldRef<"PessoaRelacionada", 'Int'>
    readonly nome: FieldRef<"PessoaRelacionada", 'String'>
    readonly telefone: FieldRef<"PessoaRelacionada", 'String'>
    readonly stInativo: FieldRef<"PessoaRelacionada", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * PessoaRelacionada findUnique
   */
  export type PessoaRelacionadaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaRelacionada
     */
    select?: PessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PessoaRelacionada
     */
    omit?: PessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaRelacionadaInclude<ExtArgs> | null
    /**
     * Filter, which PessoaRelacionada to fetch.
     */
    where: PessoaRelacionadaWhereUniqueInput
  }

  /**
   * PessoaRelacionada findUniqueOrThrow
   */
  export type PessoaRelacionadaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaRelacionada
     */
    select?: PessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PessoaRelacionada
     */
    omit?: PessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaRelacionadaInclude<ExtArgs> | null
    /**
     * Filter, which PessoaRelacionada to fetch.
     */
    where: PessoaRelacionadaWhereUniqueInput
  }

  /**
   * PessoaRelacionada findFirst
   */
  export type PessoaRelacionadaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaRelacionada
     */
    select?: PessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PessoaRelacionada
     */
    omit?: PessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaRelacionadaInclude<ExtArgs> | null
    /**
     * Filter, which PessoaRelacionada to fetch.
     */
    where?: PessoaRelacionadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PessoaRelacionadas to fetch.
     */
    orderBy?: PessoaRelacionadaOrderByWithRelationInput | PessoaRelacionadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PessoaRelacionadas.
     */
    cursor?: PessoaRelacionadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PessoaRelacionadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PessoaRelacionadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PessoaRelacionadas.
     */
    distinct?: PessoaRelacionadaScalarFieldEnum | PessoaRelacionadaScalarFieldEnum[]
  }

  /**
   * PessoaRelacionada findFirstOrThrow
   */
  export type PessoaRelacionadaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaRelacionada
     */
    select?: PessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PessoaRelacionada
     */
    omit?: PessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaRelacionadaInclude<ExtArgs> | null
    /**
     * Filter, which PessoaRelacionada to fetch.
     */
    where?: PessoaRelacionadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PessoaRelacionadas to fetch.
     */
    orderBy?: PessoaRelacionadaOrderByWithRelationInput | PessoaRelacionadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PessoaRelacionadas.
     */
    cursor?: PessoaRelacionadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PessoaRelacionadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PessoaRelacionadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PessoaRelacionadas.
     */
    distinct?: PessoaRelacionadaScalarFieldEnum | PessoaRelacionadaScalarFieldEnum[]
  }

  /**
   * PessoaRelacionada findMany
   */
  export type PessoaRelacionadaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaRelacionada
     */
    select?: PessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PessoaRelacionada
     */
    omit?: PessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaRelacionadaInclude<ExtArgs> | null
    /**
     * Filter, which PessoaRelacionadas to fetch.
     */
    where?: PessoaRelacionadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PessoaRelacionadas to fetch.
     */
    orderBy?: PessoaRelacionadaOrderByWithRelationInput | PessoaRelacionadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PessoaRelacionadas.
     */
    cursor?: PessoaRelacionadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PessoaRelacionadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PessoaRelacionadas.
     */
    skip?: number
    distinct?: PessoaRelacionadaScalarFieldEnum | PessoaRelacionadaScalarFieldEnum[]
  }

  /**
   * PessoaRelacionada create
   */
  export type PessoaRelacionadaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaRelacionada
     */
    select?: PessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PessoaRelacionada
     */
    omit?: PessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaRelacionadaInclude<ExtArgs> | null
    /**
     * The data needed to create a PessoaRelacionada.
     */
    data: XOR<PessoaRelacionadaCreateInput, PessoaRelacionadaUncheckedCreateInput>
  }

  /**
   * PessoaRelacionada createMany
   */
  export type PessoaRelacionadaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PessoaRelacionadas.
     */
    data: PessoaRelacionadaCreateManyInput | PessoaRelacionadaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PessoaRelacionada createManyAndReturn
   */
  export type PessoaRelacionadaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaRelacionada
     */
    select?: PessoaRelacionadaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PessoaRelacionada
     */
    omit?: PessoaRelacionadaOmit<ExtArgs> | null
    /**
     * The data used to create many PessoaRelacionadas.
     */
    data: PessoaRelacionadaCreateManyInput | PessoaRelacionadaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PessoaRelacionada update
   */
  export type PessoaRelacionadaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaRelacionada
     */
    select?: PessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PessoaRelacionada
     */
    omit?: PessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaRelacionadaInclude<ExtArgs> | null
    /**
     * The data needed to update a PessoaRelacionada.
     */
    data: XOR<PessoaRelacionadaUpdateInput, PessoaRelacionadaUncheckedUpdateInput>
    /**
     * Choose, which PessoaRelacionada to update.
     */
    where: PessoaRelacionadaWhereUniqueInput
  }

  /**
   * PessoaRelacionada updateMany
   */
  export type PessoaRelacionadaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PessoaRelacionadas.
     */
    data: XOR<PessoaRelacionadaUpdateManyMutationInput, PessoaRelacionadaUncheckedUpdateManyInput>
    /**
     * Filter which PessoaRelacionadas to update
     */
    where?: PessoaRelacionadaWhereInput
    /**
     * Limit how many PessoaRelacionadas to update.
     */
    limit?: number
  }

  /**
   * PessoaRelacionada updateManyAndReturn
   */
  export type PessoaRelacionadaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaRelacionada
     */
    select?: PessoaRelacionadaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PessoaRelacionada
     */
    omit?: PessoaRelacionadaOmit<ExtArgs> | null
    /**
     * The data used to update PessoaRelacionadas.
     */
    data: XOR<PessoaRelacionadaUpdateManyMutationInput, PessoaRelacionadaUncheckedUpdateManyInput>
    /**
     * Filter which PessoaRelacionadas to update
     */
    where?: PessoaRelacionadaWhereInput
    /**
     * Limit how many PessoaRelacionadas to update.
     */
    limit?: number
  }

  /**
   * PessoaRelacionada upsert
   */
  export type PessoaRelacionadaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaRelacionada
     */
    select?: PessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PessoaRelacionada
     */
    omit?: PessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaRelacionadaInclude<ExtArgs> | null
    /**
     * The filter to search for the PessoaRelacionada to update in case it exists.
     */
    where: PessoaRelacionadaWhereUniqueInput
    /**
     * In case the PessoaRelacionada found by the `where` argument doesn't exist, create a new PessoaRelacionada with this data.
     */
    create: XOR<PessoaRelacionadaCreateInput, PessoaRelacionadaUncheckedCreateInput>
    /**
     * In case the PessoaRelacionada was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PessoaRelacionadaUpdateInput, PessoaRelacionadaUncheckedUpdateInput>
  }

  /**
   * PessoaRelacionada delete
   */
  export type PessoaRelacionadaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaRelacionada
     */
    select?: PessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PessoaRelacionada
     */
    omit?: PessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaRelacionadaInclude<ExtArgs> | null
    /**
     * Filter which PessoaRelacionada to delete.
     */
    where: PessoaRelacionadaWhereUniqueInput
  }

  /**
   * PessoaRelacionada deleteMany
   */
  export type PessoaRelacionadaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PessoaRelacionadas to delete
     */
    where?: PessoaRelacionadaWhereInput
    /**
     * Limit how many PessoaRelacionadas to delete.
     */
    limit?: number
  }

  /**
   * PessoaRelacionada.enderecos
   */
  export type PessoaRelacionada$enderecosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPessoaRelacionada
     */
    select?: EnderecoPessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPessoaRelacionada
     */
    omit?: EnderecoPessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPessoaRelacionadaInclude<ExtArgs> | null
    where?: EnderecoPessoaRelacionadaWhereInput
    orderBy?: EnderecoPessoaRelacionadaOrderByWithRelationInput | EnderecoPessoaRelacionadaOrderByWithRelationInput[]
    cursor?: EnderecoPessoaRelacionadaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnderecoPessoaRelacionadaScalarFieldEnum | EnderecoPessoaRelacionadaScalarFieldEnum[]
  }

  /**
   * PessoaRelacionada.parentescos
   */
  export type PessoaRelacionada$parentescosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentescoPaciente
     */
    select?: ParentescoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentescoPaciente
     */
    omit?: ParentescoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentescoPacienteInclude<ExtArgs> | null
    where?: ParentescoPacienteWhereInput
    orderBy?: ParentescoPacienteOrderByWithRelationInput | ParentescoPacienteOrderByWithRelationInput[]
    cursor?: ParentescoPacienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentescoPacienteScalarFieldEnum | ParentescoPacienteScalarFieldEnum[]
  }

  /**
   * PessoaRelacionada without action
   */
  export type PessoaRelacionadaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaRelacionada
     */
    select?: PessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PessoaRelacionada
     */
    omit?: PessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaRelacionadaInclude<ExtArgs> | null
  }


  /**
   * Model ParentescoPaciente
   */

  export type AggregateParentescoPaciente = {
    _count: ParentescoPacienteCountAggregateOutputType | null
    _avg: ParentescoPacienteAvgAggregateOutputType | null
    _sum: ParentescoPacienteSumAggregateOutputType | null
    _min: ParentescoPacienteMinAggregateOutputType | null
    _max: ParentescoPacienteMaxAggregateOutputType | null
  }

  export type ParentescoPacienteAvgAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdPessoa: number | null
  }

  export type ParentescoPacienteSumAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdPessoa: number | null
  }

  export type ParentescoPacienteMinAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdPessoa: number | null
    parentesco: $Enums.TipoParentesco | null
  }

  export type ParentescoPacienteMaxAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdPaciente: number | null
    cdPessoa: number | null
    parentesco: $Enums.TipoParentesco | null
  }

  export type ParentescoPacienteCountAggregateOutputType = {
    id: number
    cdMaster: number
    cdPaciente: number
    cdPessoa: number
    parentesco: number
    _all: number
  }


  export type ParentescoPacienteAvgAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdPessoa?: true
  }

  export type ParentescoPacienteSumAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdPessoa?: true
  }

  export type ParentescoPacienteMinAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdPessoa?: true
    parentesco?: true
  }

  export type ParentescoPacienteMaxAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdPessoa?: true
    parentesco?: true
  }

  export type ParentescoPacienteCountAggregateInputType = {
    id?: true
    cdMaster?: true
    cdPaciente?: true
    cdPessoa?: true
    parentesco?: true
    _all?: true
  }

  export type ParentescoPacienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParentescoPaciente to aggregate.
     */
    where?: ParentescoPacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentescoPacientes to fetch.
     */
    orderBy?: ParentescoPacienteOrderByWithRelationInput | ParentescoPacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentescoPacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentescoPacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentescoPacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParentescoPacientes
    **/
    _count?: true | ParentescoPacienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParentescoPacienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParentescoPacienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentescoPacienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentescoPacienteMaxAggregateInputType
  }

  export type GetParentescoPacienteAggregateType<T extends ParentescoPacienteAggregateArgs> = {
        [P in keyof T & keyof AggregateParentescoPaciente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParentescoPaciente[P]>
      : GetScalarType<T[P], AggregateParentescoPaciente[P]>
  }




  export type ParentescoPacienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentescoPacienteWhereInput
    orderBy?: ParentescoPacienteOrderByWithAggregationInput | ParentescoPacienteOrderByWithAggregationInput[]
    by: ParentescoPacienteScalarFieldEnum[] | ParentescoPacienteScalarFieldEnum
    having?: ParentescoPacienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentescoPacienteCountAggregateInputType | true
    _avg?: ParentescoPacienteAvgAggregateInputType
    _sum?: ParentescoPacienteSumAggregateInputType
    _min?: ParentescoPacienteMinAggregateInputType
    _max?: ParentescoPacienteMaxAggregateInputType
  }

  export type ParentescoPacienteGroupByOutputType = {
    id: number
    cdMaster: number
    cdPaciente: number
    cdPessoa: number
    parentesco: $Enums.TipoParentesco
    _count: ParentescoPacienteCountAggregateOutputType | null
    _avg: ParentescoPacienteAvgAggregateOutputType | null
    _sum: ParentescoPacienteSumAggregateOutputType | null
    _min: ParentescoPacienteMinAggregateOutputType | null
    _max: ParentescoPacienteMaxAggregateOutputType | null
  }

  type GetParentescoPacienteGroupByPayload<T extends ParentescoPacienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentescoPacienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentescoPacienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentescoPacienteGroupByOutputType[P]>
            : GetScalarType<T[P], ParentescoPacienteGroupByOutputType[P]>
        }
      >
    >


  export type ParentescoPacienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdPessoa?: boolean
    parentesco?: boolean
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
    pessoaRelacionada?: boolean | PessoaRelacionadaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parentescoPaciente"]>

  export type ParentescoPacienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdPessoa?: boolean
    parentesco?: boolean
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
    pessoaRelacionada?: boolean | PessoaRelacionadaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parentescoPaciente"]>

  export type ParentescoPacienteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdPessoa?: boolean
    parentesco?: boolean
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
    pessoaRelacionada?: boolean | PessoaRelacionadaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parentescoPaciente"]>

  export type ParentescoPacienteSelectScalar = {
    id?: boolean
    cdMaster?: boolean
    cdPaciente?: boolean
    cdPessoa?: boolean
    parentesco?: boolean
  }

  export type ParentescoPacienteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdMaster" | "cdPaciente" | "cdPessoa" | "parentesco", ExtArgs["result"]["parentescoPaciente"]>
  export type ParentescoPacienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
    pessoaRelacionada?: boolean | PessoaRelacionadaDefaultArgs<ExtArgs>
  }
  export type ParentescoPacienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
    pessoaRelacionada?: boolean | PessoaRelacionadaDefaultArgs<ExtArgs>
  }
  export type ParentescoPacienteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | PacienteDefaultArgs<ExtArgs>
    pessoaRelacionada?: boolean | PessoaRelacionadaDefaultArgs<ExtArgs>
  }

  export type $ParentescoPacientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParentescoPaciente"
    objects: {
      paciente: Prisma.$PacientePayload<ExtArgs>
      pessoaRelacionada: Prisma.$PessoaRelacionadaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdMaster: number
      cdPaciente: number
      cdPessoa: number
      parentesco: $Enums.TipoParentesco
    }, ExtArgs["result"]["parentescoPaciente"]>
    composites: {}
  }

  type ParentescoPacienteGetPayload<S extends boolean | null | undefined | ParentescoPacienteDefaultArgs> = $Result.GetResult<Prisma.$ParentescoPacientePayload, S>

  type ParentescoPacienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParentescoPacienteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParentescoPacienteCountAggregateInputType | true
    }

  export interface ParentescoPacienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParentescoPaciente'], meta: { name: 'ParentescoPaciente' } }
    /**
     * Find zero or one ParentescoPaciente that matches the filter.
     * @param {ParentescoPacienteFindUniqueArgs} args - Arguments to find a ParentescoPaciente
     * @example
     * // Get one ParentescoPaciente
     * const parentescoPaciente = await prisma.parentescoPaciente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentescoPacienteFindUniqueArgs>(args: SelectSubset<T, ParentescoPacienteFindUniqueArgs<ExtArgs>>): Prisma__ParentescoPacienteClient<$Result.GetResult<Prisma.$ParentescoPacientePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParentescoPaciente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParentescoPacienteFindUniqueOrThrowArgs} args - Arguments to find a ParentescoPaciente
     * @example
     * // Get one ParentescoPaciente
     * const parentescoPaciente = await prisma.parentescoPaciente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentescoPacienteFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentescoPacienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentescoPacienteClient<$Result.GetResult<Prisma.$ParentescoPacientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParentescoPaciente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentescoPacienteFindFirstArgs} args - Arguments to find a ParentescoPaciente
     * @example
     * // Get one ParentescoPaciente
     * const parentescoPaciente = await prisma.parentescoPaciente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentescoPacienteFindFirstArgs>(args?: SelectSubset<T, ParentescoPacienteFindFirstArgs<ExtArgs>>): Prisma__ParentescoPacienteClient<$Result.GetResult<Prisma.$ParentescoPacientePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParentescoPaciente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentescoPacienteFindFirstOrThrowArgs} args - Arguments to find a ParentescoPaciente
     * @example
     * // Get one ParentescoPaciente
     * const parentescoPaciente = await prisma.parentescoPaciente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentescoPacienteFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentescoPacienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentescoPacienteClient<$Result.GetResult<Prisma.$ParentescoPacientePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParentescoPacientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentescoPacienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParentescoPacientes
     * const parentescoPacientes = await prisma.parentescoPaciente.findMany()
     * 
     * // Get first 10 ParentescoPacientes
     * const parentescoPacientes = await prisma.parentescoPaciente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentescoPacienteWithIdOnly = await prisma.parentescoPaciente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentescoPacienteFindManyArgs>(args?: SelectSubset<T, ParentescoPacienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentescoPacientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParentescoPaciente.
     * @param {ParentescoPacienteCreateArgs} args - Arguments to create a ParentescoPaciente.
     * @example
     * // Create one ParentescoPaciente
     * const ParentescoPaciente = await prisma.parentescoPaciente.create({
     *   data: {
     *     // ... data to create a ParentescoPaciente
     *   }
     * })
     * 
     */
    create<T extends ParentescoPacienteCreateArgs>(args: SelectSubset<T, ParentescoPacienteCreateArgs<ExtArgs>>): Prisma__ParentescoPacienteClient<$Result.GetResult<Prisma.$ParentescoPacientePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParentescoPacientes.
     * @param {ParentescoPacienteCreateManyArgs} args - Arguments to create many ParentescoPacientes.
     * @example
     * // Create many ParentescoPacientes
     * const parentescoPaciente = await prisma.parentescoPaciente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentescoPacienteCreateManyArgs>(args?: SelectSubset<T, ParentescoPacienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParentescoPacientes and returns the data saved in the database.
     * @param {ParentescoPacienteCreateManyAndReturnArgs} args - Arguments to create many ParentescoPacientes.
     * @example
     * // Create many ParentescoPacientes
     * const parentescoPaciente = await prisma.parentescoPaciente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParentescoPacientes and only return the `id`
     * const parentescoPacienteWithIdOnly = await prisma.parentescoPaciente.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParentescoPacienteCreateManyAndReturnArgs>(args?: SelectSubset<T, ParentescoPacienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentescoPacientePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParentescoPaciente.
     * @param {ParentescoPacienteDeleteArgs} args - Arguments to delete one ParentescoPaciente.
     * @example
     * // Delete one ParentescoPaciente
     * const ParentescoPaciente = await prisma.parentescoPaciente.delete({
     *   where: {
     *     // ... filter to delete one ParentescoPaciente
     *   }
     * })
     * 
     */
    delete<T extends ParentescoPacienteDeleteArgs>(args: SelectSubset<T, ParentescoPacienteDeleteArgs<ExtArgs>>): Prisma__ParentescoPacienteClient<$Result.GetResult<Prisma.$ParentescoPacientePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParentescoPaciente.
     * @param {ParentescoPacienteUpdateArgs} args - Arguments to update one ParentescoPaciente.
     * @example
     * // Update one ParentescoPaciente
     * const parentescoPaciente = await prisma.parentescoPaciente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentescoPacienteUpdateArgs>(args: SelectSubset<T, ParentescoPacienteUpdateArgs<ExtArgs>>): Prisma__ParentescoPacienteClient<$Result.GetResult<Prisma.$ParentescoPacientePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParentescoPacientes.
     * @param {ParentescoPacienteDeleteManyArgs} args - Arguments to filter ParentescoPacientes to delete.
     * @example
     * // Delete a few ParentescoPacientes
     * const { count } = await prisma.parentescoPaciente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentescoPacienteDeleteManyArgs>(args?: SelectSubset<T, ParentescoPacienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParentescoPacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentescoPacienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParentescoPacientes
     * const parentescoPaciente = await prisma.parentescoPaciente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentescoPacienteUpdateManyArgs>(args: SelectSubset<T, ParentescoPacienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParentescoPacientes and returns the data updated in the database.
     * @param {ParentescoPacienteUpdateManyAndReturnArgs} args - Arguments to update many ParentescoPacientes.
     * @example
     * // Update many ParentescoPacientes
     * const parentescoPaciente = await prisma.parentescoPaciente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParentescoPacientes and only return the `id`
     * const parentescoPacienteWithIdOnly = await prisma.parentescoPaciente.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParentescoPacienteUpdateManyAndReturnArgs>(args: SelectSubset<T, ParentescoPacienteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentescoPacientePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParentescoPaciente.
     * @param {ParentescoPacienteUpsertArgs} args - Arguments to update or create a ParentescoPaciente.
     * @example
     * // Update or create a ParentescoPaciente
     * const parentescoPaciente = await prisma.parentescoPaciente.upsert({
     *   create: {
     *     // ... data to create a ParentescoPaciente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParentescoPaciente we want to update
     *   }
     * })
     */
    upsert<T extends ParentescoPacienteUpsertArgs>(args: SelectSubset<T, ParentescoPacienteUpsertArgs<ExtArgs>>): Prisma__ParentescoPacienteClient<$Result.GetResult<Prisma.$ParentescoPacientePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParentescoPacientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentescoPacienteCountArgs} args - Arguments to filter ParentescoPacientes to count.
     * @example
     * // Count the number of ParentescoPacientes
     * const count = await prisma.parentescoPaciente.count({
     *   where: {
     *     // ... the filter for the ParentescoPacientes we want to count
     *   }
     * })
    **/
    count<T extends ParentescoPacienteCountArgs>(
      args?: Subset<T, ParentescoPacienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentescoPacienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParentescoPaciente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentescoPacienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentescoPacienteAggregateArgs>(args: Subset<T, ParentescoPacienteAggregateArgs>): Prisma.PrismaPromise<GetParentescoPacienteAggregateType<T>>

    /**
     * Group by ParentescoPaciente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentescoPacienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentescoPacienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentescoPacienteGroupByArgs['orderBy'] }
        : { orderBy?: ParentescoPacienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentescoPacienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentescoPacienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParentescoPaciente model
   */
  readonly fields: ParentescoPacienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParentescoPaciente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentescoPacienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paciente<T extends PacienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PacienteDefaultArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pessoaRelacionada<T extends PessoaRelacionadaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PessoaRelacionadaDefaultArgs<ExtArgs>>): Prisma__PessoaRelacionadaClient<$Result.GetResult<Prisma.$PessoaRelacionadaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParentescoPaciente model
   */
  interface ParentescoPacienteFieldRefs {
    readonly id: FieldRef<"ParentescoPaciente", 'Int'>
    readonly cdMaster: FieldRef<"ParentescoPaciente", 'Int'>
    readonly cdPaciente: FieldRef<"ParentescoPaciente", 'Int'>
    readonly cdPessoa: FieldRef<"ParentescoPaciente", 'Int'>
    readonly parentesco: FieldRef<"ParentescoPaciente", 'TipoParentesco'>
  }
    

  // Custom InputTypes
  /**
   * ParentescoPaciente findUnique
   */
  export type ParentescoPacienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentescoPaciente
     */
    select?: ParentescoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentescoPaciente
     */
    omit?: ParentescoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentescoPacienteInclude<ExtArgs> | null
    /**
     * Filter, which ParentescoPaciente to fetch.
     */
    where: ParentescoPacienteWhereUniqueInput
  }

  /**
   * ParentescoPaciente findUniqueOrThrow
   */
  export type ParentescoPacienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentescoPaciente
     */
    select?: ParentescoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentescoPaciente
     */
    omit?: ParentescoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentescoPacienteInclude<ExtArgs> | null
    /**
     * Filter, which ParentescoPaciente to fetch.
     */
    where: ParentescoPacienteWhereUniqueInput
  }

  /**
   * ParentescoPaciente findFirst
   */
  export type ParentescoPacienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentescoPaciente
     */
    select?: ParentescoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentescoPaciente
     */
    omit?: ParentescoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentescoPacienteInclude<ExtArgs> | null
    /**
     * Filter, which ParentescoPaciente to fetch.
     */
    where?: ParentescoPacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentescoPacientes to fetch.
     */
    orderBy?: ParentescoPacienteOrderByWithRelationInput | ParentescoPacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParentescoPacientes.
     */
    cursor?: ParentescoPacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentescoPacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentescoPacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParentescoPacientes.
     */
    distinct?: ParentescoPacienteScalarFieldEnum | ParentescoPacienteScalarFieldEnum[]
  }

  /**
   * ParentescoPaciente findFirstOrThrow
   */
  export type ParentescoPacienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentescoPaciente
     */
    select?: ParentescoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentescoPaciente
     */
    omit?: ParentescoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentescoPacienteInclude<ExtArgs> | null
    /**
     * Filter, which ParentescoPaciente to fetch.
     */
    where?: ParentescoPacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentescoPacientes to fetch.
     */
    orderBy?: ParentescoPacienteOrderByWithRelationInput | ParentescoPacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParentescoPacientes.
     */
    cursor?: ParentescoPacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentescoPacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentescoPacientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParentescoPacientes.
     */
    distinct?: ParentescoPacienteScalarFieldEnum | ParentescoPacienteScalarFieldEnum[]
  }

  /**
   * ParentescoPaciente findMany
   */
  export type ParentescoPacienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentescoPaciente
     */
    select?: ParentescoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentescoPaciente
     */
    omit?: ParentescoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentescoPacienteInclude<ExtArgs> | null
    /**
     * Filter, which ParentescoPacientes to fetch.
     */
    where?: ParentescoPacienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentescoPacientes to fetch.
     */
    orderBy?: ParentescoPacienteOrderByWithRelationInput | ParentescoPacienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParentescoPacientes.
     */
    cursor?: ParentescoPacienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentescoPacientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentescoPacientes.
     */
    skip?: number
    distinct?: ParentescoPacienteScalarFieldEnum | ParentescoPacienteScalarFieldEnum[]
  }

  /**
   * ParentescoPaciente create
   */
  export type ParentescoPacienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentescoPaciente
     */
    select?: ParentescoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentescoPaciente
     */
    omit?: ParentescoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentescoPacienteInclude<ExtArgs> | null
    /**
     * The data needed to create a ParentescoPaciente.
     */
    data: XOR<ParentescoPacienteCreateInput, ParentescoPacienteUncheckedCreateInput>
  }

  /**
   * ParentescoPaciente createMany
   */
  export type ParentescoPacienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParentescoPacientes.
     */
    data: ParentescoPacienteCreateManyInput | ParentescoPacienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParentescoPaciente createManyAndReturn
   */
  export type ParentescoPacienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentescoPaciente
     */
    select?: ParentescoPacienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParentescoPaciente
     */
    omit?: ParentescoPacienteOmit<ExtArgs> | null
    /**
     * The data used to create many ParentescoPacientes.
     */
    data: ParentescoPacienteCreateManyInput | ParentescoPacienteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentescoPacienteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParentescoPaciente update
   */
  export type ParentescoPacienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentescoPaciente
     */
    select?: ParentescoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentescoPaciente
     */
    omit?: ParentescoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentescoPacienteInclude<ExtArgs> | null
    /**
     * The data needed to update a ParentescoPaciente.
     */
    data: XOR<ParentescoPacienteUpdateInput, ParentescoPacienteUncheckedUpdateInput>
    /**
     * Choose, which ParentescoPaciente to update.
     */
    where: ParentescoPacienteWhereUniqueInput
  }

  /**
   * ParentescoPaciente updateMany
   */
  export type ParentescoPacienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParentescoPacientes.
     */
    data: XOR<ParentescoPacienteUpdateManyMutationInput, ParentescoPacienteUncheckedUpdateManyInput>
    /**
     * Filter which ParentescoPacientes to update
     */
    where?: ParentescoPacienteWhereInput
    /**
     * Limit how many ParentescoPacientes to update.
     */
    limit?: number
  }

  /**
   * ParentescoPaciente updateManyAndReturn
   */
  export type ParentescoPacienteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentescoPaciente
     */
    select?: ParentescoPacienteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParentescoPaciente
     */
    omit?: ParentescoPacienteOmit<ExtArgs> | null
    /**
     * The data used to update ParentescoPacientes.
     */
    data: XOR<ParentescoPacienteUpdateManyMutationInput, ParentescoPacienteUncheckedUpdateManyInput>
    /**
     * Filter which ParentescoPacientes to update
     */
    where?: ParentescoPacienteWhereInput
    /**
     * Limit how many ParentescoPacientes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentescoPacienteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParentescoPaciente upsert
   */
  export type ParentescoPacienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentescoPaciente
     */
    select?: ParentescoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentescoPaciente
     */
    omit?: ParentescoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentescoPacienteInclude<ExtArgs> | null
    /**
     * The filter to search for the ParentescoPaciente to update in case it exists.
     */
    where: ParentescoPacienteWhereUniqueInput
    /**
     * In case the ParentescoPaciente found by the `where` argument doesn't exist, create a new ParentescoPaciente with this data.
     */
    create: XOR<ParentescoPacienteCreateInput, ParentescoPacienteUncheckedCreateInput>
    /**
     * In case the ParentescoPaciente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentescoPacienteUpdateInput, ParentescoPacienteUncheckedUpdateInput>
  }

  /**
   * ParentescoPaciente delete
   */
  export type ParentescoPacienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentescoPaciente
     */
    select?: ParentescoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentescoPaciente
     */
    omit?: ParentescoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentescoPacienteInclude<ExtArgs> | null
    /**
     * Filter which ParentescoPaciente to delete.
     */
    where: ParentescoPacienteWhereUniqueInput
  }

  /**
   * ParentescoPaciente deleteMany
   */
  export type ParentescoPacienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParentescoPacientes to delete
     */
    where?: ParentescoPacienteWhereInput
    /**
     * Limit how many ParentescoPacientes to delete.
     */
    limit?: number
  }

  /**
   * ParentescoPaciente without action
   */
  export type ParentescoPacienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentescoPaciente
     */
    select?: ParentescoPacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParentescoPaciente
     */
    omit?: ParentescoPacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentescoPacienteInclude<ExtArgs> | null
  }


  /**
   * Model Plano
   */

  export type AggregatePlano = {
    _count: PlanoCountAggregateOutputType | null
    _avg: PlanoAvgAggregateOutputType | null
    _sum: PlanoSumAggregateOutputType | null
    _min: PlanoMinAggregateOutputType | null
    _max: PlanoMaxAggregateOutputType | null
  }

  export type PlanoAvgAggregateOutputType = {
    id: number | null
  }

  export type PlanoSumAggregateOutputType = {
    id: number | null
  }

  export type PlanoMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type PlanoMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type PlanoCountAggregateOutputType = {
    id: number
    descricao: number
    stInativo: number
    _all: number
  }


  export type PlanoAvgAggregateInputType = {
    id?: true
  }

  export type PlanoSumAggregateInputType = {
    id?: true
  }

  export type PlanoMinAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
  }

  export type PlanoMaxAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
  }

  export type PlanoCountAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
    _all?: true
  }

  export type PlanoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plano to aggregate.
     */
    where?: PlanoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Planos to fetch.
     */
    orderBy?: PlanoOrderByWithRelationInput | PlanoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Planos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Planos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Planos
    **/
    _count?: true | PlanoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanoMaxAggregateInputType
  }

  export type GetPlanoAggregateType<T extends PlanoAggregateArgs> = {
        [P in keyof T & keyof AggregatePlano]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlano[P]>
      : GetScalarType<T[P], AggregatePlano[P]>
  }




  export type PlanoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanoWhereInput
    orderBy?: PlanoOrderByWithAggregationInput | PlanoOrderByWithAggregationInput[]
    by: PlanoScalarFieldEnum[] | PlanoScalarFieldEnum
    having?: PlanoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanoCountAggregateInputType | true
    _avg?: PlanoAvgAggregateInputType
    _sum?: PlanoSumAggregateInputType
    _min?: PlanoMinAggregateInputType
    _max?: PlanoMaxAggregateInputType
  }

  export type PlanoGroupByOutputType = {
    id: number
    descricao: string
    stInativo: $Enums.SimNao | null
    _count: PlanoCountAggregateOutputType | null
    _avg: PlanoAvgAggregateOutputType | null
    _sum: PlanoSumAggregateOutputType | null
    _min: PlanoMinAggregateOutputType | null
    _max: PlanoMaxAggregateOutputType | null
  }

  type GetPlanoGroupByPayload<T extends PlanoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanoGroupByOutputType[P]>
            : GetScalarType<T[P], PlanoGroupByOutputType[P]>
        }
      >
    >


  export type PlanoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["plano"]>

  export type PlanoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["plano"]>

  export type PlanoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["plano"]>

  export type PlanoSelectScalar = {
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }

  export type PlanoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "stInativo", ExtArgs["result"]["plano"]>

  export type $PlanoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plano"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["plano"]>
    composites: {}
  }

  type PlanoGetPayload<S extends boolean | null | undefined | PlanoDefaultArgs> = $Result.GetResult<Prisma.$PlanoPayload, S>

  type PlanoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanoCountAggregateInputType | true
    }

  export interface PlanoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plano'], meta: { name: 'Plano' } }
    /**
     * Find zero or one Plano that matches the filter.
     * @param {PlanoFindUniqueArgs} args - Arguments to find a Plano
     * @example
     * // Get one Plano
     * const plano = await prisma.plano.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanoFindUniqueArgs>(args: SelectSubset<T, PlanoFindUniqueArgs<ExtArgs>>): Prisma__PlanoClient<$Result.GetResult<Prisma.$PlanoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plano that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanoFindUniqueOrThrowArgs} args - Arguments to find a Plano
     * @example
     * // Get one Plano
     * const plano = await prisma.plano.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanoFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanoClient<$Result.GetResult<Prisma.$PlanoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plano that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanoFindFirstArgs} args - Arguments to find a Plano
     * @example
     * // Get one Plano
     * const plano = await prisma.plano.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanoFindFirstArgs>(args?: SelectSubset<T, PlanoFindFirstArgs<ExtArgs>>): Prisma__PlanoClient<$Result.GetResult<Prisma.$PlanoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plano that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanoFindFirstOrThrowArgs} args - Arguments to find a Plano
     * @example
     * // Get one Plano
     * const plano = await prisma.plano.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanoFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanoClient<$Result.GetResult<Prisma.$PlanoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Planos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Planos
     * const planos = await prisma.plano.findMany()
     * 
     * // Get first 10 Planos
     * const planos = await prisma.plano.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planoWithIdOnly = await prisma.plano.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanoFindManyArgs>(args?: SelectSubset<T, PlanoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plano.
     * @param {PlanoCreateArgs} args - Arguments to create a Plano.
     * @example
     * // Create one Plano
     * const Plano = await prisma.plano.create({
     *   data: {
     *     // ... data to create a Plano
     *   }
     * })
     * 
     */
    create<T extends PlanoCreateArgs>(args: SelectSubset<T, PlanoCreateArgs<ExtArgs>>): Prisma__PlanoClient<$Result.GetResult<Prisma.$PlanoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Planos.
     * @param {PlanoCreateManyArgs} args - Arguments to create many Planos.
     * @example
     * // Create many Planos
     * const plano = await prisma.plano.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanoCreateManyArgs>(args?: SelectSubset<T, PlanoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Planos and returns the data saved in the database.
     * @param {PlanoCreateManyAndReturnArgs} args - Arguments to create many Planos.
     * @example
     * // Create many Planos
     * const plano = await prisma.plano.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Planos and only return the `id`
     * const planoWithIdOnly = await prisma.plano.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanoCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plano.
     * @param {PlanoDeleteArgs} args - Arguments to delete one Plano.
     * @example
     * // Delete one Plano
     * const Plano = await prisma.plano.delete({
     *   where: {
     *     // ... filter to delete one Plano
     *   }
     * })
     * 
     */
    delete<T extends PlanoDeleteArgs>(args: SelectSubset<T, PlanoDeleteArgs<ExtArgs>>): Prisma__PlanoClient<$Result.GetResult<Prisma.$PlanoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plano.
     * @param {PlanoUpdateArgs} args - Arguments to update one Plano.
     * @example
     * // Update one Plano
     * const plano = await prisma.plano.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanoUpdateArgs>(args: SelectSubset<T, PlanoUpdateArgs<ExtArgs>>): Prisma__PlanoClient<$Result.GetResult<Prisma.$PlanoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Planos.
     * @param {PlanoDeleteManyArgs} args - Arguments to filter Planos to delete.
     * @example
     * // Delete a few Planos
     * const { count } = await prisma.plano.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanoDeleteManyArgs>(args?: SelectSubset<T, PlanoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Planos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Planos
     * const plano = await prisma.plano.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanoUpdateManyArgs>(args: SelectSubset<T, PlanoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Planos and returns the data updated in the database.
     * @param {PlanoUpdateManyAndReturnArgs} args - Arguments to update many Planos.
     * @example
     * // Update many Planos
     * const plano = await prisma.plano.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Planos and only return the `id`
     * const planoWithIdOnly = await prisma.plano.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanoUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plano.
     * @param {PlanoUpsertArgs} args - Arguments to update or create a Plano.
     * @example
     * // Update or create a Plano
     * const plano = await prisma.plano.upsert({
     *   create: {
     *     // ... data to create a Plano
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plano we want to update
     *   }
     * })
     */
    upsert<T extends PlanoUpsertArgs>(args: SelectSubset<T, PlanoUpsertArgs<ExtArgs>>): Prisma__PlanoClient<$Result.GetResult<Prisma.$PlanoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Planos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanoCountArgs} args - Arguments to filter Planos to count.
     * @example
     * // Count the number of Planos
     * const count = await prisma.plano.count({
     *   where: {
     *     // ... the filter for the Planos we want to count
     *   }
     * })
    **/
    count<T extends PlanoCountArgs>(
      args?: Subset<T, PlanoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plano.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanoAggregateArgs>(args: Subset<T, PlanoAggregateArgs>): Prisma.PrismaPromise<GetPlanoAggregateType<T>>

    /**
     * Group by Plano.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanoGroupByArgs['orderBy'] }
        : { orderBy?: PlanoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plano model
   */
  readonly fields: PlanoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plano.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plano model
   */
  interface PlanoFieldRefs {
    readonly id: FieldRef<"Plano", 'Int'>
    readonly descricao: FieldRef<"Plano", 'String'>
    readonly stInativo: FieldRef<"Plano", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * Plano findUnique
   */
  export type PlanoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plano
     */
    select?: PlanoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plano
     */
    omit?: PlanoOmit<ExtArgs> | null
    /**
     * Filter, which Plano to fetch.
     */
    where: PlanoWhereUniqueInput
  }

  /**
   * Plano findUniqueOrThrow
   */
  export type PlanoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plano
     */
    select?: PlanoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plano
     */
    omit?: PlanoOmit<ExtArgs> | null
    /**
     * Filter, which Plano to fetch.
     */
    where: PlanoWhereUniqueInput
  }

  /**
   * Plano findFirst
   */
  export type PlanoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plano
     */
    select?: PlanoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plano
     */
    omit?: PlanoOmit<ExtArgs> | null
    /**
     * Filter, which Plano to fetch.
     */
    where?: PlanoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Planos to fetch.
     */
    orderBy?: PlanoOrderByWithRelationInput | PlanoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Planos.
     */
    cursor?: PlanoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Planos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Planos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Planos.
     */
    distinct?: PlanoScalarFieldEnum | PlanoScalarFieldEnum[]
  }

  /**
   * Plano findFirstOrThrow
   */
  export type PlanoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plano
     */
    select?: PlanoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plano
     */
    omit?: PlanoOmit<ExtArgs> | null
    /**
     * Filter, which Plano to fetch.
     */
    where?: PlanoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Planos to fetch.
     */
    orderBy?: PlanoOrderByWithRelationInput | PlanoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Planos.
     */
    cursor?: PlanoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Planos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Planos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Planos.
     */
    distinct?: PlanoScalarFieldEnum | PlanoScalarFieldEnum[]
  }

  /**
   * Plano findMany
   */
  export type PlanoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plano
     */
    select?: PlanoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plano
     */
    omit?: PlanoOmit<ExtArgs> | null
    /**
     * Filter, which Planos to fetch.
     */
    where?: PlanoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Planos to fetch.
     */
    orderBy?: PlanoOrderByWithRelationInput | PlanoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Planos.
     */
    cursor?: PlanoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Planos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Planos.
     */
    skip?: number
    distinct?: PlanoScalarFieldEnum | PlanoScalarFieldEnum[]
  }

  /**
   * Plano create
   */
  export type PlanoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plano
     */
    select?: PlanoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plano
     */
    omit?: PlanoOmit<ExtArgs> | null
    /**
     * The data needed to create a Plano.
     */
    data: XOR<PlanoCreateInput, PlanoUncheckedCreateInput>
  }

  /**
   * Plano createMany
   */
  export type PlanoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Planos.
     */
    data: PlanoCreateManyInput | PlanoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plano createManyAndReturn
   */
  export type PlanoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plano
     */
    select?: PlanoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plano
     */
    omit?: PlanoOmit<ExtArgs> | null
    /**
     * The data used to create many Planos.
     */
    data: PlanoCreateManyInput | PlanoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plano update
   */
  export type PlanoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plano
     */
    select?: PlanoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plano
     */
    omit?: PlanoOmit<ExtArgs> | null
    /**
     * The data needed to update a Plano.
     */
    data: XOR<PlanoUpdateInput, PlanoUncheckedUpdateInput>
    /**
     * Choose, which Plano to update.
     */
    where: PlanoWhereUniqueInput
  }

  /**
   * Plano updateMany
   */
  export type PlanoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Planos.
     */
    data: XOR<PlanoUpdateManyMutationInput, PlanoUncheckedUpdateManyInput>
    /**
     * Filter which Planos to update
     */
    where?: PlanoWhereInput
    /**
     * Limit how many Planos to update.
     */
    limit?: number
  }

  /**
   * Plano updateManyAndReturn
   */
  export type PlanoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plano
     */
    select?: PlanoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plano
     */
    omit?: PlanoOmit<ExtArgs> | null
    /**
     * The data used to update Planos.
     */
    data: XOR<PlanoUpdateManyMutationInput, PlanoUncheckedUpdateManyInput>
    /**
     * Filter which Planos to update
     */
    where?: PlanoWhereInput
    /**
     * Limit how many Planos to update.
     */
    limit?: number
  }

  /**
   * Plano upsert
   */
  export type PlanoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plano
     */
    select?: PlanoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plano
     */
    omit?: PlanoOmit<ExtArgs> | null
    /**
     * The filter to search for the Plano to update in case it exists.
     */
    where: PlanoWhereUniqueInput
    /**
     * In case the Plano found by the `where` argument doesn't exist, create a new Plano with this data.
     */
    create: XOR<PlanoCreateInput, PlanoUncheckedCreateInput>
    /**
     * In case the Plano was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanoUpdateInput, PlanoUncheckedUpdateInput>
  }

  /**
   * Plano delete
   */
  export type PlanoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plano
     */
    select?: PlanoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plano
     */
    omit?: PlanoOmit<ExtArgs> | null
    /**
     * Filter which Plano to delete.
     */
    where: PlanoWhereUniqueInput
  }

  /**
   * Plano deleteMany
   */
  export type PlanoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Planos to delete
     */
    where?: PlanoWhereInput
    /**
     * Limit how many Planos to delete.
     */
    limit?: number
  }

  /**
   * Plano without action
   */
  export type PlanoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plano
     */
    select?: PlanoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plano
     */
    omit?: PlanoOmit<ExtArgs> | null
  }


  /**
   * Model Motivo
   */

  export type AggregateMotivo = {
    _count: MotivoCountAggregateOutputType | null
    _avg: MotivoAvgAggregateOutputType | null
    _sum: MotivoSumAggregateOutputType | null
    _min: MotivoMinAggregateOutputType | null
    _max: MotivoMaxAggregateOutputType | null
  }

  export type MotivoAvgAggregateOutputType = {
    id: number | null
  }

  export type MotivoSumAggregateOutputType = {
    id: number | null
  }

  export type MotivoMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type MotivoMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type MotivoCountAggregateOutputType = {
    id: number
    descricao: number
    stInativo: number
    _all: number
  }


  export type MotivoAvgAggregateInputType = {
    id?: true
  }

  export type MotivoSumAggregateInputType = {
    id?: true
  }

  export type MotivoMinAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
  }

  export type MotivoMaxAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
  }

  export type MotivoCountAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
    _all?: true
  }

  export type MotivoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Motivo to aggregate.
     */
    where?: MotivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motivos to fetch.
     */
    orderBy?: MotivoOrderByWithRelationInput | MotivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MotivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Motivos
    **/
    _count?: true | MotivoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MotivoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MotivoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MotivoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MotivoMaxAggregateInputType
  }

  export type GetMotivoAggregateType<T extends MotivoAggregateArgs> = {
        [P in keyof T & keyof AggregateMotivo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMotivo[P]>
      : GetScalarType<T[P], AggregateMotivo[P]>
  }




  export type MotivoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MotivoWhereInput
    orderBy?: MotivoOrderByWithAggregationInput | MotivoOrderByWithAggregationInput[]
    by: MotivoScalarFieldEnum[] | MotivoScalarFieldEnum
    having?: MotivoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MotivoCountAggregateInputType | true
    _avg?: MotivoAvgAggregateInputType
    _sum?: MotivoSumAggregateInputType
    _min?: MotivoMinAggregateInputType
    _max?: MotivoMaxAggregateInputType
  }

  export type MotivoGroupByOutputType = {
    id: number
    descricao: string
    stInativo: $Enums.SimNao | null
    _count: MotivoCountAggregateOutputType | null
    _avg: MotivoAvgAggregateOutputType | null
    _sum: MotivoSumAggregateOutputType | null
    _min: MotivoMinAggregateOutputType | null
    _max: MotivoMaxAggregateOutputType | null
  }

  type GetMotivoGroupByPayload<T extends MotivoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MotivoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MotivoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MotivoGroupByOutputType[P]>
            : GetScalarType<T[P], MotivoGroupByOutputType[P]>
        }
      >
    >


  export type MotivoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["motivo"]>

  export type MotivoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["motivo"]>

  export type MotivoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["motivo"]>

  export type MotivoSelectScalar = {
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }

  export type MotivoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "stInativo", ExtArgs["result"]["motivo"]>

  export type $MotivoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Motivo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["motivo"]>
    composites: {}
  }

  type MotivoGetPayload<S extends boolean | null | undefined | MotivoDefaultArgs> = $Result.GetResult<Prisma.$MotivoPayload, S>

  type MotivoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MotivoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MotivoCountAggregateInputType | true
    }

  export interface MotivoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Motivo'], meta: { name: 'Motivo' } }
    /**
     * Find zero or one Motivo that matches the filter.
     * @param {MotivoFindUniqueArgs} args - Arguments to find a Motivo
     * @example
     * // Get one Motivo
     * const motivo = await prisma.motivo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MotivoFindUniqueArgs>(args: SelectSubset<T, MotivoFindUniqueArgs<ExtArgs>>): Prisma__MotivoClient<$Result.GetResult<Prisma.$MotivoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Motivo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MotivoFindUniqueOrThrowArgs} args - Arguments to find a Motivo
     * @example
     * // Get one Motivo
     * const motivo = await prisma.motivo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MotivoFindUniqueOrThrowArgs>(args: SelectSubset<T, MotivoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MotivoClient<$Result.GetResult<Prisma.$MotivoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Motivo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotivoFindFirstArgs} args - Arguments to find a Motivo
     * @example
     * // Get one Motivo
     * const motivo = await prisma.motivo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MotivoFindFirstArgs>(args?: SelectSubset<T, MotivoFindFirstArgs<ExtArgs>>): Prisma__MotivoClient<$Result.GetResult<Prisma.$MotivoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Motivo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotivoFindFirstOrThrowArgs} args - Arguments to find a Motivo
     * @example
     * // Get one Motivo
     * const motivo = await prisma.motivo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MotivoFindFirstOrThrowArgs>(args?: SelectSubset<T, MotivoFindFirstOrThrowArgs<ExtArgs>>): Prisma__MotivoClient<$Result.GetResult<Prisma.$MotivoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Motivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotivoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Motivos
     * const motivos = await prisma.motivo.findMany()
     * 
     * // Get first 10 Motivos
     * const motivos = await prisma.motivo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const motivoWithIdOnly = await prisma.motivo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MotivoFindManyArgs>(args?: SelectSubset<T, MotivoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MotivoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Motivo.
     * @param {MotivoCreateArgs} args - Arguments to create a Motivo.
     * @example
     * // Create one Motivo
     * const Motivo = await prisma.motivo.create({
     *   data: {
     *     // ... data to create a Motivo
     *   }
     * })
     * 
     */
    create<T extends MotivoCreateArgs>(args: SelectSubset<T, MotivoCreateArgs<ExtArgs>>): Prisma__MotivoClient<$Result.GetResult<Prisma.$MotivoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Motivos.
     * @param {MotivoCreateManyArgs} args - Arguments to create many Motivos.
     * @example
     * // Create many Motivos
     * const motivo = await prisma.motivo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MotivoCreateManyArgs>(args?: SelectSubset<T, MotivoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Motivos and returns the data saved in the database.
     * @param {MotivoCreateManyAndReturnArgs} args - Arguments to create many Motivos.
     * @example
     * // Create many Motivos
     * const motivo = await prisma.motivo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Motivos and only return the `id`
     * const motivoWithIdOnly = await prisma.motivo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MotivoCreateManyAndReturnArgs>(args?: SelectSubset<T, MotivoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MotivoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Motivo.
     * @param {MotivoDeleteArgs} args - Arguments to delete one Motivo.
     * @example
     * // Delete one Motivo
     * const Motivo = await prisma.motivo.delete({
     *   where: {
     *     // ... filter to delete one Motivo
     *   }
     * })
     * 
     */
    delete<T extends MotivoDeleteArgs>(args: SelectSubset<T, MotivoDeleteArgs<ExtArgs>>): Prisma__MotivoClient<$Result.GetResult<Prisma.$MotivoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Motivo.
     * @param {MotivoUpdateArgs} args - Arguments to update one Motivo.
     * @example
     * // Update one Motivo
     * const motivo = await prisma.motivo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MotivoUpdateArgs>(args: SelectSubset<T, MotivoUpdateArgs<ExtArgs>>): Prisma__MotivoClient<$Result.GetResult<Prisma.$MotivoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Motivos.
     * @param {MotivoDeleteManyArgs} args - Arguments to filter Motivos to delete.
     * @example
     * // Delete a few Motivos
     * const { count } = await prisma.motivo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MotivoDeleteManyArgs>(args?: SelectSubset<T, MotivoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Motivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotivoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Motivos
     * const motivo = await prisma.motivo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MotivoUpdateManyArgs>(args: SelectSubset<T, MotivoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Motivos and returns the data updated in the database.
     * @param {MotivoUpdateManyAndReturnArgs} args - Arguments to update many Motivos.
     * @example
     * // Update many Motivos
     * const motivo = await prisma.motivo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Motivos and only return the `id`
     * const motivoWithIdOnly = await prisma.motivo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MotivoUpdateManyAndReturnArgs>(args: SelectSubset<T, MotivoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MotivoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Motivo.
     * @param {MotivoUpsertArgs} args - Arguments to update or create a Motivo.
     * @example
     * // Update or create a Motivo
     * const motivo = await prisma.motivo.upsert({
     *   create: {
     *     // ... data to create a Motivo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Motivo we want to update
     *   }
     * })
     */
    upsert<T extends MotivoUpsertArgs>(args: SelectSubset<T, MotivoUpsertArgs<ExtArgs>>): Prisma__MotivoClient<$Result.GetResult<Prisma.$MotivoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Motivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotivoCountArgs} args - Arguments to filter Motivos to count.
     * @example
     * // Count the number of Motivos
     * const count = await prisma.motivo.count({
     *   where: {
     *     // ... the filter for the Motivos we want to count
     *   }
     * })
    **/
    count<T extends MotivoCountArgs>(
      args?: Subset<T, MotivoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MotivoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Motivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotivoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MotivoAggregateArgs>(args: Subset<T, MotivoAggregateArgs>): Prisma.PrismaPromise<GetMotivoAggregateType<T>>

    /**
     * Group by Motivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotivoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MotivoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MotivoGroupByArgs['orderBy'] }
        : { orderBy?: MotivoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MotivoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMotivoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Motivo model
   */
  readonly fields: MotivoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Motivo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MotivoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Motivo model
   */
  interface MotivoFieldRefs {
    readonly id: FieldRef<"Motivo", 'Int'>
    readonly descricao: FieldRef<"Motivo", 'String'>
    readonly stInativo: FieldRef<"Motivo", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * Motivo findUnique
   */
  export type MotivoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo
     */
    select?: MotivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo
     */
    omit?: MotivoOmit<ExtArgs> | null
    /**
     * Filter, which Motivo to fetch.
     */
    where: MotivoWhereUniqueInput
  }

  /**
   * Motivo findUniqueOrThrow
   */
  export type MotivoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo
     */
    select?: MotivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo
     */
    omit?: MotivoOmit<ExtArgs> | null
    /**
     * Filter, which Motivo to fetch.
     */
    where: MotivoWhereUniqueInput
  }

  /**
   * Motivo findFirst
   */
  export type MotivoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo
     */
    select?: MotivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo
     */
    omit?: MotivoOmit<ExtArgs> | null
    /**
     * Filter, which Motivo to fetch.
     */
    where?: MotivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motivos to fetch.
     */
    orderBy?: MotivoOrderByWithRelationInput | MotivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Motivos.
     */
    cursor?: MotivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Motivos.
     */
    distinct?: MotivoScalarFieldEnum | MotivoScalarFieldEnum[]
  }

  /**
   * Motivo findFirstOrThrow
   */
  export type MotivoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo
     */
    select?: MotivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo
     */
    omit?: MotivoOmit<ExtArgs> | null
    /**
     * Filter, which Motivo to fetch.
     */
    where?: MotivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motivos to fetch.
     */
    orderBy?: MotivoOrderByWithRelationInput | MotivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Motivos.
     */
    cursor?: MotivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Motivos.
     */
    distinct?: MotivoScalarFieldEnum | MotivoScalarFieldEnum[]
  }

  /**
   * Motivo findMany
   */
  export type MotivoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo
     */
    select?: MotivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo
     */
    omit?: MotivoOmit<ExtArgs> | null
    /**
     * Filter, which Motivos to fetch.
     */
    where?: MotivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motivos to fetch.
     */
    orderBy?: MotivoOrderByWithRelationInput | MotivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Motivos.
     */
    cursor?: MotivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motivos.
     */
    skip?: number
    distinct?: MotivoScalarFieldEnum | MotivoScalarFieldEnum[]
  }

  /**
   * Motivo create
   */
  export type MotivoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo
     */
    select?: MotivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo
     */
    omit?: MotivoOmit<ExtArgs> | null
    /**
     * The data needed to create a Motivo.
     */
    data: XOR<MotivoCreateInput, MotivoUncheckedCreateInput>
  }

  /**
   * Motivo createMany
   */
  export type MotivoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Motivos.
     */
    data: MotivoCreateManyInput | MotivoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Motivo createManyAndReturn
   */
  export type MotivoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo
     */
    select?: MotivoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo
     */
    omit?: MotivoOmit<ExtArgs> | null
    /**
     * The data used to create many Motivos.
     */
    data: MotivoCreateManyInput | MotivoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Motivo update
   */
  export type MotivoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo
     */
    select?: MotivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo
     */
    omit?: MotivoOmit<ExtArgs> | null
    /**
     * The data needed to update a Motivo.
     */
    data: XOR<MotivoUpdateInput, MotivoUncheckedUpdateInput>
    /**
     * Choose, which Motivo to update.
     */
    where: MotivoWhereUniqueInput
  }

  /**
   * Motivo updateMany
   */
  export type MotivoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Motivos.
     */
    data: XOR<MotivoUpdateManyMutationInput, MotivoUncheckedUpdateManyInput>
    /**
     * Filter which Motivos to update
     */
    where?: MotivoWhereInput
    /**
     * Limit how many Motivos to update.
     */
    limit?: number
  }

  /**
   * Motivo updateManyAndReturn
   */
  export type MotivoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo
     */
    select?: MotivoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo
     */
    omit?: MotivoOmit<ExtArgs> | null
    /**
     * The data used to update Motivos.
     */
    data: XOR<MotivoUpdateManyMutationInput, MotivoUncheckedUpdateManyInput>
    /**
     * Filter which Motivos to update
     */
    where?: MotivoWhereInput
    /**
     * Limit how many Motivos to update.
     */
    limit?: number
  }

  /**
   * Motivo upsert
   */
  export type MotivoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo
     */
    select?: MotivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo
     */
    omit?: MotivoOmit<ExtArgs> | null
    /**
     * The filter to search for the Motivo to update in case it exists.
     */
    where: MotivoWhereUniqueInput
    /**
     * In case the Motivo found by the `where` argument doesn't exist, create a new Motivo with this data.
     */
    create: XOR<MotivoCreateInput, MotivoUncheckedCreateInput>
    /**
     * In case the Motivo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MotivoUpdateInput, MotivoUncheckedUpdateInput>
  }

  /**
   * Motivo delete
   */
  export type MotivoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo
     */
    select?: MotivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo
     */
    omit?: MotivoOmit<ExtArgs> | null
    /**
     * Filter which Motivo to delete.
     */
    where: MotivoWhereUniqueInput
  }

  /**
   * Motivo deleteMany
   */
  export type MotivoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Motivos to delete
     */
    where?: MotivoWhereInput
    /**
     * Limit how many Motivos to delete.
     */
    limit?: number
  }

  /**
   * Motivo without action
   */
  export type MotivoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Motivo
     */
    select?: MotivoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Motivo
     */
    omit?: MotivoOmit<ExtArgs> | null
  }


  /**
   * Model TipoProcedimento
   */

  export type AggregateTipoProcedimento = {
    _count: TipoProcedimentoCountAggregateOutputType | null
    _avg: TipoProcedimentoAvgAggregateOutputType | null
    _sum: TipoProcedimentoSumAggregateOutputType | null
    _min: TipoProcedimentoMinAggregateOutputType | null
    _max: TipoProcedimentoMaxAggregateOutputType | null
  }

  export type TipoProcedimentoAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoProcedimentoSumAggregateOutputType = {
    id: number | null
  }

  export type TipoProcedimentoMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type TipoProcedimentoMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type TipoProcedimentoCountAggregateOutputType = {
    id: number
    descricao: number
    stInativo: number
    _all: number
  }


  export type TipoProcedimentoAvgAggregateInputType = {
    id?: true
  }

  export type TipoProcedimentoSumAggregateInputType = {
    id?: true
  }

  export type TipoProcedimentoMinAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
  }

  export type TipoProcedimentoMaxAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
  }

  export type TipoProcedimentoCountAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
    _all?: true
  }

  export type TipoProcedimentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoProcedimento to aggregate.
     */
    where?: TipoProcedimentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoProcedimentos to fetch.
     */
    orderBy?: TipoProcedimentoOrderByWithRelationInput | TipoProcedimentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoProcedimentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoProcedimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoProcedimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoProcedimentos
    **/
    _count?: true | TipoProcedimentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoProcedimentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoProcedimentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoProcedimentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoProcedimentoMaxAggregateInputType
  }

  export type GetTipoProcedimentoAggregateType<T extends TipoProcedimentoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoProcedimento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoProcedimento[P]>
      : GetScalarType<T[P], AggregateTipoProcedimento[P]>
  }




  export type TipoProcedimentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoProcedimentoWhereInput
    orderBy?: TipoProcedimentoOrderByWithAggregationInput | TipoProcedimentoOrderByWithAggregationInput[]
    by: TipoProcedimentoScalarFieldEnum[] | TipoProcedimentoScalarFieldEnum
    having?: TipoProcedimentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoProcedimentoCountAggregateInputType | true
    _avg?: TipoProcedimentoAvgAggregateInputType
    _sum?: TipoProcedimentoSumAggregateInputType
    _min?: TipoProcedimentoMinAggregateInputType
    _max?: TipoProcedimentoMaxAggregateInputType
  }

  export type TipoProcedimentoGroupByOutputType = {
    id: number
    descricao: string
    stInativo: $Enums.SimNao | null
    _count: TipoProcedimentoCountAggregateOutputType | null
    _avg: TipoProcedimentoAvgAggregateOutputType | null
    _sum: TipoProcedimentoSumAggregateOutputType | null
    _min: TipoProcedimentoMinAggregateOutputType | null
    _max: TipoProcedimentoMaxAggregateOutputType | null
  }

  type GetTipoProcedimentoGroupByPayload<T extends TipoProcedimentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoProcedimentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoProcedimentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoProcedimentoGroupByOutputType[P]>
            : GetScalarType<T[P], TipoProcedimentoGroupByOutputType[P]>
        }
      >
    >


  export type TipoProcedimentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["tipoProcedimento"]>

  export type TipoProcedimentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["tipoProcedimento"]>

  export type TipoProcedimentoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["tipoProcedimento"]>

  export type TipoProcedimentoSelectScalar = {
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }

  export type TipoProcedimentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "stInativo", ExtArgs["result"]["tipoProcedimento"]>

  export type $TipoProcedimentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoProcedimento"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["tipoProcedimento"]>
    composites: {}
  }

  type TipoProcedimentoGetPayload<S extends boolean | null | undefined | TipoProcedimentoDefaultArgs> = $Result.GetResult<Prisma.$TipoProcedimentoPayload, S>

  type TipoProcedimentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoProcedimentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoProcedimentoCountAggregateInputType | true
    }

  export interface TipoProcedimentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoProcedimento'], meta: { name: 'TipoProcedimento' } }
    /**
     * Find zero or one TipoProcedimento that matches the filter.
     * @param {TipoProcedimentoFindUniqueArgs} args - Arguments to find a TipoProcedimento
     * @example
     * // Get one TipoProcedimento
     * const tipoProcedimento = await prisma.tipoProcedimento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoProcedimentoFindUniqueArgs>(args: SelectSubset<T, TipoProcedimentoFindUniqueArgs<ExtArgs>>): Prisma__TipoProcedimentoClient<$Result.GetResult<Prisma.$TipoProcedimentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoProcedimento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoProcedimentoFindUniqueOrThrowArgs} args - Arguments to find a TipoProcedimento
     * @example
     * // Get one TipoProcedimento
     * const tipoProcedimento = await prisma.tipoProcedimento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoProcedimentoFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoProcedimentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoProcedimentoClient<$Result.GetResult<Prisma.$TipoProcedimentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoProcedimento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoProcedimentoFindFirstArgs} args - Arguments to find a TipoProcedimento
     * @example
     * // Get one TipoProcedimento
     * const tipoProcedimento = await prisma.tipoProcedimento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoProcedimentoFindFirstArgs>(args?: SelectSubset<T, TipoProcedimentoFindFirstArgs<ExtArgs>>): Prisma__TipoProcedimentoClient<$Result.GetResult<Prisma.$TipoProcedimentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoProcedimento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoProcedimentoFindFirstOrThrowArgs} args - Arguments to find a TipoProcedimento
     * @example
     * // Get one TipoProcedimento
     * const tipoProcedimento = await prisma.tipoProcedimento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoProcedimentoFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoProcedimentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoProcedimentoClient<$Result.GetResult<Prisma.$TipoProcedimentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoProcedimentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoProcedimentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoProcedimentos
     * const tipoProcedimentos = await prisma.tipoProcedimento.findMany()
     * 
     * // Get first 10 TipoProcedimentos
     * const tipoProcedimentos = await prisma.tipoProcedimento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoProcedimentoWithIdOnly = await prisma.tipoProcedimento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoProcedimentoFindManyArgs>(args?: SelectSubset<T, TipoProcedimentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoProcedimentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoProcedimento.
     * @param {TipoProcedimentoCreateArgs} args - Arguments to create a TipoProcedimento.
     * @example
     * // Create one TipoProcedimento
     * const TipoProcedimento = await prisma.tipoProcedimento.create({
     *   data: {
     *     // ... data to create a TipoProcedimento
     *   }
     * })
     * 
     */
    create<T extends TipoProcedimentoCreateArgs>(args: SelectSubset<T, TipoProcedimentoCreateArgs<ExtArgs>>): Prisma__TipoProcedimentoClient<$Result.GetResult<Prisma.$TipoProcedimentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoProcedimentos.
     * @param {TipoProcedimentoCreateManyArgs} args - Arguments to create many TipoProcedimentos.
     * @example
     * // Create many TipoProcedimentos
     * const tipoProcedimento = await prisma.tipoProcedimento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoProcedimentoCreateManyArgs>(args?: SelectSubset<T, TipoProcedimentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoProcedimentos and returns the data saved in the database.
     * @param {TipoProcedimentoCreateManyAndReturnArgs} args - Arguments to create many TipoProcedimentos.
     * @example
     * // Create many TipoProcedimentos
     * const tipoProcedimento = await prisma.tipoProcedimento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoProcedimentos and only return the `id`
     * const tipoProcedimentoWithIdOnly = await prisma.tipoProcedimento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoProcedimentoCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoProcedimentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoProcedimentoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoProcedimento.
     * @param {TipoProcedimentoDeleteArgs} args - Arguments to delete one TipoProcedimento.
     * @example
     * // Delete one TipoProcedimento
     * const TipoProcedimento = await prisma.tipoProcedimento.delete({
     *   where: {
     *     // ... filter to delete one TipoProcedimento
     *   }
     * })
     * 
     */
    delete<T extends TipoProcedimentoDeleteArgs>(args: SelectSubset<T, TipoProcedimentoDeleteArgs<ExtArgs>>): Prisma__TipoProcedimentoClient<$Result.GetResult<Prisma.$TipoProcedimentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoProcedimento.
     * @param {TipoProcedimentoUpdateArgs} args - Arguments to update one TipoProcedimento.
     * @example
     * // Update one TipoProcedimento
     * const tipoProcedimento = await prisma.tipoProcedimento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoProcedimentoUpdateArgs>(args: SelectSubset<T, TipoProcedimentoUpdateArgs<ExtArgs>>): Prisma__TipoProcedimentoClient<$Result.GetResult<Prisma.$TipoProcedimentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoProcedimentos.
     * @param {TipoProcedimentoDeleteManyArgs} args - Arguments to filter TipoProcedimentos to delete.
     * @example
     * // Delete a few TipoProcedimentos
     * const { count } = await prisma.tipoProcedimento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoProcedimentoDeleteManyArgs>(args?: SelectSubset<T, TipoProcedimentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoProcedimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoProcedimentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoProcedimentos
     * const tipoProcedimento = await prisma.tipoProcedimento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoProcedimentoUpdateManyArgs>(args: SelectSubset<T, TipoProcedimentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoProcedimentos and returns the data updated in the database.
     * @param {TipoProcedimentoUpdateManyAndReturnArgs} args - Arguments to update many TipoProcedimentos.
     * @example
     * // Update many TipoProcedimentos
     * const tipoProcedimento = await prisma.tipoProcedimento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoProcedimentos and only return the `id`
     * const tipoProcedimentoWithIdOnly = await prisma.tipoProcedimento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoProcedimentoUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoProcedimentoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoProcedimentoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoProcedimento.
     * @param {TipoProcedimentoUpsertArgs} args - Arguments to update or create a TipoProcedimento.
     * @example
     * // Update or create a TipoProcedimento
     * const tipoProcedimento = await prisma.tipoProcedimento.upsert({
     *   create: {
     *     // ... data to create a TipoProcedimento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoProcedimento we want to update
     *   }
     * })
     */
    upsert<T extends TipoProcedimentoUpsertArgs>(args: SelectSubset<T, TipoProcedimentoUpsertArgs<ExtArgs>>): Prisma__TipoProcedimentoClient<$Result.GetResult<Prisma.$TipoProcedimentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoProcedimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoProcedimentoCountArgs} args - Arguments to filter TipoProcedimentos to count.
     * @example
     * // Count the number of TipoProcedimentos
     * const count = await prisma.tipoProcedimento.count({
     *   where: {
     *     // ... the filter for the TipoProcedimentos we want to count
     *   }
     * })
    **/
    count<T extends TipoProcedimentoCountArgs>(
      args?: Subset<T, TipoProcedimentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoProcedimentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoProcedimento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoProcedimentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoProcedimentoAggregateArgs>(args: Subset<T, TipoProcedimentoAggregateArgs>): Prisma.PrismaPromise<GetTipoProcedimentoAggregateType<T>>

    /**
     * Group by TipoProcedimento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoProcedimentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoProcedimentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoProcedimentoGroupByArgs['orderBy'] }
        : { orderBy?: TipoProcedimentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoProcedimentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoProcedimentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoProcedimento model
   */
  readonly fields: TipoProcedimentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoProcedimento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoProcedimentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoProcedimento model
   */
  interface TipoProcedimentoFieldRefs {
    readonly id: FieldRef<"TipoProcedimento", 'Int'>
    readonly descricao: FieldRef<"TipoProcedimento", 'String'>
    readonly stInativo: FieldRef<"TipoProcedimento", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * TipoProcedimento findUnique
   */
  export type TipoProcedimentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProcedimento
     */
    select?: TipoProcedimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProcedimento
     */
    omit?: TipoProcedimentoOmit<ExtArgs> | null
    /**
     * Filter, which TipoProcedimento to fetch.
     */
    where: TipoProcedimentoWhereUniqueInput
  }

  /**
   * TipoProcedimento findUniqueOrThrow
   */
  export type TipoProcedimentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProcedimento
     */
    select?: TipoProcedimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProcedimento
     */
    omit?: TipoProcedimentoOmit<ExtArgs> | null
    /**
     * Filter, which TipoProcedimento to fetch.
     */
    where: TipoProcedimentoWhereUniqueInput
  }

  /**
   * TipoProcedimento findFirst
   */
  export type TipoProcedimentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProcedimento
     */
    select?: TipoProcedimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProcedimento
     */
    omit?: TipoProcedimentoOmit<ExtArgs> | null
    /**
     * Filter, which TipoProcedimento to fetch.
     */
    where?: TipoProcedimentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoProcedimentos to fetch.
     */
    orderBy?: TipoProcedimentoOrderByWithRelationInput | TipoProcedimentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoProcedimentos.
     */
    cursor?: TipoProcedimentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoProcedimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoProcedimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoProcedimentos.
     */
    distinct?: TipoProcedimentoScalarFieldEnum | TipoProcedimentoScalarFieldEnum[]
  }

  /**
   * TipoProcedimento findFirstOrThrow
   */
  export type TipoProcedimentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProcedimento
     */
    select?: TipoProcedimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProcedimento
     */
    omit?: TipoProcedimentoOmit<ExtArgs> | null
    /**
     * Filter, which TipoProcedimento to fetch.
     */
    where?: TipoProcedimentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoProcedimentos to fetch.
     */
    orderBy?: TipoProcedimentoOrderByWithRelationInput | TipoProcedimentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoProcedimentos.
     */
    cursor?: TipoProcedimentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoProcedimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoProcedimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoProcedimentos.
     */
    distinct?: TipoProcedimentoScalarFieldEnum | TipoProcedimentoScalarFieldEnum[]
  }

  /**
   * TipoProcedimento findMany
   */
  export type TipoProcedimentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProcedimento
     */
    select?: TipoProcedimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProcedimento
     */
    omit?: TipoProcedimentoOmit<ExtArgs> | null
    /**
     * Filter, which TipoProcedimentos to fetch.
     */
    where?: TipoProcedimentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoProcedimentos to fetch.
     */
    orderBy?: TipoProcedimentoOrderByWithRelationInput | TipoProcedimentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoProcedimentos.
     */
    cursor?: TipoProcedimentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoProcedimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoProcedimentos.
     */
    skip?: number
    distinct?: TipoProcedimentoScalarFieldEnum | TipoProcedimentoScalarFieldEnum[]
  }

  /**
   * TipoProcedimento create
   */
  export type TipoProcedimentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProcedimento
     */
    select?: TipoProcedimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProcedimento
     */
    omit?: TipoProcedimentoOmit<ExtArgs> | null
    /**
     * The data needed to create a TipoProcedimento.
     */
    data: XOR<TipoProcedimentoCreateInput, TipoProcedimentoUncheckedCreateInput>
  }

  /**
   * TipoProcedimento createMany
   */
  export type TipoProcedimentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoProcedimentos.
     */
    data: TipoProcedimentoCreateManyInput | TipoProcedimentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoProcedimento createManyAndReturn
   */
  export type TipoProcedimentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProcedimento
     */
    select?: TipoProcedimentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProcedimento
     */
    omit?: TipoProcedimentoOmit<ExtArgs> | null
    /**
     * The data used to create many TipoProcedimentos.
     */
    data: TipoProcedimentoCreateManyInput | TipoProcedimentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoProcedimento update
   */
  export type TipoProcedimentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProcedimento
     */
    select?: TipoProcedimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProcedimento
     */
    omit?: TipoProcedimentoOmit<ExtArgs> | null
    /**
     * The data needed to update a TipoProcedimento.
     */
    data: XOR<TipoProcedimentoUpdateInput, TipoProcedimentoUncheckedUpdateInput>
    /**
     * Choose, which TipoProcedimento to update.
     */
    where: TipoProcedimentoWhereUniqueInput
  }

  /**
   * TipoProcedimento updateMany
   */
  export type TipoProcedimentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoProcedimentos.
     */
    data: XOR<TipoProcedimentoUpdateManyMutationInput, TipoProcedimentoUncheckedUpdateManyInput>
    /**
     * Filter which TipoProcedimentos to update
     */
    where?: TipoProcedimentoWhereInput
    /**
     * Limit how many TipoProcedimentos to update.
     */
    limit?: number
  }

  /**
   * TipoProcedimento updateManyAndReturn
   */
  export type TipoProcedimentoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProcedimento
     */
    select?: TipoProcedimentoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProcedimento
     */
    omit?: TipoProcedimentoOmit<ExtArgs> | null
    /**
     * The data used to update TipoProcedimentos.
     */
    data: XOR<TipoProcedimentoUpdateManyMutationInput, TipoProcedimentoUncheckedUpdateManyInput>
    /**
     * Filter which TipoProcedimentos to update
     */
    where?: TipoProcedimentoWhereInput
    /**
     * Limit how many TipoProcedimentos to update.
     */
    limit?: number
  }

  /**
   * TipoProcedimento upsert
   */
  export type TipoProcedimentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProcedimento
     */
    select?: TipoProcedimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProcedimento
     */
    omit?: TipoProcedimentoOmit<ExtArgs> | null
    /**
     * The filter to search for the TipoProcedimento to update in case it exists.
     */
    where: TipoProcedimentoWhereUniqueInput
    /**
     * In case the TipoProcedimento found by the `where` argument doesn't exist, create a new TipoProcedimento with this data.
     */
    create: XOR<TipoProcedimentoCreateInput, TipoProcedimentoUncheckedCreateInput>
    /**
     * In case the TipoProcedimento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoProcedimentoUpdateInput, TipoProcedimentoUncheckedUpdateInput>
  }

  /**
   * TipoProcedimento delete
   */
  export type TipoProcedimentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProcedimento
     */
    select?: TipoProcedimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProcedimento
     */
    omit?: TipoProcedimentoOmit<ExtArgs> | null
    /**
     * Filter which TipoProcedimento to delete.
     */
    where: TipoProcedimentoWhereUniqueInput
  }

  /**
   * TipoProcedimento deleteMany
   */
  export type TipoProcedimentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoProcedimentos to delete
     */
    where?: TipoProcedimentoWhereInput
    /**
     * Limit how many TipoProcedimentos to delete.
     */
    limit?: number
  }

  /**
   * TipoProcedimento without action
   */
  export type TipoProcedimentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoProcedimento
     */
    select?: TipoProcedimentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoProcedimento
     */
    omit?: TipoProcedimentoOmit<ExtArgs> | null
  }


  /**
   * Model TipoEvolucaoSimples
   */

  export type AggregateTipoEvolucaoSimples = {
    _count: TipoEvolucaoSimplesCountAggregateOutputType | null
    _avg: TipoEvolucaoSimplesAvgAggregateOutputType | null
    _sum: TipoEvolucaoSimplesSumAggregateOutputType | null
    _min: TipoEvolucaoSimplesMinAggregateOutputType | null
    _max: TipoEvolucaoSimplesMaxAggregateOutputType | null
  }

  export type TipoEvolucaoSimplesAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoEvolucaoSimplesSumAggregateOutputType = {
    id: number | null
  }

  export type TipoEvolucaoSimplesMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type TipoEvolucaoSimplesMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type TipoEvolucaoSimplesCountAggregateOutputType = {
    id: number
    descricao: number
    stInativo: number
    _all: number
  }


  export type TipoEvolucaoSimplesAvgAggregateInputType = {
    id?: true
  }

  export type TipoEvolucaoSimplesSumAggregateInputType = {
    id?: true
  }

  export type TipoEvolucaoSimplesMinAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
  }

  export type TipoEvolucaoSimplesMaxAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
  }

  export type TipoEvolucaoSimplesCountAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
    _all?: true
  }

  export type TipoEvolucaoSimplesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoEvolucaoSimples to aggregate.
     */
    where?: TipoEvolucaoSimplesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEvolucaoSimples to fetch.
     */
    orderBy?: TipoEvolucaoSimplesOrderByWithRelationInput | TipoEvolucaoSimplesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoEvolucaoSimplesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEvolucaoSimples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEvolucaoSimples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoEvolucaoSimples
    **/
    _count?: true | TipoEvolucaoSimplesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoEvolucaoSimplesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoEvolucaoSimplesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoEvolucaoSimplesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoEvolucaoSimplesMaxAggregateInputType
  }

  export type GetTipoEvolucaoSimplesAggregateType<T extends TipoEvolucaoSimplesAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoEvolucaoSimples]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoEvolucaoSimples[P]>
      : GetScalarType<T[P], AggregateTipoEvolucaoSimples[P]>
  }




  export type TipoEvolucaoSimplesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoEvolucaoSimplesWhereInput
    orderBy?: TipoEvolucaoSimplesOrderByWithAggregationInput | TipoEvolucaoSimplesOrderByWithAggregationInput[]
    by: TipoEvolucaoSimplesScalarFieldEnum[] | TipoEvolucaoSimplesScalarFieldEnum
    having?: TipoEvolucaoSimplesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoEvolucaoSimplesCountAggregateInputType | true
    _avg?: TipoEvolucaoSimplesAvgAggregateInputType
    _sum?: TipoEvolucaoSimplesSumAggregateInputType
    _min?: TipoEvolucaoSimplesMinAggregateInputType
    _max?: TipoEvolucaoSimplesMaxAggregateInputType
  }

  export type TipoEvolucaoSimplesGroupByOutputType = {
    id: number
    descricao: string
    stInativo: $Enums.SimNao | null
    _count: TipoEvolucaoSimplesCountAggregateOutputType | null
    _avg: TipoEvolucaoSimplesAvgAggregateOutputType | null
    _sum: TipoEvolucaoSimplesSumAggregateOutputType | null
    _min: TipoEvolucaoSimplesMinAggregateOutputType | null
    _max: TipoEvolucaoSimplesMaxAggregateOutputType | null
  }

  type GetTipoEvolucaoSimplesGroupByPayload<T extends TipoEvolucaoSimplesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoEvolucaoSimplesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoEvolucaoSimplesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoEvolucaoSimplesGroupByOutputType[P]>
            : GetScalarType<T[P], TipoEvolucaoSimplesGroupByOutputType[P]>
        }
      >
    >


  export type TipoEvolucaoSimplesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["tipoEvolucaoSimples"]>

  export type TipoEvolucaoSimplesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["tipoEvolucaoSimples"]>

  export type TipoEvolucaoSimplesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["tipoEvolucaoSimples"]>

  export type TipoEvolucaoSimplesSelectScalar = {
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }

  export type TipoEvolucaoSimplesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "stInativo", ExtArgs["result"]["tipoEvolucaoSimples"]>

  export type $TipoEvolucaoSimplesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoEvolucaoSimples"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["tipoEvolucaoSimples"]>
    composites: {}
  }

  type TipoEvolucaoSimplesGetPayload<S extends boolean | null | undefined | TipoEvolucaoSimplesDefaultArgs> = $Result.GetResult<Prisma.$TipoEvolucaoSimplesPayload, S>

  type TipoEvolucaoSimplesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoEvolucaoSimplesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoEvolucaoSimplesCountAggregateInputType | true
    }

  export interface TipoEvolucaoSimplesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoEvolucaoSimples'], meta: { name: 'TipoEvolucaoSimples' } }
    /**
     * Find zero or one TipoEvolucaoSimples that matches the filter.
     * @param {TipoEvolucaoSimplesFindUniqueArgs} args - Arguments to find a TipoEvolucaoSimples
     * @example
     * // Get one TipoEvolucaoSimples
     * const tipoEvolucaoSimples = await prisma.tipoEvolucaoSimples.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoEvolucaoSimplesFindUniqueArgs>(args: SelectSubset<T, TipoEvolucaoSimplesFindUniqueArgs<ExtArgs>>): Prisma__TipoEvolucaoSimplesClient<$Result.GetResult<Prisma.$TipoEvolucaoSimplesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoEvolucaoSimples that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoEvolucaoSimplesFindUniqueOrThrowArgs} args - Arguments to find a TipoEvolucaoSimples
     * @example
     * // Get one TipoEvolucaoSimples
     * const tipoEvolucaoSimples = await prisma.tipoEvolucaoSimples.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoEvolucaoSimplesFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoEvolucaoSimplesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoEvolucaoSimplesClient<$Result.GetResult<Prisma.$TipoEvolucaoSimplesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoEvolucaoSimples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEvolucaoSimplesFindFirstArgs} args - Arguments to find a TipoEvolucaoSimples
     * @example
     * // Get one TipoEvolucaoSimples
     * const tipoEvolucaoSimples = await prisma.tipoEvolucaoSimples.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoEvolucaoSimplesFindFirstArgs>(args?: SelectSubset<T, TipoEvolucaoSimplesFindFirstArgs<ExtArgs>>): Prisma__TipoEvolucaoSimplesClient<$Result.GetResult<Prisma.$TipoEvolucaoSimplesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoEvolucaoSimples that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEvolucaoSimplesFindFirstOrThrowArgs} args - Arguments to find a TipoEvolucaoSimples
     * @example
     * // Get one TipoEvolucaoSimples
     * const tipoEvolucaoSimples = await prisma.tipoEvolucaoSimples.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoEvolucaoSimplesFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoEvolucaoSimplesFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoEvolucaoSimplesClient<$Result.GetResult<Prisma.$TipoEvolucaoSimplesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoEvolucaoSimples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEvolucaoSimplesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoEvolucaoSimples
     * const tipoEvolucaoSimples = await prisma.tipoEvolucaoSimples.findMany()
     * 
     * // Get first 10 TipoEvolucaoSimples
     * const tipoEvolucaoSimples = await prisma.tipoEvolucaoSimples.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoEvolucaoSimplesWithIdOnly = await prisma.tipoEvolucaoSimples.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoEvolucaoSimplesFindManyArgs>(args?: SelectSubset<T, TipoEvolucaoSimplesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoEvolucaoSimplesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoEvolucaoSimples.
     * @param {TipoEvolucaoSimplesCreateArgs} args - Arguments to create a TipoEvolucaoSimples.
     * @example
     * // Create one TipoEvolucaoSimples
     * const TipoEvolucaoSimples = await prisma.tipoEvolucaoSimples.create({
     *   data: {
     *     // ... data to create a TipoEvolucaoSimples
     *   }
     * })
     * 
     */
    create<T extends TipoEvolucaoSimplesCreateArgs>(args: SelectSubset<T, TipoEvolucaoSimplesCreateArgs<ExtArgs>>): Prisma__TipoEvolucaoSimplesClient<$Result.GetResult<Prisma.$TipoEvolucaoSimplesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoEvolucaoSimples.
     * @param {TipoEvolucaoSimplesCreateManyArgs} args - Arguments to create many TipoEvolucaoSimples.
     * @example
     * // Create many TipoEvolucaoSimples
     * const tipoEvolucaoSimples = await prisma.tipoEvolucaoSimples.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoEvolucaoSimplesCreateManyArgs>(args?: SelectSubset<T, TipoEvolucaoSimplesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoEvolucaoSimples and returns the data saved in the database.
     * @param {TipoEvolucaoSimplesCreateManyAndReturnArgs} args - Arguments to create many TipoEvolucaoSimples.
     * @example
     * // Create many TipoEvolucaoSimples
     * const tipoEvolucaoSimples = await prisma.tipoEvolucaoSimples.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoEvolucaoSimples and only return the `id`
     * const tipoEvolucaoSimplesWithIdOnly = await prisma.tipoEvolucaoSimples.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoEvolucaoSimplesCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoEvolucaoSimplesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoEvolucaoSimplesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoEvolucaoSimples.
     * @param {TipoEvolucaoSimplesDeleteArgs} args - Arguments to delete one TipoEvolucaoSimples.
     * @example
     * // Delete one TipoEvolucaoSimples
     * const TipoEvolucaoSimples = await prisma.tipoEvolucaoSimples.delete({
     *   where: {
     *     // ... filter to delete one TipoEvolucaoSimples
     *   }
     * })
     * 
     */
    delete<T extends TipoEvolucaoSimplesDeleteArgs>(args: SelectSubset<T, TipoEvolucaoSimplesDeleteArgs<ExtArgs>>): Prisma__TipoEvolucaoSimplesClient<$Result.GetResult<Prisma.$TipoEvolucaoSimplesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoEvolucaoSimples.
     * @param {TipoEvolucaoSimplesUpdateArgs} args - Arguments to update one TipoEvolucaoSimples.
     * @example
     * // Update one TipoEvolucaoSimples
     * const tipoEvolucaoSimples = await prisma.tipoEvolucaoSimples.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoEvolucaoSimplesUpdateArgs>(args: SelectSubset<T, TipoEvolucaoSimplesUpdateArgs<ExtArgs>>): Prisma__TipoEvolucaoSimplesClient<$Result.GetResult<Prisma.$TipoEvolucaoSimplesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoEvolucaoSimples.
     * @param {TipoEvolucaoSimplesDeleteManyArgs} args - Arguments to filter TipoEvolucaoSimples to delete.
     * @example
     * // Delete a few TipoEvolucaoSimples
     * const { count } = await prisma.tipoEvolucaoSimples.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoEvolucaoSimplesDeleteManyArgs>(args?: SelectSubset<T, TipoEvolucaoSimplesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoEvolucaoSimples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEvolucaoSimplesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoEvolucaoSimples
     * const tipoEvolucaoSimples = await prisma.tipoEvolucaoSimples.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoEvolucaoSimplesUpdateManyArgs>(args: SelectSubset<T, TipoEvolucaoSimplesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoEvolucaoSimples and returns the data updated in the database.
     * @param {TipoEvolucaoSimplesUpdateManyAndReturnArgs} args - Arguments to update many TipoEvolucaoSimples.
     * @example
     * // Update many TipoEvolucaoSimples
     * const tipoEvolucaoSimples = await prisma.tipoEvolucaoSimples.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoEvolucaoSimples and only return the `id`
     * const tipoEvolucaoSimplesWithIdOnly = await prisma.tipoEvolucaoSimples.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoEvolucaoSimplesUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoEvolucaoSimplesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoEvolucaoSimplesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoEvolucaoSimples.
     * @param {TipoEvolucaoSimplesUpsertArgs} args - Arguments to update or create a TipoEvolucaoSimples.
     * @example
     * // Update or create a TipoEvolucaoSimples
     * const tipoEvolucaoSimples = await prisma.tipoEvolucaoSimples.upsert({
     *   create: {
     *     // ... data to create a TipoEvolucaoSimples
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoEvolucaoSimples we want to update
     *   }
     * })
     */
    upsert<T extends TipoEvolucaoSimplesUpsertArgs>(args: SelectSubset<T, TipoEvolucaoSimplesUpsertArgs<ExtArgs>>): Prisma__TipoEvolucaoSimplesClient<$Result.GetResult<Prisma.$TipoEvolucaoSimplesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoEvolucaoSimples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEvolucaoSimplesCountArgs} args - Arguments to filter TipoEvolucaoSimples to count.
     * @example
     * // Count the number of TipoEvolucaoSimples
     * const count = await prisma.tipoEvolucaoSimples.count({
     *   where: {
     *     // ... the filter for the TipoEvolucaoSimples we want to count
     *   }
     * })
    **/
    count<T extends TipoEvolucaoSimplesCountArgs>(
      args?: Subset<T, TipoEvolucaoSimplesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoEvolucaoSimplesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoEvolucaoSimples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEvolucaoSimplesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoEvolucaoSimplesAggregateArgs>(args: Subset<T, TipoEvolucaoSimplesAggregateArgs>): Prisma.PrismaPromise<GetTipoEvolucaoSimplesAggregateType<T>>

    /**
     * Group by TipoEvolucaoSimples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEvolucaoSimplesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoEvolucaoSimplesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoEvolucaoSimplesGroupByArgs['orderBy'] }
        : { orderBy?: TipoEvolucaoSimplesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoEvolucaoSimplesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoEvolucaoSimplesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoEvolucaoSimples model
   */
  readonly fields: TipoEvolucaoSimplesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoEvolucaoSimples.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoEvolucaoSimplesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoEvolucaoSimples model
   */
  interface TipoEvolucaoSimplesFieldRefs {
    readonly id: FieldRef<"TipoEvolucaoSimples", 'Int'>
    readonly descricao: FieldRef<"TipoEvolucaoSimples", 'String'>
    readonly stInativo: FieldRef<"TipoEvolucaoSimples", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * TipoEvolucaoSimples findUnique
   */
  export type TipoEvolucaoSimplesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoSimples
     */
    select?: TipoEvolucaoSimplesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoSimples
     */
    omit?: TipoEvolucaoSimplesOmit<ExtArgs> | null
    /**
     * Filter, which TipoEvolucaoSimples to fetch.
     */
    where: TipoEvolucaoSimplesWhereUniqueInput
  }

  /**
   * TipoEvolucaoSimples findUniqueOrThrow
   */
  export type TipoEvolucaoSimplesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoSimples
     */
    select?: TipoEvolucaoSimplesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoSimples
     */
    omit?: TipoEvolucaoSimplesOmit<ExtArgs> | null
    /**
     * Filter, which TipoEvolucaoSimples to fetch.
     */
    where: TipoEvolucaoSimplesWhereUniqueInput
  }

  /**
   * TipoEvolucaoSimples findFirst
   */
  export type TipoEvolucaoSimplesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoSimples
     */
    select?: TipoEvolucaoSimplesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoSimples
     */
    omit?: TipoEvolucaoSimplesOmit<ExtArgs> | null
    /**
     * Filter, which TipoEvolucaoSimples to fetch.
     */
    where?: TipoEvolucaoSimplesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEvolucaoSimples to fetch.
     */
    orderBy?: TipoEvolucaoSimplesOrderByWithRelationInput | TipoEvolucaoSimplesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoEvolucaoSimples.
     */
    cursor?: TipoEvolucaoSimplesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEvolucaoSimples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEvolucaoSimples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoEvolucaoSimples.
     */
    distinct?: TipoEvolucaoSimplesScalarFieldEnum | TipoEvolucaoSimplesScalarFieldEnum[]
  }

  /**
   * TipoEvolucaoSimples findFirstOrThrow
   */
  export type TipoEvolucaoSimplesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoSimples
     */
    select?: TipoEvolucaoSimplesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoSimples
     */
    omit?: TipoEvolucaoSimplesOmit<ExtArgs> | null
    /**
     * Filter, which TipoEvolucaoSimples to fetch.
     */
    where?: TipoEvolucaoSimplesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEvolucaoSimples to fetch.
     */
    orderBy?: TipoEvolucaoSimplesOrderByWithRelationInput | TipoEvolucaoSimplesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoEvolucaoSimples.
     */
    cursor?: TipoEvolucaoSimplesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEvolucaoSimples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEvolucaoSimples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoEvolucaoSimples.
     */
    distinct?: TipoEvolucaoSimplesScalarFieldEnum | TipoEvolucaoSimplesScalarFieldEnum[]
  }

  /**
   * TipoEvolucaoSimples findMany
   */
  export type TipoEvolucaoSimplesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoSimples
     */
    select?: TipoEvolucaoSimplesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoSimples
     */
    omit?: TipoEvolucaoSimplesOmit<ExtArgs> | null
    /**
     * Filter, which TipoEvolucaoSimples to fetch.
     */
    where?: TipoEvolucaoSimplesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEvolucaoSimples to fetch.
     */
    orderBy?: TipoEvolucaoSimplesOrderByWithRelationInput | TipoEvolucaoSimplesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoEvolucaoSimples.
     */
    cursor?: TipoEvolucaoSimplesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEvolucaoSimples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEvolucaoSimples.
     */
    skip?: number
    distinct?: TipoEvolucaoSimplesScalarFieldEnum | TipoEvolucaoSimplesScalarFieldEnum[]
  }

  /**
   * TipoEvolucaoSimples create
   */
  export type TipoEvolucaoSimplesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoSimples
     */
    select?: TipoEvolucaoSimplesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoSimples
     */
    omit?: TipoEvolucaoSimplesOmit<ExtArgs> | null
    /**
     * The data needed to create a TipoEvolucaoSimples.
     */
    data: XOR<TipoEvolucaoSimplesCreateInput, TipoEvolucaoSimplesUncheckedCreateInput>
  }

  /**
   * TipoEvolucaoSimples createMany
   */
  export type TipoEvolucaoSimplesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoEvolucaoSimples.
     */
    data: TipoEvolucaoSimplesCreateManyInput | TipoEvolucaoSimplesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoEvolucaoSimples createManyAndReturn
   */
  export type TipoEvolucaoSimplesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoSimples
     */
    select?: TipoEvolucaoSimplesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoSimples
     */
    omit?: TipoEvolucaoSimplesOmit<ExtArgs> | null
    /**
     * The data used to create many TipoEvolucaoSimples.
     */
    data: TipoEvolucaoSimplesCreateManyInput | TipoEvolucaoSimplesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoEvolucaoSimples update
   */
  export type TipoEvolucaoSimplesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoSimples
     */
    select?: TipoEvolucaoSimplesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoSimples
     */
    omit?: TipoEvolucaoSimplesOmit<ExtArgs> | null
    /**
     * The data needed to update a TipoEvolucaoSimples.
     */
    data: XOR<TipoEvolucaoSimplesUpdateInput, TipoEvolucaoSimplesUncheckedUpdateInput>
    /**
     * Choose, which TipoEvolucaoSimples to update.
     */
    where: TipoEvolucaoSimplesWhereUniqueInput
  }

  /**
   * TipoEvolucaoSimples updateMany
   */
  export type TipoEvolucaoSimplesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoEvolucaoSimples.
     */
    data: XOR<TipoEvolucaoSimplesUpdateManyMutationInput, TipoEvolucaoSimplesUncheckedUpdateManyInput>
    /**
     * Filter which TipoEvolucaoSimples to update
     */
    where?: TipoEvolucaoSimplesWhereInput
    /**
     * Limit how many TipoEvolucaoSimples to update.
     */
    limit?: number
  }

  /**
   * TipoEvolucaoSimples updateManyAndReturn
   */
  export type TipoEvolucaoSimplesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoSimples
     */
    select?: TipoEvolucaoSimplesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoSimples
     */
    omit?: TipoEvolucaoSimplesOmit<ExtArgs> | null
    /**
     * The data used to update TipoEvolucaoSimples.
     */
    data: XOR<TipoEvolucaoSimplesUpdateManyMutationInput, TipoEvolucaoSimplesUncheckedUpdateManyInput>
    /**
     * Filter which TipoEvolucaoSimples to update
     */
    where?: TipoEvolucaoSimplesWhereInput
    /**
     * Limit how many TipoEvolucaoSimples to update.
     */
    limit?: number
  }

  /**
   * TipoEvolucaoSimples upsert
   */
  export type TipoEvolucaoSimplesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoSimples
     */
    select?: TipoEvolucaoSimplesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoSimples
     */
    omit?: TipoEvolucaoSimplesOmit<ExtArgs> | null
    /**
     * The filter to search for the TipoEvolucaoSimples to update in case it exists.
     */
    where: TipoEvolucaoSimplesWhereUniqueInput
    /**
     * In case the TipoEvolucaoSimples found by the `where` argument doesn't exist, create a new TipoEvolucaoSimples with this data.
     */
    create: XOR<TipoEvolucaoSimplesCreateInput, TipoEvolucaoSimplesUncheckedCreateInput>
    /**
     * In case the TipoEvolucaoSimples was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoEvolucaoSimplesUpdateInput, TipoEvolucaoSimplesUncheckedUpdateInput>
  }

  /**
   * TipoEvolucaoSimples delete
   */
  export type TipoEvolucaoSimplesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoSimples
     */
    select?: TipoEvolucaoSimplesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoSimples
     */
    omit?: TipoEvolucaoSimplesOmit<ExtArgs> | null
    /**
     * Filter which TipoEvolucaoSimples to delete.
     */
    where: TipoEvolucaoSimplesWhereUniqueInput
  }

  /**
   * TipoEvolucaoSimples deleteMany
   */
  export type TipoEvolucaoSimplesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoEvolucaoSimples to delete
     */
    where?: TipoEvolucaoSimplesWhereInput
    /**
     * Limit how many TipoEvolucaoSimples to delete.
     */
    limit?: number
  }

  /**
   * TipoEvolucaoSimples without action
   */
  export type TipoEvolucaoSimplesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoSimples
     */
    select?: TipoEvolucaoSimplesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoSimples
     */
    omit?: TipoEvolucaoSimplesOmit<ExtArgs> | null
  }


  /**
   * Model Pais
   */

  export type AggregatePais = {
    _count: PaisCountAggregateOutputType | null
    _avg: PaisAvgAggregateOutputType | null
    _sum: PaisSumAggregateOutputType | null
    _min: PaisMinAggregateOutputType | null
    _max: PaisMaxAggregateOutputType | null
  }

  export type PaisAvgAggregateOutputType = {
    id: number | null
    cdIbge: number | null
  }

  export type PaisSumAggregateOutputType = {
    id: number | null
    cdIbge: number | null
  }

  export type PaisMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    nacionalidade: string | null
    cdIbge: number | null
  }

  export type PaisMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    nacionalidade: string | null
    cdIbge: number | null
  }

  export type PaisCountAggregateOutputType = {
    id: number
    descricao: number
    nacionalidade: number
    cdIbge: number
    _all: number
  }


  export type PaisAvgAggregateInputType = {
    id?: true
    cdIbge?: true
  }

  export type PaisSumAggregateInputType = {
    id?: true
    cdIbge?: true
  }

  export type PaisMinAggregateInputType = {
    id?: true
    descricao?: true
    nacionalidade?: true
    cdIbge?: true
  }

  export type PaisMaxAggregateInputType = {
    id?: true
    descricao?: true
    nacionalidade?: true
    cdIbge?: true
  }

  export type PaisCountAggregateInputType = {
    id?: true
    descricao?: true
    nacionalidade?: true
    cdIbge?: true
    _all?: true
  }

  export type PaisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pais to aggregate.
     */
    where?: PaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pais to fetch.
     */
    orderBy?: PaisOrderByWithRelationInput | PaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pais
    **/
    _count?: true | PaisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaisMaxAggregateInputType
  }

  export type GetPaisAggregateType<T extends PaisAggregateArgs> = {
        [P in keyof T & keyof AggregatePais]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePais[P]>
      : GetScalarType<T[P], AggregatePais[P]>
  }




  export type PaisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaisWhereInput
    orderBy?: PaisOrderByWithAggregationInput | PaisOrderByWithAggregationInput[]
    by: PaisScalarFieldEnum[] | PaisScalarFieldEnum
    having?: PaisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaisCountAggregateInputType | true
    _avg?: PaisAvgAggregateInputType
    _sum?: PaisSumAggregateInputType
    _min?: PaisMinAggregateInputType
    _max?: PaisMaxAggregateInputType
  }

  export type PaisGroupByOutputType = {
    id: number
    descricao: string
    nacionalidade: string | null
    cdIbge: number | null
    _count: PaisCountAggregateOutputType | null
    _avg: PaisAvgAggregateOutputType | null
    _sum: PaisSumAggregateOutputType | null
    _min: PaisMinAggregateOutputType | null
    _max: PaisMaxAggregateOutputType | null
  }

  type GetPaisGroupByPayload<T extends PaisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaisGroupByOutputType[P]>
            : GetScalarType<T[P], PaisGroupByOutputType[P]>
        }
      >
    >


  export type PaisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    nacionalidade?: boolean
    cdIbge?: boolean
    cidades?: boolean | Pais$cidadesArgs<ExtArgs>
    _count?: boolean | PaisCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pais"]>

  export type PaisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    nacionalidade?: boolean
    cdIbge?: boolean
  }, ExtArgs["result"]["pais"]>

  export type PaisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    nacionalidade?: boolean
    cdIbge?: boolean
  }, ExtArgs["result"]["pais"]>

  export type PaisSelectScalar = {
    id?: boolean
    descricao?: boolean
    nacionalidade?: boolean
    cdIbge?: boolean
  }

  export type PaisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "nacionalidade" | "cdIbge", ExtArgs["result"]["pais"]>
  export type PaisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cidades?: boolean | Pais$cidadesArgs<ExtArgs>
    _count?: boolean | PaisCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PaisIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PaisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pais"
    objects: {
      cidades: Prisma.$CidadePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      nacionalidade: string | null
      cdIbge: number | null
    }, ExtArgs["result"]["pais"]>
    composites: {}
  }

  type PaisGetPayload<S extends boolean | null | undefined | PaisDefaultArgs> = $Result.GetResult<Prisma.$PaisPayload, S>

  type PaisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaisCountAggregateInputType | true
    }

  export interface PaisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pais'], meta: { name: 'Pais' } }
    /**
     * Find zero or one Pais that matches the filter.
     * @param {PaisFindUniqueArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaisFindUniqueArgs>(args: SelectSubset<T, PaisFindUniqueArgs<ExtArgs>>): Prisma__PaisClient<$Result.GetResult<Prisma.$PaisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pais that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaisFindUniqueOrThrowArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaisFindUniqueOrThrowArgs>(args: SelectSubset<T, PaisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaisClient<$Result.GetResult<Prisma.$PaisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaisFindFirstArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaisFindFirstArgs>(args?: SelectSubset<T, PaisFindFirstArgs<ExtArgs>>): Prisma__PaisClient<$Result.GetResult<Prisma.$PaisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pais that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaisFindFirstOrThrowArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaisFindFirstOrThrowArgs>(args?: SelectSubset<T, PaisFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaisClient<$Result.GetResult<Prisma.$PaisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pais
     * const pais = await prisma.pais.findMany()
     * 
     * // Get first 10 Pais
     * const pais = await prisma.pais.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paisWithIdOnly = await prisma.pais.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaisFindManyArgs>(args?: SelectSubset<T, PaisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pais.
     * @param {PaisCreateArgs} args - Arguments to create a Pais.
     * @example
     * // Create one Pais
     * const Pais = await prisma.pais.create({
     *   data: {
     *     // ... data to create a Pais
     *   }
     * })
     * 
     */
    create<T extends PaisCreateArgs>(args: SelectSubset<T, PaisCreateArgs<ExtArgs>>): Prisma__PaisClient<$Result.GetResult<Prisma.$PaisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pais.
     * @param {PaisCreateManyArgs} args - Arguments to create many Pais.
     * @example
     * // Create many Pais
     * const pais = await prisma.pais.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaisCreateManyArgs>(args?: SelectSubset<T, PaisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pais and returns the data saved in the database.
     * @param {PaisCreateManyAndReturnArgs} args - Arguments to create many Pais.
     * @example
     * // Create many Pais
     * const pais = await prisma.pais.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pais and only return the `id`
     * const paisWithIdOnly = await prisma.pais.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaisCreateManyAndReturnArgs>(args?: SelectSubset<T, PaisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pais.
     * @param {PaisDeleteArgs} args - Arguments to delete one Pais.
     * @example
     * // Delete one Pais
     * const Pais = await prisma.pais.delete({
     *   where: {
     *     // ... filter to delete one Pais
     *   }
     * })
     * 
     */
    delete<T extends PaisDeleteArgs>(args: SelectSubset<T, PaisDeleteArgs<ExtArgs>>): Prisma__PaisClient<$Result.GetResult<Prisma.$PaisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pais.
     * @param {PaisUpdateArgs} args - Arguments to update one Pais.
     * @example
     * // Update one Pais
     * const pais = await prisma.pais.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaisUpdateArgs>(args: SelectSubset<T, PaisUpdateArgs<ExtArgs>>): Prisma__PaisClient<$Result.GetResult<Prisma.$PaisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pais.
     * @param {PaisDeleteManyArgs} args - Arguments to filter Pais to delete.
     * @example
     * // Delete a few Pais
     * const { count } = await prisma.pais.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaisDeleteManyArgs>(args?: SelectSubset<T, PaisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pais
     * const pais = await prisma.pais.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaisUpdateManyArgs>(args: SelectSubset<T, PaisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pais and returns the data updated in the database.
     * @param {PaisUpdateManyAndReturnArgs} args - Arguments to update many Pais.
     * @example
     * // Update many Pais
     * const pais = await prisma.pais.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pais and only return the `id`
     * const paisWithIdOnly = await prisma.pais.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaisUpdateManyAndReturnArgs>(args: SelectSubset<T, PaisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pais.
     * @param {PaisUpsertArgs} args - Arguments to update or create a Pais.
     * @example
     * // Update or create a Pais
     * const pais = await prisma.pais.upsert({
     *   create: {
     *     // ... data to create a Pais
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pais we want to update
     *   }
     * })
     */
    upsert<T extends PaisUpsertArgs>(args: SelectSubset<T, PaisUpsertArgs<ExtArgs>>): Prisma__PaisClient<$Result.GetResult<Prisma.$PaisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaisCountArgs} args - Arguments to filter Pais to count.
     * @example
     * // Count the number of Pais
     * const count = await prisma.pais.count({
     *   where: {
     *     // ... the filter for the Pais we want to count
     *   }
     * })
    **/
    count<T extends PaisCountArgs>(
      args?: Subset<T, PaisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaisAggregateArgs>(args: Subset<T, PaisAggregateArgs>): Prisma.PrismaPromise<GetPaisAggregateType<T>>

    /**
     * Group by Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaisGroupByArgs['orderBy'] }
        : { orderBy?: PaisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pais model
   */
  readonly fields: PaisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pais.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cidades<T extends Pais$cidadesArgs<ExtArgs> = {}>(args?: Subset<T, Pais$cidadesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pais model
   */
  interface PaisFieldRefs {
    readonly id: FieldRef<"Pais", 'Int'>
    readonly descricao: FieldRef<"Pais", 'String'>
    readonly nacionalidade: FieldRef<"Pais", 'String'>
    readonly cdIbge: FieldRef<"Pais", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Pais findUnique
   */
  export type PaisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pais
     */
    select?: PaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pais
     */
    omit?: PaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaisInclude<ExtArgs> | null
    /**
     * Filter, which Pais to fetch.
     */
    where: PaisWhereUniqueInput
  }

  /**
   * Pais findUniqueOrThrow
   */
  export type PaisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pais
     */
    select?: PaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pais
     */
    omit?: PaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaisInclude<ExtArgs> | null
    /**
     * Filter, which Pais to fetch.
     */
    where: PaisWhereUniqueInput
  }

  /**
   * Pais findFirst
   */
  export type PaisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pais
     */
    select?: PaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pais
     */
    omit?: PaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaisInclude<ExtArgs> | null
    /**
     * Filter, which Pais to fetch.
     */
    where?: PaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pais to fetch.
     */
    orderBy?: PaisOrderByWithRelationInput | PaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pais.
     */
    cursor?: PaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pais.
     */
    distinct?: PaisScalarFieldEnum | PaisScalarFieldEnum[]
  }

  /**
   * Pais findFirstOrThrow
   */
  export type PaisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pais
     */
    select?: PaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pais
     */
    omit?: PaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaisInclude<ExtArgs> | null
    /**
     * Filter, which Pais to fetch.
     */
    where?: PaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pais to fetch.
     */
    orderBy?: PaisOrderByWithRelationInput | PaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pais.
     */
    cursor?: PaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pais.
     */
    distinct?: PaisScalarFieldEnum | PaisScalarFieldEnum[]
  }

  /**
   * Pais findMany
   */
  export type PaisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pais
     */
    select?: PaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pais
     */
    omit?: PaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaisInclude<ExtArgs> | null
    /**
     * Filter, which Pais to fetch.
     */
    where?: PaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pais to fetch.
     */
    orderBy?: PaisOrderByWithRelationInput | PaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pais.
     */
    cursor?: PaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pais.
     */
    skip?: number
    distinct?: PaisScalarFieldEnum | PaisScalarFieldEnum[]
  }

  /**
   * Pais create
   */
  export type PaisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pais
     */
    select?: PaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pais
     */
    omit?: PaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaisInclude<ExtArgs> | null
    /**
     * The data needed to create a Pais.
     */
    data: XOR<PaisCreateInput, PaisUncheckedCreateInput>
  }

  /**
   * Pais createMany
   */
  export type PaisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pais.
     */
    data: PaisCreateManyInput | PaisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pais createManyAndReturn
   */
  export type PaisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pais
     */
    select?: PaisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pais
     */
    omit?: PaisOmit<ExtArgs> | null
    /**
     * The data used to create many Pais.
     */
    data: PaisCreateManyInput | PaisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pais update
   */
  export type PaisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pais
     */
    select?: PaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pais
     */
    omit?: PaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaisInclude<ExtArgs> | null
    /**
     * The data needed to update a Pais.
     */
    data: XOR<PaisUpdateInput, PaisUncheckedUpdateInput>
    /**
     * Choose, which Pais to update.
     */
    where: PaisWhereUniqueInput
  }

  /**
   * Pais updateMany
   */
  export type PaisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pais.
     */
    data: XOR<PaisUpdateManyMutationInput, PaisUncheckedUpdateManyInput>
    /**
     * Filter which Pais to update
     */
    where?: PaisWhereInput
    /**
     * Limit how many Pais to update.
     */
    limit?: number
  }

  /**
   * Pais updateManyAndReturn
   */
  export type PaisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pais
     */
    select?: PaisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pais
     */
    omit?: PaisOmit<ExtArgs> | null
    /**
     * The data used to update Pais.
     */
    data: XOR<PaisUpdateManyMutationInput, PaisUncheckedUpdateManyInput>
    /**
     * Filter which Pais to update
     */
    where?: PaisWhereInput
    /**
     * Limit how many Pais to update.
     */
    limit?: number
  }

  /**
   * Pais upsert
   */
  export type PaisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pais
     */
    select?: PaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pais
     */
    omit?: PaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaisInclude<ExtArgs> | null
    /**
     * The filter to search for the Pais to update in case it exists.
     */
    where: PaisWhereUniqueInput
    /**
     * In case the Pais found by the `where` argument doesn't exist, create a new Pais with this data.
     */
    create: XOR<PaisCreateInput, PaisUncheckedCreateInput>
    /**
     * In case the Pais was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaisUpdateInput, PaisUncheckedUpdateInput>
  }

  /**
   * Pais delete
   */
  export type PaisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pais
     */
    select?: PaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pais
     */
    omit?: PaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaisInclude<ExtArgs> | null
    /**
     * Filter which Pais to delete.
     */
    where: PaisWhereUniqueInput
  }

  /**
   * Pais deleteMany
   */
  export type PaisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pais to delete
     */
    where?: PaisWhereInput
    /**
     * Limit how many Pais to delete.
     */
    limit?: number
  }

  /**
   * Pais.cidades
   */
  export type Pais$cidadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cidade
     */
    select?: CidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cidade
     */
    omit?: CidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidadeInclude<ExtArgs> | null
    where?: CidadeWhereInput
    orderBy?: CidadeOrderByWithRelationInput | CidadeOrderByWithRelationInput[]
    cursor?: CidadeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CidadeScalarFieldEnum | CidadeScalarFieldEnum[]
  }

  /**
   * Pais without action
   */
  export type PaisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pais
     */
    select?: PaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pais
     */
    omit?: PaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaisInclude<ExtArgs> | null
  }


  /**
   * Model UnidadeFederacao
   */

  export type AggregateUnidadeFederacao = {
    _count: UnidadeFederacaoCountAggregateOutputType | null
    _avg: UnidadeFederacaoAvgAggregateOutputType | null
    _sum: UnidadeFederacaoSumAggregateOutputType | null
    _min: UnidadeFederacaoMinAggregateOutputType | null
    _max: UnidadeFederacaoMaxAggregateOutputType | null
  }

  export type UnidadeFederacaoAvgAggregateOutputType = {
    cdIbge: number | null
  }

  export type UnidadeFederacaoSumAggregateOutputType = {
    cdIbge: number | null
  }

  export type UnidadeFederacaoMinAggregateOutputType = {
    id: string | null
    descricao: string | null
    cdIbge: number | null
  }

  export type UnidadeFederacaoMaxAggregateOutputType = {
    id: string | null
    descricao: string | null
    cdIbge: number | null
  }

  export type UnidadeFederacaoCountAggregateOutputType = {
    id: number
    descricao: number
    cdIbge: number
    _all: number
  }


  export type UnidadeFederacaoAvgAggregateInputType = {
    cdIbge?: true
  }

  export type UnidadeFederacaoSumAggregateInputType = {
    cdIbge?: true
  }

  export type UnidadeFederacaoMinAggregateInputType = {
    id?: true
    descricao?: true
    cdIbge?: true
  }

  export type UnidadeFederacaoMaxAggregateInputType = {
    id?: true
    descricao?: true
    cdIbge?: true
  }

  export type UnidadeFederacaoCountAggregateInputType = {
    id?: true
    descricao?: true
    cdIbge?: true
    _all?: true
  }

  export type UnidadeFederacaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnidadeFederacao to aggregate.
     */
    where?: UnidadeFederacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnidadeFederacaos to fetch.
     */
    orderBy?: UnidadeFederacaoOrderByWithRelationInput | UnidadeFederacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnidadeFederacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnidadeFederacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnidadeFederacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnidadeFederacaos
    **/
    _count?: true | UnidadeFederacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnidadeFederacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnidadeFederacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnidadeFederacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnidadeFederacaoMaxAggregateInputType
  }

  export type GetUnidadeFederacaoAggregateType<T extends UnidadeFederacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateUnidadeFederacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnidadeFederacao[P]>
      : GetScalarType<T[P], AggregateUnidadeFederacao[P]>
  }




  export type UnidadeFederacaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnidadeFederacaoWhereInput
    orderBy?: UnidadeFederacaoOrderByWithAggregationInput | UnidadeFederacaoOrderByWithAggregationInput[]
    by: UnidadeFederacaoScalarFieldEnum[] | UnidadeFederacaoScalarFieldEnum
    having?: UnidadeFederacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnidadeFederacaoCountAggregateInputType | true
    _avg?: UnidadeFederacaoAvgAggregateInputType
    _sum?: UnidadeFederacaoSumAggregateInputType
    _min?: UnidadeFederacaoMinAggregateInputType
    _max?: UnidadeFederacaoMaxAggregateInputType
  }

  export type UnidadeFederacaoGroupByOutputType = {
    id: string
    descricao: string
    cdIbge: number | null
    _count: UnidadeFederacaoCountAggregateOutputType | null
    _avg: UnidadeFederacaoAvgAggregateOutputType | null
    _sum: UnidadeFederacaoSumAggregateOutputType | null
    _min: UnidadeFederacaoMinAggregateOutputType | null
    _max: UnidadeFederacaoMaxAggregateOutputType | null
  }

  type GetUnidadeFederacaoGroupByPayload<T extends UnidadeFederacaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnidadeFederacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnidadeFederacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnidadeFederacaoGroupByOutputType[P]>
            : GetScalarType<T[P], UnidadeFederacaoGroupByOutputType[P]>
        }
      >
    >


  export type UnidadeFederacaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    cdIbge?: boolean
    cidades?: boolean | UnidadeFederacao$cidadesArgs<ExtArgs>
    _count?: boolean | UnidadeFederacaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unidadeFederacao"]>

  export type UnidadeFederacaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    cdIbge?: boolean
  }, ExtArgs["result"]["unidadeFederacao"]>

  export type UnidadeFederacaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    cdIbge?: boolean
  }, ExtArgs["result"]["unidadeFederacao"]>

  export type UnidadeFederacaoSelectScalar = {
    id?: boolean
    descricao?: boolean
    cdIbge?: boolean
  }

  export type UnidadeFederacaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "cdIbge", ExtArgs["result"]["unidadeFederacao"]>
  export type UnidadeFederacaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cidades?: boolean | UnidadeFederacao$cidadesArgs<ExtArgs>
    _count?: boolean | UnidadeFederacaoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnidadeFederacaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UnidadeFederacaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnidadeFederacaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnidadeFederacao"
    objects: {
      cidades: Prisma.$CidadePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      descricao: string
      cdIbge: number | null
    }, ExtArgs["result"]["unidadeFederacao"]>
    composites: {}
  }

  type UnidadeFederacaoGetPayload<S extends boolean | null | undefined | UnidadeFederacaoDefaultArgs> = $Result.GetResult<Prisma.$UnidadeFederacaoPayload, S>

  type UnidadeFederacaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnidadeFederacaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnidadeFederacaoCountAggregateInputType | true
    }

  export interface UnidadeFederacaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnidadeFederacao'], meta: { name: 'UnidadeFederacao' } }
    /**
     * Find zero or one UnidadeFederacao that matches the filter.
     * @param {UnidadeFederacaoFindUniqueArgs} args - Arguments to find a UnidadeFederacao
     * @example
     * // Get one UnidadeFederacao
     * const unidadeFederacao = await prisma.unidadeFederacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnidadeFederacaoFindUniqueArgs>(args: SelectSubset<T, UnidadeFederacaoFindUniqueArgs<ExtArgs>>): Prisma__UnidadeFederacaoClient<$Result.GetResult<Prisma.$UnidadeFederacaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnidadeFederacao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnidadeFederacaoFindUniqueOrThrowArgs} args - Arguments to find a UnidadeFederacao
     * @example
     * // Get one UnidadeFederacao
     * const unidadeFederacao = await prisma.unidadeFederacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnidadeFederacaoFindUniqueOrThrowArgs>(args: SelectSubset<T, UnidadeFederacaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnidadeFederacaoClient<$Result.GetResult<Prisma.$UnidadeFederacaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnidadeFederacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadeFederacaoFindFirstArgs} args - Arguments to find a UnidadeFederacao
     * @example
     * // Get one UnidadeFederacao
     * const unidadeFederacao = await prisma.unidadeFederacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnidadeFederacaoFindFirstArgs>(args?: SelectSubset<T, UnidadeFederacaoFindFirstArgs<ExtArgs>>): Prisma__UnidadeFederacaoClient<$Result.GetResult<Prisma.$UnidadeFederacaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnidadeFederacao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadeFederacaoFindFirstOrThrowArgs} args - Arguments to find a UnidadeFederacao
     * @example
     * // Get one UnidadeFederacao
     * const unidadeFederacao = await prisma.unidadeFederacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnidadeFederacaoFindFirstOrThrowArgs>(args?: SelectSubset<T, UnidadeFederacaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnidadeFederacaoClient<$Result.GetResult<Prisma.$UnidadeFederacaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnidadeFederacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadeFederacaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnidadeFederacaos
     * const unidadeFederacaos = await prisma.unidadeFederacao.findMany()
     * 
     * // Get first 10 UnidadeFederacaos
     * const unidadeFederacaos = await prisma.unidadeFederacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unidadeFederacaoWithIdOnly = await prisma.unidadeFederacao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnidadeFederacaoFindManyArgs>(args?: SelectSubset<T, UnidadeFederacaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnidadeFederacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnidadeFederacao.
     * @param {UnidadeFederacaoCreateArgs} args - Arguments to create a UnidadeFederacao.
     * @example
     * // Create one UnidadeFederacao
     * const UnidadeFederacao = await prisma.unidadeFederacao.create({
     *   data: {
     *     // ... data to create a UnidadeFederacao
     *   }
     * })
     * 
     */
    create<T extends UnidadeFederacaoCreateArgs>(args: SelectSubset<T, UnidadeFederacaoCreateArgs<ExtArgs>>): Prisma__UnidadeFederacaoClient<$Result.GetResult<Prisma.$UnidadeFederacaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnidadeFederacaos.
     * @param {UnidadeFederacaoCreateManyArgs} args - Arguments to create many UnidadeFederacaos.
     * @example
     * // Create many UnidadeFederacaos
     * const unidadeFederacao = await prisma.unidadeFederacao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnidadeFederacaoCreateManyArgs>(args?: SelectSubset<T, UnidadeFederacaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnidadeFederacaos and returns the data saved in the database.
     * @param {UnidadeFederacaoCreateManyAndReturnArgs} args - Arguments to create many UnidadeFederacaos.
     * @example
     * // Create many UnidadeFederacaos
     * const unidadeFederacao = await prisma.unidadeFederacao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnidadeFederacaos and only return the `id`
     * const unidadeFederacaoWithIdOnly = await prisma.unidadeFederacao.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnidadeFederacaoCreateManyAndReturnArgs>(args?: SelectSubset<T, UnidadeFederacaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnidadeFederacaoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnidadeFederacao.
     * @param {UnidadeFederacaoDeleteArgs} args - Arguments to delete one UnidadeFederacao.
     * @example
     * // Delete one UnidadeFederacao
     * const UnidadeFederacao = await prisma.unidadeFederacao.delete({
     *   where: {
     *     // ... filter to delete one UnidadeFederacao
     *   }
     * })
     * 
     */
    delete<T extends UnidadeFederacaoDeleteArgs>(args: SelectSubset<T, UnidadeFederacaoDeleteArgs<ExtArgs>>): Prisma__UnidadeFederacaoClient<$Result.GetResult<Prisma.$UnidadeFederacaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnidadeFederacao.
     * @param {UnidadeFederacaoUpdateArgs} args - Arguments to update one UnidadeFederacao.
     * @example
     * // Update one UnidadeFederacao
     * const unidadeFederacao = await prisma.unidadeFederacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnidadeFederacaoUpdateArgs>(args: SelectSubset<T, UnidadeFederacaoUpdateArgs<ExtArgs>>): Prisma__UnidadeFederacaoClient<$Result.GetResult<Prisma.$UnidadeFederacaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnidadeFederacaos.
     * @param {UnidadeFederacaoDeleteManyArgs} args - Arguments to filter UnidadeFederacaos to delete.
     * @example
     * // Delete a few UnidadeFederacaos
     * const { count } = await prisma.unidadeFederacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnidadeFederacaoDeleteManyArgs>(args?: SelectSubset<T, UnidadeFederacaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnidadeFederacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadeFederacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnidadeFederacaos
     * const unidadeFederacao = await prisma.unidadeFederacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnidadeFederacaoUpdateManyArgs>(args: SelectSubset<T, UnidadeFederacaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnidadeFederacaos and returns the data updated in the database.
     * @param {UnidadeFederacaoUpdateManyAndReturnArgs} args - Arguments to update many UnidadeFederacaos.
     * @example
     * // Update many UnidadeFederacaos
     * const unidadeFederacao = await prisma.unidadeFederacao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnidadeFederacaos and only return the `id`
     * const unidadeFederacaoWithIdOnly = await prisma.unidadeFederacao.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnidadeFederacaoUpdateManyAndReturnArgs>(args: SelectSubset<T, UnidadeFederacaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnidadeFederacaoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnidadeFederacao.
     * @param {UnidadeFederacaoUpsertArgs} args - Arguments to update or create a UnidadeFederacao.
     * @example
     * // Update or create a UnidadeFederacao
     * const unidadeFederacao = await prisma.unidadeFederacao.upsert({
     *   create: {
     *     // ... data to create a UnidadeFederacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnidadeFederacao we want to update
     *   }
     * })
     */
    upsert<T extends UnidadeFederacaoUpsertArgs>(args: SelectSubset<T, UnidadeFederacaoUpsertArgs<ExtArgs>>): Prisma__UnidadeFederacaoClient<$Result.GetResult<Prisma.$UnidadeFederacaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnidadeFederacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadeFederacaoCountArgs} args - Arguments to filter UnidadeFederacaos to count.
     * @example
     * // Count the number of UnidadeFederacaos
     * const count = await prisma.unidadeFederacao.count({
     *   where: {
     *     // ... the filter for the UnidadeFederacaos we want to count
     *   }
     * })
    **/
    count<T extends UnidadeFederacaoCountArgs>(
      args?: Subset<T, UnidadeFederacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnidadeFederacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnidadeFederacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadeFederacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnidadeFederacaoAggregateArgs>(args: Subset<T, UnidadeFederacaoAggregateArgs>): Prisma.PrismaPromise<GetUnidadeFederacaoAggregateType<T>>

    /**
     * Group by UnidadeFederacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnidadeFederacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnidadeFederacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnidadeFederacaoGroupByArgs['orderBy'] }
        : { orderBy?: UnidadeFederacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnidadeFederacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnidadeFederacaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnidadeFederacao model
   */
  readonly fields: UnidadeFederacaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnidadeFederacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnidadeFederacaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cidades<T extends UnidadeFederacao$cidadesArgs<ExtArgs> = {}>(args?: Subset<T, UnidadeFederacao$cidadesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnidadeFederacao model
   */
  interface UnidadeFederacaoFieldRefs {
    readonly id: FieldRef<"UnidadeFederacao", 'String'>
    readonly descricao: FieldRef<"UnidadeFederacao", 'String'>
    readonly cdIbge: FieldRef<"UnidadeFederacao", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UnidadeFederacao findUnique
   */
  export type UnidadeFederacaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadeFederacao
     */
    select?: UnidadeFederacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadeFederacao
     */
    omit?: UnidadeFederacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeFederacaoInclude<ExtArgs> | null
    /**
     * Filter, which UnidadeFederacao to fetch.
     */
    where: UnidadeFederacaoWhereUniqueInput
  }

  /**
   * UnidadeFederacao findUniqueOrThrow
   */
  export type UnidadeFederacaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadeFederacao
     */
    select?: UnidadeFederacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadeFederacao
     */
    omit?: UnidadeFederacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeFederacaoInclude<ExtArgs> | null
    /**
     * Filter, which UnidadeFederacao to fetch.
     */
    where: UnidadeFederacaoWhereUniqueInput
  }

  /**
   * UnidadeFederacao findFirst
   */
  export type UnidadeFederacaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadeFederacao
     */
    select?: UnidadeFederacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadeFederacao
     */
    omit?: UnidadeFederacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeFederacaoInclude<ExtArgs> | null
    /**
     * Filter, which UnidadeFederacao to fetch.
     */
    where?: UnidadeFederacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnidadeFederacaos to fetch.
     */
    orderBy?: UnidadeFederacaoOrderByWithRelationInput | UnidadeFederacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnidadeFederacaos.
     */
    cursor?: UnidadeFederacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnidadeFederacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnidadeFederacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnidadeFederacaos.
     */
    distinct?: UnidadeFederacaoScalarFieldEnum | UnidadeFederacaoScalarFieldEnum[]
  }

  /**
   * UnidadeFederacao findFirstOrThrow
   */
  export type UnidadeFederacaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadeFederacao
     */
    select?: UnidadeFederacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadeFederacao
     */
    omit?: UnidadeFederacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeFederacaoInclude<ExtArgs> | null
    /**
     * Filter, which UnidadeFederacao to fetch.
     */
    where?: UnidadeFederacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnidadeFederacaos to fetch.
     */
    orderBy?: UnidadeFederacaoOrderByWithRelationInput | UnidadeFederacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnidadeFederacaos.
     */
    cursor?: UnidadeFederacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnidadeFederacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnidadeFederacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnidadeFederacaos.
     */
    distinct?: UnidadeFederacaoScalarFieldEnum | UnidadeFederacaoScalarFieldEnum[]
  }

  /**
   * UnidadeFederacao findMany
   */
  export type UnidadeFederacaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadeFederacao
     */
    select?: UnidadeFederacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadeFederacao
     */
    omit?: UnidadeFederacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeFederacaoInclude<ExtArgs> | null
    /**
     * Filter, which UnidadeFederacaos to fetch.
     */
    where?: UnidadeFederacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnidadeFederacaos to fetch.
     */
    orderBy?: UnidadeFederacaoOrderByWithRelationInput | UnidadeFederacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnidadeFederacaos.
     */
    cursor?: UnidadeFederacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnidadeFederacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnidadeFederacaos.
     */
    skip?: number
    distinct?: UnidadeFederacaoScalarFieldEnum | UnidadeFederacaoScalarFieldEnum[]
  }

  /**
   * UnidadeFederacao create
   */
  export type UnidadeFederacaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadeFederacao
     */
    select?: UnidadeFederacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadeFederacao
     */
    omit?: UnidadeFederacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeFederacaoInclude<ExtArgs> | null
    /**
     * The data needed to create a UnidadeFederacao.
     */
    data: XOR<UnidadeFederacaoCreateInput, UnidadeFederacaoUncheckedCreateInput>
  }

  /**
   * UnidadeFederacao createMany
   */
  export type UnidadeFederacaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnidadeFederacaos.
     */
    data: UnidadeFederacaoCreateManyInput | UnidadeFederacaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnidadeFederacao createManyAndReturn
   */
  export type UnidadeFederacaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadeFederacao
     */
    select?: UnidadeFederacaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadeFederacao
     */
    omit?: UnidadeFederacaoOmit<ExtArgs> | null
    /**
     * The data used to create many UnidadeFederacaos.
     */
    data: UnidadeFederacaoCreateManyInput | UnidadeFederacaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnidadeFederacao update
   */
  export type UnidadeFederacaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadeFederacao
     */
    select?: UnidadeFederacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadeFederacao
     */
    omit?: UnidadeFederacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeFederacaoInclude<ExtArgs> | null
    /**
     * The data needed to update a UnidadeFederacao.
     */
    data: XOR<UnidadeFederacaoUpdateInput, UnidadeFederacaoUncheckedUpdateInput>
    /**
     * Choose, which UnidadeFederacao to update.
     */
    where: UnidadeFederacaoWhereUniqueInput
  }

  /**
   * UnidadeFederacao updateMany
   */
  export type UnidadeFederacaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnidadeFederacaos.
     */
    data: XOR<UnidadeFederacaoUpdateManyMutationInput, UnidadeFederacaoUncheckedUpdateManyInput>
    /**
     * Filter which UnidadeFederacaos to update
     */
    where?: UnidadeFederacaoWhereInput
    /**
     * Limit how many UnidadeFederacaos to update.
     */
    limit?: number
  }

  /**
   * UnidadeFederacao updateManyAndReturn
   */
  export type UnidadeFederacaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadeFederacao
     */
    select?: UnidadeFederacaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadeFederacao
     */
    omit?: UnidadeFederacaoOmit<ExtArgs> | null
    /**
     * The data used to update UnidadeFederacaos.
     */
    data: XOR<UnidadeFederacaoUpdateManyMutationInput, UnidadeFederacaoUncheckedUpdateManyInput>
    /**
     * Filter which UnidadeFederacaos to update
     */
    where?: UnidadeFederacaoWhereInput
    /**
     * Limit how many UnidadeFederacaos to update.
     */
    limit?: number
  }

  /**
   * UnidadeFederacao upsert
   */
  export type UnidadeFederacaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadeFederacao
     */
    select?: UnidadeFederacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadeFederacao
     */
    omit?: UnidadeFederacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeFederacaoInclude<ExtArgs> | null
    /**
     * The filter to search for the UnidadeFederacao to update in case it exists.
     */
    where: UnidadeFederacaoWhereUniqueInput
    /**
     * In case the UnidadeFederacao found by the `where` argument doesn't exist, create a new UnidadeFederacao with this data.
     */
    create: XOR<UnidadeFederacaoCreateInput, UnidadeFederacaoUncheckedCreateInput>
    /**
     * In case the UnidadeFederacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnidadeFederacaoUpdateInput, UnidadeFederacaoUncheckedUpdateInput>
  }

  /**
   * UnidadeFederacao delete
   */
  export type UnidadeFederacaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadeFederacao
     */
    select?: UnidadeFederacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadeFederacao
     */
    omit?: UnidadeFederacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeFederacaoInclude<ExtArgs> | null
    /**
     * Filter which UnidadeFederacao to delete.
     */
    where: UnidadeFederacaoWhereUniqueInput
  }

  /**
   * UnidadeFederacao deleteMany
   */
  export type UnidadeFederacaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnidadeFederacaos to delete
     */
    where?: UnidadeFederacaoWhereInput
    /**
     * Limit how many UnidadeFederacaos to delete.
     */
    limit?: number
  }

  /**
   * UnidadeFederacao.cidades
   */
  export type UnidadeFederacao$cidadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cidade
     */
    select?: CidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cidade
     */
    omit?: CidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidadeInclude<ExtArgs> | null
    where?: CidadeWhereInput
    orderBy?: CidadeOrderByWithRelationInput | CidadeOrderByWithRelationInput[]
    cursor?: CidadeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CidadeScalarFieldEnum | CidadeScalarFieldEnum[]
  }

  /**
   * UnidadeFederacao without action
   */
  export type UnidadeFederacaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnidadeFederacao
     */
    select?: UnidadeFederacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnidadeFederacao
     */
    omit?: UnidadeFederacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnidadeFederacaoInclude<ExtArgs> | null
  }


  /**
   * Model Cidade
   */

  export type AggregateCidade = {
    _count: CidadeCountAggregateOutputType | null
    _avg: CidadeAvgAggregateOutputType | null
    _sum: CidadeSumAggregateOutputType | null
    _min: CidadeMinAggregateOutputType | null
    _max: CidadeMaxAggregateOutputType | null
  }

  export type CidadeAvgAggregateOutputType = {
    id: number | null
    cdPais: number | null
    cdIbge: number | null
  }

  export type CidadeSumAggregateOutputType = {
    id: number | null
    cdPais: number | null
    cdIbge: number | null
  }

  export type CidadeMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    cdUf: string | null
    cdPais: number | null
    cepGeral: string | null
    cdIbge: number | null
    stInativo: $Enums.SimNao | null
  }

  export type CidadeMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    cdUf: string | null
    cdPais: number | null
    cepGeral: string | null
    cdIbge: number | null
    stInativo: $Enums.SimNao | null
  }

  export type CidadeCountAggregateOutputType = {
    id: number
    descricao: number
    cdUf: number
    cdPais: number
    cepGeral: number
    cdIbge: number
    stInativo: number
    _all: number
  }


  export type CidadeAvgAggregateInputType = {
    id?: true
    cdPais?: true
    cdIbge?: true
  }

  export type CidadeSumAggregateInputType = {
    id?: true
    cdPais?: true
    cdIbge?: true
  }

  export type CidadeMinAggregateInputType = {
    id?: true
    descricao?: true
    cdUf?: true
    cdPais?: true
    cepGeral?: true
    cdIbge?: true
    stInativo?: true
  }

  export type CidadeMaxAggregateInputType = {
    id?: true
    descricao?: true
    cdUf?: true
    cdPais?: true
    cepGeral?: true
    cdIbge?: true
    stInativo?: true
  }

  export type CidadeCountAggregateInputType = {
    id?: true
    descricao?: true
    cdUf?: true
    cdPais?: true
    cepGeral?: true
    cdIbge?: true
    stInativo?: true
    _all?: true
  }

  export type CidadeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cidade to aggregate.
     */
    where?: CidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cidades to fetch.
     */
    orderBy?: CidadeOrderByWithRelationInput | CidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cidades
    **/
    _count?: true | CidadeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CidadeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CidadeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CidadeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CidadeMaxAggregateInputType
  }

  export type GetCidadeAggregateType<T extends CidadeAggregateArgs> = {
        [P in keyof T & keyof AggregateCidade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCidade[P]>
      : GetScalarType<T[P], AggregateCidade[P]>
  }




  export type CidadeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CidadeWhereInput
    orderBy?: CidadeOrderByWithAggregationInput | CidadeOrderByWithAggregationInput[]
    by: CidadeScalarFieldEnum[] | CidadeScalarFieldEnum
    having?: CidadeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CidadeCountAggregateInputType | true
    _avg?: CidadeAvgAggregateInputType
    _sum?: CidadeSumAggregateInputType
    _min?: CidadeMinAggregateInputType
    _max?: CidadeMaxAggregateInputType
  }

  export type CidadeGroupByOutputType = {
    id: number
    descricao: string
    cdUf: string
    cdPais: number
    cepGeral: string | null
    cdIbge: number | null
    stInativo: $Enums.SimNao | null
    _count: CidadeCountAggregateOutputType | null
    _avg: CidadeAvgAggregateOutputType | null
    _sum: CidadeSumAggregateOutputType | null
    _min: CidadeMinAggregateOutputType | null
    _max: CidadeMaxAggregateOutputType | null
  }

  type GetCidadeGroupByPayload<T extends CidadeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CidadeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CidadeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CidadeGroupByOutputType[P]>
            : GetScalarType<T[P], CidadeGroupByOutputType[P]>
        }
      >
    >


  export type CidadeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    cdUf?: boolean
    cdPais?: boolean
    cepGeral?: boolean
    cdIbge?: boolean
    stInativo?: boolean
    bairros?: boolean | Cidade$bairrosArgs<ExtArgs>
    pais?: boolean | PaisDefaultArgs<ExtArgs>
    uf?: boolean | UnidadeFederacaoDefaultArgs<ExtArgs>
    distritos?: boolean | Cidade$distritosArgs<ExtArgs>
    enderecos?: boolean | Cidade$enderecosArgs<ExtArgs>
    _count?: boolean | CidadeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cidade"]>

  export type CidadeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    cdUf?: boolean
    cdPais?: boolean
    cepGeral?: boolean
    cdIbge?: boolean
    stInativo?: boolean
    pais?: boolean | PaisDefaultArgs<ExtArgs>
    uf?: boolean | UnidadeFederacaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cidade"]>

  export type CidadeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    cdUf?: boolean
    cdPais?: boolean
    cepGeral?: boolean
    cdIbge?: boolean
    stInativo?: boolean
    pais?: boolean | PaisDefaultArgs<ExtArgs>
    uf?: boolean | UnidadeFederacaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cidade"]>

  export type CidadeSelectScalar = {
    id?: boolean
    descricao?: boolean
    cdUf?: boolean
    cdPais?: boolean
    cepGeral?: boolean
    cdIbge?: boolean
    stInativo?: boolean
  }

  export type CidadeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "cdUf" | "cdPais" | "cepGeral" | "cdIbge" | "stInativo", ExtArgs["result"]["cidade"]>
  export type CidadeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bairros?: boolean | Cidade$bairrosArgs<ExtArgs>
    pais?: boolean | PaisDefaultArgs<ExtArgs>
    uf?: boolean | UnidadeFederacaoDefaultArgs<ExtArgs>
    distritos?: boolean | Cidade$distritosArgs<ExtArgs>
    enderecos?: boolean | Cidade$enderecosArgs<ExtArgs>
    _count?: boolean | CidadeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CidadeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | PaisDefaultArgs<ExtArgs>
    uf?: boolean | UnidadeFederacaoDefaultArgs<ExtArgs>
  }
  export type CidadeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | PaisDefaultArgs<ExtArgs>
    uf?: boolean | UnidadeFederacaoDefaultArgs<ExtArgs>
  }

  export type $CidadePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cidade"
    objects: {
      bairros: Prisma.$BairroPayload<ExtArgs>[]
      pais: Prisma.$PaisPayload<ExtArgs>
      uf: Prisma.$UnidadeFederacaoPayload<ExtArgs>
      distritos: Prisma.$DistritoPayload<ExtArgs>[]
      enderecos: Prisma.$EnderecoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      cdUf: string
      cdPais: number
      cepGeral: string | null
      cdIbge: number | null
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["cidade"]>
    composites: {}
  }

  type CidadeGetPayload<S extends boolean | null | undefined | CidadeDefaultArgs> = $Result.GetResult<Prisma.$CidadePayload, S>

  type CidadeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CidadeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CidadeCountAggregateInputType | true
    }

  export interface CidadeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cidade'], meta: { name: 'Cidade' } }
    /**
     * Find zero or one Cidade that matches the filter.
     * @param {CidadeFindUniqueArgs} args - Arguments to find a Cidade
     * @example
     * // Get one Cidade
     * const cidade = await prisma.cidade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CidadeFindUniqueArgs>(args: SelectSubset<T, CidadeFindUniqueArgs<ExtArgs>>): Prisma__CidadeClient<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cidade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CidadeFindUniqueOrThrowArgs} args - Arguments to find a Cidade
     * @example
     * // Get one Cidade
     * const cidade = await prisma.cidade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CidadeFindUniqueOrThrowArgs>(args: SelectSubset<T, CidadeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CidadeClient<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cidade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidadeFindFirstArgs} args - Arguments to find a Cidade
     * @example
     * // Get one Cidade
     * const cidade = await prisma.cidade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CidadeFindFirstArgs>(args?: SelectSubset<T, CidadeFindFirstArgs<ExtArgs>>): Prisma__CidadeClient<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cidade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidadeFindFirstOrThrowArgs} args - Arguments to find a Cidade
     * @example
     * // Get one Cidade
     * const cidade = await prisma.cidade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CidadeFindFirstOrThrowArgs>(args?: SelectSubset<T, CidadeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CidadeClient<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cidades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidadeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cidades
     * const cidades = await prisma.cidade.findMany()
     * 
     * // Get first 10 Cidades
     * const cidades = await prisma.cidade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cidadeWithIdOnly = await prisma.cidade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CidadeFindManyArgs>(args?: SelectSubset<T, CidadeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cidade.
     * @param {CidadeCreateArgs} args - Arguments to create a Cidade.
     * @example
     * // Create one Cidade
     * const Cidade = await prisma.cidade.create({
     *   data: {
     *     // ... data to create a Cidade
     *   }
     * })
     * 
     */
    create<T extends CidadeCreateArgs>(args: SelectSubset<T, CidadeCreateArgs<ExtArgs>>): Prisma__CidadeClient<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cidades.
     * @param {CidadeCreateManyArgs} args - Arguments to create many Cidades.
     * @example
     * // Create many Cidades
     * const cidade = await prisma.cidade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CidadeCreateManyArgs>(args?: SelectSubset<T, CidadeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cidades and returns the data saved in the database.
     * @param {CidadeCreateManyAndReturnArgs} args - Arguments to create many Cidades.
     * @example
     * // Create many Cidades
     * const cidade = await prisma.cidade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cidades and only return the `id`
     * const cidadeWithIdOnly = await prisma.cidade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CidadeCreateManyAndReturnArgs>(args?: SelectSubset<T, CidadeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cidade.
     * @param {CidadeDeleteArgs} args - Arguments to delete one Cidade.
     * @example
     * // Delete one Cidade
     * const Cidade = await prisma.cidade.delete({
     *   where: {
     *     // ... filter to delete one Cidade
     *   }
     * })
     * 
     */
    delete<T extends CidadeDeleteArgs>(args: SelectSubset<T, CidadeDeleteArgs<ExtArgs>>): Prisma__CidadeClient<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cidade.
     * @param {CidadeUpdateArgs} args - Arguments to update one Cidade.
     * @example
     * // Update one Cidade
     * const cidade = await prisma.cidade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CidadeUpdateArgs>(args: SelectSubset<T, CidadeUpdateArgs<ExtArgs>>): Prisma__CidadeClient<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cidades.
     * @param {CidadeDeleteManyArgs} args - Arguments to filter Cidades to delete.
     * @example
     * // Delete a few Cidades
     * const { count } = await prisma.cidade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CidadeDeleteManyArgs>(args?: SelectSubset<T, CidadeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidadeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cidades
     * const cidade = await prisma.cidade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CidadeUpdateManyArgs>(args: SelectSubset<T, CidadeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cidades and returns the data updated in the database.
     * @param {CidadeUpdateManyAndReturnArgs} args - Arguments to update many Cidades.
     * @example
     * // Update many Cidades
     * const cidade = await prisma.cidade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cidades and only return the `id`
     * const cidadeWithIdOnly = await prisma.cidade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CidadeUpdateManyAndReturnArgs>(args: SelectSubset<T, CidadeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cidade.
     * @param {CidadeUpsertArgs} args - Arguments to update or create a Cidade.
     * @example
     * // Update or create a Cidade
     * const cidade = await prisma.cidade.upsert({
     *   create: {
     *     // ... data to create a Cidade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cidade we want to update
     *   }
     * })
     */
    upsert<T extends CidadeUpsertArgs>(args: SelectSubset<T, CidadeUpsertArgs<ExtArgs>>): Prisma__CidadeClient<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidadeCountArgs} args - Arguments to filter Cidades to count.
     * @example
     * // Count the number of Cidades
     * const count = await prisma.cidade.count({
     *   where: {
     *     // ... the filter for the Cidades we want to count
     *   }
     * })
    **/
    count<T extends CidadeCountArgs>(
      args?: Subset<T, CidadeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CidadeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidadeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CidadeAggregateArgs>(args: Subset<T, CidadeAggregateArgs>): Prisma.PrismaPromise<GetCidadeAggregateType<T>>

    /**
     * Group by Cidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidadeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CidadeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CidadeGroupByArgs['orderBy'] }
        : { orderBy?: CidadeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CidadeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCidadeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cidade model
   */
  readonly fields: CidadeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cidade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CidadeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bairros<T extends Cidade$bairrosArgs<ExtArgs> = {}>(args?: Subset<T, Cidade$bairrosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BairroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pais<T extends PaisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaisDefaultArgs<ExtArgs>>): Prisma__PaisClient<$Result.GetResult<Prisma.$PaisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uf<T extends UnidadeFederacaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnidadeFederacaoDefaultArgs<ExtArgs>>): Prisma__UnidadeFederacaoClient<$Result.GetResult<Prisma.$UnidadeFederacaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    distritos<T extends Cidade$distritosArgs<ExtArgs> = {}>(args?: Subset<T, Cidade$distritosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enderecos<T extends Cidade$enderecosArgs<ExtArgs> = {}>(args?: Subset<T, Cidade$enderecosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cidade model
   */
  interface CidadeFieldRefs {
    readonly id: FieldRef<"Cidade", 'Int'>
    readonly descricao: FieldRef<"Cidade", 'String'>
    readonly cdUf: FieldRef<"Cidade", 'String'>
    readonly cdPais: FieldRef<"Cidade", 'Int'>
    readonly cepGeral: FieldRef<"Cidade", 'String'>
    readonly cdIbge: FieldRef<"Cidade", 'Int'>
    readonly stInativo: FieldRef<"Cidade", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * Cidade findUnique
   */
  export type CidadeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cidade
     */
    select?: CidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cidade
     */
    omit?: CidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidadeInclude<ExtArgs> | null
    /**
     * Filter, which Cidade to fetch.
     */
    where: CidadeWhereUniqueInput
  }

  /**
   * Cidade findUniqueOrThrow
   */
  export type CidadeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cidade
     */
    select?: CidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cidade
     */
    omit?: CidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidadeInclude<ExtArgs> | null
    /**
     * Filter, which Cidade to fetch.
     */
    where: CidadeWhereUniqueInput
  }

  /**
   * Cidade findFirst
   */
  export type CidadeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cidade
     */
    select?: CidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cidade
     */
    omit?: CidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidadeInclude<ExtArgs> | null
    /**
     * Filter, which Cidade to fetch.
     */
    where?: CidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cidades to fetch.
     */
    orderBy?: CidadeOrderByWithRelationInput | CidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cidades.
     */
    cursor?: CidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cidades.
     */
    distinct?: CidadeScalarFieldEnum | CidadeScalarFieldEnum[]
  }

  /**
   * Cidade findFirstOrThrow
   */
  export type CidadeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cidade
     */
    select?: CidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cidade
     */
    omit?: CidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidadeInclude<ExtArgs> | null
    /**
     * Filter, which Cidade to fetch.
     */
    where?: CidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cidades to fetch.
     */
    orderBy?: CidadeOrderByWithRelationInput | CidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cidades.
     */
    cursor?: CidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cidades.
     */
    distinct?: CidadeScalarFieldEnum | CidadeScalarFieldEnum[]
  }

  /**
   * Cidade findMany
   */
  export type CidadeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cidade
     */
    select?: CidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cidade
     */
    omit?: CidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidadeInclude<ExtArgs> | null
    /**
     * Filter, which Cidades to fetch.
     */
    where?: CidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cidades to fetch.
     */
    orderBy?: CidadeOrderByWithRelationInput | CidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cidades.
     */
    cursor?: CidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cidades.
     */
    skip?: number
    distinct?: CidadeScalarFieldEnum | CidadeScalarFieldEnum[]
  }

  /**
   * Cidade create
   */
  export type CidadeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cidade
     */
    select?: CidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cidade
     */
    omit?: CidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidadeInclude<ExtArgs> | null
    /**
     * The data needed to create a Cidade.
     */
    data: XOR<CidadeCreateInput, CidadeUncheckedCreateInput>
  }

  /**
   * Cidade createMany
   */
  export type CidadeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cidades.
     */
    data: CidadeCreateManyInput | CidadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cidade createManyAndReturn
   */
  export type CidadeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cidade
     */
    select?: CidadeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cidade
     */
    omit?: CidadeOmit<ExtArgs> | null
    /**
     * The data used to create many Cidades.
     */
    data: CidadeCreateManyInput | CidadeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidadeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cidade update
   */
  export type CidadeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cidade
     */
    select?: CidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cidade
     */
    omit?: CidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidadeInclude<ExtArgs> | null
    /**
     * The data needed to update a Cidade.
     */
    data: XOR<CidadeUpdateInput, CidadeUncheckedUpdateInput>
    /**
     * Choose, which Cidade to update.
     */
    where: CidadeWhereUniqueInput
  }

  /**
   * Cidade updateMany
   */
  export type CidadeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cidades.
     */
    data: XOR<CidadeUpdateManyMutationInput, CidadeUncheckedUpdateManyInput>
    /**
     * Filter which Cidades to update
     */
    where?: CidadeWhereInput
    /**
     * Limit how many Cidades to update.
     */
    limit?: number
  }

  /**
   * Cidade updateManyAndReturn
   */
  export type CidadeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cidade
     */
    select?: CidadeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cidade
     */
    omit?: CidadeOmit<ExtArgs> | null
    /**
     * The data used to update Cidades.
     */
    data: XOR<CidadeUpdateManyMutationInput, CidadeUncheckedUpdateManyInput>
    /**
     * Filter which Cidades to update
     */
    where?: CidadeWhereInput
    /**
     * Limit how many Cidades to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidadeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cidade upsert
   */
  export type CidadeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cidade
     */
    select?: CidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cidade
     */
    omit?: CidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidadeInclude<ExtArgs> | null
    /**
     * The filter to search for the Cidade to update in case it exists.
     */
    where: CidadeWhereUniqueInput
    /**
     * In case the Cidade found by the `where` argument doesn't exist, create a new Cidade with this data.
     */
    create: XOR<CidadeCreateInput, CidadeUncheckedCreateInput>
    /**
     * In case the Cidade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CidadeUpdateInput, CidadeUncheckedUpdateInput>
  }

  /**
   * Cidade delete
   */
  export type CidadeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cidade
     */
    select?: CidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cidade
     */
    omit?: CidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidadeInclude<ExtArgs> | null
    /**
     * Filter which Cidade to delete.
     */
    where: CidadeWhereUniqueInput
  }

  /**
   * Cidade deleteMany
   */
  export type CidadeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cidades to delete
     */
    where?: CidadeWhereInput
    /**
     * Limit how many Cidades to delete.
     */
    limit?: number
  }

  /**
   * Cidade.bairros
   */
  export type Cidade$bairrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bairro
     */
    select?: BairroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bairro
     */
    omit?: BairroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BairroInclude<ExtArgs> | null
    where?: BairroWhereInput
    orderBy?: BairroOrderByWithRelationInput | BairroOrderByWithRelationInput[]
    cursor?: BairroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BairroScalarFieldEnum | BairroScalarFieldEnum[]
  }

  /**
   * Cidade.distritos
   */
  export type Cidade$distritosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distrito
     */
    omit?: DistritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistritoInclude<ExtArgs> | null
    where?: DistritoWhereInput
    orderBy?: DistritoOrderByWithRelationInput | DistritoOrderByWithRelationInput[]
    cursor?: DistritoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DistritoScalarFieldEnum | DistritoScalarFieldEnum[]
  }

  /**
   * Cidade.enderecos
   */
  export type Cidade$enderecosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    where?: EnderecoWhereInput
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    cursor?: EnderecoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * Cidade without action
   */
  export type CidadeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cidade
     */
    select?: CidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cidade
     */
    omit?: CidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidadeInclude<ExtArgs> | null
  }


  /**
   * Model Escolaridade
   */

  export type AggregateEscolaridade = {
    _count: EscolaridadeCountAggregateOutputType | null
    _avg: EscolaridadeAvgAggregateOutputType | null
    _sum: EscolaridadeSumAggregateOutputType | null
    _min: EscolaridadeMinAggregateOutputType | null
    _max: EscolaridadeMaxAggregateOutputType | null
  }

  export type EscolaridadeAvgAggregateOutputType = {
    id: number | null
  }

  export type EscolaridadeSumAggregateOutputType = {
    id: number | null
  }

  export type EscolaridadeMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type EscolaridadeMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type EscolaridadeCountAggregateOutputType = {
    id: number
    descricao: number
    stInativo: number
    _all: number
  }


  export type EscolaridadeAvgAggregateInputType = {
    id?: true
  }

  export type EscolaridadeSumAggregateInputType = {
    id?: true
  }

  export type EscolaridadeMinAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
  }

  export type EscolaridadeMaxAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
  }

  export type EscolaridadeCountAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
    _all?: true
  }

  export type EscolaridadeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Escolaridade to aggregate.
     */
    where?: EscolaridadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escolaridades to fetch.
     */
    orderBy?: EscolaridadeOrderByWithRelationInput | EscolaridadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscolaridadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escolaridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escolaridades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Escolaridades
    **/
    _count?: true | EscolaridadeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EscolaridadeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EscolaridadeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscolaridadeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscolaridadeMaxAggregateInputType
  }

  export type GetEscolaridadeAggregateType<T extends EscolaridadeAggregateArgs> = {
        [P in keyof T & keyof AggregateEscolaridade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscolaridade[P]>
      : GetScalarType<T[P], AggregateEscolaridade[P]>
  }




  export type EscolaridadeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscolaridadeWhereInput
    orderBy?: EscolaridadeOrderByWithAggregationInput | EscolaridadeOrderByWithAggregationInput[]
    by: EscolaridadeScalarFieldEnum[] | EscolaridadeScalarFieldEnum
    having?: EscolaridadeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscolaridadeCountAggregateInputType | true
    _avg?: EscolaridadeAvgAggregateInputType
    _sum?: EscolaridadeSumAggregateInputType
    _min?: EscolaridadeMinAggregateInputType
    _max?: EscolaridadeMaxAggregateInputType
  }

  export type EscolaridadeGroupByOutputType = {
    id: number
    descricao: string
    stInativo: $Enums.SimNao | null
    _count: EscolaridadeCountAggregateOutputType | null
    _avg: EscolaridadeAvgAggregateOutputType | null
    _sum: EscolaridadeSumAggregateOutputType | null
    _min: EscolaridadeMinAggregateOutputType | null
    _max: EscolaridadeMaxAggregateOutputType | null
  }

  type GetEscolaridadeGroupByPayload<T extends EscolaridadeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscolaridadeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscolaridadeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscolaridadeGroupByOutputType[P]>
            : GetScalarType<T[P], EscolaridadeGroupByOutputType[P]>
        }
      >
    >


  export type EscolaridadeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
    pacientes?: boolean | Escolaridade$pacientesArgs<ExtArgs>
    _count?: boolean | EscolaridadeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escolaridade"]>

  export type EscolaridadeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["escolaridade"]>

  export type EscolaridadeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["escolaridade"]>

  export type EscolaridadeSelectScalar = {
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }

  export type EscolaridadeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "stInativo", ExtArgs["result"]["escolaridade"]>
  export type EscolaridadeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pacientes?: boolean | Escolaridade$pacientesArgs<ExtArgs>
    _count?: boolean | EscolaridadeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EscolaridadeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EscolaridadeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EscolaridadePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Escolaridade"
    objects: {
      pacientes: Prisma.$PacientePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["escolaridade"]>
    composites: {}
  }

  type EscolaridadeGetPayload<S extends boolean | null | undefined | EscolaridadeDefaultArgs> = $Result.GetResult<Prisma.$EscolaridadePayload, S>

  type EscolaridadeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EscolaridadeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EscolaridadeCountAggregateInputType | true
    }

  export interface EscolaridadeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Escolaridade'], meta: { name: 'Escolaridade' } }
    /**
     * Find zero or one Escolaridade that matches the filter.
     * @param {EscolaridadeFindUniqueArgs} args - Arguments to find a Escolaridade
     * @example
     * // Get one Escolaridade
     * const escolaridade = await prisma.escolaridade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EscolaridadeFindUniqueArgs>(args: SelectSubset<T, EscolaridadeFindUniqueArgs<ExtArgs>>): Prisma__EscolaridadeClient<$Result.GetResult<Prisma.$EscolaridadePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Escolaridade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EscolaridadeFindUniqueOrThrowArgs} args - Arguments to find a Escolaridade
     * @example
     * // Get one Escolaridade
     * const escolaridade = await prisma.escolaridade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EscolaridadeFindUniqueOrThrowArgs>(args: SelectSubset<T, EscolaridadeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EscolaridadeClient<$Result.GetResult<Prisma.$EscolaridadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Escolaridade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaridadeFindFirstArgs} args - Arguments to find a Escolaridade
     * @example
     * // Get one Escolaridade
     * const escolaridade = await prisma.escolaridade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EscolaridadeFindFirstArgs>(args?: SelectSubset<T, EscolaridadeFindFirstArgs<ExtArgs>>): Prisma__EscolaridadeClient<$Result.GetResult<Prisma.$EscolaridadePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Escolaridade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaridadeFindFirstOrThrowArgs} args - Arguments to find a Escolaridade
     * @example
     * // Get one Escolaridade
     * const escolaridade = await prisma.escolaridade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EscolaridadeFindFirstOrThrowArgs>(args?: SelectSubset<T, EscolaridadeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EscolaridadeClient<$Result.GetResult<Prisma.$EscolaridadePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Escolaridades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaridadeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Escolaridades
     * const escolaridades = await prisma.escolaridade.findMany()
     * 
     * // Get first 10 Escolaridades
     * const escolaridades = await prisma.escolaridade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escolaridadeWithIdOnly = await prisma.escolaridade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EscolaridadeFindManyArgs>(args?: SelectSubset<T, EscolaridadeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscolaridadePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Escolaridade.
     * @param {EscolaridadeCreateArgs} args - Arguments to create a Escolaridade.
     * @example
     * // Create one Escolaridade
     * const Escolaridade = await prisma.escolaridade.create({
     *   data: {
     *     // ... data to create a Escolaridade
     *   }
     * })
     * 
     */
    create<T extends EscolaridadeCreateArgs>(args: SelectSubset<T, EscolaridadeCreateArgs<ExtArgs>>): Prisma__EscolaridadeClient<$Result.GetResult<Prisma.$EscolaridadePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Escolaridades.
     * @param {EscolaridadeCreateManyArgs} args - Arguments to create many Escolaridades.
     * @example
     * // Create many Escolaridades
     * const escolaridade = await prisma.escolaridade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EscolaridadeCreateManyArgs>(args?: SelectSubset<T, EscolaridadeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Escolaridades and returns the data saved in the database.
     * @param {EscolaridadeCreateManyAndReturnArgs} args - Arguments to create many Escolaridades.
     * @example
     * // Create many Escolaridades
     * const escolaridade = await prisma.escolaridade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Escolaridades and only return the `id`
     * const escolaridadeWithIdOnly = await prisma.escolaridade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EscolaridadeCreateManyAndReturnArgs>(args?: SelectSubset<T, EscolaridadeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscolaridadePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Escolaridade.
     * @param {EscolaridadeDeleteArgs} args - Arguments to delete one Escolaridade.
     * @example
     * // Delete one Escolaridade
     * const Escolaridade = await prisma.escolaridade.delete({
     *   where: {
     *     // ... filter to delete one Escolaridade
     *   }
     * })
     * 
     */
    delete<T extends EscolaridadeDeleteArgs>(args: SelectSubset<T, EscolaridadeDeleteArgs<ExtArgs>>): Prisma__EscolaridadeClient<$Result.GetResult<Prisma.$EscolaridadePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Escolaridade.
     * @param {EscolaridadeUpdateArgs} args - Arguments to update one Escolaridade.
     * @example
     * // Update one Escolaridade
     * const escolaridade = await prisma.escolaridade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EscolaridadeUpdateArgs>(args: SelectSubset<T, EscolaridadeUpdateArgs<ExtArgs>>): Prisma__EscolaridadeClient<$Result.GetResult<Prisma.$EscolaridadePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Escolaridades.
     * @param {EscolaridadeDeleteManyArgs} args - Arguments to filter Escolaridades to delete.
     * @example
     * // Delete a few Escolaridades
     * const { count } = await prisma.escolaridade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EscolaridadeDeleteManyArgs>(args?: SelectSubset<T, EscolaridadeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escolaridades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaridadeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Escolaridades
     * const escolaridade = await prisma.escolaridade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EscolaridadeUpdateManyArgs>(args: SelectSubset<T, EscolaridadeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escolaridades and returns the data updated in the database.
     * @param {EscolaridadeUpdateManyAndReturnArgs} args - Arguments to update many Escolaridades.
     * @example
     * // Update many Escolaridades
     * const escolaridade = await prisma.escolaridade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Escolaridades and only return the `id`
     * const escolaridadeWithIdOnly = await prisma.escolaridade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EscolaridadeUpdateManyAndReturnArgs>(args: SelectSubset<T, EscolaridadeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscolaridadePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Escolaridade.
     * @param {EscolaridadeUpsertArgs} args - Arguments to update or create a Escolaridade.
     * @example
     * // Update or create a Escolaridade
     * const escolaridade = await prisma.escolaridade.upsert({
     *   create: {
     *     // ... data to create a Escolaridade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Escolaridade we want to update
     *   }
     * })
     */
    upsert<T extends EscolaridadeUpsertArgs>(args: SelectSubset<T, EscolaridadeUpsertArgs<ExtArgs>>): Prisma__EscolaridadeClient<$Result.GetResult<Prisma.$EscolaridadePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Escolaridades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaridadeCountArgs} args - Arguments to filter Escolaridades to count.
     * @example
     * // Count the number of Escolaridades
     * const count = await prisma.escolaridade.count({
     *   where: {
     *     // ... the filter for the Escolaridades we want to count
     *   }
     * })
    **/
    count<T extends EscolaridadeCountArgs>(
      args?: Subset<T, EscolaridadeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscolaridadeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Escolaridade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaridadeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscolaridadeAggregateArgs>(args: Subset<T, EscolaridadeAggregateArgs>): Prisma.PrismaPromise<GetEscolaridadeAggregateType<T>>

    /**
     * Group by Escolaridade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaridadeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscolaridadeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscolaridadeGroupByArgs['orderBy'] }
        : { orderBy?: EscolaridadeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscolaridadeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscolaridadeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Escolaridade model
   */
  readonly fields: EscolaridadeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Escolaridade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscolaridadeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pacientes<T extends Escolaridade$pacientesArgs<ExtArgs> = {}>(args?: Subset<T, Escolaridade$pacientesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Escolaridade model
   */
  interface EscolaridadeFieldRefs {
    readonly id: FieldRef<"Escolaridade", 'Int'>
    readonly descricao: FieldRef<"Escolaridade", 'String'>
    readonly stInativo: FieldRef<"Escolaridade", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * Escolaridade findUnique
   */
  export type EscolaridadeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escolaridade
     */
    select?: EscolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escolaridade
     */
    omit?: EscolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaridadeInclude<ExtArgs> | null
    /**
     * Filter, which Escolaridade to fetch.
     */
    where: EscolaridadeWhereUniqueInput
  }

  /**
   * Escolaridade findUniqueOrThrow
   */
  export type EscolaridadeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escolaridade
     */
    select?: EscolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escolaridade
     */
    omit?: EscolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaridadeInclude<ExtArgs> | null
    /**
     * Filter, which Escolaridade to fetch.
     */
    where: EscolaridadeWhereUniqueInput
  }

  /**
   * Escolaridade findFirst
   */
  export type EscolaridadeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escolaridade
     */
    select?: EscolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escolaridade
     */
    omit?: EscolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaridadeInclude<ExtArgs> | null
    /**
     * Filter, which Escolaridade to fetch.
     */
    where?: EscolaridadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escolaridades to fetch.
     */
    orderBy?: EscolaridadeOrderByWithRelationInput | EscolaridadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Escolaridades.
     */
    cursor?: EscolaridadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escolaridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escolaridades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Escolaridades.
     */
    distinct?: EscolaridadeScalarFieldEnum | EscolaridadeScalarFieldEnum[]
  }

  /**
   * Escolaridade findFirstOrThrow
   */
  export type EscolaridadeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escolaridade
     */
    select?: EscolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escolaridade
     */
    omit?: EscolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaridadeInclude<ExtArgs> | null
    /**
     * Filter, which Escolaridade to fetch.
     */
    where?: EscolaridadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escolaridades to fetch.
     */
    orderBy?: EscolaridadeOrderByWithRelationInput | EscolaridadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Escolaridades.
     */
    cursor?: EscolaridadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escolaridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escolaridades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Escolaridades.
     */
    distinct?: EscolaridadeScalarFieldEnum | EscolaridadeScalarFieldEnum[]
  }

  /**
   * Escolaridade findMany
   */
  export type EscolaridadeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escolaridade
     */
    select?: EscolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escolaridade
     */
    omit?: EscolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaridadeInclude<ExtArgs> | null
    /**
     * Filter, which Escolaridades to fetch.
     */
    where?: EscolaridadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escolaridades to fetch.
     */
    orderBy?: EscolaridadeOrderByWithRelationInput | EscolaridadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Escolaridades.
     */
    cursor?: EscolaridadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escolaridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escolaridades.
     */
    skip?: number
    distinct?: EscolaridadeScalarFieldEnum | EscolaridadeScalarFieldEnum[]
  }

  /**
   * Escolaridade create
   */
  export type EscolaridadeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escolaridade
     */
    select?: EscolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escolaridade
     */
    omit?: EscolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaridadeInclude<ExtArgs> | null
    /**
     * The data needed to create a Escolaridade.
     */
    data: XOR<EscolaridadeCreateInput, EscolaridadeUncheckedCreateInput>
  }

  /**
   * Escolaridade createMany
   */
  export type EscolaridadeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Escolaridades.
     */
    data: EscolaridadeCreateManyInput | EscolaridadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Escolaridade createManyAndReturn
   */
  export type EscolaridadeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escolaridade
     */
    select?: EscolaridadeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Escolaridade
     */
    omit?: EscolaridadeOmit<ExtArgs> | null
    /**
     * The data used to create many Escolaridades.
     */
    data: EscolaridadeCreateManyInput | EscolaridadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Escolaridade update
   */
  export type EscolaridadeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escolaridade
     */
    select?: EscolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escolaridade
     */
    omit?: EscolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaridadeInclude<ExtArgs> | null
    /**
     * The data needed to update a Escolaridade.
     */
    data: XOR<EscolaridadeUpdateInput, EscolaridadeUncheckedUpdateInput>
    /**
     * Choose, which Escolaridade to update.
     */
    where: EscolaridadeWhereUniqueInput
  }

  /**
   * Escolaridade updateMany
   */
  export type EscolaridadeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Escolaridades.
     */
    data: XOR<EscolaridadeUpdateManyMutationInput, EscolaridadeUncheckedUpdateManyInput>
    /**
     * Filter which Escolaridades to update
     */
    where?: EscolaridadeWhereInput
    /**
     * Limit how many Escolaridades to update.
     */
    limit?: number
  }

  /**
   * Escolaridade updateManyAndReturn
   */
  export type EscolaridadeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escolaridade
     */
    select?: EscolaridadeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Escolaridade
     */
    omit?: EscolaridadeOmit<ExtArgs> | null
    /**
     * The data used to update Escolaridades.
     */
    data: XOR<EscolaridadeUpdateManyMutationInput, EscolaridadeUncheckedUpdateManyInput>
    /**
     * Filter which Escolaridades to update
     */
    where?: EscolaridadeWhereInput
    /**
     * Limit how many Escolaridades to update.
     */
    limit?: number
  }

  /**
   * Escolaridade upsert
   */
  export type EscolaridadeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escolaridade
     */
    select?: EscolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escolaridade
     */
    omit?: EscolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaridadeInclude<ExtArgs> | null
    /**
     * The filter to search for the Escolaridade to update in case it exists.
     */
    where: EscolaridadeWhereUniqueInput
    /**
     * In case the Escolaridade found by the `where` argument doesn't exist, create a new Escolaridade with this data.
     */
    create: XOR<EscolaridadeCreateInput, EscolaridadeUncheckedCreateInput>
    /**
     * In case the Escolaridade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscolaridadeUpdateInput, EscolaridadeUncheckedUpdateInput>
  }

  /**
   * Escolaridade delete
   */
  export type EscolaridadeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escolaridade
     */
    select?: EscolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escolaridade
     */
    omit?: EscolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaridadeInclude<ExtArgs> | null
    /**
     * Filter which Escolaridade to delete.
     */
    where: EscolaridadeWhereUniqueInput
  }

  /**
   * Escolaridade deleteMany
   */
  export type EscolaridadeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Escolaridades to delete
     */
    where?: EscolaridadeWhereInput
    /**
     * Limit how many Escolaridades to delete.
     */
    limit?: number
  }

  /**
   * Escolaridade.pacientes
   */
  export type Escolaridade$pacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    where?: PacienteWhereInput
    orderBy?: PacienteOrderByWithRelationInput | PacienteOrderByWithRelationInput[]
    cursor?: PacienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PacienteScalarFieldEnum | PacienteScalarFieldEnum[]
  }

  /**
   * Escolaridade without action
   */
  export type EscolaridadeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escolaridade
     */
    select?: EscolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Escolaridade
     */
    omit?: EscolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscolaridadeInclude<ExtArgs> | null
  }


  /**
   * Model Ocupacao
   */

  export type AggregateOcupacao = {
    _count: OcupacaoCountAggregateOutputType | null
    _avg: OcupacaoAvgAggregateOutputType | null
    _sum: OcupacaoSumAggregateOutputType | null
    _min: OcupacaoMinAggregateOutputType | null
    _max: OcupacaoMaxAggregateOutputType | null
  }

  export type OcupacaoAvgAggregateOutputType = {
    id: number | null
  }

  export type OcupacaoSumAggregateOutputType = {
    id: number | null
  }

  export type OcupacaoMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    cbo: string | null
    stInativo: $Enums.SimNao | null
  }

  export type OcupacaoMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    cbo: string | null
    stInativo: $Enums.SimNao | null
  }

  export type OcupacaoCountAggregateOutputType = {
    id: number
    descricao: number
    cbo: number
    stInativo: number
    _all: number
  }


  export type OcupacaoAvgAggregateInputType = {
    id?: true
  }

  export type OcupacaoSumAggregateInputType = {
    id?: true
  }

  export type OcupacaoMinAggregateInputType = {
    id?: true
    descricao?: true
    cbo?: true
    stInativo?: true
  }

  export type OcupacaoMaxAggregateInputType = {
    id?: true
    descricao?: true
    cbo?: true
    stInativo?: true
  }

  export type OcupacaoCountAggregateInputType = {
    id?: true
    descricao?: true
    cbo?: true
    stInativo?: true
    _all?: true
  }

  export type OcupacaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ocupacao to aggregate.
     */
    where?: OcupacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ocupacaos to fetch.
     */
    orderBy?: OcupacaoOrderByWithRelationInput | OcupacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OcupacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ocupacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ocupacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ocupacaos
    **/
    _count?: true | OcupacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OcupacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OcupacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OcupacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OcupacaoMaxAggregateInputType
  }

  export type GetOcupacaoAggregateType<T extends OcupacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateOcupacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOcupacao[P]>
      : GetScalarType<T[P], AggregateOcupacao[P]>
  }




  export type OcupacaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OcupacaoWhereInput
    orderBy?: OcupacaoOrderByWithAggregationInput | OcupacaoOrderByWithAggregationInput[]
    by: OcupacaoScalarFieldEnum[] | OcupacaoScalarFieldEnum
    having?: OcupacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OcupacaoCountAggregateInputType | true
    _avg?: OcupacaoAvgAggregateInputType
    _sum?: OcupacaoSumAggregateInputType
    _min?: OcupacaoMinAggregateInputType
    _max?: OcupacaoMaxAggregateInputType
  }

  export type OcupacaoGroupByOutputType = {
    id: number
    descricao: string
    cbo: string | null
    stInativo: $Enums.SimNao | null
    _count: OcupacaoCountAggregateOutputType | null
    _avg: OcupacaoAvgAggregateOutputType | null
    _sum: OcupacaoSumAggregateOutputType | null
    _min: OcupacaoMinAggregateOutputType | null
    _max: OcupacaoMaxAggregateOutputType | null
  }

  type GetOcupacaoGroupByPayload<T extends OcupacaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OcupacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OcupacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OcupacaoGroupByOutputType[P]>
            : GetScalarType<T[P], OcupacaoGroupByOutputType[P]>
        }
      >
    >


  export type OcupacaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    cbo?: boolean
    stInativo?: boolean
    pacientes?: boolean | Ocupacao$pacientesArgs<ExtArgs>
    profissionals?: boolean | Ocupacao$profissionalsArgs<ExtArgs>
    _count?: boolean | OcupacaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ocupacao"]>

  export type OcupacaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    cbo?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["ocupacao"]>

  export type OcupacaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    cbo?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["ocupacao"]>

  export type OcupacaoSelectScalar = {
    id?: boolean
    descricao?: boolean
    cbo?: boolean
    stInativo?: boolean
  }

  export type OcupacaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "cbo" | "stInativo", ExtArgs["result"]["ocupacao"]>
  export type OcupacaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pacientes?: boolean | Ocupacao$pacientesArgs<ExtArgs>
    profissionals?: boolean | Ocupacao$profissionalsArgs<ExtArgs>
    _count?: boolean | OcupacaoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OcupacaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OcupacaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OcupacaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ocupacao"
    objects: {
      pacientes: Prisma.$PacientePayload<ExtArgs>[]
      profissionals: Prisma.$ProfissionalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      cbo: string | null
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["ocupacao"]>
    composites: {}
  }

  type OcupacaoGetPayload<S extends boolean | null | undefined | OcupacaoDefaultArgs> = $Result.GetResult<Prisma.$OcupacaoPayload, S>

  type OcupacaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OcupacaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OcupacaoCountAggregateInputType | true
    }

  export interface OcupacaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ocupacao'], meta: { name: 'Ocupacao' } }
    /**
     * Find zero or one Ocupacao that matches the filter.
     * @param {OcupacaoFindUniqueArgs} args - Arguments to find a Ocupacao
     * @example
     * // Get one Ocupacao
     * const ocupacao = await prisma.ocupacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OcupacaoFindUniqueArgs>(args: SelectSubset<T, OcupacaoFindUniqueArgs<ExtArgs>>): Prisma__OcupacaoClient<$Result.GetResult<Prisma.$OcupacaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ocupacao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OcupacaoFindUniqueOrThrowArgs} args - Arguments to find a Ocupacao
     * @example
     * // Get one Ocupacao
     * const ocupacao = await prisma.ocupacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OcupacaoFindUniqueOrThrowArgs>(args: SelectSubset<T, OcupacaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OcupacaoClient<$Result.GetResult<Prisma.$OcupacaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ocupacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OcupacaoFindFirstArgs} args - Arguments to find a Ocupacao
     * @example
     * // Get one Ocupacao
     * const ocupacao = await prisma.ocupacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OcupacaoFindFirstArgs>(args?: SelectSubset<T, OcupacaoFindFirstArgs<ExtArgs>>): Prisma__OcupacaoClient<$Result.GetResult<Prisma.$OcupacaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ocupacao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OcupacaoFindFirstOrThrowArgs} args - Arguments to find a Ocupacao
     * @example
     * // Get one Ocupacao
     * const ocupacao = await prisma.ocupacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OcupacaoFindFirstOrThrowArgs>(args?: SelectSubset<T, OcupacaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__OcupacaoClient<$Result.GetResult<Prisma.$OcupacaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ocupacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OcupacaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ocupacaos
     * const ocupacaos = await prisma.ocupacao.findMany()
     * 
     * // Get first 10 Ocupacaos
     * const ocupacaos = await prisma.ocupacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ocupacaoWithIdOnly = await prisma.ocupacao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OcupacaoFindManyArgs>(args?: SelectSubset<T, OcupacaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OcupacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ocupacao.
     * @param {OcupacaoCreateArgs} args - Arguments to create a Ocupacao.
     * @example
     * // Create one Ocupacao
     * const Ocupacao = await prisma.ocupacao.create({
     *   data: {
     *     // ... data to create a Ocupacao
     *   }
     * })
     * 
     */
    create<T extends OcupacaoCreateArgs>(args: SelectSubset<T, OcupacaoCreateArgs<ExtArgs>>): Prisma__OcupacaoClient<$Result.GetResult<Prisma.$OcupacaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ocupacaos.
     * @param {OcupacaoCreateManyArgs} args - Arguments to create many Ocupacaos.
     * @example
     * // Create many Ocupacaos
     * const ocupacao = await prisma.ocupacao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OcupacaoCreateManyArgs>(args?: SelectSubset<T, OcupacaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ocupacaos and returns the data saved in the database.
     * @param {OcupacaoCreateManyAndReturnArgs} args - Arguments to create many Ocupacaos.
     * @example
     * // Create many Ocupacaos
     * const ocupacao = await prisma.ocupacao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ocupacaos and only return the `id`
     * const ocupacaoWithIdOnly = await prisma.ocupacao.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OcupacaoCreateManyAndReturnArgs>(args?: SelectSubset<T, OcupacaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OcupacaoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ocupacao.
     * @param {OcupacaoDeleteArgs} args - Arguments to delete one Ocupacao.
     * @example
     * // Delete one Ocupacao
     * const Ocupacao = await prisma.ocupacao.delete({
     *   where: {
     *     // ... filter to delete one Ocupacao
     *   }
     * })
     * 
     */
    delete<T extends OcupacaoDeleteArgs>(args: SelectSubset<T, OcupacaoDeleteArgs<ExtArgs>>): Prisma__OcupacaoClient<$Result.GetResult<Prisma.$OcupacaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ocupacao.
     * @param {OcupacaoUpdateArgs} args - Arguments to update one Ocupacao.
     * @example
     * // Update one Ocupacao
     * const ocupacao = await prisma.ocupacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OcupacaoUpdateArgs>(args: SelectSubset<T, OcupacaoUpdateArgs<ExtArgs>>): Prisma__OcupacaoClient<$Result.GetResult<Prisma.$OcupacaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ocupacaos.
     * @param {OcupacaoDeleteManyArgs} args - Arguments to filter Ocupacaos to delete.
     * @example
     * // Delete a few Ocupacaos
     * const { count } = await prisma.ocupacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OcupacaoDeleteManyArgs>(args?: SelectSubset<T, OcupacaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ocupacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OcupacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ocupacaos
     * const ocupacao = await prisma.ocupacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OcupacaoUpdateManyArgs>(args: SelectSubset<T, OcupacaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ocupacaos and returns the data updated in the database.
     * @param {OcupacaoUpdateManyAndReturnArgs} args - Arguments to update many Ocupacaos.
     * @example
     * // Update many Ocupacaos
     * const ocupacao = await prisma.ocupacao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ocupacaos and only return the `id`
     * const ocupacaoWithIdOnly = await prisma.ocupacao.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OcupacaoUpdateManyAndReturnArgs>(args: SelectSubset<T, OcupacaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OcupacaoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ocupacao.
     * @param {OcupacaoUpsertArgs} args - Arguments to update or create a Ocupacao.
     * @example
     * // Update or create a Ocupacao
     * const ocupacao = await prisma.ocupacao.upsert({
     *   create: {
     *     // ... data to create a Ocupacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ocupacao we want to update
     *   }
     * })
     */
    upsert<T extends OcupacaoUpsertArgs>(args: SelectSubset<T, OcupacaoUpsertArgs<ExtArgs>>): Prisma__OcupacaoClient<$Result.GetResult<Prisma.$OcupacaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ocupacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OcupacaoCountArgs} args - Arguments to filter Ocupacaos to count.
     * @example
     * // Count the number of Ocupacaos
     * const count = await prisma.ocupacao.count({
     *   where: {
     *     // ... the filter for the Ocupacaos we want to count
     *   }
     * })
    **/
    count<T extends OcupacaoCountArgs>(
      args?: Subset<T, OcupacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OcupacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ocupacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OcupacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OcupacaoAggregateArgs>(args: Subset<T, OcupacaoAggregateArgs>): Prisma.PrismaPromise<GetOcupacaoAggregateType<T>>

    /**
     * Group by Ocupacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OcupacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OcupacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OcupacaoGroupByArgs['orderBy'] }
        : { orderBy?: OcupacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OcupacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOcupacaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ocupacao model
   */
  readonly fields: OcupacaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ocupacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OcupacaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pacientes<T extends Ocupacao$pacientesArgs<ExtArgs> = {}>(args?: Subset<T, Ocupacao$pacientesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profissionals<T extends Ocupacao$profissionalsArgs<ExtArgs> = {}>(args?: Subset<T, Ocupacao$profissionalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ocupacao model
   */
  interface OcupacaoFieldRefs {
    readonly id: FieldRef<"Ocupacao", 'Int'>
    readonly descricao: FieldRef<"Ocupacao", 'String'>
    readonly cbo: FieldRef<"Ocupacao", 'String'>
    readonly stInativo: FieldRef<"Ocupacao", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * Ocupacao findUnique
   */
  export type OcupacaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ocupacao
     */
    select?: OcupacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ocupacao
     */
    omit?: OcupacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcupacaoInclude<ExtArgs> | null
    /**
     * Filter, which Ocupacao to fetch.
     */
    where: OcupacaoWhereUniqueInput
  }

  /**
   * Ocupacao findUniqueOrThrow
   */
  export type OcupacaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ocupacao
     */
    select?: OcupacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ocupacao
     */
    omit?: OcupacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcupacaoInclude<ExtArgs> | null
    /**
     * Filter, which Ocupacao to fetch.
     */
    where: OcupacaoWhereUniqueInput
  }

  /**
   * Ocupacao findFirst
   */
  export type OcupacaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ocupacao
     */
    select?: OcupacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ocupacao
     */
    omit?: OcupacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcupacaoInclude<ExtArgs> | null
    /**
     * Filter, which Ocupacao to fetch.
     */
    where?: OcupacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ocupacaos to fetch.
     */
    orderBy?: OcupacaoOrderByWithRelationInput | OcupacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ocupacaos.
     */
    cursor?: OcupacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ocupacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ocupacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ocupacaos.
     */
    distinct?: OcupacaoScalarFieldEnum | OcupacaoScalarFieldEnum[]
  }

  /**
   * Ocupacao findFirstOrThrow
   */
  export type OcupacaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ocupacao
     */
    select?: OcupacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ocupacao
     */
    omit?: OcupacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcupacaoInclude<ExtArgs> | null
    /**
     * Filter, which Ocupacao to fetch.
     */
    where?: OcupacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ocupacaos to fetch.
     */
    orderBy?: OcupacaoOrderByWithRelationInput | OcupacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ocupacaos.
     */
    cursor?: OcupacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ocupacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ocupacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ocupacaos.
     */
    distinct?: OcupacaoScalarFieldEnum | OcupacaoScalarFieldEnum[]
  }

  /**
   * Ocupacao findMany
   */
  export type OcupacaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ocupacao
     */
    select?: OcupacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ocupacao
     */
    omit?: OcupacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcupacaoInclude<ExtArgs> | null
    /**
     * Filter, which Ocupacaos to fetch.
     */
    where?: OcupacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ocupacaos to fetch.
     */
    orderBy?: OcupacaoOrderByWithRelationInput | OcupacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ocupacaos.
     */
    cursor?: OcupacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ocupacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ocupacaos.
     */
    skip?: number
    distinct?: OcupacaoScalarFieldEnum | OcupacaoScalarFieldEnum[]
  }

  /**
   * Ocupacao create
   */
  export type OcupacaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ocupacao
     */
    select?: OcupacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ocupacao
     */
    omit?: OcupacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcupacaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Ocupacao.
     */
    data: XOR<OcupacaoCreateInput, OcupacaoUncheckedCreateInput>
  }

  /**
   * Ocupacao createMany
   */
  export type OcupacaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ocupacaos.
     */
    data: OcupacaoCreateManyInput | OcupacaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ocupacao createManyAndReturn
   */
  export type OcupacaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ocupacao
     */
    select?: OcupacaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ocupacao
     */
    omit?: OcupacaoOmit<ExtArgs> | null
    /**
     * The data used to create many Ocupacaos.
     */
    data: OcupacaoCreateManyInput | OcupacaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ocupacao update
   */
  export type OcupacaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ocupacao
     */
    select?: OcupacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ocupacao
     */
    omit?: OcupacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcupacaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Ocupacao.
     */
    data: XOR<OcupacaoUpdateInput, OcupacaoUncheckedUpdateInput>
    /**
     * Choose, which Ocupacao to update.
     */
    where: OcupacaoWhereUniqueInput
  }

  /**
   * Ocupacao updateMany
   */
  export type OcupacaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ocupacaos.
     */
    data: XOR<OcupacaoUpdateManyMutationInput, OcupacaoUncheckedUpdateManyInput>
    /**
     * Filter which Ocupacaos to update
     */
    where?: OcupacaoWhereInput
    /**
     * Limit how many Ocupacaos to update.
     */
    limit?: number
  }

  /**
   * Ocupacao updateManyAndReturn
   */
  export type OcupacaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ocupacao
     */
    select?: OcupacaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ocupacao
     */
    omit?: OcupacaoOmit<ExtArgs> | null
    /**
     * The data used to update Ocupacaos.
     */
    data: XOR<OcupacaoUpdateManyMutationInput, OcupacaoUncheckedUpdateManyInput>
    /**
     * Filter which Ocupacaos to update
     */
    where?: OcupacaoWhereInput
    /**
     * Limit how many Ocupacaos to update.
     */
    limit?: number
  }

  /**
   * Ocupacao upsert
   */
  export type OcupacaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ocupacao
     */
    select?: OcupacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ocupacao
     */
    omit?: OcupacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcupacaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Ocupacao to update in case it exists.
     */
    where: OcupacaoWhereUniqueInput
    /**
     * In case the Ocupacao found by the `where` argument doesn't exist, create a new Ocupacao with this data.
     */
    create: XOR<OcupacaoCreateInput, OcupacaoUncheckedCreateInput>
    /**
     * In case the Ocupacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OcupacaoUpdateInput, OcupacaoUncheckedUpdateInput>
  }

  /**
   * Ocupacao delete
   */
  export type OcupacaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ocupacao
     */
    select?: OcupacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ocupacao
     */
    omit?: OcupacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcupacaoInclude<ExtArgs> | null
    /**
     * Filter which Ocupacao to delete.
     */
    where: OcupacaoWhereUniqueInput
  }

  /**
   * Ocupacao deleteMany
   */
  export type OcupacaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ocupacaos to delete
     */
    where?: OcupacaoWhereInput
    /**
     * Limit how many Ocupacaos to delete.
     */
    limit?: number
  }

  /**
   * Ocupacao.pacientes
   */
  export type Ocupacao$pacientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    where?: PacienteWhereInput
    orderBy?: PacienteOrderByWithRelationInput | PacienteOrderByWithRelationInput[]
    cursor?: PacienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PacienteScalarFieldEnum | PacienteScalarFieldEnum[]
  }

  /**
   * Ocupacao.profissionals
   */
  export type Ocupacao$profissionalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    where?: ProfissionalWhereInput
    orderBy?: ProfissionalOrderByWithRelationInput | ProfissionalOrderByWithRelationInput[]
    cursor?: ProfissionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfissionalScalarFieldEnum | ProfissionalScalarFieldEnum[]
  }

  /**
   * Ocupacao without action
   */
  export type OcupacaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ocupacao
     */
    select?: OcupacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ocupacao
     */
    omit?: OcupacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OcupacaoInclude<ExtArgs> | null
  }


  /**
   * Model Distrito
   */

  export type AggregateDistrito = {
    _count: DistritoCountAggregateOutputType | null
    _avg: DistritoAvgAggregateOutputType | null
    _sum: DistritoSumAggregateOutputType | null
    _min: DistritoMinAggregateOutputType | null
    _max: DistritoMaxAggregateOutputType | null
  }

  export type DistritoAvgAggregateOutputType = {
    id: number | null
    cdCidade: number | null
  }

  export type DistritoSumAggregateOutputType = {
    id: number | null
    cdCidade: number | null
  }

  export type DistritoMinAggregateOutputType = {
    id: number | null
    cdCidade: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type DistritoMaxAggregateOutputType = {
    id: number | null
    cdCidade: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type DistritoCountAggregateOutputType = {
    id: number
    cdCidade: number
    descricao: number
    stInativo: number
    _all: number
  }


  export type DistritoAvgAggregateInputType = {
    id?: true
    cdCidade?: true
  }

  export type DistritoSumAggregateInputType = {
    id?: true
    cdCidade?: true
  }

  export type DistritoMinAggregateInputType = {
    id?: true
    cdCidade?: true
    descricao?: true
    stInativo?: true
  }

  export type DistritoMaxAggregateInputType = {
    id?: true
    cdCidade?: true
    descricao?: true
    stInativo?: true
  }

  export type DistritoCountAggregateInputType = {
    id?: true
    cdCidade?: true
    descricao?: true
    stInativo?: true
    _all?: true
  }

  export type DistritoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Distrito to aggregate.
     */
    where?: DistritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distritos to fetch.
     */
    orderBy?: DistritoOrderByWithRelationInput | DistritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distritos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Distritos
    **/
    _count?: true | DistritoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DistritoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DistritoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistritoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistritoMaxAggregateInputType
  }

  export type GetDistritoAggregateType<T extends DistritoAggregateArgs> = {
        [P in keyof T & keyof AggregateDistrito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistrito[P]>
      : GetScalarType<T[P], AggregateDistrito[P]>
  }




  export type DistritoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistritoWhereInput
    orderBy?: DistritoOrderByWithAggregationInput | DistritoOrderByWithAggregationInput[]
    by: DistritoScalarFieldEnum[] | DistritoScalarFieldEnum
    having?: DistritoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistritoCountAggregateInputType | true
    _avg?: DistritoAvgAggregateInputType
    _sum?: DistritoSumAggregateInputType
    _min?: DistritoMinAggregateInputType
    _max?: DistritoMaxAggregateInputType
  }

  export type DistritoGroupByOutputType = {
    id: number
    cdCidade: number
    descricao: string
    stInativo: $Enums.SimNao | null
    _count: DistritoCountAggregateOutputType | null
    _avg: DistritoAvgAggregateOutputType | null
    _sum: DistritoSumAggregateOutputType | null
    _min: DistritoMinAggregateOutputType | null
    _max: DistritoMaxAggregateOutputType | null
  }

  type GetDistritoGroupByPayload<T extends DistritoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistritoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistritoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistritoGroupByOutputType[P]>
            : GetScalarType<T[P], DistritoGroupByOutputType[P]>
        }
      >
    >


  export type DistritoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdCidade?: boolean
    descricao?: boolean
    stInativo?: boolean
    bairros?: boolean | Distrito$bairrosArgs<ExtArgs>
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
    _count?: boolean | DistritoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["distrito"]>

  export type DistritoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdCidade?: boolean
    descricao?: boolean
    stInativo?: boolean
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["distrito"]>

  export type DistritoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdCidade?: boolean
    descricao?: boolean
    stInativo?: boolean
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["distrito"]>

  export type DistritoSelectScalar = {
    id?: boolean
    cdCidade?: boolean
    descricao?: boolean
    stInativo?: boolean
  }

  export type DistritoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdCidade" | "descricao" | "stInativo", ExtArgs["result"]["distrito"]>
  export type DistritoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bairros?: boolean | Distrito$bairrosArgs<ExtArgs>
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
    _count?: boolean | DistritoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DistritoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
  }
  export type DistritoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
  }

  export type $DistritoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Distrito"
    objects: {
      bairros: Prisma.$BairroPayload<ExtArgs>[]
      cidade: Prisma.$CidadePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdCidade: number
      descricao: string
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["distrito"]>
    composites: {}
  }

  type DistritoGetPayload<S extends boolean | null | undefined | DistritoDefaultArgs> = $Result.GetResult<Prisma.$DistritoPayload, S>

  type DistritoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DistritoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DistritoCountAggregateInputType | true
    }

  export interface DistritoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Distrito'], meta: { name: 'Distrito' } }
    /**
     * Find zero or one Distrito that matches the filter.
     * @param {DistritoFindUniqueArgs} args - Arguments to find a Distrito
     * @example
     * // Get one Distrito
     * const distrito = await prisma.distrito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DistritoFindUniqueArgs>(args: SelectSubset<T, DistritoFindUniqueArgs<ExtArgs>>): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Distrito that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DistritoFindUniqueOrThrowArgs} args - Arguments to find a Distrito
     * @example
     * // Get one Distrito
     * const distrito = await prisma.distrito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DistritoFindUniqueOrThrowArgs>(args: SelectSubset<T, DistritoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Distrito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistritoFindFirstArgs} args - Arguments to find a Distrito
     * @example
     * // Get one Distrito
     * const distrito = await prisma.distrito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DistritoFindFirstArgs>(args?: SelectSubset<T, DistritoFindFirstArgs<ExtArgs>>): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Distrito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistritoFindFirstOrThrowArgs} args - Arguments to find a Distrito
     * @example
     * // Get one Distrito
     * const distrito = await prisma.distrito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DistritoFindFirstOrThrowArgs>(args?: SelectSubset<T, DistritoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Distritos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistritoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Distritos
     * const distritos = await prisma.distrito.findMany()
     * 
     * // Get first 10 Distritos
     * const distritos = await prisma.distrito.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const distritoWithIdOnly = await prisma.distrito.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DistritoFindManyArgs>(args?: SelectSubset<T, DistritoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Distrito.
     * @param {DistritoCreateArgs} args - Arguments to create a Distrito.
     * @example
     * // Create one Distrito
     * const Distrito = await prisma.distrito.create({
     *   data: {
     *     // ... data to create a Distrito
     *   }
     * })
     * 
     */
    create<T extends DistritoCreateArgs>(args: SelectSubset<T, DistritoCreateArgs<ExtArgs>>): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Distritos.
     * @param {DistritoCreateManyArgs} args - Arguments to create many Distritos.
     * @example
     * // Create many Distritos
     * const distrito = await prisma.distrito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DistritoCreateManyArgs>(args?: SelectSubset<T, DistritoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Distritos and returns the data saved in the database.
     * @param {DistritoCreateManyAndReturnArgs} args - Arguments to create many Distritos.
     * @example
     * // Create many Distritos
     * const distrito = await prisma.distrito.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Distritos and only return the `id`
     * const distritoWithIdOnly = await prisma.distrito.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DistritoCreateManyAndReturnArgs>(args?: SelectSubset<T, DistritoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Distrito.
     * @param {DistritoDeleteArgs} args - Arguments to delete one Distrito.
     * @example
     * // Delete one Distrito
     * const Distrito = await prisma.distrito.delete({
     *   where: {
     *     // ... filter to delete one Distrito
     *   }
     * })
     * 
     */
    delete<T extends DistritoDeleteArgs>(args: SelectSubset<T, DistritoDeleteArgs<ExtArgs>>): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Distrito.
     * @param {DistritoUpdateArgs} args - Arguments to update one Distrito.
     * @example
     * // Update one Distrito
     * const distrito = await prisma.distrito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DistritoUpdateArgs>(args: SelectSubset<T, DistritoUpdateArgs<ExtArgs>>): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Distritos.
     * @param {DistritoDeleteManyArgs} args - Arguments to filter Distritos to delete.
     * @example
     * // Delete a few Distritos
     * const { count } = await prisma.distrito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DistritoDeleteManyArgs>(args?: SelectSubset<T, DistritoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Distritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistritoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Distritos
     * const distrito = await prisma.distrito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DistritoUpdateManyArgs>(args: SelectSubset<T, DistritoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Distritos and returns the data updated in the database.
     * @param {DistritoUpdateManyAndReturnArgs} args - Arguments to update many Distritos.
     * @example
     * // Update many Distritos
     * const distrito = await prisma.distrito.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Distritos and only return the `id`
     * const distritoWithIdOnly = await prisma.distrito.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DistritoUpdateManyAndReturnArgs>(args: SelectSubset<T, DistritoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Distrito.
     * @param {DistritoUpsertArgs} args - Arguments to update or create a Distrito.
     * @example
     * // Update or create a Distrito
     * const distrito = await prisma.distrito.upsert({
     *   create: {
     *     // ... data to create a Distrito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Distrito we want to update
     *   }
     * })
     */
    upsert<T extends DistritoUpsertArgs>(args: SelectSubset<T, DistritoUpsertArgs<ExtArgs>>): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Distritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistritoCountArgs} args - Arguments to filter Distritos to count.
     * @example
     * // Count the number of Distritos
     * const count = await prisma.distrito.count({
     *   where: {
     *     // ... the filter for the Distritos we want to count
     *   }
     * })
    **/
    count<T extends DistritoCountArgs>(
      args?: Subset<T, DistritoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistritoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Distrito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistritoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistritoAggregateArgs>(args: Subset<T, DistritoAggregateArgs>): Prisma.PrismaPromise<GetDistritoAggregateType<T>>

    /**
     * Group by Distrito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistritoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistritoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistritoGroupByArgs['orderBy'] }
        : { orderBy?: DistritoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistritoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistritoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Distrito model
   */
  readonly fields: DistritoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Distrito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistritoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bairros<T extends Distrito$bairrosArgs<ExtArgs> = {}>(args?: Subset<T, Distrito$bairrosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BairroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cidade<T extends CidadeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CidadeDefaultArgs<ExtArgs>>): Prisma__CidadeClient<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Distrito model
   */
  interface DistritoFieldRefs {
    readonly id: FieldRef<"Distrito", 'Int'>
    readonly cdCidade: FieldRef<"Distrito", 'Int'>
    readonly descricao: FieldRef<"Distrito", 'String'>
    readonly stInativo: FieldRef<"Distrito", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * Distrito findUnique
   */
  export type DistritoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distrito
     */
    omit?: DistritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * Filter, which Distrito to fetch.
     */
    where: DistritoWhereUniqueInput
  }

  /**
   * Distrito findUniqueOrThrow
   */
  export type DistritoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distrito
     */
    omit?: DistritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * Filter, which Distrito to fetch.
     */
    where: DistritoWhereUniqueInput
  }

  /**
   * Distrito findFirst
   */
  export type DistritoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distrito
     */
    omit?: DistritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * Filter, which Distrito to fetch.
     */
    where?: DistritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distritos to fetch.
     */
    orderBy?: DistritoOrderByWithRelationInput | DistritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Distritos.
     */
    cursor?: DistritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distritos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Distritos.
     */
    distinct?: DistritoScalarFieldEnum | DistritoScalarFieldEnum[]
  }

  /**
   * Distrito findFirstOrThrow
   */
  export type DistritoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distrito
     */
    omit?: DistritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * Filter, which Distrito to fetch.
     */
    where?: DistritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distritos to fetch.
     */
    orderBy?: DistritoOrderByWithRelationInput | DistritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Distritos.
     */
    cursor?: DistritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distritos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Distritos.
     */
    distinct?: DistritoScalarFieldEnum | DistritoScalarFieldEnum[]
  }

  /**
   * Distrito findMany
   */
  export type DistritoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distrito
     */
    omit?: DistritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * Filter, which Distritos to fetch.
     */
    where?: DistritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distritos to fetch.
     */
    orderBy?: DistritoOrderByWithRelationInput | DistritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Distritos.
     */
    cursor?: DistritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distritos.
     */
    skip?: number
    distinct?: DistritoScalarFieldEnum | DistritoScalarFieldEnum[]
  }

  /**
   * Distrito create
   */
  export type DistritoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distrito
     */
    omit?: DistritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * The data needed to create a Distrito.
     */
    data: XOR<DistritoCreateInput, DistritoUncheckedCreateInput>
  }

  /**
   * Distrito createMany
   */
  export type DistritoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Distritos.
     */
    data: DistritoCreateManyInput | DistritoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Distrito createManyAndReturn
   */
  export type DistritoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Distrito
     */
    omit?: DistritoOmit<ExtArgs> | null
    /**
     * The data used to create many Distritos.
     */
    data: DistritoCreateManyInput | DistritoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistritoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Distrito update
   */
  export type DistritoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distrito
     */
    omit?: DistritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * The data needed to update a Distrito.
     */
    data: XOR<DistritoUpdateInput, DistritoUncheckedUpdateInput>
    /**
     * Choose, which Distrito to update.
     */
    where: DistritoWhereUniqueInput
  }

  /**
   * Distrito updateMany
   */
  export type DistritoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Distritos.
     */
    data: XOR<DistritoUpdateManyMutationInput, DistritoUncheckedUpdateManyInput>
    /**
     * Filter which Distritos to update
     */
    where?: DistritoWhereInput
    /**
     * Limit how many Distritos to update.
     */
    limit?: number
  }

  /**
   * Distrito updateManyAndReturn
   */
  export type DistritoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Distrito
     */
    omit?: DistritoOmit<ExtArgs> | null
    /**
     * The data used to update Distritos.
     */
    data: XOR<DistritoUpdateManyMutationInput, DistritoUncheckedUpdateManyInput>
    /**
     * Filter which Distritos to update
     */
    where?: DistritoWhereInput
    /**
     * Limit how many Distritos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistritoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Distrito upsert
   */
  export type DistritoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distrito
     */
    omit?: DistritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * The filter to search for the Distrito to update in case it exists.
     */
    where: DistritoWhereUniqueInput
    /**
     * In case the Distrito found by the `where` argument doesn't exist, create a new Distrito with this data.
     */
    create: XOR<DistritoCreateInput, DistritoUncheckedCreateInput>
    /**
     * In case the Distrito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistritoUpdateInput, DistritoUncheckedUpdateInput>
  }

  /**
   * Distrito delete
   */
  export type DistritoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distrito
     */
    omit?: DistritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistritoInclude<ExtArgs> | null
    /**
     * Filter which Distrito to delete.
     */
    where: DistritoWhereUniqueInput
  }

  /**
   * Distrito deleteMany
   */
  export type DistritoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Distritos to delete
     */
    where?: DistritoWhereInput
    /**
     * Limit how many Distritos to delete.
     */
    limit?: number
  }

  /**
   * Distrito.bairros
   */
  export type Distrito$bairrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bairro
     */
    select?: BairroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bairro
     */
    omit?: BairroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BairroInclude<ExtArgs> | null
    where?: BairroWhereInput
    orderBy?: BairroOrderByWithRelationInput | BairroOrderByWithRelationInput[]
    cursor?: BairroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BairroScalarFieldEnum | BairroScalarFieldEnum[]
  }

  /**
   * Distrito without action
   */
  export type DistritoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distrito
     */
    omit?: DistritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistritoInclude<ExtArgs> | null
  }


  /**
   * Model Bairro
   */

  export type AggregateBairro = {
    _count: BairroCountAggregateOutputType | null
    _avg: BairroAvgAggregateOutputType | null
    _sum: BairroSumAggregateOutputType | null
    _min: BairroMinAggregateOutputType | null
    _max: BairroMaxAggregateOutputType | null
  }

  export type BairroAvgAggregateOutputType = {
    id: number | null
    cdDistrito: number | null
    cdCidade: number | null
  }

  export type BairroSumAggregateOutputType = {
    id: number | null
    cdDistrito: number | null
    cdCidade: number | null
  }

  export type BairroMinAggregateOutputType = {
    id: number | null
    cdDistrito: number | null
    cdCidade: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type BairroMaxAggregateOutputType = {
    id: number | null
    cdDistrito: number | null
    cdCidade: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type BairroCountAggregateOutputType = {
    id: number
    cdDistrito: number
    cdCidade: number
    descricao: number
    stInativo: number
    _all: number
  }


  export type BairroAvgAggregateInputType = {
    id?: true
    cdDistrito?: true
    cdCidade?: true
  }

  export type BairroSumAggregateInputType = {
    id?: true
    cdDistrito?: true
    cdCidade?: true
  }

  export type BairroMinAggregateInputType = {
    id?: true
    cdDistrito?: true
    cdCidade?: true
    descricao?: true
    stInativo?: true
  }

  export type BairroMaxAggregateInputType = {
    id?: true
    cdDistrito?: true
    cdCidade?: true
    descricao?: true
    stInativo?: true
  }

  export type BairroCountAggregateInputType = {
    id?: true
    cdDistrito?: true
    cdCidade?: true
    descricao?: true
    stInativo?: true
    _all?: true
  }

  export type BairroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bairro to aggregate.
     */
    where?: BairroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bairros to fetch.
     */
    orderBy?: BairroOrderByWithRelationInput | BairroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BairroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bairros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bairros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bairros
    **/
    _count?: true | BairroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BairroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BairroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BairroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BairroMaxAggregateInputType
  }

  export type GetBairroAggregateType<T extends BairroAggregateArgs> = {
        [P in keyof T & keyof AggregateBairro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBairro[P]>
      : GetScalarType<T[P], AggregateBairro[P]>
  }




  export type BairroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BairroWhereInput
    orderBy?: BairroOrderByWithAggregationInput | BairroOrderByWithAggregationInput[]
    by: BairroScalarFieldEnum[] | BairroScalarFieldEnum
    having?: BairroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BairroCountAggregateInputType | true
    _avg?: BairroAvgAggregateInputType
    _sum?: BairroSumAggregateInputType
    _min?: BairroMinAggregateInputType
    _max?: BairroMaxAggregateInputType
  }

  export type BairroGroupByOutputType = {
    id: number
    cdDistrito: number | null
    cdCidade: number
    descricao: string
    stInativo: $Enums.SimNao | null
    _count: BairroCountAggregateOutputType | null
    _avg: BairroAvgAggregateOutputType | null
    _sum: BairroSumAggregateOutputType | null
    _min: BairroMinAggregateOutputType | null
    _max: BairroMaxAggregateOutputType | null
  }

  type GetBairroGroupByPayload<T extends BairroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BairroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BairroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BairroGroupByOutputType[P]>
            : GetScalarType<T[P], BairroGroupByOutputType[P]>
        }
      >
    >


  export type BairroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdDistrito?: boolean
    cdCidade?: boolean
    descricao?: boolean
    stInativo?: boolean
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
    distrito?: boolean | Bairro$distritoArgs<ExtArgs>
    enderecos?: boolean | Bairro$enderecosArgs<ExtArgs>
    _count?: boolean | BairroCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bairro"]>

  export type BairroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdDistrito?: boolean
    cdCidade?: boolean
    descricao?: boolean
    stInativo?: boolean
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
    distrito?: boolean | Bairro$distritoArgs<ExtArgs>
  }, ExtArgs["result"]["bairro"]>

  export type BairroSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdDistrito?: boolean
    cdCidade?: boolean
    descricao?: boolean
    stInativo?: boolean
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
    distrito?: boolean | Bairro$distritoArgs<ExtArgs>
  }, ExtArgs["result"]["bairro"]>

  export type BairroSelectScalar = {
    id?: boolean
    cdDistrito?: boolean
    cdCidade?: boolean
    descricao?: boolean
    stInativo?: boolean
  }

  export type BairroOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdDistrito" | "cdCidade" | "descricao" | "stInativo", ExtArgs["result"]["bairro"]>
  export type BairroInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
    distrito?: boolean | Bairro$distritoArgs<ExtArgs>
    enderecos?: boolean | Bairro$enderecosArgs<ExtArgs>
    _count?: boolean | BairroCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BairroIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
    distrito?: boolean | Bairro$distritoArgs<ExtArgs>
  }
  export type BairroIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cidade?: boolean | CidadeDefaultArgs<ExtArgs>
    distrito?: boolean | Bairro$distritoArgs<ExtArgs>
  }

  export type $BairroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bairro"
    objects: {
      cidade: Prisma.$CidadePayload<ExtArgs>
      distrito: Prisma.$DistritoPayload<ExtArgs> | null
      enderecos: Prisma.$EnderecoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdDistrito: number | null
      cdCidade: number
      descricao: string
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["bairro"]>
    composites: {}
  }

  type BairroGetPayload<S extends boolean | null | undefined | BairroDefaultArgs> = $Result.GetResult<Prisma.$BairroPayload, S>

  type BairroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BairroFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BairroCountAggregateInputType | true
    }

  export interface BairroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bairro'], meta: { name: 'Bairro' } }
    /**
     * Find zero or one Bairro that matches the filter.
     * @param {BairroFindUniqueArgs} args - Arguments to find a Bairro
     * @example
     * // Get one Bairro
     * const bairro = await prisma.bairro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BairroFindUniqueArgs>(args: SelectSubset<T, BairroFindUniqueArgs<ExtArgs>>): Prisma__BairroClient<$Result.GetResult<Prisma.$BairroPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bairro that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BairroFindUniqueOrThrowArgs} args - Arguments to find a Bairro
     * @example
     * // Get one Bairro
     * const bairro = await prisma.bairro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BairroFindUniqueOrThrowArgs>(args: SelectSubset<T, BairroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BairroClient<$Result.GetResult<Prisma.$BairroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bairro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BairroFindFirstArgs} args - Arguments to find a Bairro
     * @example
     * // Get one Bairro
     * const bairro = await prisma.bairro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BairroFindFirstArgs>(args?: SelectSubset<T, BairroFindFirstArgs<ExtArgs>>): Prisma__BairroClient<$Result.GetResult<Prisma.$BairroPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bairro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BairroFindFirstOrThrowArgs} args - Arguments to find a Bairro
     * @example
     * // Get one Bairro
     * const bairro = await prisma.bairro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BairroFindFirstOrThrowArgs>(args?: SelectSubset<T, BairroFindFirstOrThrowArgs<ExtArgs>>): Prisma__BairroClient<$Result.GetResult<Prisma.$BairroPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bairros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BairroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bairros
     * const bairros = await prisma.bairro.findMany()
     * 
     * // Get first 10 Bairros
     * const bairros = await prisma.bairro.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bairroWithIdOnly = await prisma.bairro.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BairroFindManyArgs>(args?: SelectSubset<T, BairroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BairroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bairro.
     * @param {BairroCreateArgs} args - Arguments to create a Bairro.
     * @example
     * // Create one Bairro
     * const Bairro = await prisma.bairro.create({
     *   data: {
     *     // ... data to create a Bairro
     *   }
     * })
     * 
     */
    create<T extends BairroCreateArgs>(args: SelectSubset<T, BairroCreateArgs<ExtArgs>>): Prisma__BairroClient<$Result.GetResult<Prisma.$BairroPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bairros.
     * @param {BairroCreateManyArgs} args - Arguments to create many Bairros.
     * @example
     * // Create many Bairros
     * const bairro = await prisma.bairro.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BairroCreateManyArgs>(args?: SelectSubset<T, BairroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bairros and returns the data saved in the database.
     * @param {BairroCreateManyAndReturnArgs} args - Arguments to create many Bairros.
     * @example
     * // Create many Bairros
     * const bairro = await prisma.bairro.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bairros and only return the `id`
     * const bairroWithIdOnly = await prisma.bairro.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BairroCreateManyAndReturnArgs>(args?: SelectSubset<T, BairroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BairroPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bairro.
     * @param {BairroDeleteArgs} args - Arguments to delete one Bairro.
     * @example
     * // Delete one Bairro
     * const Bairro = await prisma.bairro.delete({
     *   where: {
     *     // ... filter to delete one Bairro
     *   }
     * })
     * 
     */
    delete<T extends BairroDeleteArgs>(args: SelectSubset<T, BairroDeleteArgs<ExtArgs>>): Prisma__BairroClient<$Result.GetResult<Prisma.$BairroPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bairro.
     * @param {BairroUpdateArgs} args - Arguments to update one Bairro.
     * @example
     * // Update one Bairro
     * const bairro = await prisma.bairro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BairroUpdateArgs>(args: SelectSubset<T, BairroUpdateArgs<ExtArgs>>): Prisma__BairroClient<$Result.GetResult<Prisma.$BairroPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bairros.
     * @param {BairroDeleteManyArgs} args - Arguments to filter Bairros to delete.
     * @example
     * // Delete a few Bairros
     * const { count } = await prisma.bairro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BairroDeleteManyArgs>(args?: SelectSubset<T, BairroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bairros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BairroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bairros
     * const bairro = await prisma.bairro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BairroUpdateManyArgs>(args: SelectSubset<T, BairroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bairros and returns the data updated in the database.
     * @param {BairroUpdateManyAndReturnArgs} args - Arguments to update many Bairros.
     * @example
     * // Update many Bairros
     * const bairro = await prisma.bairro.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bairros and only return the `id`
     * const bairroWithIdOnly = await prisma.bairro.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BairroUpdateManyAndReturnArgs>(args: SelectSubset<T, BairroUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BairroPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bairro.
     * @param {BairroUpsertArgs} args - Arguments to update or create a Bairro.
     * @example
     * // Update or create a Bairro
     * const bairro = await prisma.bairro.upsert({
     *   create: {
     *     // ... data to create a Bairro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bairro we want to update
     *   }
     * })
     */
    upsert<T extends BairroUpsertArgs>(args: SelectSubset<T, BairroUpsertArgs<ExtArgs>>): Prisma__BairroClient<$Result.GetResult<Prisma.$BairroPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bairros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BairroCountArgs} args - Arguments to filter Bairros to count.
     * @example
     * // Count the number of Bairros
     * const count = await prisma.bairro.count({
     *   where: {
     *     // ... the filter for the Bairros we want to count
     *   }
     * })
    **/
    count<T extends BairroCountArgs>(
      args?: Subset<T, BairroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BairroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bairro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BairroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BairroAggregateArgs>(args: Subset<T, BairroAggregateArgs>): Prisma.PrismaPromise<GetBairroAggregateType<T>>

    /**
     * Group by Bairro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BairroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BairroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BairroGroupByArgs['orderBy'] }
        : { orderBy?: BairroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BairroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBairroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bairro model
   */
  readonly fields: BairroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bairro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BairroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cidade<T extends CidadeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CidadeDefaultArgs<ExtArgs>>): Prisma__CidadeClient<$Result.GetResult<Prisma.$CidadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    distrito<T extends Bairro$distritoArgs<ExtArgs> = {}>(args?: Subset<T, Bairro$distritoArgs<ExtArgs>>): Prisma__DistritoClient<$Result.GetResult<Prisma.$DistritoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    enderecos<T extends Bairro$enderecosArgs<ExtArgs> = {}>(args?: Subset<T, Bairro$enderecosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bairro model
   */
  interface BairroFieldRefs {
    readonly id: FieldRef<"Bairro", 'Int'>
    readonly cdDistrito: FieldRef<"Bairro", 'Int'>
    readonly cdCidade: FieldRef<"Bairro", 'Int'>
    readonly descricao: FieldRef<"Bairro", 'String'>
    readonly stInativo: FieldRef<"Bairro", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * Bairro findUnique
   */
  export type BairroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bairro
     */
    select?: BairroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bairro
     */
    omit?: BairroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BairroInclude<ExtArgs> | null
    /**
     * Filter, which Bairro to fetch.
     */
    where: BairroWhereUniqueInput
  }

  /**
   * Bairro findUniqueOrThrow
   */
  export type BairroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bairro
     */
    select?: BairroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bairro
     */
    omit?: BairroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BairroInclude<ExtArgs> | null
    /**
     * Filter, which Bairro to fetch.
     */
    where: BairroWhereUniqueInput
  }

  /**
   * Bairro findFirst
   */
  export type BairroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bairro
     */
    select?: BairroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bairro
     */
    omit?: BairroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BairroInclude<ExtArgs> | null
    /**
     * Filter, which Bairro to fetch.
     */
    where?: BairroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bairros to fetch.
     */
    orderBy?: BairroOrderByWithRelationInput | BairroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bairros.
     */
    cursor?: BairroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bairros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bairros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bairros.
     */
    distinct?: BairroScalarFieldEnum | BairroScalarFieldEnum[]
  }

  /**
   * Bairro findFirstOrThrow
   */
  export type BairroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bairro
     */
    select?: BairroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bairro
     */
    omit?: BairroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BairroInclude<ExtArgs> | null
    /**
     * Filter, which Bairro to fetch.
     */
    where?: BairroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bairros to fetch.
     */
    orderBy?: BairroOrderByWithRelationInput | BairroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bairros.
     */
    cursor?: BairroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bairros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bairros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bairros.
     */
    distinct?: BairroScalarFieldEnum | BairroScalarFieldEnum[]
  }

  /**
   * Bairro findMany
   */
  export type BairroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bairro
     */
    select?: BairroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bairro
     */
    omit?: BairroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BairroInclude<ExtArgs> | null
    /**
     * Filter, which Bairros to fetch.
     */
    where?: BairroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bairros to fetch.
     */
    orderBy?: BairroOrderByWithRelationInput | BairroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bairros.
     */
    cursor?: BairroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bairros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bairros.
     */
    skip?: number
    distinct?: BairroScalarFieldEnum | BairroScalarFieldEnum[]
  }

  /**
   * Bairro create
   */
  export type BairroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bairro
     */
    select?: BairroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bairro
     */
    omit?: BairroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BairroInclude<ExtArgs> | null
    /**
     * The data needed to create a Bairro.
     */
    data: XOR<BairroCreateInput, BairroUncheckedCreateInput>
  }

  /**
   * Bairro createMany
   */
  export type BairroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bairros.
     */
    data: BairroCreateManyInput | BairroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bairro createManyAndReturn
   */
  export type BairroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bairro
     */
    select?: BairroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bairro
     */
    omit?: BairroOmit<ExtArgs> | null
    /**
     * The data used to create many Bairros.
     */
    data: BairroCreateManyInput | BairroCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BairroIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bairro update
   */
  export type BairroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bairro
     */
    select?: BairroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bairro
     */
    omit?: BairroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BairroInclude<ExtArgs> | null
    /**
     * The data needed to update a Bairro.
     */
    data: XOR<BairroUpdateInput, BairroUncheckedUpdateInput>
    /**
     * Choose, which Bairro to update.
     */
    where: BairroWhereUniqueInput
  }

  /**
   * Bairro updateMany
   */
  export type BairroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bairros.
     */
    data: XOR<BairroUpdateManyMutationInput, BairroUncheckedUpdateManyInput>
    /**
     * Filter which Bairros to update
     */
    where?: BairroWhereInput
    /**
     * Limit how many Bairros to update.
     */
    limit?: number
  }

  /**
   * Bairro updateManyAndReturn
   */
  export type BairroUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bairro
     */
    select?: BairroSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bairro
     */
    omit?: BairroOmit<ExtArgs> | null
    /**
     * The data used to update Bairros.
     */
    data: XOR<BairroUpdateManyMutationInput, BairroUncheckedUpdateManyInput>
    /**
     * Filter which Bairros to update
     */
    where?: BairroWhereInput
    /**
     * Limit how many Bairros to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BairroIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bairro upsert
   */
  export type BairroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bairro
     */
    select?: BairroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bairro
     */
    omit?: BairroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BairroInclude<ExtArgs> | null
    /**
     * The filter to search for the Bairro to update in case it exists.
     */
    where: BairroWhereUniqueInput
    /**
     * In case the Bairro found by the `where` argument doesn't exist, create a new Bairro with this data.
     */
    create: XOR<BairroCreateInput, BairroUncheckedCreateInput>
    /**
     * In case the Bairro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BairroUpdateInput, BairroUncheckedUpdateInput>
  }

  /**
   * Bairro delete
   */
  export type BairroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bairro
     */
    select?: BairroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bairro
     */
    omit?: BairroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BairroInclude<ExtArgs> | null
    /**
     * Filter which Bairro to delete.
     */
    where: BairroWhereUniqueInput
  }

  /**
   * Bairro deleteMany
   */
  export type BairroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bairros to delete
     */
    where?: BairroWhereInput
    /**
     * Limit how many Bairros to delete.
     */
    limit?: number
  }

  /**
   * Bairro.distrito
   */
  export type Bairro$distritoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distrito
     */
    select?: DistritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Distrito
     */
    omit?: DistritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistritoInclude<ExtArgs> | null
    where?: DistritoWhereInput
  }

  /**
   * Bairro.enderecos
   */
  export type Bairro$enderecosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    where?: EnderecoWhereInput
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    cursor?: EnderecoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * Bairro without action
   */
  export type BairroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bairro
     */
    select?: BairroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bairro
     */
    omit?: BairroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BairroInclude<ExtArgs> | null
  }


  /**
   * Model EnderecoPessoaRelacionada
   */

  export type AggregateEnderecoPessoaRelacionada = {
    _count: EnderecoPessoaRelacionadaCountAggregateOutputType | null
    _avg: EnderecoPessoaRelacionadaAvgAggregateOutputType | null
    _sum: EnderecoPessoaRelacionadaSumAggregateOutputType | null
    _min: EnderecoPessoaRelacionadaMinAggregateOutputType | null
    _max: EnderecoPessoaRelacionadaMaxAggregateOutputType | null
  }

  export type EnderecoPessoaRelacionadaAvgAggregateOutputType = {
    id: number | null
    cdPessoa: number | null
    cdEndereco: number | null
  }

  export type EnderecoPessoaRelacionadaSumAggregateOutputType = {
    id: number | null
    cdPessoa: number | null
    cdEndereco: number | null
  }

  export type EnderecoPessoaRelacionadaMinAggregateOutputType = {
    id: number | null
    cdPessoa: number | null
    cdEndereco: number | null
  }

  export type EnderecoPessoaRelacionadaMaxAggregateOutputType = {
    id: number | null
    cdPessoa: number | null
    cdEndereco: number | null
  }

  export type EnderecoPessoaRelacionadaCountAggregateOutputType = {
    id: number
    cdPessoa: number
    cdEndereco: number
    _all: number
  }


  export type EnderecoPessoaRelacionadaAvgAggregateInputType = {
    id?: true
    cdPessoa?: true
    cdEndereco?: true
  }

  export type EnderecoPessoaRelacionadaSumAggregateInputType = {
    id?: true
    cdPessoa?: true
    cdEndereco?: true
  }

  export type EnderecoPessoaRelacionadaMinAggregateInputType = {
    id?: true
    cdPessoa?: true
    cdEndereco?: true
  }

  export type EnderecoPessoaRelacionadaMaxAggregateInputType = {
    id?: true
    cdPessoa?: true
    cdEndereco?: true
  }

  export type EnderecoPessoaRelacionadaCountAggregateInputType = {
    id?: true
    cdPessoa?: true
    cdEndereco?: true
    _all?: true
  }

  export type EnderecoPessoaRelacionadaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnderecoPessoaRelacionada to aggregate.
     */
    where?: EnderecoPessoaRelacionadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnderecoPessoaRelacionadas to fetch.
     */
    orderBy?: EnderecoPessoaRelacionadaOrderByWithRelationInput | EnderecoPessoaRelacionadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnderecoPessoaRelacionadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnderecoPessoaRelacionadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnderecoPessoaRelacionadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EnderecoPessoaRelacionadas
    **/
    _count?: true | EnderecoPessoaRelacionadaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnderecoPessoaRelacionadaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnderecoPessoaRelacionadaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnderecoPessoaRelacionadaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnderecoPessoaRelacionadaMaxAggregateInputType
  }

  export type GetEnderecoPessoaRelacionadaAggregateType<T extends EnderecoPessoaRelacionadaAggregateArgs> = {
        [P in keyof T & keyof AggregateEnderecoPessoaRelacionada]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnderecoPessoaRelacionada[P]>
      : GetScalarType<T[P], AggregateEnderecoPessoaRelacionada[P]>
  }




  export type EnderecoPessoaRelacionadaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnderecoPessoaRelacionadaWhereInput
    orderBy?: EnderecoPessoaRelacionadaOrderByWithAggregationInput | EnderecoPessoaRelacionadaOrderByWithAggregationInput[]
    by: EnderecoPessoaRelacionadaScalarFieldEnum[] | EnderecoPessoaRelacionadaScalarFieldEnum
    having?: EnderecoPessoaRelacionadaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnderecoPessoaRelacionadaCountAggregateInputType | true
    _avg?: EnderecoPessoaRelacionadaAvgAggregateInputType
    _sum?: EnderecoPessoaRelacionadaSumAggregateInputType
    _min?: EnderecoPessoaRelacionadaMinAggregateInputType
    _max?: EnderecoPessoaRelacionadaMaxAggregateInputType
  }

  export type EnderecoPessoaRelacionadaGroupByOutputType = {
    id: number
    cdPessoa: number
    cdEndereco: number
    _count: EnderecoPessoaRelacionadaCountAggregateOutputType | null
    _avg: EnderecoPessoaRelacionadaAvgAggregateOutputType | null
    _sum: EnderecoPessoaRelacionadaSumAggregateOutputType | null
    _min: EnderecoPessoaRelacionadaMinAggregateOutputType | null
    _max: EnderecoPessoaRelacionadaMaxAggregateOutputType | null
  }

  type GetEnderecoPessoaRelacionadaGroupByPayload<T extends EnderecoPessoaRelacionadaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnderecoPessoaRelacionadaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnderecoPessoaRelacionadaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnderecoPessoaRelacionadaGroupByOutputType[P]>
            : GetScalarType<T[P], EnderecoPessoaRelacionadaGroupByOutputType[P]>
        }
      >
    >


  export type EnderecoPessoaRelacionadaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdPessoa?: boolean
    cdEndereco?: boolean
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    pessoaRelacionada?: boolean | PessoaRelacionadaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enderecoPessoaRelacionada"]>

  export type EnderecoPessoaRelacionadaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdPessoa?: boolean
    cdEndereco?: boolean
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    pessoaRelacionada?: boolean | PessoaRelacionadaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enderecoPessoaRelacionada"]>

  export type EnderecoPessoaRelacionadaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdPessoa?: boolean
    cdEndereco?: boolean
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    pessoaRelacionada?: boolean | PessoaRelacionadaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enderecoPessoaRelacionada"]>

  export type EnderecoPessoaRelacionadaSelectScalar = {
    id?: boolean
    cdPessoa?: boolean
    cdEndereco?: boolean
  }

  export type EnderecoPessoaRelacionadaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdPessoa" | "cdEndereco", ExtArgs["result"]["enderecoPessoaRelacionada"]>
  export type EnderecoPessoaRelacionadaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    pessoaRelacionada?: boolean | PessoaRelacionadaDefaultArgs<ExtArgs>
  }
  export type EnderecoPessoaRelacionadaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    pessoaRelacionada?: boolean | PessoaRelacionadaDefaultArgs<ExtArgs>
  }
  export type EnderecoPessoaRelacionadaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    pessoaRelacionada?: boolean | PessoaRelacionadaDefaultArgs<ExtArgs>
  }

  export type $EnderecoPessoaRelacionadaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EnderecoPessoaRelacionada"
    objects: {
      endereco: Prisma.$EnderecoPayload<ExtArgs>
      pessoaRelacionada: Prisma.$PessoaRelacionadaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdPessoa: number
      cdEndereco: number
    }, ExtArgs["result"]["enderecoPessoaRelacionada"]>
    composites: {}
  }

  type EnderecoPessoaRelacionadaGetPayload<S extends boolean | null | undefined | EnderecoPessoaRelacionadaDefaultArgs> = $Result.GetResult<Prisma.$EnderecoPessoaRelacionadaPayload, S>

  type EnderecoPessoaRelacionadaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnderecoPessoaRelacionadaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnderecoPessoaRelacionadaCountAggregateInputType | true
    }

  export interface EnderecoPessoaRelacionadaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EnderecoPessoaRelacionada'], meta: { name: 'EnderecoPessoaRelacionada' } }
    /**
     * Find zero or one EnderecoPessoaRelacionada that matches the filter.
     * @param {EnderecoPessoaRelacionadaFindUniqueArgs} args - Arguments to find a EnderecoPessoaRelacionada
     * @example
     * // Get one EnderecoPessoaRelacionada
     * const enderecoPessoaRelacionada = await prisma.enderecoPessoaRelacionada.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnderecoPessoaRelacionadaFindUniqueArgs>(args: SelectSubset<T, EnderecoPessoaRelacionadaFindUniqueArgs<ExtArgs>>): Prisma__EnderecoPessoaRelacionadaClient<$Result.GetResult<Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EnderecoPessoaRelacionada that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnderecoPessoaRelacionadaFindUniqueOrThrowArgs} args - Arguments to find a EnderecoPessoaRelacionada
     * @example
     * // Get one EnderecoPessoaRelacionada
     * const enderecoPessoaRelacionada = await prisma.enderecoPessoaRelacionada.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnderecoPessoaRelacionadaFindUniqueOrThrowArgs>(args: SelectSubset<T, EnderecoPessoaRelacionadaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnderecoPessoaRelacionadaClient<$Result.GetResult<Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnderecoPessoaRelacionada that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoPessoaRelacionadaFindFirstArgs} args - Arguments to find a EnderecoPessoaRelacionada
     * @example
     * // Get one EnderecoPessoaRelacionada
     * const enderecoPessoaRelacionada = await prisma.enderecoPessoaRelacionada.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnderecoPessoaRelacionadaFindFirstArgs>(args?: SelectSubset<T, EnderecoPessoaRelacionadaFindFirstArgs<ExtArgs>>): Prisma__EnderecoPessoaRelacionadaClient<$Result.GetResult<Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnderecoPessoaRelacionada that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoPessoaRelacionadaFindFirstOrThrowArgs} args - Arguments to find a EnderecoPessoaRelacionada
     * @example
     * // Get one EnderecoPessoaRelacionada
     * const enderecoPessoaRelacionada = await prisma.enderecoPessoaRelacionada.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnderecoPessoaRelacionadaFindFirstOrThrowArgs>(args?: SelectSubset<T, EnderecoPessoaRelacionadaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnderecoPessoaRelacionadaClient<$Result.GetResult<Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EnderecoPessoaRelacionadas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoPessoaRelacionadaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EnderecoPessoaRelacionadas
     * const enderecoPessoaRelacionadas = await prisma.enderecoPessoaRelacionada.findMany()
     * 
     * // Get first 10 EnderecoPessoaRelacionadas
     * const enderecoPessoaRelacionadas = await prisma.enderecoPessoaRelacionada.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enderecoPessoaRelacionadaWithIdOnly = await prisma.enderecoPessoaRelacionada.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnderecoPessoaRelacionadaFindManyArgs>(args?: SelectSubset<T, EnderecoPessoaRelacionadaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EnderecoPessoaRelacionada.
     * @param {EnderecoPessoaRelacionadaCreateArgs} args - Arguments to create a EnderecoPessoaRelacionada.
     * @example
     * // Create one EnderecoPessoaRelacionada
     * const EnderecoPessoaRelacionada = await prisma.enderecoPessoaRelacionada.create({
     *   data: {
     *     // ... data to create a EnderecoPessoaRelacionada
     *   }
     * })
     * 
     */
    create<T extends EnderecoPessoaRelacionadaCreateArgs>(args: SelectSubset<T, EnderecoPessoaRelacionadaCreateArgs<ExtArgs>>): Prisma__EnderecoPessoaRelacionadaClient<$Result.GetResult<Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EnderecoPessoaRelacionadas.
     * @param {EnderecoPessoaRelacionadaCreateManyArgs} args - Arguments to create many EnderecoPessoaRelacionadas.
     * @example
     * // Create many EnderecoPessoaRelacionadas
     * const enderecoPessoaRelacionada = await prisma.enderecoPessoaRelacionada.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnderecoPessoaRelacionadaCreateManyArgs>(args?: SelectSubset<T, EnderecoPessoaRelacionadaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EnderecoPessoaRelacionadas and returns the data saved in the database.
     * @param {EnderecoPessoaRelacionadaCreateManyAndReturnArgs} args - Arguments to create many EnderecoPessoaRelacionadas.
     * @example
     * // Create many EnderecoPessoaRelacionadas
     * const enderecoPessoaRelacionada = await prisma.enderecoPessoaRelacionada.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EnderecoPessoaRelacionadas and only return the `id`
     * const enderecoPessoaRelacionadaWithIdOnly = await prisma.enderecoPessoaRelacionada.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnderecoPessoaRelacionadaCreateManyAndReturnArgs>(args?: SelectSubset<T, EnderecoPessoaRelacionadaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EnderecoPessoaRelacionada.
     * @param {EnderecoPessoaRelacionadaDeleteArgs} args - Arguments to delete one EnderecoPessoaRelacionada.
     * @example
     * // Delete one EnderecoPessoaRelacionada
     * const EnderecoPessoaRelacionada = await prisma.enderecoPessoaRelacionada.delete({
     *   where: {
     *     // ... filter to delete one EnderecoPessoaRelacionada
     *   }
     * })
     * 
     */
    delete<T extends EnderecoPessoaRelacionadaDeleteArgs>(args: SelectSubset<T, EnderecoPessoaRelacionadaDeleteArgs<ExtArgs>>): Prisma__EnderecoPessoaRelacionadaClient<$Result.GetResult<Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EnderecoPessoaRelacionada.
     * @param {EnderecoPessoaRelacionadaUpdateArgs} args - Arguments to update one EnderecoPessoaRelacionada.
     * @example
     * // Update one EnderecoPessoaRelacionada
     * const enderecoPessoaRelacionada = await prisma.enderecoPessoaRelacionada.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnderecoPessoaRelacionadaUpdateArgs>(args: SelectSubset<T, EnderecoPessoaRelacionadaUpdateArgs<ExtArgs>>): Prisma__EnderecoPessoaRelacionadaClient<$Result.GetResult<Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EnderecoPessoaRelacionadas.
     * @param {EnderecoPessoaRelacionadaDeleteManyArgs} args - Arguments to filter EnderecoPessoaRelacionadas to delete.
     * @example
     * // Delete a few EnderecoPessoaRelacionadas
     * const { count } = await prisma.enderecoPessoaRelacionada.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnderecoPessoaRelacionadaDeleteManyArgs>(args?: SelectSubset<T, EnderecoPessoaRelacionadaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnderecoPessoaRelacionadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoPessoaRelacionadaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EnderecoPessoaRelacionadas
     * const enderecoPessoaRelacionada = await prisma.enderecoPessoaRelacionada.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnderecoPessoaRelacionadaUpdateManyArgs>(args: SelectSubset<T, EnderecoPessoaRelacionadaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnderecoPessoaRelacionadas and returns the data updated in the database.
     * @param {EnderecoPessoaRelacionadaUpdateManyAndReturnArgs} args - Arguments to update many EnderecoPessoaRelacionadas.
     * @example
     * // Update many EnderecoPessoaRelacionadas
     * const enderecoPessoaRelacionada = await prisma.enderecoPessoaRelacionada.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EnderecoPessoaRelacionadas and only return the `id`
     * const enderecoPessoaRelacionadaWithIdOnly = await prisma.enderecoPessoaRelacionada.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnderecoPessoaRelacionadaUpdateManyAndReturnArgs>(args: SelectSubset<T, EnderecoPessoaRelacionadaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EnderecoPessoaRelacionada.
     * @param {EnderecoPessoaRelacionadaUpsertArgs} args - Arguments to update or create a EnderecoPessoaRelacionada.
     * @example
     * // Update or create a EnderecoPessoaRelacionada
     * const enderecoPessoaRelacionada = await prisma.enderecoPessoaRelacionada.upsert({
     *   create: {
     *     // ... data to create a EnderecoPessoaRelacionada
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EnderecoPessoaRelacionada we want to update
     *   }
     * })
     */
    upsert<T extends EnderecoPessoaRelacionadaUpsertArgs>(args: SelectSubset<T, EnderecoPessoaRelacionadaUpsertArgs<ExtArgs>>): Prisma__EnderecoPessoaRelacionadaClient<$Result.GetResult<Prisma.$EnderecoPessoaRelacionadaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EnderecoPessoaRelacionadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoPessoaRelacionadaCountArgs} args - Arguments to filter EnderecoPessoaRelacionadas to count.
     * @example
     * // Count the number of EnderecoPessoaRelacionadas
     * const count = await prisma.enderecoPessoaRelacionada.count({
     *   where: {
     *     // ... the filter for the EnderecoPessoaRelacionadas we want to count
     *   }
     * })
    **/
    count<T extends EnderecoPessoaRelacionadaCountArgs>(
      args?: Subset<T, EnderecoPessoaRelacionadaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnderecoPessoaRelacionadaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EnderecoPessoaRelacionada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoPessoaRelacionadaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnderecoPessoaRelacionadaAggregateArgs>(args: Subset<T, EnderecoPessoaRelacionadaAggregateArgs>): Prisma.PrismaPromise<GetEnderecoPessoaRelacionadaAggregateType<T>>

    /**
     * Group by EnderecoPessoaRelacionada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoPessoaRelacionadaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnderecoPessoaRelacionadaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnderecoPessoaRelacionadaGroupByArgs['orderBy'] }
        : { orderBy?: EnderecoPessoaRelacionadaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnderecoPessoaRelacionadaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnderecoPessoaRelacionadaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EnderecoPessoaRelacionada model
   */
  readonly fields: EnderecoPessoaRelacionadaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EnderecoPessoaRelacionada.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnderecoPessoaRelacionadaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    endereco<T extends EnderecoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnderecoDefaultArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pessoaRelacionada<T extends PessoaRelacionadaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PessoaRelacionadaDefaultArgs<ExtArgs>>): Prisma__PessoaRelacionadaClient<$Result.GetResult<Prisma.$PessoaRelacionadaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EnderecoPessoaRelacionada model
   */
  interface EnderecoPessoaRelacionadaFieldRefs {
    readonly id: FieldRef<"EnderecoPessoaRelacionada", 'Int'>
    readonly cdPessoa: FieldRef<"EnderecoPessoaRelacionada", 'Int'>
    readonly cdEndereco: FieldRef<"EnderecoPessoaRelacionada", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EnderecoPessoaRelacionada findUnique
   */
  export type EnderecoPessoaRelacionadaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPessoaRelacionada
     */
    select?: EnderecoPessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPessoaRelacionada
     */
    omit?: EnderecoPessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPessoaRelacionadaInclude<ExtArgs> | null
    /**
     * Filter, which EnderecoPessoaRelacionada to fetch.
     */
    where: EnderecoPessoaRelacionadaWhereUniqueInput
  }

  /**
   * EnderecoPessoaRelacionada findUniqueOrThrow
   */
  export type EnderecoPessoaRelacionadaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPessoaRelacionada
     */
    select?: EnderecoPessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPessoaRelacionada
     */
    omit?: EnderecoPessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPessoaRelacionadaInclude<ExtArgs> | null
    /**
     * Filter, which EnderecoPessoaRelacionada to fetch.
     */
    where: EnderecoPessoaRelacionadaWhereUniqueInput
  }

  /**
   * EnderecoPessoaRelacionada findFirst
   */
  export type EnderecoPessoaRelacionadaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPessoaRelacionada
     */
    select?: EnderecoPessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPessoaRelacionada
     */
    omit?: EnderecoPessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPessoaRelacionadaInclude<ExtArgs> | null
    /**
     * Filter, which EnderecoPessoaRelacionada to fetch.
     */
    where?: EnderecoPessoaRelacionadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnderecoPessoaRelacionadas to fetch.
     */
    orderBy?: EnderecoPessoaRelacionadaOrderByWithRelationInput | EnderecoPessoaRelacionadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnderecoPessoaRelacionadas.
     */
    cursor?: EnderecoPessoaRelacionadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnderecoPessoaRelacionadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnderecoPessoaRelacionadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnderecoPessoaRelacionadas.
     */
    distinct?: EnderecoPessoaRelacionadaScalarFieldEnum | EnderecoPessoaRelacionadaScalarFieldEnum[]
  }

  /**
   * EnderecoPessoaRelacionada findFirstOrThrow
   */
  export type EnderecoPessoaRelacionadaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPessoaRelacionada
     */
    select?: EnderecoPessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPessoaRelacionada
     */
    omit?: EnderecoPessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPessoaRelacionadaInclude<ExtArgs> | null
    /**
     * Filter, which EnderecoPessoaRelacionada to fetch.
     */
    where?: EnderecoPessoaRelacionadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnderecoPessoaRelacionadas to fetch.
     */
    orderBy?: EnderecoPessoaRelacionadaOrderByWithRelationInput | EnderecoPessoaRelacionadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnderecoPessoaRelacionadas.
     */
    cursor?: EnderecoPessoaRelacionadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnderecoPessoaRelacionadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnderecoPessoaRelacionadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnderecoPessoaRelacionadas.
     */
    distinct?: EnderecoPessoaRelacionadaScalarFieldEnum | EnderecoPessoaRelacionadaScalarFieldEnum[]
  }

  /**
   * EnderecoPessoaRelacionada findMany
   */
  export type EnderecoPessoaRelacionadaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPessoaRelacionada
     */
    select?: EnderecoPessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPessoaRelacionada
     */
    omit?: EnderecoPessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPessoaRelacionadaInclude<ExtArgs> | null
    /**
     * Filter, which EnderecoPessoaRelacionadas to fetch.
     */
    where?: EnderecoPessoaRelacionadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnderecoPessoaRelacionadas to fetch.
     */
    orderBy?: EnderecoPessoaRelacionadaOrderByWithRelationInput | EnderecoPessoaRelacionadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EnderecoPessoaRelacionadas.
     */
    cursor?: EnderecoPessoaRelacionadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnderecoPessoaRelacionadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnderecoPessoaRelacionadas.
     */
    skip?: number
    distinct?: EnderecoPessoaRelacionadaScalarFieldEnum | EnderecoPessoaRelacionadaScalarFieldEnum[]
  }

  /**
   * EnderecoPessoaRelacionada create
   */
  export type EnderecoPessoaRelacionadaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPessoaRelacionada
     */
    select?: EnderecoPessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPessoaRelacionada
     */
    omit?: EnderecoPessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPessoaRelacionadaInclude<ExtArgs> | null
    /**
     * The data needed to create a EnderecoPessoaRelacionada.
     */
    data: XOR<EnderecoPessoaRelacionadaCreateInput, EnderecoPessoaRelacionadaUncheckedCreateInput>
  }

  /**
   * EnderecoPessoaRelacionada createMany
   */
  export type EnderecoPessoaRelacionadaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EnderecoPessoaRelacionadas.
     */
    data: EnderecoPessoaRelacionadaCreateManyInput | EnderecoPessoaRelacionadaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EnderecoPessoaRelacionada createManyAndReturn
   */
  export type EnderecoPessoaRelacionadaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPessoaRelacionada
     */
    select?: EnderecoPessoaRelacionadaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPessoaRelacionada
     */
    omit?: EnderecoPessoaRelacionadaOmit<ExtArgs> | null
    /**
     * The data used to create many EnderecoPessoaRelacionadas.
     */
    data: EnderecoPessoaRelacionadaCreateManyInput | EnderecoPessoaRelacionadaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPessoaRelacionadaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnderecoPessoaRelacionada update
   */
  export type EnderecoPessoaRelacionadaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPessoaRelacionada
     */
    select?: EnderecoPessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPessoaRelacionada
     */
    omit?: EnderecoPessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPessoaRelacionadaInclude<ExtArgs> | null
    /**
     * The data needed to update a EnderecoPessoaRelacionada.
     */
    data: XOR<EnderecoPessoaRelacionadaUpdateInput, EnderecoPessoaRelacionadaUncheckedUpdateInput>
    /**
     * Choose, which EnderecoPessoaRelacionada to update.
     */
    where: EnderecoPessoaRelacionadaWhereUniqueInput
  }

  /**
   * EnderecoPessoaRelacionada updateMany
   */
  export type EnderecoPessoaRelacionadaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EnderecoPessoaRelacionadas.
     */
    data: XOR<EnderecoPessoaRelacionadaUpdateManyMutationInput, EnderecoPessoaRelacionadaUncheckedUpdateManyInput>
    /**
     * Filter which EnderecoPessoaRelacionadas to update
     */
    where?: EnderecoPessoaRelacionadaWhereInput
    /**
     * Limit how many EnderecoPessoaRelacionadas to update.
     */
    limit?: number
  }

  /**
   * EnderecoPessoaRelacionada updateManyAndReturn
   */
  export type EnderecoPessoaRelacionadaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPessoaRelacionada
     */
    select?: EnderecoPessoaRelacionadaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPessoaRelacionada
     */
    omit?: EnderecoPessoaRelacionadaOmit<ExtArgs> | null
    /**
     * The data used to update EnderecoPessoaRelacionadas.
     */
    data: XOR<EnderecoPessoaRelacionadaUpdateManyMutationInput, EnderecoPessoaRelacionadaUncheckedUpdateManyInput>
    /**
     * Filter which EnderecoPessoaRelacionadas to update
     */
    where?: EnderecoPessoaRelacionadaWhereInput
    /**
     * Limit how many EnderecoPessoaRelacionadas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPessoaRelacionadaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnderecoPessoaRelacionada upsert
   */
  export type EnderecoPessoaRelacionadaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPessoaRelacionada
     */
    select?: EnderecoPessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPessoaRelacionada
     */
    omit?: EnderecoPessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPessoaRelacionadaInclude<ExtArgs> | null
    /**
     * The filter to search for the EnderecoPessoaRelacionada to update in case it exists.
     */
    where: EnderecoPessoaRelacionadaWhereUniqueInput
    /**
     * In case the EnderecoPessoaRelacionada found by the `where` argument doesn't exist, create a new EnderecoPessoaRelacionada with this data.
     */
    create: XOR<EnderecoPessoaRelacionadaCreateInput, EnderecoPessoaRelacionadaUncheckedCreateInput>
    /**
     * In case the EnderecoPessoaRelacionada was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnderecoPessoaRelacionadaUpdateInput, EnderecoPessoaRelacionadaUncheckedUpdateInput>
  }

  /**
   * EnderecoPessoaRelacionada delete
   */
  export type EnderecoPessoaRelacionadaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPessoaRelacionada
     */
    select?: EnderecoPessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPessoaRelacionada
     */
    omit?: EnderecoPessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPessoaRelacionadaInclude<ExtArgs> | null
    /**
     * Filter which EnderecoPessoaRelacionada to delete.
     */
    where: EnderecoPessoaRelacionadaWhereUniqueInput
  }

  /**
   * EnderecoPessoaRelacionada deleteMany
   */
  export type EnderecoPessoaRelacionadaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnderecoPessoaRelacionadas to delete
     */
    where?: EnderecoPessoaRelacionadaWhereInput
    /**
     * Limit how many EnderecoPessoaRelacionadas to delete.
     */
    limit?: number
  }

  /**
   * EnderecoPessoaRelacionada without action
   */
  export type EnderecoPessoaRelacionadaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoPessoaRelacionada
     */
    select?: EnderecoPessoaRelacionadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnderecoPessoaRelacionada
     */
    omit?: EnderecoPessoaRelacionadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoPessoaRelacionadaInclude<ExtArgs> | null
  }


  /**
   * Model Cid
   */

  export type AggregateCid = {
    _count: CidCountAggregateOutputType | null
    _avg: CidAvgAggregateOutputType | null
    _sum: CidSumAggregateOutputType | null
    _min: CidMinAggregateOutputType | null
    _max: CidMaxAggregateOutputType | null
  }

  export type CidAvgAggregateOutputType = {
    id: number | null
  }

  export type CidSumAggregateOutputType = {
    id: number | null
  }

  export type CidMinAggregateOutputType = {
    id: number | null
    codigo: string | null
    descricao: string | null
    versao: $Enums.VersaoCid | null
    stInativo: $Enums.SimNao | null
  }

  export type CidMaxAggregateOutputType = {
    id: number | null
    codigo: string | null
    descricao: string | null
    versao: $Enums.VersaoCid | null
    stInativo: $Enums.SimNao | null
  }

  export type CidCountAggregateOutputType = {
    id: number
    codigo: number
    descricao: number
    versao: number
    stInativo: number
    _all: number
  }


  export type CidAvgAggregateInputType = {
    id?: true
  }

  export type CidSumAggregateInputType = {
    id?: true
  }

  export type CidMinAggregateInputType = {
    id?: true
    codigo?: true
    descricao?: true
    versao?: true
    stInativo?: true
  }

  export type CidMaxAggregateInputType = {
    id?: true
    codigo?: true
    descricao?: true
    versao?: true
    stInativo?: true
  }

  export type CidCountAggregateInputType = {
    id?: true
    codigo?: true
    descricao?: true
    versao?: true
    stInativo?: true
    _all?: true
  }

  export type CidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cid to aggregate.
     */
    where?: CidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cids to fetch.
     */
    orderBy?: CidOrderByWithRelationInput | CidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cids
    **/
    _count?: true | CidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CidAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CidSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CidMaxAggregateInputType
  }

  export type GetCidAggregateType<T extends CidAggregateArgs> = {
        [P in keyof T & keyof AggregateCid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCid[P]>
      : GetScalarType<T[P], AggregateCid[P]>
  }




  export type CidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CidWhereInput
    orderBy?: CidOrderByWithAggregationInput | CidOrderByWithAggregationInput[]
    by: CidScalarFieldEnum[] | CidScalarFieldEnum
    having?: CidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CidCountAggregateInputType | true
    _avg?: CidAvgAggregateInputType
    _sum?: CidSumAggregateInputType
    _min?: CidMinAggregateInputType
    _max?: CidMaxAggregateInputType
  }

  export type CidGroupByOutputType = {
    id: number
    codigo: string
    descricao: string
    versao: $Enums.VersaoCid
    stInativo: $Enums.SimNao | null
    _count: CidCountAggregateOutputType | null
    _avg: CidAvgAggregateOutputType | null
    _sum: CidSumAggregateOutputType | null
    _min: CidMinAggregateOutputType | null
    _max: CidMaxAggregateOutputType | null
  }

  type GetCidGroupByPayload<T extends CidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CidGroupByOutputType[P]>
            : GetScalarType<T[P], CidGroupByOutputType[P]>
        }
      >
    >


  export type CidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    descricao?: boolean
    versao?: boolean
    stInativo?: boolean
    evolucaoCids?: boolean | Cid$evolucaoCidsArgs<ExtArgs>
    _count?: boolean | CidCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cid"]>

  export type CidSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    descricao?: boolean
    versao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["cid"]>

  export type CidSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    descricao?: boolean
    versao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["cid"]>

  export type CidSelectScalar = {
    id?: boolean
    codigo?: boolean
    descricao?: boolean
    versao?: boolean
    stInativo?: boolean
  }

  export type CidOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codigo" | "descricao" | "versao" | "stInativo", ExtArgs["result"]["cid"]>
  export type CidInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evolucaoCids?: boolean | Cid$evolucaoCidsArgs<ExtArgs>
    _count?: boolean | CidCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CidIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CidIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cid"
    objects: {
      evolucaoCids: Prisma.$EvolucaoCidPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigo: string
      descricao: string
      versao: $Enums.VersaoCid
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["cid"]>
    composites: {}
  }

  type CidGetPayload<S extends boolean | null | undefined | CidDefaultArgs> = $Result.GetResult<Prisma.$CidPayload, S>

  type CidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CidFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CidCountAggregateInputType | true
    }

  export interface CidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cid'], meta: { name: 'Cid' } }
    /**
     * Find zero or one Cid that matches the filter.
     * @param {CidFindUniqueArgs} args - Arguments to find a Cid
     * @example
     * // Get one Cid
     * const cid = await prisma.cid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CidFindUniqueArgs>(args: SelectSubset<T, CidFindUniqueArgs<ExtArgs>>): Prisma__CidClient<$Result.GetResult<Prisma.$CidPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cid that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CidFindUniqueOrThrowArgs} args - Arguments to find a Cid
     * @example
     * // Get one Cid
     * const cid = await prisma.cid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CidFindUniqueOrThrowArgs>(args: SelectSubset<T, CidFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CidClient<$Result.GetResult<Prisma.$CidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidFindFirstArgs} args - Arguments to find a Cid
     * @example
     * // Get one Cid
     * const cid = await prisma.cid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CidFindFirstArgs>(args?: SelectSubset<T, CidFindFirstArgs<ExtArgs>>): Prisma__CidClient<$Result.GetResult<Prisma.$CidPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidFindFirstOrThrowArgs} args - Arguments to find a Cid
     * @example
     * // Get one Cid
     * const cid = await prisma.cid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CidFindFirstOrThrowArgs>(args?: SelectSubset<T, CidFindFirstOrThrowArgs<ExtArgs>>): Prisma__CidClient<$Result.GetResult<Prisma.$CidPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cids
     * const cids = await prisma.cid.findMany()
     * 
     * // Get first 10 Cids
     * const cids = await prisma.cid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cidWithIdOnly = await prisma.cid.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CidFindManyArgs>(args?: SelectSubset<T, CidFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cid.
     * @param {CidCreateArgs} args - Arguments to create a Cid.
     * @example
     * // Create one Cid
     * const Cid = await prisma.cid.create({
     *   data: {
     *     // ... data to create a Cid
     *   }
     * })
     * 
     */
    create<T extends CidCreateArgs>(args: SelectSubset<T, CidCreateArgs<ExtArgs>>): Prisma__CidClient<$Result.GetResult<Prisma.$CidPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cids.
     * @param {CidCreateManyArgs} args - Arguments to create many Cids.
     * @example
     * // Create many Cids
     * const cid = await prisma.cid.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CidCreateManyArgs>(args?: SelectSubset<T, CidCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cids and returns the data saved in the database.
     * @param {CidCreateManyAndReturnArgs} args - Arguments to create many Cids.
     * @example
     * // Create many Cids
     * const cid = await prisma.cid.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cids and only return the `id`
     * const cidWithIdOnly = await prisma.cid.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CidCreateManyAndReturnArgs>(args?: SelectSubset<T, CidCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CidPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cid.
     * @param {CidDeleteArgs} args - Arguments to delete one Cid.
     * @example
     * // Delete one Cid
     * const Cid = await prisma.cid.delete({
     *   where: {
     *     // ... filter to delete one Cid
     *   }
     * })
     * 
     */
    delete<T extends CidDeleteArgs>(args: SelectSubset<T, CidDeleteArgs<ExtArgs>>): Prisma__CidClient<$Result.GetResult<Prisma.$CidPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cid.
     * @param {CidUpdateArgs} args - Arguments to update one Cid.
     * @example
     * // Update one Cid
     * const cid = await prisma.cid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CidUpdateArgs>(args: SelectSubset<T, CidUpdateArgs<ExtArgs>>): Prisma__CidClient<$Result.GetResult<Prisma.$CidPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cids.
     * @param {CidDeleteManyArgs} args - Arguments to filter Cids to delete.
     * @example
     * // Delete a few Cids
     * const { count } = await prisma.cid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CidDeleteManyArgs>(args?: SelectSubset<T, CidDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cids
     * const cid = await prisma.cid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CidUpdateManyArgs>(args: SelectSubset<T, CidUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cids and returns the data updated in the database.
     * @param {CidUpdateManyAndReturnArgs} args - Arguments to update many Cids.
     * @example
     * // Update many Cids
     * const cid = await prisma.cid.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cids and only return the `id`
     * const cidWithIdOnly = await prisma.cid.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CidUpdateManyAndReturnArgs>(args: SelectSubset<T, CidUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CidPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cid.
     * @param {CidUpsertArgs} args - Arguments to update or create a Cid.
     * @example
     * // Update or create a Cid
     * const cid = await prisma.cid.upsert({
     *   create: {
     *     // ... data to create a Cid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cid we want to update
     *   }
     * })
     */
    upsert<T extends CidUpsertArgs>(args: SelectSubset<T, CidUpsertArgs<ExtArgs>>): Prisma__CidClient<$Result.GetResult<Prisma.$CidPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidCountArgs} args - Arguments to filter Cids to count.
     * @example
     * // Count the number of Cids
     * const count = await prisma.cid.count({
     *   where: {
     *     // ... the filter for the Cids we want to count
     *   }
     * })
    **/
    count<T extends CidCountArgs>(
      args?: Subset<T, CidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CidAggregateArgs>(args: Subset<T, CidAggregateArgs>): Prisma.PrismaPromise<GetCidAggregateType<T>>

    /**
     * Group by Cid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CidGroupByArgs['orderBy'] }
        : { orderBy?: CidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cid model
   */
  readonly fields: CidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evolucaoCids<T extends Cid$evolucaoCidsArgs<ExtArgs> = {}>(args?: Subset<T, Cid$evolucaoCidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoCidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cid model
   */
  interface CidFieldRefs {
    readonly id: FieldRef<"Cid", 'Int'>
    readonly codigo: FieldRef<"Cid", 'String'>
    readonly descricao: FieldRef<"Cid", 'String'>
    readonly versao: FieldRef<"Cid", 'VersaoCid'>
    readonly stInativo: FieldRef<"Cid", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * Cid findUnique
   */
  export type CidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cid
     */
    select?: CidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cid
     */
    omit?: CidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidInclude<ExtArgs> | null
    /**
     * Filter, which Cid to fetch.
     */
    where: CidWhereUniqueInput
  }

  /**
   * Cid findUniqueOrThrow
   */
  export type CidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cid
     */
    select?: CidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cid
     */
    omit?: CidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidInclude<ExtArgs> | null
    /**
     * Filter, which Cid to fetch.
     */
    where: CidWhereUniqueInput
  }

  /**
   * Cid findFirst
   */
  export type CidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cid
     */
    select?: CidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cid
     */
    omit?: CidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidInclude<ExtArgs> | null
    /**
     * Filter, which Cid to fetch.
     */
    where?: CidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cids to fetch.
     */
    orderBy?: CidOrderByWithRelationInput | CidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cids.
     */
    cursor?: CidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cids.
     */
    distinct?: CidScalarFieldEnum | CidScalarFieldEnum[]
  }

  /**
   * Cid findFirstOrThrow
   */
  export type CidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cid
     */
    select?: CidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cid
     */
    omit?: CidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidInclude<ExtArgs> | null
    /**
     * Filter, which Cid to fetch.
     */
    where?: CidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cids to fetch.
     */
    orderBy?: CidOrderByWithRelationInput | CidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cids.
     */
    cursor?: CidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cids.
     */
    distinct?: CidScalarFieldEnum | CidScalarFieldEnum[]
  }

  /**
   * Cid findMany
   */
  export type CidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cid
     */
    select?: CidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cid
     */
    omit?: CidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidInclude<ExtArgs> | null
    /**
     * Filter, which Cids to fetch.
     */
    where?: CidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cids to fetch.
     */
    orderBy?: CidOrderByWithRelationInput | CidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cids.
     */
    cursor?: CidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cids.
     */
    skip?: number
    distinct?: CidScalarFieldEnum | CidScalarFieldEnum[]
  }

  /**
   * Cid create
   */
  export type CidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cid
     */
    select?: CidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cid
     */
    omit?: CidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidInclude<ExtArgs> | null
    /**
     * The data needed to create a Cid.
     */
    data: XOR<CidCreateInput, CidUncheckedCreateInput>
  }

  /**
   * Cid createMany
   */
  export type CidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cids.
     */
    data: CidCreateManyInput | CidCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cid createManyAndReturn
   */
  export type CidCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cid
     */
    select?: CidSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cid
     */
    omit?: CidOmit<ExtArgs> | null
    /**
     * The data used to create many Cids.
     */
    data: CidCreateManyInput | CidCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cid update
   */
  export type CidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cid
     */
    select?: CidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cid
     */
    omit?: CidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidInclude<ExtArgs> | null
    /**
     * The data needed to update a Cid.
     */
    data: XOR<CidUpdateInput, CidUncheckedUpdateInput>
    /**
     * Choose, which Cid to update.
     */
    where: CidWhereUniqueInput
  }

  /**
   * Cid updateMany
   */
  export type CidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cids.
     */
    data: XOR<CidUpdateManyMutationInput, CidUncheckedUpdateManyInput>
    /**
     * Filter which Cids to update
     */
    where?: CidWhereInput
    /**
     * Limit how many Cids to update.
     */
    limit?: number
  }

  /**
   * Cid updateManyAndReturn
   */
  export type CidUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cid
     */
    select?: CidSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cid
     */
    omit?: CidOmit<ExtArgs> | null
    /**
     * The data used to update Cids.
     */
    data: XOR<CidUpdateManyMutationInput, CidUncheckedUpdateManyInput>
    /**
     * Filter which Cids to update
     */
    where?: CidWhereInput
    /**
     * Limit how many Cids to update.
     */
    limit?: number
  }

  /**
   * Cid upsert
   */
  export type CidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cid
     */
    select?: CidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cid
     */
    omit?: CidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidInclude<ExtArgs> | null
    /**
     * The filter to search for the Cid to update in case it exists.
     */
    where: CidWhereUniqueInput
    /**
     * In case the Cid found by the `where` argument doesn't exist, create a new Cid with this data.
     */
    create: XOR<CidCreateInput, CidUncheckedCreateInput>
    /**
     * In case the Cid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CidUpdateInput, CidUncheckedUpdateInput>
  }

  /**
   * Cid delete
   */
  export type CidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cid
     */
    select?: CidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cid
     */
    omit?: CidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidInclude<ExtArgs> | null
    /**
     * Filter which Cid to delete.
     */
    where: CidWhereUniqueInput
  }

  /**
   * Cid deleteMany
   */
  export type CidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cids to delete
     */
    where?: CidWhereInput
    /**
     * Limit how many Cids to delete.
     */
    limit?: number
  }

  /**
   * Cid.evolucaoCids
   */
  export type Cid$evolucaoCidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoCid
     */
    select?: EvolucaoCidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoCid
     */
    omit?: EvolucaoCidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoCidInclude<ExtArgs> | null
    where?: EvolucaoCidWhereInput
    orderBy?: EvolucaoCidOrderByWithRelationInput | EvolucaoCidOrderByWithRelationInput[]
    cursor?: EvolucaoCidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvolucaoCidScalarFieldEnum | EvolucaoCidScalarFieldEnum[]
  }

  /**
   * Cid without action
   */
  export type CidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cid
     */
    select?: CidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cid
     */
    omit?: CidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CidInclude<ExtArgs> | null
  }


  /**
   * Model Dsm
   */

  export type AggregateDsm = {
    _count: DsmCountAggregateOutputType | null
    _avg: DsmAvgAggregateOutputType | null
    _sum: DsmSumAggregateOutputType | null
    _min: DsmMinAggregateOutputType | null
    _max: DsmMaxAggregateOutputType | null
  }

  export type DsmAvgAggregateOutputType = {
    id: number | null
  }

  export type DsmSumAggregateOutputType = {
    id: number | null
  }

  export type DsmMinAggregateOutputType = {
    id: number | null
    codigo: string | null
    descricao: string | null
    versao: $Enums.VersaoDsm | null
    stInativo: $Enums.SimNao | null
  }

  export type DsmMaxAggregateOutputType = {
    id: number | null
    codigo: string | null
    descricao: string | null
    versao: $Enums.VersaoDsm | null
    stInativo: $Enums.SimNao | null
  }

  export type DsmCountAggregateOutputType = {
    id: number
    codigo: number
    descricao: number
    versao: number
    stInativo: number
    _all: number
  }


  export type DsmAvgAggregateInputType = {
    id?: true
  }

  export type DsmSumAggregateInputType = {
    id?: true
  }

  export type DsmMinAggregateInputType = {
    id?: true
    codigo?: true
    descricao?: true
    versao?: true
    stInativo?: true
  }

  export type DsmMaxAggregateInputType = {
    id?: true
    codigo?: true
    descricao?: true
    versao?: true
    stInativo?: true
  }

  export type DsmCountAggregateInputType = {
    id?: true
    codigo?: true
    descricao?: true
    versao?: true
    stInativo?: true
    _all?: true
  }

  export type DsmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dsm to aggregate.
     */
    where?: DsmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dsms to fetch.
     */
    orderBy?: DsmOrderByWithRelationInput | DsmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DsmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dsms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dsms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dsms
    **/
    _count?: true | DsmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DsmAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DsmSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DsmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DsmMaxAggregateInputType
  }

  export type GetDsmAggregateType<T extends DsmAggregateArgs> = {
        [P in keyof T & keyof AggregateDsm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDsm[P]>
      : GetScalarType<T[P], AggregateDsm[P]>
  }




  export type DsmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DsmWhereInput
    orderBy?: DsmOrderByWithAggregationInput | DsmOrderByWithAggregationInput[]
    by: DsmScalarFieldEnum[] | DsmScalarFieldEnum
    having?: DsmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DsmCountAggregateInputType | true
    _avg?: DsmAvgAggregateInputType
    _sum?: DsmSumAggregateInputType
    _min?: DsmMinAggregateInputType
    _max?: DsmMaxAggregateInputType
  }

  export type DsmGroupByOutputType = {
    id: number
    codigo: string
    descricao: string
    versao: $Enums.VersaoDsm
    stInativo: $Enums.SimNao | null
    _count: DsmCountAggregateOutputType | null
    _avg: DsmAvgAggregateOutputType | null
    _sum: DsmSumAggregateOutputType | null
    _min: DsmMinAggregateOutputType | null
    _max: DsmMaxAggregateOutputType | null
  }

  type GetDsmGroupByPayload<T extends DsmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DsmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DsmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DsmGroupByOutputType[P]>
            : GetScalarType<T[P], DsmGroupByOutputType[P]>
        }
      >
    >


  export type DsmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    descricao?: boolean
    versao?: boolean
    stInativo?: boolean
    evolucaoDsms?: boolean | Dsm$evolucaoDsmsArgs<ExtArgs>
    _count?: boolean | DsmCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dsm"]>

  export type DsmSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    descricao?: boolean
    versao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["dsm"]>

  export type DsmSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    descricao?: boolean
    versao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["dsm"]>

  export type DsmSelectScalar = {
    id?: boolean
    codigo?: boolean
    descricao?: boolean
    versao?: boolean
    stInativo?: boolean
  }

  export type DsmOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codigo" | "descricao" | "versao" | "stInativo", ExtArgs["result"]["dsm"]>
  export type DsmInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evolucaoDsms?: boolean | Dsm$evolucaoDsmsArgs<ExtArgs>
    _count?: boolean | DsmCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DsmIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DsmIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DsmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dsm"
    objects: {
      evolucaoDsms: Prisma.$EvolucaoDsmPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigo: string
      descricao: string
      versao: $Enums.VersaoDsm
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["dsm"]>
    composites: {}
  }

  type DsmGetPayload<S extends boolean | null | undefined | DsmDefaultArgs> = $Result.GetResult<Prisma.$DsmPayload, S>

  type DsmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DsmFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DsmCountAggregateInputType | true
    }

  export interface DsmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dsm'], meta: { name: 'Dsm' } }
    /**
     * Find zero or one Dsm that matches the filter.
     * @param {DsmFindUniqueArgs} args - Arguments to find a Dsm
     * @example
     * // Get one Dsm
     * const dsm = await prisma.dsm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DsmFindUniqueArgs>(args: SelectSubset<T, DsmFindUniqueArgs<ExtArgs>>): Prisma__DsmClient<$Result.GetResult<Prisma.$DsmPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dsm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DsmFindUniqueOrThrowArgs} args - Arguments to find a Dsm
     * @example
     * // Get one Dsm
     * const dsm = await prisma.dsm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DsmFindUniqueOrThrowArgs>(args: SelectSubset<T, DsmFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DsmClient<$Result.GetResult<Prisma.$DsmPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dsm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DsmFindFirstArgs} args - Arguments to find a Dsm
     * @example
     * // Get one Dsm
     * const dsm = await prisma.dsm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DsmFindFirstArgs>(args?: SelectSubset<T, DsmFindFirstArgs<ExtArgs>>): Prisma__DsmClient<$Result.GetResult<Prisma.$DsmPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dsm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DsmFindFirstOrThrowArgs} args - Arguments to find a Dsm
     * @example
     * // Get one Dsm
     * const dsm = await prisma.dsm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DsmFindFirstOrThrowArgs>(args?: SelectSubset<T, DsmFindFirstOrThrowArgs<ExtArgs>>): Prisma__DsmClient<$Result.GetResult<Prisma.$DsmPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dsms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DsmFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dsms
     * const dsms = await prisma.dsm.findMany()
     * 
     * // Get first 10 Dsms
     * const dsms = await prisma.dsm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dsmWithIdOnly = await prisma.dsm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DsmFindManyArgs>(args?: SelectSubset<T, DsmFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DsmPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dsm.
     * @param {DsmCreateArgs} args - Arguments to create a Dsm.
     * @example
     * // Create one Dsm
     * const Dsm = await prisma.dsm.create({
     *   data: {
     *     // ... data to create a Dsm
     *   }
     * })
     * 
     */
    create<T extends DsmCreateArgs>(args: SelectSubset<T, DsmCreateArgs<ExtArgs>>): Prisma__DsmClient<$Result.GetResult<Prisma.$DsmPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dsms.
     * @param {DsmCreateManyArgs} args - Arguments to create many Dsms.
     * @example
     * // Create many Dsms
     * const dsm = await prisma.dsm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DsmCreateManyArgs>(args?: SelectSubset<T, DsmCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dsms and returns the data saved in the database.
     * @param {DsmCreateManyAndReturnArgs} args - Arguments to create many Dsms.
     * @example
     * // Create many Dsms
     * const dsm = await prisma.dsm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dsms and only return the `id`
     * const dsmWithIdOnly = await prisma.dsm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DsmCreateManyAndReturnArgs>(args?: SelectSubset<T, DsmCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DsmPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dsm.
     * @param {DsmDeleteArgs} args - Arguments to delete one Dsm.
     * @example
     * // Delete one Dsm
     * const Dsm = await prisma.dsm.delete({
     *   where: {
     *     // ... filter to delete one Dsm
     *   }
     * })
     * 
     */
    delete<T extends DsmDeleteArgs>(args: SelectSubset<T, DsmDeleteArgs<ExtArgs>>): Prisma__DsmClient<$Result.GetResult<Prisma.$DsmPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dsm.
     * @param {DsmUpdateArgs} args - Arguments to update one Dsm.
     * @example
     * // Update one Dsm
     * const dsm = await prisma.dsm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DsmUpdateArgs>(args: SelectSubset<T, DsmUpdateArgs<ExtArgs>>): Prisma__DsmClient<$Result.GetResult<Prisma.$DsmPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dsms.
     * @param {DsmDeleteManyArgs} args - Arguments to filter Dsms to delete.
     * @example
     * // Delete a few Dsms
     * const { count } = await prisma.dsm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DsmDeleteManyArgs>(args?: SelectSubset<T, DsmDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dsms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DsmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dsms
     * const dsm = await prisma.dsm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DsmUpdateManyArgs>(args: SelectSubset<T, DsmUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dsms and returns the data updated in the database.
     * @param {DsmUpdateManyAndReturnArgs} args - Arguments to update many Dsms.
     * @example
     * // Update many Dsms
     * const dsm = await prisma.dsm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dsms and only return the `id`
     * const dsmWithIdOnly = await prisma.dsm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DsmUpdateManyAndReturnArgs>(args: SelectSubset<T, DsmUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DsmPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dsm.
     * @param {DsmUpsertArgs} args - Arguments to update or create a Dsm.
     * @example
     * // Update or create a Dsm
     * const dsm = await prisma.dsm.upsert({
     *   create: {
     *     // ... data to create a Dsm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dsm we want to update
     *   }
     * })
     */
    upsert<T extends DsmUpsertArgs>(args: SelectSubset<T, DsmUpsertArgs<ExtArgs>>): Prisma__DsmClient<$Result.GetResult<Prisma.$DsmPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dsms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DsmCountArgs} args - Arguments to filter Dsms to count.
     * @example
     * // Count the number of Dsms
     * const count = await prisma.dsm.count({
     *   where: {
     *     // ... the filter for the Dsms we want to count
     *   }
     * })
    **/
    count<T extends DsmCountArgs>(
      args?: Subset<T, DsmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DsmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dsm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DsmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DsmAggregateArgs>(args: Subset<T, DsmAggregateArgs>): Prisma.PrismaPromise<GetDsmAggregateType<T>>

    /**
     * Group by Dsm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DsmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DsmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DsmGroupByArgs['orderBy'] }
        : { orderBy?: DsmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DsmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDsmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dsm model
   */
  readonly fields: DsmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dsm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DsmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evolucaoDsms<T extends Dsm$evolucaoDsmsArgs<ExtArgs> = {}>(args?: Subset<T, Dsm$evolucaoDsmsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoDsmPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dsm model
   */
  interface DsmFieldRefs {
    readonly id: FieldRef<"Dsm", 'Int'>
    readonly codigo: FieldRef<"Dsm", 'String'>
    readonly descricao: FieldRef<"Dsm", 'String'>
    readonly versao: FieldRef<"Dsm", 'VersaoDsm'>
    readonly stInativo: FieldRef<"Dsm", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * Dsm findUnique
   */
  export type DsmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dsm
     */
    select?: DsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dsm
     */
    omit?: DsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DsmInclude<ExtArgs> | null
    /**
     * Filter, which Dsm to fetch.
     */
    where: DsmWhereUniqueInput
  }

  /**
   * Dsm findUniqueOrThrow
   */
  export type DsmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dsm
     */
    select?: DsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dsm
     */
    omit?: DsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DsmInclude<ExtArgs> | null
    /**
     * Filter, which Dsm to fetch.
     */
    where: DsmWhereUniqueInput
  }

  /**
   * Dsm findFirst
   */
  export type DsmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dsm
     */
    select?: DsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dsm
     */
    omit?: DsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DsmInclude<ExtArgs> | null
    /**
     * Filter, which Dsm to fetch.
     */
    where?: DsmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dsms to fetch.
     */
    orderBy?: DsmOrderByWithRelationInput | DsmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dsms.
     */
    cursor?: DsmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dsms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dsms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dsms.
     */
    distinct?: DsmScalarFieldEnum | DsmScalarFieldEnum[]
  }

  /**
   * Dsm findFirstOrThrow
   */
  export type DsmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dsm
     */
    select?: DsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dsm
     */
    omit?: DsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DsmInclude<ExtArgs> | null
    /**
     * Filter, which Dsm to fetch.
     */
    where?: DsmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dsms to fetch.
     */
    orderBy?: DsmOrderByWithRelationInput | DsmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dsms.
     */
    cursor?: DsmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dsms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dsms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dsms.
     */
    distinct?: DsmScalarFieldEnum | DsmScalarFieldEnum[]
  }

  /**
   * Dsm findMany
   */
  export type DsmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dsm
     */
    select?: DsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dsm
     */
    omit?: DsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DsmInclude<ExtArgs> | null
    /**
     * Filter, which Dsms to fetch.
     */
    where?: DsmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dsms to fetch.
     */
    orderBy?: DsmOrderByWithRelationInput | DsmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dsms.
     */
    cursor?: DsmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dsms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dsms.
     */
    skip?: number
    distinct?: DsmScalarFieldEnum | DsmScalarFieldEnum[]
  }

  /**
   * Dsm create
   */
  export type DsmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dsm
     */
    select?: DsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dsm
     */
    omit?: DsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DsmInclude<ExtArgs> | null
    /**
     * The data needed to create a Dsm.
     */
    data: XOR<DsmCreateInput, DsmUncheckedCreateInput>
  }

  /**
   * Dsm createMany
   */
  export type DsmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dsms.
     */
    data: DsmCreateManyInput | DsmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dsm createManyAndReturn
   */
  export type DsmCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dsm
     */
    select?: DsmSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dsm
     */
    omit?: DsmOmit<ExtArgs> | null
    /**
     * The data used to create many Dsms.
     */
    data: DsmCreateManyInput | DsmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dsm update
   */
  export type DsmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dsm
     */
    select?: DsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dsm
     */
    omit?: DsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DsmInclude<ExtArgs> | null
    /**
     * The data needed to update a Dsm.
     */
    data: XOR<DsmUpdateInput, DsmUncheckedUpdateInput>
    /**
     * Choose, which Dsm to update.
     */
    where: DsmWhereUniqueInput
  }

  /**
   * Dsm updateMany
   */
  export type DsmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dsms.
     */
    data: XOR<DsmUpdateManyMutationInput, DsmUncheckedUpdateManyInput>
    /**
     * Filter which Dsms to update
     */
    where?: DsmWhereInput
    /**
     * Limit how many Dsms to update.
     */
    limit?: number
  }

  /**
   * Dsm updateManyAndReturn
   */
  export type DsmUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dsm
     */
    select?: DsmSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dsm
     */
    omit?: DsmOmit<ExtArgs> | null
    /**
     * The data used to update Dsms.
     */
    data: XOR<DsmUpdateManyMutationInput, DsmUncheckedUpdateManyInput>
    /**
     * Filter which Dsms to update
     */
    where?: DsmWhereInput
    /**
     * Limit how many Dsms to update.
     */
    limit?: number
  }

  /**
   * Dsm upsert
   */
  export type DsmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dsm
     */
    select?: DsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dsm
     */
    omit?: DsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DsmInclude<ExtArgs> | null
    /**
     * The filter to search for the Dsm to update in case it exists.
     */
    where: DsmWhereUniqueInput
    /**
     * In case the Dsm found by the `where` argument doesn't exist, create a new Dsm with this data.
     */
    create: XOR<DsmCreateInput, DsmUncheckedCreateInput>
    /**
     * In case the Dsm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DsmUpdateInput, DsmUncheckedUpdateInput>
  }

  /**
   * Dsm delete
   */
  export type DsmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dsm
     */
    select?: DsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dsm
     */
    omit?: DsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DsmInclude<ExtArgs> | null
    /**
     * Filter which Dsm to delete.
     */
    where: DsmWhereUniqueInput
  }

  /**
   * Dsm deleteMany
   */
  export type DsmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dsms to delete
     */
    where?: DsmWhereInput
    /**
     * Limit how many Dsms to delete.
     */
    limit?: number
  }

  /**
   * Dsm.evolucaoDsms
   */
  export type Dsm$evolucaoDsmsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoDsm
     */
    select?: EvolucaoDsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoDsm
     */
    omit?: EvolucaoDsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoDsmInclude<ExtArgs> | null
    where?: EvolucaoDsmWhereInput
    orderBy?: EvolucaoDsmOrderByWithRelationInput | EvolucaoDsmOrderByWithRelationInput[]
    cursor?: EvolucaoDsmWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvolucaoDsmScalarFieldEnum | EvolucaoDsmScalarFieldEnum[]
  }

  /**
   * Dsm without action
   */
  export type DsmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dsm
     */
    select?: DsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dsm
     */
    omit?: DsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DsmInclude<ExtArgs> | null
  }


  /**
   * Model TipoEvolucaoClinica
   */

  export type AggregateTipoEvolucaoClinica = {
    _count: TipoEvolucaoClinicaCountAggregateOutputType | null
    _avg: TipoEvolucaoClinicaAvgAggregateOutputType | null
    _sum: TipoEvolucaoClinicaSumAggregateOutputType | null
    _min: TipoEvolucaoClinicaMinAggregateOutputType | null
    _max: TipoEvolucaoClinicaMaxAggregateOutputType | null
  }

  export type TipoEvolucaoClinicaAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoEvolucaoClinicaSumAggregateOutputType = {
    id: number | null
  }

  export type TipoEvolucaoClinicaMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type TipoEvolucaoClinicaMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    stInativo: $Enums.SimNao | null
  }

  export type TipoEvolucaoClinicaCountAggregateOutputType = {
    id: number
    descricao: number
    stInativo: number
    _all: number
  }


  export type TipoEvolucaoClinicaAvgAggregateInputType = {
    id?: true
  }

  export type TipoEvolucaoClinicaSumAggregateInputType = {
    id?: true
  }

  export type TipoEvolucaoClinicaMinAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
  }

  export type TipoEvolucaoClinicaMaxAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
  }

  export type TipoEvolucaoClinicaCountAggregateInputType = {
    id?: true
    descricao?: true
    stInativo?: true
    _all?: true
  }

  export type TipoEvolucaoClinicaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoEvolucaoClinica to aggregate.
     */
    where?: TipoEvolucaoClinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEvolucaoClinicas to fetch.
     */
    orderBy?: TipoEvolucaoClinicaOrderByWithRelationInput | TipoEvolucaoClinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoEvolucaoClinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEvolucaoClinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEvolucaoClinicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoEvolucaoClinicas
    **/
    _count?: true | TipoEvolucaoClinicaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoEvolucaoClinicaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoEvolucaoClinicaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoEvolucaoClinicaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoEvolucaoClinicaMaxAggregateInputType
  }

  export type GetTipoEvolucaoClinicaAggregateType<T extends TipoEvolucaoClinicaAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoEvolucaoClinica]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoEvolucaoClinica[P]>
      : GetScalarType<T[P], AggregateTipoEvolucaoClinica[P]>
  }




  export type TipoEvolucaoClinicaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoEvolucaoClinicaWhereInput
    orderBy?: TipoEvolucaoClinicaOrderByWithAggregationInput | TipoEvolucaoClinicaOrderByWithAggregationInput[]
    by: TipoEvolucaoClinicaScalarFieldEnum[] | TipoEvolucaoClinicaScalarFieldEnum
    having?: TipoEvolucaoClinicaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoEvolucaoClinicaCountAggregateInputType | true
    _avg?: TipoEvolucaoClinicaAvgAggregateInputType
    _sum?: TipoEvolucaoClinicaSumAggregateInputType
    _min?: TipoEvolucaoClinicaMinAggregateInputType
    _max?: TipoEvolucaoClinicaMaxAggregateInputType
  }

  export type TipoEvolucaoClinicaGroupByOutputType = {
    id: number
    descricao: string
    stInativo: $Enums.SimNao | null
    _count: TipoEvolucaoClinicaCountAggregateOutputType | null
    _avg: TipoEvolucaoClinicaAvgAggregateOutputType | null
    _sum: TipoEvolucaoClinicaSumAggregateOutputType | null
    _min: TipoEvolucaoClinicaMinAggregateOutputType | null
    _max: TipoEvolucaoClinicaMaxAggregateOutputType | null
  }

  type GetTipoEvolucaoClinicaGroupByPayload<T extends TipoEvolucaoClinicaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoEvolucaoClinicaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoEvolucaoClinicaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoEvolucaoClinicaGroupByOutputType[P]>
            : GetScalarType<T[P], TipoEvolucaoClinicaGroupByOutputType[P]>
        }
      >
    >


  export type TipoEvolucaoClinicaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
    evolucaos?: boolean | TipoEvolucaoClinica$evolucaosArgs<ExtArgs>
    _count?: boolean | TipoEvolucaoClinicaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoEvolucaoClinica"]>

  export type TipoEvolucaoClinicaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["tipoEvolucaoClinica"]>

  export type TipoEvolucaoClinicaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }, ExtArgs["result"]["tipoEvolucaoClinica"]>

  export type TipoEvolucaoClinicaSelectScalar = {
    id?: boolean
    descricao?: boolean
    stInativo?: boolean
  }

  export type TipoEvolucaoClinicaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "stInativo", ExtArgs["result"]["tipoEvolucaoClinica"]>
  export type TipoEvolucaoClinicaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evolucaos?: boolean | TipoEvolucaoClinica$evolucaosArgs<ExtArgs>
    _count?: boolean | TipoEvolucaoClinicaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TipoEvolucaoClinicaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TipoEvolucaoClinicaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TipoEvolucaoClinicaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoEvolucaoClinica"
    objects: {
      evolucaos: Prisma.$EvolucaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      stInativo: $Enums.SimNao | null
    }, ExtArgs["result"]["tipoEvolucaoClinica"]>
    composites: {}
  }

  type TipoEvolucaoClinicaGetPayload<S extends boolean | null | undefined | TipoEvolucaoClinicaDefaultArgs> = $Result.GetResult<Prisma.$TipoEvolucaoClinicaPayload, S>

  type TipoEvolucaoClinicaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoEvolucaoClinicaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoEvolucaoClinicaCountAggregateInputType | true
    }

  export interface TipoEvolucaoClinicaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoEvolucaoClinica'], meta: { name: 'TipoEvolucaoClinica' } }
    /**
     * Find zero or one TipoEvolucaoClinica that matches the filter.
     * @param {TipoEvolucaoClinicaFindUniqueArgs} args - Arguments to find a TipoEvolucaoClinica
     * @example
     * // Get one TipoEvolucaoClinica
     * const tipoEvolucaoClinica = await prisma.tipoEvolucaoClinica.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoEvolucaoClinicaFindUniqueArgs>(args: SelectSubset<T, TipoEvolucaoClinicaFindUniqueArgs<ExtArgs>>): Prisma__TipoEvolucaoClinicaClient<$Result.GetResult<Prisma.$TipoEvolucaoClinicaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoEvolucaoClinica that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoEvolucaoClinicaFindUniqueOrThrowArgs} args - Arguments to find a TipoEvolucaoClinica
     * @example
     * // Get one TipoEvolucaoClinica
     * const tipoEvolucaoClinica = await prisma.tipoEvolucaoClinica.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoEvolucaoClinicaFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoEvolucaoClinicaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoEvolucaoClinicaClient<$Result.GetResult<Prisma.$TipoEvolucaoClinicaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoEvolucaoClinica that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEvolucaoClinicaFindFirstArgs} args - Arguments to find a TipoEvolucaoClinica
     * @example
     * // Get one TipoEvolucaoClinica
     * const tipoEvolucaoClinica = await prisma.tipoEvolucaoClinica.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoEvolucaoClinicaFindFirstArgs>(args?: SelectSubset<T, TipoEvolucaoClinicaFindFirstArgs<ExtArgs>>): Prisma__TipoEvolucaoClinicaClient<$Result.GetResult<Prisma.$TipoEvolucaoClinicaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoEvolucaoClinica that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEvolucaoClinicaFindFirstOrThrowArgs} args - Arguments to find a TipoEvolucaoClinica
     * @example
     * // Get one TipoEvolucaoClinica
     * const tipoEvolucaoClinica = await prisma.tipoEvolucaoClinica.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoEvolucaoClinicaFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoEvolucaoClinicaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoEvolucaoClinicaClient<$Result.GetResult<Prisma.$TipoEvolucaoClinicaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoEvolucaoClinicas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEvolucaoClinicaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoEvolucaoClinicas
     * const tipoEvolucaoClinicas = await prisma.tipoEvolucaoClinica.findMany()
     * 
     * // Get first 10 TipoEvolucaoClinicas
     * const tipoEvolucaoClinicas = await prisma.tipoEvolucaoClinica.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoEvolucaoClinicaWithIdOnly = await prisma.tipoEvolucaoClinica.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoEvolucaoClinicaFindManyArgs>(args?: SelectSubset<T, TipoEvolucaoClinicaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoEvolucaoClinicaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoEvolucaoClinica.
     * @param {TipoEvolucaoClinicaCreateArgs} args - Arguments to create a TipoEvolucaoClinica.
     * @example
     * // Create one TipoEvolucaoClinica
     * const TipoEvolucaoClinica = await prisma.tipoEvolucaoClinica.create({
     *   data: {
     *     // ... data to create a TipoEvolucaoClinica
     *   }
     * })
     * 
     */
    create<T extends TipoEvolucaoClinicaCreateArgs>(args: SelectSubset<T, TipoEvolucaoClinicaCreateArgs<ExtArgs>>): Prisma__TipoEvolucaoClinicaClient<$Result.GetResult<Prisma.$TipoEvolucaoClinicaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoEvolucaoClinicas.
     * @param {TipoEvolucaoClinicaCreateManyArgs} args - Arguments to create many TipoEvolucaoClinicas.
     * @example
     * // Create many TipoEvolucaoClinicas
     * const tipoEvolucaoClinica = await prisma.tipoEvolucaoClinica.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoEvolucaoClinicaCreateManyArgs>(args?: SelectSubset<T, TipoEvolucaoClinicaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoEvolucaoClinicas and returns the data saved in the database.
     * @param {TipoEvolucaoClinicaCreateManyAndReturnArgs} args - Arguments to create many TipoEvolucaoClinicas.
     * @example
     * // Create many TipoEvolucaoClinicas
     * const tipoEvolucaoClinica = await prisma.tipoEvolucaoClinica.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoEvolucaoClinicas and only return the `id`
     * const tipoEvolucaoClinicaWithIdOnly = await prisma.tipoEvolucaoClinica.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoEvolucaoClinicaCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoEvolucaoClinicaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoEvolucaoClinicaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoEvolucaoClinica.
     * @param {TipoEvolucaoClinicaDeleteArgs} args - Arguments to delete one TipoEvolucaoClinica.
     * @example
     * // Delete one TipoEvolucaoClinica
     * const TipoEvolucaoClinica = await prisma.tipoEvolucaoClinica.delete({
     *   where: {
     *     // ... filter to delete one TipoEvolucaoClinica
     *   }
     * })
     * 
     */
    delete<T extends TipoEvolucaoClinicaDeleteArgs>(args: SelectSubset<T, TipoEvolucaoClinicaDeleteArgs<ExtArgs>>): Prisma__TipoEvolucaoClinicaClient<$Result.GetResult<Prisma.$TipoEvolucaoClinicaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoEvolucaoClinica.
     * @param {TipoEvolucaoClinicaUpdateArgs} args - Arguments to update one TipoEvolucaoClinica.
     * @example
     * // Update one TipoEvolucaoClinica
     * const tipoEvolucaoClinica = await prisma.tipoEvolucaoClinica.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoEvolucaoClinicaUpdateArgs>(args: SelectSubset<T, TipoEvolucaoClinicaUpdateArgs<ExtArgs>>): Prisma__TipoEvolucaoClinicaClient<$Result.GetResult<Prisma.$TipoEvolucaoClinicaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoEvolucaoClinicas.
     * @param {TipoEvolucaoClinicaDeleteManyArgs} args - Arguments to filter TipoEvolucaoClinicas to delete.
     * @example
     * // Delete a few TipoEvolucaoClinicas
     * const { count } = await prisma.tipoEvolucaoClinica.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoEvolucaoClinicaDeleteManyArgs>(args?: SelectSubset<T, TipoEvolucaoClinicaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoEvolucaoClinicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEvolucaoClinicaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoEvolucaoClinicas
     * const tipoEvolucaoClinica = await prisma.tipoEvolucaoClinica.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoEvolucaoClinicaUpdateManyArgs>(args: SelectSubset<T, TipoEvolucaoClinicaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoEvolucaoClinicas and returns the data updated in the database.
     * @param {TipoEvolucaoClinicaUpdateManyAndReturnArgs} args - Arguments to update many TipoEvolucaoClinicas.
     * @example
     * // Update many TipoEvolucaoClinicas
     * const tipoEvolucaoClinica = await prisma.tipoEvolucaoClinica.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoEvolucaoClinicas and only return the `id`
     * const tipoEvolucaoClinicaWithIdOnly = await prisma.tipoEvolucaoClinica.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoEvolucaoClinicaUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoEvolucaoClinicaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoEvolucaoClinicaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoEvolucaoClinica.
     * @param {TipoEvolucaoClinicaUpsertArgs} args - Arguments to update or create a TipoEvolucaoClinica.
     * @example
     * // Update or create a TipoEvolucaoClinica
     * const tipoEvolucaoClinica = await prisma.tipoEvolucaoClinica.upsert({
     *   create: {
     *     // ... data to create a TipoEvolucaoClinica
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoEvolucaoClinica we want to update
     *   }
     * })
     */
    upsert<T extends TipoEvolucaoClinicaUpsertArgs>(args: SelectSubset<T, TipoEvolucaoClinicaUpsertArgs<ExtArgs>>): Prisma__TipoEvolucaoClinicaClient<$Result.GetResult<Prisma.$TipoEvolucaoClinicaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoEvolucaoClinicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEvolucaoClinicaCountArgs} args - Arguments to filter TipoEvolucaoClinicas to count.
     * @example
     * // Count the number of TipoEvolucaoClinicas
     * const count = await prisma.tipoEvolucaoClinica.count({
     *   where: {
     *     // ... the filter for the TipoEvolucaoClinicas we want to count
     *   }
     * })
    **/
    count<T extends TipoEvolucaoClinicaCountArgs>(
      args?: Subset<T, TipoEvolucaoClinicaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoEvolucaoClinicaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoEvolucaoClinica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEvolucaoClinicaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoEvolucaoClinicaAggregateArgs>(args: Subset<T, TipoEvolucaoClinicaAggregateArgs>): Prisma.PrismaPromise<GetTipoEvolucaoClinicaAggregateType<T>>

    /**
     * Group by TipoEvolucaoClinica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEvolucaoClinicaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoEvolucaoClinicaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoEvolucaoClinicaGroupByArgs['orderBy'] }
        : { orderBy?: TipoEvolucaoClinicaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoEvolucaoClinicaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoEvolucaoClinicaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoEvolucaoClinica model
   */
  readonly fields: TipoEvolucaoClinicaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoEvolucaoClinica.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoEvolucaoClinicaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evolucaos<T extends TipoEvolucaoClinica$evolucaosArgs<ExtArgs> = {}>(args?: Subset<T, TipoEvolucaoClinica$evolucaosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoEvolucaoClinica model
   */
  interface TipoEvolucaoClinicaFieldRefs {
    readonly id: FieldRef<"TipoEvolucaoClinica", 'Int'>
    readonly descricao: FieldRef<"TipoEvolucaoClinica", 'String'>
    readonly stInativo: FieldRef<"TipoEvolucaoClinica", 'SimNao'>
  }
    

  // Custom InputTypes
  /**
   * TipoEvolucaoClinica findUnique
   */
  export type TipoEvolucaoClinicaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoClinica
     */
    select?: TipoEvolucaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoClinica
     */
    omit?: TipoEvolucaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEvolucaoClinicaInclude<ExtArgs> | null
    /**
     * Filter, which TipoEvolucaoClinica to fetch.
     */
    where: TipoEvolucaoClinicaWhereUniqueInput
  }

  /**
   * TipoEvolucaoClinica findUniqueOrThrow
   */
  export type TipoEvolucaoClinicaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoClinica
     */
    select?: TipoEvolucaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoClinica
     */
    omit?: TipoEvolucaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEvolucaoClinicaInclude<ExtArgs> | null
    /**
     * Filter, which TipoEvolucaoClinica to fetch.
     */
    where: TipoEvolucaoClinicaWhereUniqueInput
  }

  /**
   * TipoEvolucaoClinica findFirst
   */
  export type TipoEvolucaoClinicaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoClinica
     */
    select?: TipoEvolucaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoClinica
     */
    omit?: TipoEvolucaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEvolucaoClinicaInclude<ExtArgs> | null
    /**
     * Filter, which TipoEvolucaoClinica to fetch.
     */
    where?: TipoEvolucaoClinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEvolucaoClinicas to fetch.
     */
    orderBy?: TipoEvolucaoClinicaOrderByWithRelationInput | TipoEvolucaoClinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoEvolucaoClinicas.
     */
    cursor?: TipoEvolucaoClinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEvolucaoClinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEvolucaoClinicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoEvolucaoClinicas.
     */
    distinct?: TipoEvolucaoClinicaScalarFieldEnum | TipoEvolucaoClinicaScalarFieldEnum[]
  }

  /**
   * TipoEvolucaoClinica findFirstOrThrow
   */
  export type TipoEvolucaoClinicaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoClinica
     */
    select?: TipoEvolucaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoClinica
     */
    omit?: TipoEvolucaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEvolucaoClinicaInclude<ExtArgs> | null
    /**
     * Filter, which TipoEvolucaoClinica to fetch.
     */
    where?: TipoEvolucaoClinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEvolucaoClinicas to fetch.
     */
    orderBy?: TipoEvolucaoClinicaOrderByWithRelationInput | TipoEvolucaoClinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoEvolucaoClinicas.
     */
    cursor?: TipoEvolucaoClinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEvolucaoClinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEvolucaoClinicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoEvolucaoClinicas.
     */
    distinct?: TipoEvolucaoClinicaScalarFieldEnum | TipoEvolucaoClinicaScalarFieldEnum[]
  }

  /**
   * TipoEvolucaoClinica findMany
   */
  export type TipoEvolucaoClinicaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoClinica
     */
    select?: TipoEvolucaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoClinica
     */
    omit?: TipoEvolucaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEvolucaoClinicaInclude<ExtArgs> | null
    /**
     * Filter, which TipoEvolucaoClinicas to fetch.
     */
    where?: TipoEvolucaoClinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEvolucaoClinicas to fetch.
     */
    orderBy?: TipoEvolucaoClinicaOrderByWithRelationInput | TipoEvolucaoClinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoEvolucaoClinicas.
     */
    cursor?: TipoEvolucaoClinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEvolucaoClinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEvolucaoClinicas.
     */
    skip?: number
    distinct?: TipoEvolucaoClinicaScalarFieldEnum | TipoEvolucaoClinicaScalarFieldEnum[]
  }

  /**
   * TipoEvolucaoClinica create
   */
  export type TipoEvolucaoClinicaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoClinica
     */
    select?: TipoEvolucaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoClinica
     */
    omit?: TipoEvolucaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEvolucaoClinicaInclude<ExtArgs> | null
    /**
     * The data needed to create a TipoEvolucaoClinica.
     */
    data: XOR<TipoEvolucaoClinicaCreateInput, TipoEvolucaoClinicaUncheckedCreateInput>
  }

  /**
   * TipoEvolucaoClinica createMany
   */
  export type TipoEvolucaoClinicaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoEvolucaoClinicas.
     */
    data: TipoEvolucaoClinicaCreateManyInput | TipoEvolucaoClinicaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoEvolucaoClinica createManyAndReturn
   */
  export type TipoEvolucaoClinicaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoClinica
     */
    select?: TipoEvolucaoClinicaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoClinica
     */
    omit?: TipoEvolucaoClinicaOmit<ExtArgs> | null
    /**
     * The data used to create many TipoEvolucaoClinicas.
     */
    data: TipoEvolucaoClinicaCreateManyInput | TipoEvolucaoClinicaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoEvolucaoClinica update
   */
  export type TipoEvolucaoClinicaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoClinica
     */
    select?: TipoEvolucaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoClinica
     */
    omit?: TipoEvolucaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEvolucaoClinicaInclude<ExtArgs> | null
    /**
     * The data needed to update a TipoEvolucaoClinica.
     */
    data: XOR<TipoEvolucaoClinicaUpdateInput, TipoEvolucaoClinicaUncheckedUpdateInput>
    /**
     * Choose, which TipoEvolucaoClinica to update.
     */
    where: TipoEvolucaoClinicaWhereUniqueInput
  }

  /**
   * TipoEvolucaoClinica updateMany
   */
  export type TipoEvolucaoClinicaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoEvolucaoClinicas.
     */
    data: XOR<TipoEvolucaoClinicaUpdateManyMutationInput, TipoEvolucaoClinicaUncheckedUpdateManyInput>
    /**
     * Filter which TipoEvolucaoClinicas to update
     */
    where?: TipoEvolucaoClinicaWhereInput
    /**
     * Limit how many TipoEvolucaoClinicas to update.
     */
    limit?: number
  }

  /**
   * TipoEvolucaoClinica updateManyAndReturn
   */
  export type TipoEvolucaoClinicaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoClinica
     */
    select?: TipoEvolucaoClinicaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoClinica
     */
    omit?: TipoEvolucaoClinicaOmit<ExtArgs> | null
    /**
     * The data used to update TipoEvolucaoClinicas.
     */
    data: XOR<TipoEvolucaoClinicaUpdateManyMutationInput, TipoEvolucaoClinicaUncheckedUpdateManyInput>
    /**
     * Filter which TipoEvolucaoClinicas to update
     */
    where?: TipoEvolucaoClinicaWhereInput
    /**
     * Limit how many TipoEvolucaoClinicas to update.
     */
    limit?: number
  }

  /**
   * TipoEvolucaoClinica upsert
   */
  export type TipoEvolucaoClinicaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoClinica
     */
    select?: TipoEvolucaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoClinica
     */
    omit?: TipoEvolucaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEvolucaoClinicaInclude<ExtArgs> | null
    /**
     * The filter to search for the TipoEvolucaoClinica to update in case it exists.
     */
    where: TipoEvolucaoClinicaWhereUniqueInput
    /**
     * In case the TipoEvolucaoClinica found by the `where` argument doesn't exist, create a new TipoEvolucaoClinica with this data.
     */
    create: XOR<TipoEvolucaoClinicaCreateInput, TipoEvolucaoClinicaUncheckedCreateInput>
    /**
     * In case the TipoEvolucaoClinica was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoEvolucaoClinicaUpdateInput, TipoEvolucaoClinicaUncheckedUpdateInput>
  }

  /**
   * TipoEvolucaoClinica delete
   */
  export type TipoEvolucaoClinicaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoClinica
     */
    select?: TipoEvolucaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoClinica
     */
    omit?: TipoEvolucaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEvolucaoClinicaInclude<ExtArgs> | null
    /**
     * Filter which TipoEvolucaoClinica to delete.
     */
    where: TipoEvolucaoClinicaWhereUniqueInput
  }

  /**
   * TipoEvolucaoClinica deleteMany
   */
  export type TipoEvolucaoClinicaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoEvolucaoClinicas to delete
     */
    where?: TipoEvolucaoClinicaWhereInput
    /**
     * Limit how many TipoEvolucaoClinicas to delete.
     */
    limit?: number
  }

  /**
   * TipoEvolucaoClinica.evolucaos
   */
  export type TipoEvolucaoClinica$evolucaosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolucao
     */
    select?: EvolucaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evolucao
     */
    omit?: EvolucaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoInclude<ExtArgs> | null
    where?: EvolucaoWhereInput
    orderBy?: EvolucaoOrderByWithRelationInput | EvolucaoOrderByWithRelationInput[]
    cursor?: EvolucaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvolucaoScalarFieldEnum | EvolucaoScalarFieldEnum[]
  }

  /**
   * TipoEvolucaoClinica without action
   */
  export type TipoEvolucaoClinicaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvolucaoClinica
     */
    select?: TipoEvolucaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEvolucaoClinica
     */
    omit?: TipoEvolucaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEvolucaoClinicaInclude<ExtArgs> | null
  }


  /**
   * Model EvolucaoCid
   */

  export type AggregateEvolucaoCid = {
    _count: EvolucaoCidCountAggregateOutputType | null
    _avg: EvolucaoCidAvgAggregateOutputType | null
    _sum: EvolucaoCidSumAggregateOutputType | null
    _min: EvolucaoCidMinAggregateOutputType | null
    _max: EvolucaoCidMaxAggregateOutputType | null
  }

  export type EvolucaoCidAvgAggregateOutputType = {
    id: number | null
    cdEvolucao: number | null
    cdCid: number | null
  }

  export type EvolucaoCidSumAggregateOutputType = {
    id: number | null
    cdEvolucao: number | null
    cdCid: number | null
  }

  export type EvolucaoCidMinAggregateOutputType = {
    id: number | null
    cdEvolucao: number | null
    cdCid: number | null
  }

  export type EvolucaoCidMaxAggregateOutputType = {
    id: number | null
    cdEvolucao: number | null
    cdCid: number | null
  }

  export type EvolucaoCidCountAggregateOutputType = {
    id: number
    cdEvolucao: number
    cdCid: number
    _all: number
  }


  export type EvolucaoCidAvgAggregateInputType = {
    id?: true
    cdEvolucao?: true
    cdCid?: true
  }

  export type EvolucaoCidSumAggregateInputType = {
    id?: true
    cdEvolucao?: true
    cdCid?: true
  }

  export type EvolucaoCidMinAggregateInputType = {
    id?: true
    cdEvolucao?: true
    cdCid?: true
  }

  export type EvolucaoCidMaxAggregateInputType = {
    id?: true
    cdEvolucao?: true
    cdCid?: true
  }

  export type EvolucaoCidCountAggregateInputType = {
    id?: true
    cdEvolucao?: true
    cdCid?: true
    _all?: true
  }

  export type EvolucaoCidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvolucaoCid to aggregate.
     */
    where?: EvolucaoCidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolucaoCids to fetch.
     */
    orderBy?: EvolucaoCidOrderByWithRelationInput | EvolucaoCidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvolucaoCidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolucaoCids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolucaoCids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvolucaoCids
    **/
    _count?: true | EvolucaoCidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvolucaoCidAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvolucaoCidSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvolucaoCidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvolucaoCidMaxAggregateInputType
  }

  export type GetEvolucaoCidAggregateType<T extends EvolucaoCidAggregateArgs> = {
        [P in keyof T & keyof AggregateEvolucaoCid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvolucaoCid[P]>
      : GetScalarType<T[P], AggregateEvolucaoCid[P]>
  }




  export type EvolucaoCidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolucaoCidWhereInput
    orderBy?: EvolucaoCidOrderByWithAggregationInput | EvolucaoCidOrderByWithAggregationInput[]
    by: EvolucaoCidScalarFieldEnum[] | EvolucaoCidScalarFieldEnum
    having?: EvolucaoCidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvolucaoCidCountAggregateInputType | true
    _avg?: EvolucaoCidAvgAggregateInputType
    _sum?: EvolucaoCidSumAggregateInputType
    _min?: EvolucaoCidMinAggregateInputType
    _max?: EvolucaoCidMaxAggregateInputType
  }

  export type EvolucaoCidGroupByOutputType = {
    id: number
    cdEvolucao: number
    cdCid: number
    _count: EvolucaoCidCountAggregateOutputType | null
    _avg: EvolucaoCidAvgAggregateOutputType | null
    _sum: EvolucaoCidSumAggregateOutputType | null
    _min: EvolucaoCidMinAggregateOutputType | null
    _max: EvolucaoCidMaxAggregateOutputType | null
  }

  type GetEvolucaoCidGroupByPayload<T extends EvolucaoCidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvolucaoCidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvolucaoCidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvolucaoCidGroupByOutputType[P]>
            : GetScalarType<T[P], EvolucaoCidGroupByOutputType[P]>
        }
      >
    >


  export type EvolucaoCidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdEvolucao?: boolean
    cdCid?: boolean
    cid?: boolean | CidDefaultArgs<ExtArgs>
    evolucao?: boolean | EvolucaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evolucaoCid"]>

  export type EvolucaoCidSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdEvolucao?: boolean
    cdCid?: boolean
    cid?: boolean | CidDefaultArgs<ExtArgs>
    evolucao?: boolean | EvolucaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evolucaoCid"]>

  export type EvolucaoCidSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdEvolucao?: boolean
    cdCid?: boolean
    cid?: boolean | CidDefaultArgs<ExtArgs>
    evolucao?: boolean | EvolucaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evolucaoCid"]>

  export type EvolucaoCidSelectScalar = {
    id?: boolean
    cdEvolucao?: boolean
    cdCid?: boolean
  }

  export type EvolucaoCidOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdEvolucao" | "cdCid", ExtArgs["result"]["evolucaoCid"]>
  export type EvolucaoCidInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cid?: boolean | CidDefaultArgs<ExtArgs>
    evolucao?: boolean | EvolucaoDefaultArgs<ExtArgs>
  }
  export type EvolucaoCidIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cid?: boolean | CidDefaultArgs<ExtArgs>
    evolucao?: boolean | EvolucaoDefaultArgs<ExtArgs>
  }
  export type EvolucaoCidIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cid?: boolean | CidDefaultArgs<ExtArgs>
    evolucao?: boolean | EvolucaoDefaultArgs<ExtArgs>
  }

  export type $EvolucaoCidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvolucaoCid"
    objects: {
      cid: Prisma.$CidPayload<ExtArgs>
      evolucao: Prisma.$EvolucaoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdEvolucao: number
      cdCid: number
    }, ExtArgs["result"]["evolucaoCid"]>
    composites: {}
  }

  type EvolucaoCidGetPayload<S extends boolean | null | undefined | EvolucaoCidDefaultArgs> = $Result.GetResult<Prisma.$EvolucaoCidPayload, S>

  type EvolucaoCidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvolucaoCidFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvolucaoCidCountAggregateInputType | true
    }

  export interface EvolucaoCidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvolucaoCid'], meta: { name: 'EvolucaoCid' } }
    /**
     * Find zero or one EvolucaoCid that matches the filter.
     * @param {EvolucaoCidFindUniqueArgs} args - Arguments to find a EvolucaoCid
     * @example
     * // Get one EvolucaoCid
     * const evolucaoCid = await prisma.evolucaoCid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvolucaoCidFindUniqueArgs>(args: SelectSubset<T, EvolucaoCidFindUniqueArgs<ExtArgs>>): Prisma__EvolucaoCidClient<$Result.GetResult<Prisma.$EvolucaoCidPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EvolucaoCid that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvolucaoCidFindUniqueOrThrowArgs} args - Arguments to find a EvolucaoCid
     * @example
     * // Get one EvolucaoCid
     * const evolucaoCid = await prisma.evolucaoCid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvolucaoCidFindUniqueOrThrowArgs>(args: SelectSubset<T, EvolucaoCidFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvolucaoCidClient<$Result.GetResult<Prisma.$EvolucaoCidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvolucaoCid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoCidFindFirstArgs} args - Arguments to find a EvolucaoCid
     * @example
     * // Get one EvolucaoCid
     * const evolucaoCid = await prisma.evolucaoCid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvolucaoCidFindFirstArgs>(args?: SelectSubset<T, EvolucaoCidFindFirstArgs<ExtArgs>>): Prisma__EvolucaoCidClient<$Result.GetResult<Prisma.$EvolucaoCidPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvolucaoCid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoCidFindFirstOrThrowArgs} args - Arguments to find a EvolucaoCid
     * @example
     * // Get one EvolucaoCid
     * const evolucaoCid = await prisma.evolucaoCid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvolucaoCidFindFirstOrThrowArgs>(args?: SelectSubset<T, EvolucaoCidFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvolucaoCidClient<$Result.GetResult<Prisma.$EvolucaoCidPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EvolucaoCids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoCidFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvolucaoCids
     * const evolucaoCids = await prisma.evolucaoCid.findMany()
     * 
     * // Get first 10 EvolucaoCids
     * const evolucaoCids = await prisma.evolucaoCid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evolucaoCidWithIdOnly = await prisma.evolucaoCid.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvolucaoCidFindManyArgs>(args?: SelectSubset<T, EvolucaoCidFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoCidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EvolucaoCid.
     * @param {EvolucaoCidCreateArgs} args - Arguments to create a EvolucaoCid.
     * @example
     * // Create one EvolucaoCid
     * const EvolucaoCid = await prisma.evolucaoCid.create({
     *   data: {
     *     // ... data to create a EvolucaoCid
     *   }
     * })
     * 
     */
    create<T extends EvolucaoCidCreateArgs>(args: SelectSubset<T, EvolucaoCidCreateArgs<ExtArgs>>): Prisma__EvolucaoCidClient<$Result.GetResult<Prisma.$EvolucaoCidPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EvolucaoCids.
     * @param {EvolucaoCidCreateManyArgs} args - Arguments to create many EvolucaoCids.
     * @example
     * // Create many EvolucaoCids
     * const evolucaoCid = await prisma.evolucaoCid.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvolucaoCidCreateManyArgs>(args?: SelectSubset<T, EvolucaoCidCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvolucaoCids and returns the data saved in the database.
     * @param {EvolucaoCidCreateManyAndReturnArgs} args - Arguments to create many EvolucaoCids.
     * @example
     * // Create many EvolucaoCids
     * const evolucaoCid = await prisma.evolucaoCid.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvolucaoCids and only return the `id`
     * const evolucaoCidWithIdOnly = await prisma.evolucaoCid.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvolucaoCidCreateManyAndReturnArgs>(args?: SelectSubset<T, EvolucaoCidCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoCidPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EvolucaoCid.
     * @param {EvolucaoCidDeleteArgs} args - Arguments to delete one EvolucaoCid.
     * @example
     * // Delete one EvolucaoCid
     * const EvolucaoCid = await prisma.evolucaoCid.delete({
     *   where: {
     *     // ... filter to delete one EvolucaoCid
     *   }
     * })
     * 
     */
    delete<T extends EvolucaoCidDeleteArgs>(args: SelectSubset<T, EvolucaoCidDeleteArgs<ExtArgs>>): Prisma__EvolucaoCidClient<$Result.GetResult<Prisma.$EvolucaoCidPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EvolucaoCid.
     * @param {EvolucaoCidUpdateArgs} args - Arguments to update one EvolucaoCid.
     * @example
     * // Update one EvolucaoCid
     * const evolucaoCid = await prisma.evolucaoCid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvolucaoCidUpdateArgs>(args: SelectSubset<T, EvolucaoCidUpdateArgs<ExtArgs>>): Prisma__EvolucaoCidClient<$Result.GetResult<Prisma.$EvolucaoCidPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EvolucaoCids.
     * @param {EvolucaoCidDeleteManyArgs} args - Arguments to filter EvolucaoCids to delete.
     * @example
     * // Delete a few EvolucaoCids
     * const { count } = await prisma.evolucaoCid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvolucaoCidDeleteManyArgs>(args?: SelectSubset<T, EvolucaoCidDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvolucaoCids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoCidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvolucaoCids
     * const evolucaoCid = await prisma.evolucaoCid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvolucaoCidUpdateManyArgs>(args: SelectSubset<T, EvolucaoCidUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvolucaoCids and returns the data updated in the database.
     * @param {EvolucaoCidUpdateManyAndReturnArgs} args - Arguments to update many EvolucaoCids.
     * @example
     * // Update many EvolucaoCids
     * const evolucaoCid = await prisma.evolucaoCid.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EvolucaoCids and only return the `id`
     * const evolucaoCidWithIdOnly = await prisma.evolucaoCid.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvolucaoCidUpdateManyAndReturnArgs>(args: SelectSubset<T, EvolucaoCidUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoCidPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EvolucaoCid.
     * @param {EvolucaoCidUpsertArgs} args - Arguments to update or create a EvolucaoCid.
     * @example
     * // Update or create a EvolucaoCid
     * const evolucaoCid = await prisma.evolucaoCid.upsert({
     *   create: {
     *     // ... data to create a EvolucaoCid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvolucaoCid we want to update
     *   }
     * })
     */
    upsert<T extends EvolucaoCidUpsertArgs>(args: SelectSubset<T, EvolucaoCidUpsertArgs<ExtArgs>>): Prisma__EvolucaoCidClient<$Result.GetResult<Prisma.$EvolucaoCidPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EvolucaoCids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoCidCountArgs} args - Arguments to filter EvolucaoCids to count.
     * @example
     * // Count the number of EvolucaoCids
     * const count = await prisma.evolucaoCid.count({
     *   where: {
     *     // ... the filter for the EvolucaoCids we want to count
     *   }
     * })
    **/
    count<T extends EvolucaoCidCountArgs>(
      args?: Subset<T, EvolucaoCidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvolucaoCidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvolucaoCid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoCidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvolucaoCidAggregateArgs>(args: Subset<T, EvolucaoCidAggregateArgs>): Prisma.PrismaPromise<GetEvolucaoCidAggregateType<T>>

    /**
     * Group by EvolucaoCid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoCidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvolucaoCidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvolucaoCidGroupByArgs['orderBy'] }
        : { orderBy?: EvolucaoCidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvolucaoCidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvolucaoCidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvolucaoCid model
   */
  readonly fields: EvolucaoCidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvolucaoCid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvolucaoCidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cid<T extends CidDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CidDefaultArgs<ExtArgs>>): Prisma__CidClient<$Result.GetResult<Prisma.$CidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    evolucao<T extends EvolucaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvolucaoDefaultArgs<ExtArgs>>): Prisma__EvolucaoClient<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvolucaoCid model
   */
  interface EvolucaoCidFieldRefs {
    readonly id: FieldRef<"EvolucaoCid", 'Int'>
    readonly cdEvolucao: FieldRef<"EvolucaoCid", 'Int'>
    readonly cdCid: FieldRef<"EvolucaoCid", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EvolucaoCid findUnique
   */
  export type EvolucaoCidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoCid
     */
    select?: EvolucaoCidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoCid
     */
    omit?: EvolucaoCidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoCidInclude<ExtArgs> | null
    /**
     * Filter, which EvolucaoCid to fetch.
     */
    where: EvolucaoCidWhereUniqueInput
  }

  /**
   * EvolucaoCid findUniqueOrThrow
   */
  export type EvolucaoCidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoCid
     */
    select?: EvolucaoCidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoCid
     */
    omit?: EvolucaoCidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoCidInclude<ExtArgs> | null
    /**
     * Filter, which EvolucaoCid to fetch.
     */
    where: EvolucaoCidWhereUniqueInput
  }

  /**
   * EvolucaoCid findFirst
   */
  export type EvolucaoCidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoCid
     */
    select?: EvolucaoCidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoCid
     */
    omit?: EvolucaoCidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoCidInclude<ExtArgs> | null
    /**
     * Filter, which EvolucaoCid to fetch.
     */
    where?: EvolucaoCidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolucaoCids to fetch.
     */
    orderBy?: EvolucaoCidOrderByWithRelationInput | EvolucaoCidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvolucaoCids.
     */
    cursor?: EvolucaoCidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolucaoCids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolucaoCids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvolucaoCids.
     */
    distinct?: EvolucaoCidScalarFieldEnum | EvolucaoCidScalarFieldEnum[]
  }

  /**
   * EvolucaoCid findFirstOrThrow
   */
  export type EvolucaoCidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoCid
     */
    select?: EvolucaoCidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoCid
     */
    omit?: EvolucaoCidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoCidInclude<ExtArgs> | null
    /**
     * Filter, which EvolucaoCid to fetch.
     */
    where?: EvolucaoCidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolucaoCids to fetch.
     */
    orderBy?: EvolucaoCidOrderByWithRelationInput | EvolucaoCidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvolucaoCids.
     */
    cursor?: EvolucaoCidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolucaoCids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolucaoCids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvolucaoCids.
     */
    distinct?: EvolucaoCidScalarFieldEnum | EvolucaoCidScalarFieldEnum[]
  }

  /**
   * EvolucaoCid findMany
   */
  export type EvolucaoCidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoCid
     */
    select?: EvolucaoCidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoCid
     */
    omit?: EvolucaoCidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoCidInclude<ExtArgs> | null
    /**
     * Filter, which EvolucaoCids to fetch.
     */
    where?: EvolucaoCidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolucaoCids to fetch.
     */
    orderBy?: EvolucaoCidOrderByWithRelationInput | EvolucaoCidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvolucaoCids.
     */
    cursor?: EvolucaoCidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolucaoCids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolucaoCids.
     */
    skip?: number
    distinct?: EvolucaoCidScalarFieldEnum | EvolucaoCidScalarFieldEnum[]
  }

  /**
   * EvolucaoCid create
   */
  export type EvolucaoCidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoCid
     */
    select?: EvolucaoCidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoCid
     */
    omit?: EvolucaoCidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoCidInclude<ExtArgs> | null
    /**
     * The data needed to create a EvolucaoCid.
     */
    data: XOR<EvolucaoCidCreateInput, EvolucaoCidUncheckedCreateInput>
  }

  /**
   * EvolucaoCid createMany
   */
  export type EvolucaoCidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvolucaoCids.
     */
    data: EvolucaoCidCreateManyInput | EvolucaoCidCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvolucaoCid createManyAndReturn
   */
  export type EvolucaoCidCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoCid
     */
    select?: EvolucaoCidSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoCid
     */
    omit?: EvolucaoCidOmit<ExtArgs> | null
    /**
     * The data used to create many EvolucaoCids.
     */
    data: EvolucaoCidCreateManyInput | EvolucaoCidCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoCidIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvolucaoCid update
   */
  export type EvolucaoCidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoCid
     */
    select?: EvolucaoCidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoCid
     */
    omit?: EvolucaoCidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoCidInclude<ExtArgs> | null
    /**
     * The data needed to update a EvolucaoCid.
     */
    data: XOR<EvolucaoCidUpdateInput, EvolucaoCidUncheckedUpdateInput>
    /**
     * Choose, which EvolucaoCid to update.
     */
    where: EvolucaoCidWhereUniqueInput
  }

  /**
   * EvolucaoCid updateMany
   */
  export type EvolucaoCidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvolucaoCids.
     */
    data: XOR<EvolucaoCidUpdateManyMutationInput, EvolucaoCidUncheckedUpdateManyInput>
    /**
     * Filter which EvolucaoCids to update
     */
    where?: EvolucaoCidWhereInput
    /**
     * Limit how many EvolucaoCids to update.
     */
    limit?: number
  }

  /**
   * EvolucaoCid updateManyAndReturn
   */
  export type EvolucaoCidUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoCid
     */
    select?: EvolucaoCidSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoCid
     */
    omit?: EvolucaoCidOmit<ExtArgs> | null
    /**
     * The data used to update EvolucaoCids.
     */
    data: XOR<EvolucaoCidUpdateManyMutationInput, EvolucaoCidUncheckedUpdateManyInput>
    /**
     * Filter which EvolucaoCids to update
     */
    where?: EvolucaoCidWhereInput
    /**
     * Limit how many EvolucaoCids to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoCidIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvolucaoCid upsert
   */
  export type EvolucaoCidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoCid
     */
    select?: EvolucaoCidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoCid
     */
    omit?: EvolucaoCidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoCidInclude<ExtArgs> | null
    /**
     * The filter to search for the EvolucaoCid to update in case it exists.
     */
    where: EvolucaoCidWhereUniqueInput
    /**
     * In case the EvolucaoCid found by the `where` argument doesn't exist, create a new EvolucaoCid with this data.
     */
    create: XOR<EvolucaoCidCreateInput, EvolucaoCidUncheckedCreateInput>
    /**
     * In case the EvolucaoCid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvolucaoCidUpdateInput, EvolucaoCidUncheckedUpdateInput>
  }

  /**
   * EvolucaoCid delete
   */
  export type EvolucaoCidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoCid
     */
    select?: EvolucaoCidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoCid
     */
    omit?: EvolucaoCidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoCidInclude<ExtArgs> | null
    /**
     * Filter which EvolucaoCid to delete.
     */
    where: EvolucaoCidWhereUniqueInput
  }

  /**
   * EvolucaoCid deleteMany
   */
  export type EvolucaoCidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvolucaoCids to delete
     */
    where?: EvolucaoCidWhereInput
    /**
     * Limit how many EvolucaoCids to delete.
     */
    limit?: number
  }

  /**
   * EvolucaoCid without action
   */
  export type EvolucaoCidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoCid
     */
    select?: EvolucaoCidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoCid
     */
    omit?: EvolucaoCidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoCidInclude<ExtArgs> | null
  }


  /**
   * Model EvolucaoDsm
   */

  export type AggregateEvolucaoDsm = {
    _count: EvolucaoDsmCountAggregateOutputType | null
    _avg: EvolucaoDsmAvgAggregateOutputType | null
    _sum: EvolucaoDsmSumAggregateOutputType | null
    _min: EvolucaoDsmMinAggregateOutputType | null
    _max: EvolucaoDsmMaxAggregateOutputType | null
  }

  export type EvolucaoDsmAvgAggregateOutputType = {
    id: number | null
    cdEvolucao: number | null
    cdDsm: number | null
  }

  export type EvolucaoDsmSumAggregateOutputType = {
    id: number | null
    cdEvolucao: number | null
    cdDsm: number | null
  }

  export type EvolucaoDsmMinAggregateOutputType = {
    id: number | null
    cdEvolucao: number | null
    cdDsm: number | null
  }

  export type EvolucaoDsmMaxAggregateOutputType = {
    id: number | null
    cdEvolucao: number | null
    cdDsm: number | null
  }

  export type EvolucaoDsmCountAggregateOutputType = {
    id: number
    cdEvolucao: number
    cdDsm: number
    _all: number
  }


  export type EvolucaoDsmAvgAggregateInputType = {
    id?: true
    cdEvolucao?: true
    cdDsm?: true
  }

  export type EvolucaoDsmSumAggregateInputType = {
    id?: true
    cdEvolucao?: true
    cdDsm?: true
  }

  export type EvolucaoDsmMinAggregateInputType = {
    id?: true
    cdEvolucao?: true
    cdDsm?: true
  }

  export type EvolucaoDsmMaxAggregateInputType = {
    id?: true
    cdEvolucao?: true
    cdDsm?: true
  }

  export type EvolucaoDsmCountAggregateInputType = {
    id?: true
    cdEvolucao?: true
    cdDsm?: true
    _all?: true
  }

  export type EvolucaoDsmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvolucaoDsm to aggregate.
     */
    where?: EvolucaoDsmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolucaoDsms to fetch.
     */
    orderBy?: EvolucaoDsmOrderByWithRelationInput | EvolucaoDsmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvolucaoDsmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolucaoDsms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolucaoDsms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvolucaoDsms
    **/
    _count?: true | EvolucaoDsmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvolucaoDsmAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvolucaoDsmSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvolucaoDsmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvolucaoDsmMaxAggregateInputType
  }

  export type GetEvolucaoDsmAggregateType<T extends EvolucaoDsmAggregateArgs> = {
        [P in keyof T & keyof AggregateEvolucaoDsm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvolucaoDsm[P]>
      : GetScalarType<T[P], AggregateEvolucaoDsm[P]>
  }




  export type EvolucaoDsmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolucaoDsmWhereInput
    orderBy?: EvolucaoDsmOrderByWithAggregationInput | EvolucaoDsmOrderByWithAggregationInput[]
    by: EvolucaoDsmScalarFieldEnum[] | EvolucaoDsmScalarFieldEnum
    having?: EvolucaoDsmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvolucaoDsmCountAggregateInputType | true
    _avg?: EvolucaoDsmAvgAggregateInputType
    _sum?: EvolucaoDsmSumAggregateInputType
    _min?: EvolucaoDsmMinAggregateInputType
    _max?: EvolucaoDsmMaxAggregateInputType
  }

  export type EvolucaoDsmGroupByOutputType = {
    id: number
    cdEvolucao: number
    cdDsm: number
    _count: EvolucaoDsmCountAggregateOutputType | null
    _avg: EvolucaoDsmAvgAggregateOutputType | null
    _sum: EvolucaoDsmSumAggregateOutputType | null
    _min: EvolucaoDsmMinAggregateOutputType | null
    _max: EvolucaoDsmMaxAggregateOutputType | null
  }

  type GetEvolucaoDsmGroupByPayload<T extends EvolucaoDsmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvolucaoDsmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvolucaoDsmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvolucaoDsmGroupByOutputType[P]>
            : GetScalarType<T[P], EvolucaoDsmGroupByOutputType[P]>
        }
      >
    >


  export type EvolucaoDsmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdEvolucao?: boolean
    cdDsm?: boolean
    dsm?: boolean | DsmDefaultArgs<ExtArgs>
    evolucao?: boolean | EvolucaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evolucaoDsm"]>

  export type EvolucaoDsmSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdEvolucao?: boolean
    cdDsm?: boolean
    dsm?: boolean | DsmDefaultArgs<ExtArgs>
    evolucao?: boolean | EvolucaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evolucaoDsm"]>

  export type EvolucaoDsmSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdEvolucao?: boolean
    cdDsm?: boolean
    dsm?: boolean | DsmDefaultArgs<ExtArgs>
    evolucao?: boolean | EvolucaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evolucaoDsm"]>

  export type EvolucaoDsmSelectScalar = {
    id?: boolean
    cdEvolucao?: boolean
    cdDsm?: boolean
  }

  export type EvolucaoDsmOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdEvolucao" | "cdDsm", ExtArgs["result"]["evolucaoDsm"]>
  export type EvolucaoDsmInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dsm?: boolean | DsmDefaultArgs<ExtArgs>
    evolucao?: boolean | EvolucaoDefaultArgs<ExtArgs>
  }
  export type EvolucaoDsmIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dsm?: boolean | DsmDefaultArgs<ExtArgs>
    evolucao?: boolean | EvolucaoDefaultArgs<ExtArgs>
  }
  export type EvolucaoDsmIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dsm?: boolean | DsmDefaultArgs<ExtArgs>
    evolucao?: boolean | EvolucaoDefaultArgs<ExtArgs>
  }

  export type $EvolucaoDsmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvolucaoDsm"
    objects: {
      dsm: Prisma.$DsmPayload<ExtArgs>
      evolucao: Prisma.$EvolucaoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdEvolucao: number
      cdDsm: number
    }, ExtArgs["result"]["evolucaoDsm"]>
    composites: {}
  }

  type EvolucaoDsmGetPayload<S extends boolean | null | undefined | EvolucaoDsmDefaultArgs> = $Result.GetResult<Prisma.$EvolucaoDsmPayload, S>

  type EvolucaoDsmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvolucaoDsmFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvolucaoDsmCountAggregateInputType | true
    }

  export interface EvolucaoDsmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvolucaoDsm'], meta: { name: 'EvolucaoDsm' } }
    /**
     * Find zero or one EvolucaoDsm that matches the filter.
     * @param {EvolucaoDsmFindUniqueArgs} args - Arguments to find a EvolucaoDsm
     * @example
     * // Get one EvolucaoDsm
     * const evolucaoDsm = await prisma.evolucaoDsm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvolucaoDsmFindUniqueArgs>(args: SelectSubset<T, EvolucaoDsmFindUniqueArgs<ExtArgs>>): Prisma__EvolucaoDsmClient<$Result.GetResult<Prisma.$EvolucaoDsmPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EvolucaoDsm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvolucaoDsmFindUniqueOrThrowArgs} args - Arguments to find a EvolucaoDsm
     * @example
     * // Get one EvolucaoDsm
     * const evolucaoDsm = await prisma.evolucaoDsm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvolucaoDsmFindUniqueOrThrowArgs>(args: SelectSubset<T, EvolucaoDsmFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvolucaoDsmClient<$Result.GetResult<Prisma.$EvolucaoDsmPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvolucaoDsm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoDsmFindFirstArgs} args - Arguments to find a EvolucaoDsm
     * @example
     * // Get one EvolucaoDsm
     * const evolucaoDsm = await prisma.evolucaoDsm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvolucaoDsmFindFirstArgs>(args?: SelectSubset<T, EvolucaoDsmFindFirstArgs<ExtArgs>>): Prisma__EvolucaoDsmClient<$Result.GetResult<Prisma.$EvolucaoDsmPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvolucaoDsm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoDsmFindFirstOrThrowArgs} args - Arguments to find a EvolucaoDsm
     * @example
     * // Get one EvolucaoDsm
     * const evolucaoDsm = await prisma.evolucaoDsm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvolucaoDsmFindFirstOrThrowArgs>(args?: SelectSubset<T, EvolucaoDsmFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvolucaoDsmClient<$Result.GetResult<Prisma.$EvolucaoDsmPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EvolucaoDsms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoDsmFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvolucaoDsms
     * const evolucaoDsms = await prisma.evolucaoDsm.findMany()
     * 
     * // Get first 10 EvolucaoDsms
     * const evolucaoDsms = await prisma.evolucaoDsm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evolucaoDsmWithIdOnly = await prisma.evolucaoDsm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvolucaoDsmFindManyArgs>(args?: SelectSubset<T, EvolucaoDsmFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoDsmPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EvolucaoDsm.
     * @param {EvolucaoDsmCreateArgs} args - Arguments to create a EvolucaoDsm.
     * @example
     * // Create one EvolucaoDsm
     * const EvolucaoDsm = await prisma.evolucaoDsm.create({
     *   data: {
     *     // ... data to create a EvolucaoDsm
     *   }
     * })
     * 
     */
    create<T extends EvolucaoDsmCreateArgs>(args: SelectSubset<T, EvolucaoDsmCreateArgs<ExtArgs>>): Prisma__EvolucaoDsmClient<$Result.GetResult<Prisma.$EvolucaoDsmPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EvolucaoDsms.
     * @param {EvolucaoDsmCreateManyArgs} args - Arguments to create many EvolucaoDsms.
     * @example
     * // Create many EvolucaoDsms
     * const evolucaoDsm = await prisma.evolucaoDsm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvolucaoDsmCreateManyArgs>(args?: SelectSubset<T, EvolucaoDsmCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvolucaoDsms and returns the data saved in the database.
     * @param {EvolucaoDsmCreateManyAndReturnArgs} args - Arguments to create many EvolucaoDsms.
     * @example
     * // Create many EvolucaoDsms
     * const evolucaoDsm = await prisma.evolucaoDsm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvolucaoDsms and only return the `id`
     * const evolucaoDsmWithIdOnly = await prisma.evolucaoDsm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvolucaoDsmCreateManyAndReturnArgs>(args?: SelectSubset<T, EvolucaoDsmCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoDsmPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EvolucaoDsm.
     * @param {EvolucaoDsmDeleteArgs} args - Arguments to delete one EvolucaoDsm.
     * @example
     * // Delete one EvolucaoDsm
     * const EvolucaoDsm = await prisma.evolucaoDsm.delete({
     *   where: {
     *     // ... filter to delete one EvolucaoDsm
     *   }
     * })
     * 
     */
    delete<T extends EvolucaoDsmDeleteArgs>(args: SelectSubset<T, EvolucaoDsmDeleteArgs<ExtArgs>>): Prisma__EvolucaoDsmClient<$Result.GetResult<Prisma.$EvolucaoDsmPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EvolucaoDsm.
     * @param {EvolucaoDsmUpdateArgs} args - Arguments to update one EvolucaoDsm.
     * @example
     * // Update one EvolucaoDsm
     * const evolucaoDsm = await prisma.evolucaoDsm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvolucaoDsmUpdateArgs>(args: SelectSubset<T, EvolucaoDsmUpdateArgs<ExtArgs>>): Prisma__EvolucaoDsmClient<$Result.GetResult<Prisma.$EvolucaoDsmPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EvolucaoDsms.
     * @param {EvolucaoDsmDeleteManyArgs} args - Arguments to filter EvolucaoDsms to delete.
     * @example
     * // Delete a few EvolucaoDsms
     * const { count } = await prisma.evolucaoDsm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvolucaoDsmDeleteManyArgs>(args?: SelectSubset<T, EvolucaoDsmDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvolucaoDsms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoDsmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvolucaoDsms
     * const evolucaoDsm = await prisma.evolucaoDsm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvolucaoDsmUpdateManyArgs>(args: SelectSubset<T, EvolucaoDsmUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvolucaoDsms and returns the data updated in the database.
     * @param {EvolucaoDsmUpdateManyAndReturnArgs} args - Arguments to update many EvolucaoDsms.
     * @example
     * // Update many EvolucaoDsms
     * const evolucaoDsm = await prisma.evolucaoDsm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EvolucaoDsms and only return the `id`
     * const evolucaoDsmWithIdOnly = await prisma.evolucaoDsm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvolucaoDsmUpdateManyAndReturnArgs>(args: SelectSubset<T, EvolucaoDsmUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolucaoDsmPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EvolucaoDsm.
     * @param {EvolucaoDsmUpsertArgs} args - Arguments to update or create a EvolucaoDsm.
     * @example
     * // Update or create a EvolucaoDsm
     * const evolucaoDsm = await prisma.evolucaoDsm.upsert({
     *   create: {
     *     // ... data to create a EvolucaoDsm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvolucaoDsm we want to update
     *   }
     * })
     */
    upsert<T extends EvolucaoDsmUpsertArgs>(args: SelectSubset<T, EvolucaoDsmUpsertArgs<ExtArgs>>): Prisma__EvolucaoDsmClient<$Result.GetResult<Prisma.$EvolucaoDsmPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EvolucaoDsms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoDsmCountArgs} args - Arguments to filter EvolucaoDsms to count.
     * @example
     * // Count the number of EvolucaoDsms
     * const count = await prisma.evolucaoDsm.count({
     *   where: {
     *     // ... the filter for the EvolucaoDsms we want to count
     *   }
     * })
    **/
    count<T extends EvolucaoDsmCountArgs>(
      args?: Subset<T, EvolucaoDsmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvolucaoDsmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvolucaoDsm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoDsmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvolucaoDsmAggregateArgs>(args: Subset<T, EvolucaoDsmAggregateArgs>): Prisma.PrismaPromise<GetEvolucaoDsmAggregateType<T>>

    /**
     * Group by EvolucaoDsm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolucaoDsmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvolucaoDsmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvolucaoDsmGroupByArgs['orderBy'] }
        : { orderBy?: EvolucaoDsmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvolucaoDsmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvolucaoDsmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvolucaoDsm model
   */
  readonly fields: EvolucaoDsmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvolucaoDsm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvolucaoDsmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dsm<T extends DsmDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DsmDefaultArgs<ExtArgs>>): Prisma__DsmClient<$Result.GetResult<Prisma.$DsmPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    evolucao<T extends EvolucaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvolucaoDefaultArgs<ExtArgs>>): Prisma__EvolucaoClient<$Result.GetResult<Prisma.$EvolucaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvolucaoDsm model
   */
  interface EvolucaoDsmFieldRefs {
    readonly id: FieldRef<"EvolucaoDsm", 'Int'>
    readonly cdEvolucao: FieldRef<"EvolucaoDsm", 'Int'>
    readonly cdDsm: FieldRef<"EvolucaoDsm", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EvolucaoDsm findUnique
   */
  export type EvolucaoDsmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoDsm
     */
    select?: EvolucaoDsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoDsm
     */
    omit?: EvolucaoDsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoDsmInclude<ExtArgs> | null
    /**
     * Filter, which EvolucaoDsm to fetch.
     */
    where: EvolucaoDsmWhereUniqueInput
  }

  /**
   * EvolucaoDsm findUniqueOrThrow
   */
  export type EvolucaoDsmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoDsm
     */
    select?: EvolucaoDsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoDsm
     */
    omit?: EvolucaoDsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoDsmInclude<ExtArgs> | null
    /**
     * Filter, which EvolucaoDsm to fetch.
     */
    where: EvolucaoDsmWhereUniqueInput
  }

  /**
   * EvolucaoDsm findFirst
   */
  export type EvolucaoDsmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoDsm
     */
    select?: EvolucaoDsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoDsm
     */
    omit?: EvolucaoDsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoDsmInclude<ExtArgs> | null
    /**
     * Filter, which EvolucaoDsm to fetch.
     */
    where?: EvolucaoDsmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolucaoDsms to fetch.
     */
    orderBy?: EvolucaoDsmOrderByWithRelationInput | EvolucaoDsmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvolucaoDsms.
     */
    cursor?: EvolucaoDsmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolucaoDsms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolucaoDsms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvolucaoDsms.
     */
    distinct?: EvolucaoDsmScalarFieldEnum | EvolucaoDsmScalarFieldEnum[]
  }

  /**
   * EvolucaoDsm findFirstOrThrow
   */
  export type EvolucaoDsmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoDsm
     */
    select?: EvolucaoDsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoDsm
     */
    omit?: EvolucaoDsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoDsmInclude<ExtArgs> | null
    /**
     * Filter, which EvolucaoDsm to fetch.
     */
    where?: EvolucaoDsmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolucaoDsms to fetch.
     */
    orderBy?: EvolucaoDsmOrderByWithRelationInput | EvolucaoDsmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvolucaoDsms.
     */
    cursor?: EvolucaoDsmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolucaoDsms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolucaoDsms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvolucaoDsms.
     */
    distinct?: EvolucaoDsmScalarFieldEnum | EvolucaoDsmScalarFieldEnum[]
  }

  /**
   * EvolucaoDsm findMany
   */
  export type EvolucaoDsmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoDsm
     */
    select?: EvolucaoDsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoDsm
     */
    omit?: EvolucaoDsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoDsmInclude<ExtArgs> | null
    /**
     * Filter, which EvolucaoDsms to fetch.
     */
    where?: EvolucaoDsmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolucaoDsms to fetch.
     */
    orderBy?: EvolucaoDsmOrderByWithRelationInput | EvolucaoDsmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvolucaoDsms.
     */
    cursor?: EvolucaoDsmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolucaoDsms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolucaoDsms.
     */
    skip?: number
    distinct?: EvolucaoDsmScalarFieldEnum | EvolucaoDsmScalarFieldEnum[]
  }

  /**
   * EvolucaoDsm create
   */
  export type EvolucaoDsmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoDsm
     */
    select?: EvolucaoDsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoDsm
     */
    omit?: EvolucaoDsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoDsmInclude<ExtArgs> | null
    /**
     * The data needed to create a EvolucaoDsm.
     */
    data: XOR<EvolucaoDsmCreateInput, EvolucaoDsmUncheckedCreateInput>
  }

  /**
   * EvolucaoDsm createMany
   */
  export type EvolucaoDsmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvolucaoDsms.
     */
    data: EvolucaoDsmCreateManyInput | EvolucaoDsmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvolucaoDsm createManyAndReturn
   */
  export type EvolucaoDsmCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoDsm
     */
    select?: EvolucaoDsmSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoDsm
     */
    omit?: EvolucaoDsmOmit<ExtArgs> | null
    /**
     * The data used to create many EvolucaoDsms.
     */
    data: EvolucaoDsmCreateManyInput | EvolucaoDsmCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoDsmIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvolucaoDsm update
   */
  export type EvolucaoDsmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoDsm
     */
    select?: EvolucaoDsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoDsm
     */
    omit?: EvolucaoDsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoDsmInclude<ExtArgs> | null
    /**
     * The data needed to update a EvolucaoDsm.
     */
    data: XOR<EvolucaoDsmUpdateInput, EvolucaoDsmUncheckedUpdateInput>
    /**
     * Choose, which EvolucaoDsm to update.
     */
    where: EvolucaoDsmWhereUniqueInput
  }

  /**
   * EvolucaoDsm updateMany
   */
  export type EvolucaoDsmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvolucaoDsms.
     */
    data: XOR<EvolucaoDsmUpdateManyMutationInput, EvolucaoDsmUncheckedUpdateManyInput>
    /**
     * Filter which EvolucaoDsms to update
     */
    where?: EvolucaoDsmWhereInput
    /**
     * Limit how many EvolucaoDsms to update.
     */
    limit?: number
  }

  /**
   * EvolucaoDsm updateManyAndReturn
   */
  export type EvolucaoDsmUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoDsm
     */
    select?: EvolucaoDsmSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoDsm
     */
    omit?: EvolucaoDsmOmit<ExtArgs> | null
    /**
     * The data used to update EvolucaoDsms.
     */
    data: XOR<EvolucaoDsmUpdateManyMutationInput, EvolucaoDsmUncheckedUpdateManyInput>
    /**
     * Filter which EvolucaoDsms to update
     */
    where?: EvolucaoDsmWhereInput
    /**
     * Limit how many EvolucaoDsms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoDsmIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvolucaoDsm upsert
   */
  export type EvolucaoDsmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoDsm
     */
    select?: EvolucaoDsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoDsm
     */
    omit?: EvolucaoDsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoDsmInclude<ExtArgs> | null
    /**
     * The filter to search for the EvolucaoDsm to update in case it exists.
     */
    where: EvolucaoDsmWhereUniqueInput
    /**
     * In case the EvolucaoDsm found by the `where` argument doesn't exist, create a new EvolucaoDsm with this data.
     */
    create: XOR<EvolucaoDsmCreateInput, EvolucaoDsmUncheckedCreateInput>
    /**
     * In case the EvolucaoDsm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvolucaoDsmUpdateInput, EvolucaoDsmUncheckedUpdateInput>
  }

  /**
   * EvolucaoDsm delete
   */
  export type EvolucaoDsmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoDsm
     */
    select?: EvolucaoDsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoDsm
     */
    omit?: EvolucaoDsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoDsmInclude<ExtArgs> | null
    /**
     * Filter which EvolucaoDsm to delete.
     */
    where: EvolucaoDsmWhereUniqueInput
  }

  /**
   * EvolucaoDsm deleteMany
   */
  export type EvolucaoDsmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvolucaoDsms to delete
     */
    where?: EvolucaoDsmWhereInput
    /**
     * Limit how many EvolucaoDsms to delete.
     */
    limit?: number
  }

  /**
   * EvolucaoDsm without action
   */
  export type EvolucaoDsmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolucaoDsm
     */
    select?: EvolucaoDsmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolucaoDsm
     */
    omit?: EvolucaoDsmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolucaoDsmInclude<ExtArgs> | null
  }


  /**
   * Model SinaisVitais
   */

  export type AggregateSinaisVitais = {
    _count: SinaisVitaisCountAggregateOutputType | null
    _avg: SinaisVitaisAvgAggregateOutputType | null
    _sum: SinaisVitaisSumAggregateOutputType | null
    _min: SinaisVitaisMinAggregateOutputType | null
    _max: SinaisVitaisMaxAggregateOutputType | null
  }

  export type SinaisVitaisAvgAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    paSistolica: number | null
    paDiastolica: number | null
    fc: number | null
    fr: number | null
    temperatura: Decimal | null
    spo2: number | null
    peso: Decimal | null
    altura: Decimal | null
    imc: Decimal | null
    dor: number | null
    escalaDorId: number | null
  }

  export type SinaisVitaisSumAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    paSistolica: number | null
    paDiastolica: number | null
    fc: number | null
    fr: number | null
    temperatura: Decimal | null
    spo2: number | null
    peso: Decimal | null
    altura: Decimal | null
    imc: Decimal | null
    dor: number | null
    escalaDorId: number | null
  }

  export type SinaisVitaisMinAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    data: Date | null
    paSistolica: number | null
    paDiastolica: number | null
    fc: number | null
    fr: number | null
    temperatura: Decimal | null
    spo2: number | null
    peso: Decimal | null
    altura: Decimal | null
    imc: Decimal | null
    dor: number | null
    escalaDorId: number | null
    posicao: $Enums.PosicaoPaciente | null
    origem: $Enums.OrigemAfericao | null
  }

  export type SinaisVitaisMaxAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    data: Date | null
    paSistolica: number | null
    paDiastolica: number | null
    fc: number | null
    fr: number | null
    temperatura: Decimal | null
    spo2: number | null
    peso: Decimal | null
    altura: Decimal | null
    imc: Decimal | null
    dor: number | null
    escalaDorId: number | null
    posicao: $Enums.PosicaoPaciente | null
    origem: $Enums.OrigemAfericao | null
  }

  export type SinaisVitaisCountAggregateOutputType = {
    id: number
    cdAtendimento: number
    data: number
    paSistolica: number
    paDiastolica: number
    fc: number
    fr: number
    temperatura: number
    spo2: number
    peso: number
    altura: number
    imc: number
    dor: number
    escalaDorId: number
    posicao: number
    origem: number
    metadataRaw: number
    _all: number
  }


  export type SinaisVitaisAvgAggregateInputType = {
    id?: true
    cdAtendimento?: true
    paSistolica?: true
    paDiastolica?: true
    fc?: true
    fr?: true
    temperatura?: true
    spo2?: true
    peso?: true
    altura?: true
    imc?: true
    dor?: true
    escalaDorId?: true
  }

  export type SinaisVitaisSumAggregateInputType = {
    id?: true
    cdAtendimento?: true
    paSistolica?: true
    paDiastolica?: true
    fc?: true
    fr?: true
    temperatura?: true
    spo2?: true
    peso?: true
    altura?: true
    imc?: true
    dor?: true
    escalaDorId?: true
  }

  export type SinaisVitaisMinAggregateInputType = {
    id?: true
    cdAtendimento?: true
    data?: true
    paSistolica?: true
    paDiastolica?: true
    fc?: true
    fr?: true
    temperatura?: true
    spo2?: true
    peso?: true
    altura?: true
    imc?: true
    dor?: true
    escalaDorId?: true
    posicao?: true
    origem?: true
  }

  export type SinaisVitaisMaxAggregateInputType = {
    id?: true
    cdAtendimento?: true
    data?: true
    paSistolica?: true
    paDiastolica?: true
    fc?: true
    fr?: true
    temperatura?: true
    spo2?: true
    peso?: true
    altura?: true
    imc?: true
    dor?: true
    escalaDorId?: true
    posicao?: true
    origem?: true
  }

  export type SinaisVitaisCountAggregateInputType = {
    id?: true
    cdAtendimento?: true
    data?: true
    paSistolica?: true
    paDiastolica?: true
    fc?: true
    fr?: true
    temperatura?: true
    spo2?: true
    peso?: true
    altura?: true
    imc?: true
    dor?: true
    escalaDorId?: true
    posicao?: true
    origem?: true
    metadataRaw?: true
    _all?: true
  }

  export type SinaisVitaisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SinaisVitais to aggregate.
     */
    where?: SinaisVitaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SinaisVitais to fetch.
     */
    orderBy?: SinaisVitaisOrderByWithRelationInput | SinaisVitaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SinaisVitaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SinaisVitais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SinaisVitais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SinaisVitais
    **/
    _count?: true | SinaisVitaisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SinaisVitaisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SinaisVitaisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SinaisVitaisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SinaisVitaisMaxAggregateInputType
  }

  export type GetSinaisVitaisAggregateType<T extends SinaisVitaisAggregateArgs> = {
        [P in keyof T & keyof AggregateSinaisVitais]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSinaisVitais[P]>
      : GetScalarType<T[P], AggregateSinaisVitais[P]>
  }




  export type SinaisVitaisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SinaisVitaisWhereInput
    orderBy?: SinaisVitaisOrderByWithAggregationInput | SinaisVitaisOrderByWithAggregationInput[]
    by: SinaisVitaisScalarFieldEnum[] | SinaisVitaisScalarFieldEnum
    having?: SinaisVitaisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SinaisVitaisCountAggregateInputType | true
    _avg?: SinaisVitaisAvgAggregateInputType
    _sum?: SinaisVitaisSumAggregateInputType
    _min?: SinaisVitaisMinAggregateInputType
    _max?: SinaisVitaisMaxAggregateInputType
  }

  export type SinaisVitaisGroupByOutputType = {
    id: number
    cdAtendimento: number
    data: Date
    paSistolica: number | null
    paDiastolica: number | null
    fc: number | null
    fr: number | null
    temperatura: Decimal | null
    spo2: number | null
    peso: Decimal | null
    altura: Decimal | null
    imc: Decimal | null
    dor: number | null
    escalaDorId: number | null
    posicao: $Enums.PosicaoPaciente | null
    origem: $Enums.OrigemAfericao | null
    metadataRaw: JsonValue | null
    _count: SinaisVitaisCountAggregateOutputType | null
    _avg: SinaisVitaisAvgAggregateOutputType | null
    _sum: SinaisVitaisSumAggregateOutputType | null
    _min: SinaisVitaisMinAggregateOutputType | null
    _max: SinaisVitaisMaxAggregateOutputType | null
  }

  type GetSinaisVitaisGroupByPayload<T extends SinaisVitaisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SinaisVitaisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SinaisVitaisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SinaisVitaisGroupByOutputType[P]>
            : GetScalarType<T[P], SinaisVitaisGroupByOutputType[P]>
        }
      >
    >


  export type SinaisVitaisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdAtendimento?: boolean
    data?: boolean
    paSistolica?: boolean
    paDiastolica?: boolean
    fc?: boolean
    fr?: boolean
    temperatura?: boolean
    spo2?: boolean
    peso?: boolean
    altura?: boolean
    imc?: boolean
    dor?: boolean
    escalaDorId?: boolean
    posicao?: boolean
    origem?: boolean
    metadataRaw?: boolean
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    escalaDor?: boolean | SinaisVitais$escalaDorArgs<ExtArgs>
  }, ExtArgs["result"]["sinaisVitais"]>

  export type SinaisVitaisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdAtendimento?: boolean
    data?: boolean
    paSistolica?: boolean
    paDiastolica?: boolean
    fc?: boolean
    fr?: boolean
    temperatura?: boolean
    spo2?: boolean
    peso?: boolean
    altura?: boolean
    imc?: boolean
    dor?: boolean
    escalaDorId?: boolean
    posicao?: boolean
    origem?: boolean
    metadataRaw?: boolean
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    escalaDor?: boolean | SinaisVitais$escalaDorArgs<ExtArgs>
  }, ExtArgs["result"]["sinaisVitais"]>

  export type SinaisVitaisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdAtendimento?: boolean
    data?: boolean
    paSistolica?: boolean
    paDiastolica?: boolean
    fc?: boolean
    fr?: boolean
    temperatura?: boolean
    spo2?: boolean
    peso?: boolean
    altura?: boolean
    imc?: boolean
    dor?: boolean
    escalaDorId?: boolean
    posicao?: boolean
    origem?: boolean
    metadataRaw?: boolean
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    escalaDor?: boolean | SinaisVitais$escalaDorArgs<ExtArgs>
  }, ExtArgs["result"]["sinaisVitais"]>

  export type SinaisVitaisSelectScalar = {
    id?: boolean
    cdAtendimento?: boolean
    data?: boolean
    paSistolica?: boolean
    paDiastolica?: boolean
    fc?: boolean
    fr?: boolean
    temperatura?: boolean
    spo2?: boolean
    peso?: boolean
    altura?: boolean
    imc?: boolean
    dor?: boolean
    escalaDorId?: boolean
    posicao?: boolean
    origem?: boolean
    metadataRaw?: boolean
  }

  export type SinaisVitaisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdAtendimento" | "data" | "paSistolica" | "paDiastolica" | "fc" | "fr" | "temperatura" | "spo2" | "peso" | "altura" | "imc" | "dor" | "escalaDorId" | "posicao" | "origem" | "metadataRaw", ExtArgs["result"]["sinaisVitais"]>
  export type SinaisVitaisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    escalaDor?: boolean | SinaisVitais$escalaDorArgs<ExtArgs>
  }
  export type SinaisVitaisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    escalaDor?: boolean | SinaisVitais$escalaDorArgs<ExtArgs>
  }
  export type SinaisVitaisIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    escalaDor?: boolean | SinaisVitais$escalaDorArgs<ExtArgs>
  }

  export type $SinaisVitaisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SinaisVitais"
    objects: {
      atendimento: Prisma.$AtendimentoPayload<ExtArgs>
      escalaDor: Prisma.$EscalaDorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdAtendimento: number
      data: Date
      paSistolica: number | null
      paDiastolica: number | null
      fc: number | null
      fr: number | null
      temperatura: Prisma.Decimal | null
      spo2: number | null
      peso: Prisma.Decimal | null
      altura: Prisma.Decimal | null
      imc: Prisma.Decimal | null
      dor: number | null
      escalaDorId: number | null
      posicao: $Enums.PosicaoPaciente | null
      origem: $Enums.OrigemAfericao | null
      metadataRaw: Prisma.JsonValue | null
    }, ExtArgs["result"]["sinaisVitais"]>
    composites: {}
  }

  type SinaisVitaisGetPayload<S extends boolean | null | undefined | SinaisVitaisDefaultArgs> = $Result.GetResult<Prisma.$SinaisVitaisPayload, S>

  type SinaisVitaisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SinaisVitaisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SinaisVitaisCountAggregateInputType | true
    }

  export interface SinaisVitaisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SinaisVitais'], meta: { name: 'SinaisVitais' } }
    /**
     * Find zero or one SinaisVitais that matches the filter.
     * @param {SinaisVitaisFindUniqueArgs} args - Arguments to find a SinaisVitais
     * @example
     * // Get one SinaisVitais
     * const sinaisVitais = await prisma.sinaisVitais.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SinaisVitaisFindUniqueArgs>(args: SelectSubset<T, SinaisVitaisFindUniqueArgs<ExtArgs>>): Prisma__SinaisVitaisClient<$Result.GetResult<Prisma.$SinaisVitaisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SinaisVitais that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SinaisVitaisFindUniqueOrThrowArgs} args - Arguments to find a SinaisVitais
     * @example
     * // Get one SinaisVitais
     * const sinaisVitais = await prisma.sinaisVitais.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SinaisVitaisFindUniqueOrThrowArgs>(args: SelectSubset<T, SinaisVitaisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SinaisVitaisClient<$Result.GetResult<Prisma.$SinaisVitaisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SinaisVitais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SinaisVitaisFindFirstArgs} args - Arguments to find a SinaisVitais
     * @example
     * // Get one SinaisVitais
     * const sinaisVitais = await prisma.sinaisVitais.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SinaisVitaisFindFirstArgs>(args?: SelectSubset<T, SinaisVitaisFindFirstArgs<ExtArgs>>): Prisma__SinaisVitaisClient<$Result.GetResult<Prisma.$SinaisVitaisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SinaisVitais that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SinaisVitaisFindFirstOrThrowArgs} args - Arguments to find a SinaisVitais
     * @example
     * // Get one SinaisVitais
     * const sinaisVitais = await prisma.sinaisVitais.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SinaisVitaisFindFirstOrThrowArgs>(args?: SelectSubset<T, SinaisVitaisFindFirstOrThrowArgs<ExtArgs>>): Prisma__SinaisVitaisClient<$Result.GetResult<Prisma.$SinaisVitaisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SinaisVitais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SinaisVitaisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SinaisVitais
     * const sinaisVitais = await prisma.sinaisVitais.findMany()
     * 
     * // Get first 10 SinaisVitais
     * const sinaisVitais = await prisma.sinaisVitais.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sinaisVitaisWithIdOnly = await prisma.sinaisVitais.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SinaisVitaisFindManyArgs>(args?: SelectSubset<T, SinaisVitaisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SinaisVitaisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SinaisVitais.
     * @param {SinaisVitaisCreateArgs} args - Arguments to create a SinaisVitais.
     * @example
     * // Create one SinaisVitais
     * const SinaisVitais = await prisma.sinaisVitais.create({
     *   data: {
     *     // ... data to create a SinaisVitais
     *   }
     * })
     * 
     */
    create<T extends SinaisVitaisCreateArgs>(args: SelectSubset<T, SinaisVitaisCreateArgs<ExtArgs>>): Prisma__SinaisVitaisClient<$Result.GetResult<Prisma.$SinaisVitaisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SinaisVitais.
     * @param {SinaisVitaisCreateManyArgs} args - Arguments to create many SinaisVitais.
     * @example
     * // Create many SinaisVitais
     * const sinaisVitais = await prisma.sinaisVitais.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SinaisVitaisCreateManyArgs>(args?: SelectSubset<T, SinaisVitaisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SinaisVitais and returns the data saved in the database.
     * @param {SinaisVitaisCreateManyAndReturnArgs} args - Arguments to create many SinaisVitais.
     * @example
     * // Create many SinaisVitais
     * const sinaisVitais = await prisma.sinaisVitais.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SinaisVitais and only return the `id`
     * const sinaisVitaisWithIdOnly = await prisma.sinaisVitais.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SinaisVitaisCreateManyAndReturnArgs>(args?: SelectSubset<T, SinaisVitaisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SinaisVitaisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SinaisVitais.
     * @param {SinaisVitaisDeleteArgs} args - Arguments to delete one SinaisVitais.
     * @example
     * // Delete one SinaisVitais
     * const SinaisVitais = await prisma.sinaisVitais.delete({
     *   where: {
     *     // ... filter to delete one SinaisVitais
     *   }
     * })
     * 
     */
    delete<T extends SinaisVitaisDeleteArgs>(args: SelectSubset<T, SinaisVitaisDeleteArgs<ExtArgs>>): Prisma__SinaisVitaisClient<$Result.GetResult<Prisma.$SinaisVitaisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SinaisVitais.
     * @param {SinaisVitaisUpdateArgs} args - Arguments to update one SinaisVitais.
     * @example
     * // Update one SinaisVitais
     * const sinaisVitais = await prisma.sinaisVitais.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SinaisVitaisUpdateArgs>(args: SelectSubset<T, SinaisVitaisUpdateArgs<ExtArgs>>): Prisma__SinaisVitaisClient<$Result.GetResult<Prisma.$SinaisVitaisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SinaisVitais.
     * @param {SinaisVitaisDeleteManyArgs} args - Arguments to filter SinaisVitais to delete.
     * @example
     * // Delete a few SinaisVitais
     * const { count } = await prisma.sinaisVitais.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SinaisVitaisDeleteManyArgs>(args?: SelectSubset<T, SinaisVitaisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SinaisVitais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SinaisVitaisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SinaisVitais
     * const sinaisVitais = await prisma.sinaisVitais.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SinaisVitaisUpdateManyArgs>(args: SelectSubset<T, SinaisVitaisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SinaisVitais and returns the data updated in the database.
     * @param {SinaisVitaisUpdateManyAndReturnArgs} args - Arguments to update many SinaisVitais.
     * @example
     * // Update many SinaisVitais
     * const sinaisVitais = await prisma.sinaisVitais.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SinaisVitais and only return the `id`
     * const sinaisVitaisWithIdOnly = await prisma.sinaisVitais.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SinaisVitaisUpdateManyAndReturnArgs>(args: SelectSubset<T, SinaisVitaisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SinaisVitaisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SinaisVitais.
     * @param {SinaisVitaisUpsertArgs} args - Arguments to update or create a SinaisVitais.
     * @example
     * // Update or create a SinaisVitais
     * const sinaisVitais = await prisma.sinaisVitais.upsert({
     *   create: {
     *     // ... data to create a SinaisVitais
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SinaisVitais we want to update
     *   }
     * })
     */
    upsert<T extends SinaisVitaisUpsertArgs>(args: SelectSubset<T, SinaisVitaisUpsertArgs<ExtArgs>>): Prisma__SinaisVitaisClient<$Result.GetResult<Prisma.$SinaisVitaisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SinaisVitais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SinaisVitaisCountArgs} args - Arguments to filter SinaisVitais to count.
     * @example
     * // Count the number of SinaisVitais
     * const count = await prisma.sinaisVitais.count({
     *   where: {
     *     // ... the filter for the SinaisVitais we want to count
     *   }
     * })
    **/
    count<T extends SinaisVitaisCountArgs>(
      args?: Subset<T, SinaisVitaisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SinaisVitaisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SinaisVitais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SinaisVitaisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SinaisVitaisAggregateArgs>(args: Subset<T, SinaisVitaisAggregateArgs>): Prisma.PrismaPromise<GetSinaisVitaisAggregateType<T>>

    /**
     * Group by SinaisVitais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SinaisVitaisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SinaisVitaisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SinaisVitaisGroupByArgs['orderBy'] }
        : { orderBy?: SinaisVitaisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SinaisVitaisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSinaisVitaisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SinaisVitais model
   */
  readonly fields: SinaisVitaisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SinaisVitais.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SinaisVitaisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    atendimento<T extends AtendimentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AtendimentoDefaultArgs<ExtArgs>>): Prisma__AtendimentoClient<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    escalaDor<T extends SinaisVitais$escalaDorArgs<ExtArgs> = {}>(args?: Subset<T, SinaisVitais$escalaDorArgs<ExtArgs>>): Prisma__EscalaDorClient<$Result.GetResult<Prisma.$EscalaDorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SinaisVitais model
   */
  interface SinaisVitaisFieldRefs {
    readonly id: FieldRef<"SinaisVitais", 'Int'>
    readonly cdAtendimento: FieldRef<"SinaisVitais", 'Int'>
    readonly data: FieldRef<"SinaisVitais", 'DateTime'>
    readonly paSistolica: FieldRef<"SinaisVitais", 'Int'>
    readonly paDiastolica: FieldRef<"SinaisVitais", 'Int'>
    readonly fc: FieldRef<"SinaisVitais", 'Int'>
    readonly fr: FieldRef<"SinaisVitais", 'Int'>
    readonly temperatura: FieldRef<"SinaisVitais", 'Decimal'>
    readonly spo2: FieldRef<"SinaisVitais", 'Int'>
    readonly peso: FieldRef<"SinaisVitais", 'Decimal'>
    readonly altura: FieldRef<"SinaisVitais", 'Decimal'>
    readonly imc: FieldRef<"SinaisVitais", 'Decimal'>
    readonly dor: FieldRef<"SinaisVitais", 'Int'>
    readonly escalaDorId: FieldRef<"SinaisVitais", 'Int'>
    readonly posicao: FieldRef<"SinaisVitais", 'PosicaoPaciente'>
    readonly origem: FieldRef<"SinaisVitais", 'OrigemAfericao'>
    readonly metadataRaw: FieldRef<"SinaisVitais", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * SinaisVitais findUnique
   */
  export type SinaisVitaisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SinaisVitais
     */
    select?: SinaisVitaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SinaisVitais
     */
    omit?: SinaisVitaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SinaisVitaisInclude<ExtArgs> | null
    /**
     * Filter, which SinaisVitais to fetch.
     */
    where: SinaisVitaisWhereUniqueInput
  }

  /**
   * SinaisVitais findUniqueOrThrow
   */
  export type SinaisVitaisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SinaisVitais
     */
    select?: SinaisVitaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SinaisVitais
     */
    omit?: SinaisVitaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SinaisVitaisInclude<ExtArgs> | null
    /**
     * Filter, which SinaisVitais to fetch.
     */
    where: SinaisVitaisWhereUniqueInput
  }

  /**
   * SinaisVitais findFirst
   */
  export type SinaisVitaisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SinaisVitais
     */
    select?: SinaisVitaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SinaisVitais
     */
    omit?: SinaisVitaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SinaisVitaisInclude<ExtArgs> | null
    /**
     * Filter, which SinaisVitais to fetch.
     */
    where?: SinaisVitaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SinaisVitais to fetch.
     */
    orderBy?: SinaisVitaisOrderByWithRelationInput | SinaisVitaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SinaisVitais.
     */
    cursor?: SinaisVitaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SinaisVitais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SinaisVitais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SinaisVitais.
     */
    distinct?: SinaisVitaisScalarFieldEnum | SinaisVitaisScalarFieldEnum[]
  }

  /**
   * SinaisVitais findFirstOrThrow
   */
  export type SinaisVitaisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SinaisVitais
     */
    select?: SinaisVitaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SinaisVitais
     */
    omit?: SinaisVitaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SinaisVitaisInclude<ExtArgs> | null
    /**
     * Filter, which SinaisVitais to fetch.
     */
    where?: SinaisVitaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SinaisVitais to fetch.
     */
    orderBy?: SinaisVitaisOrderByWithRelationInput | SinaisVitaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SinaisVitais.
     */
    cursor?: SinaisVitaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SinaisVitais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SinaisVitais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SinaisVitais.
     */
    distinct?: SinaisVitaisScalarFieldEnum | SinaisVitaisScalarFieldEnum[]
  }

  /**
   * SinaisVitais findMany
   */
  export type SinaisVitaisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SinaisVitais
     */
    select?: SinaisVitaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SinaisVitais
     */
    omit?: SinaisVitaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SinaisVitaisInclude<ExtArgs> | null
    /**
     * Filter, which SinaisVitais to fetch.
     */
    where?: SinaisVitaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SinaisVitais to fetch.
     */
    orderBy?: SinaisVitaisOrderByWithRelationInput | SinaisVitaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SinaisVitais.
     */
    cursor?: SinaisVitaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SinaisVitais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SinaisVitais.
     */
    skip?: number
    distinct?: SinaisVitaisScalarFieldEnum | SinaisVitaisScalarFieldEnum[]
  }

  /**
   * SinaisVitais create
   */
  export type SinaisVitaisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SinaisVitais
     */
    select?: SinaisVitaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SinaisVitais
     */
    omit?: SinaisVitaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SinaisVitaisInclude<ExtArgs> | null
    /**
     * The data needed to create a SinaisVitais.
     */
    data: XOR<SinaisVitaisCreateInput, SinaisVitaisUncheckedCreateInput>
  }

  /**
   * SinaisVitais createMany
   */
  export type SinaisVitaisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SinaisVitais.
     */
    data: SinaisVitaisCreateManyInput | SinaisVitaisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SinaisVitais createManyAndReturn
   */
  export type SinaisVitaisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SinaisVitais
     */
    select?: SinaisVitaisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SinaisVitais
     */
    omit?: SinaisVitaisOmit<ExtArgs> | null
    /**
     * The data used to create many SinaisVitais.
     */
    data: SinaisVitaisCreateManyInput | SinaisVitaisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SinaisVitaisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SinaisVitais update
   */
  export type SinaisVitaisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SinaisVitais
     */
    select?: SinaisVitaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SinaisVitais
     */
    omit?: SinaisVitaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SinaisVitaisInclude<ExtArgs> | null
    /**
     * The data needed to update a SinaisVitais.
     */
    data: XOR<SinaisVitaisUpdateInput, SinaisVitaisUncheckedUpdateInput>
    /**
     * Choose, which SinaisVitais to update.
     */
    where: SinaisVitaisWhereUniqueInput
  }

  /**
   * SinaisVitais updateMany
   */
  export type SinaisVitaisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SinaisVitais.
     */
    data: XOR<SinaisVitaisUpdateManyMutationInput, SinaisVitaisUncheckedUpdateManyInput>
    /**
     * Filter which SinaisVitais to update
     */
    where?: SinaisVitaisWhereInput
    /**
     * Limit how many SinaisVitais to update.
     */
    limit?: number
  }

  /**
   * SinaisVitais updateManyAndReturn
   */
  export type SinaisVitaisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SinaisVitais
     */
    select?: SinaisVitaisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SinaisVitais
     */
    omit?: SinaisVitaisOmit<ExtArgs> | null
    /**
     * The data used to update SinaisVitais.
     */
    data: XOR<SinaisVitaisUpdateManyMutationInput, SinaisVitaisUncheckedUpdateManyInput>
    /**
     * Filter which SinaisVitais to update
     */
    where?: SinaisVitaisWhereInput
    /**
     * Limit how many SinaisVitais to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SinaisVitaisIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SinaisVitais upsert
   */
  export type SinaisVitaisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SinaisVitais
     */
    select?: SinaisVitaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SinaisVitais
     */
    omit?: SinaisVitaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SinaisVitaisInclude<ExtArgs> | null
    /**
     * The filter to search for the SinaisVitais to update in case it exists.
     */
    where: SinaisVitaisWhereUniqueInput
    /**
     * In case the SinaisVitais found by the `where` argument doesn't exist, create a new SinaisVitais with this data.
     */
    create: XOR<SinaisVitaisCreateInput, SinaisVitaisUncheckedCreateInput>
    /**
     * In case the SinaisVitais was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SinaisVitaisUpdateInput, SinaisVitaisUncheckedUpdateInput>
  }

  /**
   * SinaisVitais delete
   */
  export type SinaisVitaisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SinaisVitais
     */
    select?: SinaisVitaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SinaisVitais
     */
    omit?: SinaisVitaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SinaisVitaisInclude<ExtArgs> | null
    /**
     * Filter which SinaisVitais to delete.
     */
    where: SinaisVitaisWhereUniqueInput
  }

  /**
   * SinaisVitais deleteMany
   */
  export type SinaisVitaisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SinaisVitais to delete
     */
    where?: SinaisVitaisWhereInput
    /**
     * Limit how many SinaisVitais to delete.
     */
    limit?: number
  }

  /**
   * SinaisVitais.escalaDor
   */
  export type SinaisVitais$escalaDorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscalaDor
     */
    select?: EscalaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EscalaDor
     */
    omit?: EscalaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaDorInclude<ExtArgs> | null
    where?: EscalaDorWhereInput
  }

  /**
   * SinaisVitais without action
   */
  export type SinaisVitaisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SinaisVitais
     */
    select?: SinaisVitaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SinaisVitais
     */
    omit?: SinaisVitaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SinaisVitaisInclude<ExtArgs> | null
  }


  /**
   * Model EscalaDor
   */

  export type AggregateEscalaDor = {
    _count: EscalaDorCountAggregateOutputType | null
    _avg: EscalaDorAvgAggregateOutputType | null
    _sum: EscalaDorSumAggregateOutputType | null
    _min: EscalaDorMinAggregateOutputType | null
    _max: EscalaDorMaxAggregateOutputType | null
  }

  export type EscalaDorAvgAggregateOutputType = {
    id: number | null
  }

  export type EscalaDorSumAggregateOutputType = {
    id: number | null
  }

  export type EscalaDorMinAggregateOutputType = {
    id: number | null
    nome: string | null
    descricao: string | null
  }

  export type EscalaDorMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    descricao: string | null
  }

  export type EscalaDorCountAggregateOutputType = {
    id: number
    nome: number
    descricao: number
    _all: number
  }


  export type EscalaDorAvgAggregateInputType = {
    id?: true
  }

  export type EscalaDorSumAggregateInputType = {
    id?: true
  }

  export type EscalaDorMinAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
  }

  export type EscalaDorMaxAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
  }

  export type EscalaDorCountAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    _all?: true
  }

  export type EscalaDorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscalaDor to aggregate.
     */
    where?: EscalaDorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscalaDors to fetch.
     */
    orderBy?: EscalaDorOrderByWithRelationInput | EscalaDorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscalaDorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscalaDors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscalaDors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EscalaDors
    **/
    _count?: true | EscalaDorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EscalaDorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EscalaDorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscalaDorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscalaDorMaxAggregateInputType
  }

  export type GetEscalaDorAggregateType<T extends EscalaDorAggregateArgs> = {
        [P in keyof T & keyof AggregateEscalaDor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscalaDor[P]>
      : GetScalarType<T[P], AggregateEscalaDor[P]>
  }




  export type EscalaDorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EscalaDorWhereInput
    orderBy?: EscalaDorOrderByWithAggregationInput | EscalaDorOrderByWithAggregationInput[]
    by: EscalaDorScalarFieldEnum[] | EscalaDorScalarFieldEnum
    having?: EscalaDorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscalaDorCountAggregateInputType | true
    _avg?: EscalaDorAvgAggregateInputType
    _sum?: EscalaDorSumAggregateInputType
    _min?: EscalaDorMinAggregateInputType
    _max?: EscalaDorMaxAggregateInputType
  }

  export type EscalaDorGroupByOutputType = {
    id: number
    nome: string
    descricao: string | null
    _count: EscalaDorCountAggregateOutputType | null
    _avg: EscalaDorAvgAggregateOutputType | null
    _sum: EscalaDorSumAggregateOutputType | null
    _min: EscalaDorMinAggregateOutputType | null
    _max: EscalaDorMaxAggregateOutputType | null
  }

  type GetEscalaDorGroupByPayload<T extends EscalaDorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscalaDorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscalaDorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscalaDorGroupByOutputType[P]>
            : GetScalarType<T[P], EscalaDorGroupByOutputType[P]>
        }
      >
    >


  export type EscalaDorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    sinaisVitais?: boolean | EscalaDor$sinaisVitaisArgs<ExtArgs>
    _count?: boolean | EscalaDorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escalaDor"]>

  export type EscalaDorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["escalaDor"]>

  export type EscalaDorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["escalaDor"]>

  export type EscalaDorSelectScalar = {
    id?: boolean
    nome?: boolean
    descricao?: boolean
  }

  export type EscalaDorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "descricao", ExtArgs["result"]["escalaDor"]>
  export type EscalaDorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sinaisVitais?: boolean | EscalaDor$sinaisVitaisArgs<ExtArgs>
    _count?: boolean | EscalaDorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EscalaDorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EscalaDorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EscalaDorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EscalaDor"
    objects: {
      sinaisVitais: Prisma.$SinaisVitaisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      descricao: string | null
    }, ExtArgs["result"]["escalaDor"]>
    composites: {}
  }

  type EscalaDorGetPayload<S extends boolean | null | undefined | EscalaDorDefaultArgs> = $Result.GetResult<Prisma.$EscalaDorPayload, S>

  type EscalaDorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EscalaDorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EscalaDorCountAggregateInputType | true
    }

  export interface EscalaDorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EscalaDor'], meta: { name: 'EscalaDor' } }
    /**
     * Find zero or one EscalaDor that matches the filter.
     * @param {EscalaDorFindUniqueArgs} args - Arguments to find a EscalaDor
     * @example
     * // Get one EscalaDor
     * const escalaDor = await prisma.escalaDor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EscalaDorFindUniqueArgs>(args: SelectSubset<T, EscalaDorFindUniqueArgs<ExtArgs>>): Prisma__EscalaDorClient<$Result.GetResult<Prisma.$EscalaDorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EscalaDor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EscalaDorFindUniqueOrThrowArgs} args - Arguments to find a EscalaDor
     * @example
     * // Get one EscalaDor
     * const escalaDor = await prisma.escalaDor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EscalaDorFindUniqueOrThrowArgs>(args: SelectSubset<T, EscalaDorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EscalaDorClient<$Result.GetResult<Prisma.$EscalaDorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EscalaDor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscalaDorFindFirstArgs} args - Arguments to find a EscalaDor
     * @example
     * // Get one EscalaDor
     * const escalaDor = await prisma.escalaDor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EscalaDorFindFirstArgs>(args?: SelectSubset<T, EscalaDorFindFirstArgs<ExtArgs>>): Prisma__EscalaDorClient<$Result.GetResult<Prisma.$EscalaDorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EscalaDor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscalaDorFindFirstOrThrowArgs} args - Arguments to find a EscalaDor
     * @example
     * // Get one EscalaDor
     * const escalaDor = await prisma.escalaDor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EscalaDorFindFirstOrThrowArgs>(args?: SelectSubset<T, EscalaDorFindFirstOrThrowArgs<ExtArgs>>): Prisma__EscalaDorClient<$Result.GetResult<Prisma.$EscalaDorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EscalaDors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscalaDorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EscalaDors
     * const escalaDors = await prisma.escalaDor.findMany()
     * 
     * // Get first 10 EscalaDors
     * const escalaDors = await prisma.escalaDor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escalaDorWithIdOnly = await prisma.escalaDor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EscalaDorFindManyArgs>(args?: SelectSubset<T, EscalaDorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscalaDorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EscalaDor.
     * @param {EscalaDorCreateArgs} args - Arguments to create a EscalaDor.
     * @example
     * // Create one EscalaDor
     * const EscalaDor = await prisma.escalaDor.create({
     *   data: {
     *     // ... data to create a EscalaDor
     *   }
     * })
     * 
     */
    create<T extends EscalaDorCreateArgs>(args: SelectSubset<T, EscalaDorCreateArgs<ExtArgs>>): Prisma__EscalaDorClient<$Result.GetResult<Prisma.$EscalaDorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EscalaDors.
     * @param {EscalaDorCreateManyArgs} args - Arguments to create many EscalaDors.
     * @example
     * // Create many EscalaDors
     * const escalaDor = await prisma.escalaDor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EscalaDorCreateManyArgs>(args?: SelectSubset<T, EscalaDorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EscalaDors and returns the data saved in the database.
     * @param {EscalaDorCreateManyAndReturnArgs} args - Arguments to create many EscalaDors.
     * @example
     * // Create many EscalaDors
     * const escalaDor = await prisma.escalaDor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EscalaDors and only return the `id`
     * const escalaDorWithIdOnly = await prisma.escalaDor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EscalaDorCreateManyAndReturnArgs>(args?: SelectSubset<T, EscalaDorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscalaDorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EscalaDor.
     * @param {EscalaDorDeleteArgs} args - Arguments to delete one EscalaDor.
     * @example
     * // Delete one EscalaDor
     * const EscalaDor = await prisma.escalaDor.delete({
     *   where: {
     *     // ... filter to delete one EscalaDor
     *   }
     * })
     * 
     */
    delete<T extends EscalaDorDeleteArgs>(args: SelectSubset<T, EscalaDorDeleteArgs<ExtArgs>>): Prisma__EscalaDorClient<$Result.GetResult<Prisma.$EscalaDorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EscalaDor.
     * @param {EscalaDorUpdateArgs} args - Arguments to update one EscalaDor.
     * @example
     * // Update one EscalaDor
     * const escalaDor = await prisma.escalaDor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EscalaDorUpdateArgs>(args: SelectSubset<T, EscalaDorUpdateArgs<ExtArgs>>): Prisma__EscalaDorClient<$Result.GetResult<Prisma.$EscalaDorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EscalaDors.
     * @param {EscalaDorDeleteManyArgs} args - Arguments to filter EscalaDors to delete.
     * @example
     * // Delete a few EscalaDors
     * const { count } = await prisma.escalaDor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EscalaDorDeleteManyArgs>(args?: SelectSubset<T, EscalaDorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EscalaDors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscalaDorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EscalaDors
     * const escalaDor = await prisma.escalaDor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EscalaDorUpdateManyArgs>(args: SelectSubset<T, EscalaDorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EscalaDors and returns the data updated in the database.
     * @param {EscalaDorUpdateManyAndReturnArgs} args - Arguments to update many EscalaDors.
     * @example
     * // Update many EscalaDors
     * const escalaDor = await prisma.escalaDor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EscalaDors and only return the `id`
     * const escalaDorWithIdOnly = await prisma.escalaDor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EscalaDorUpdateManyAndReturnArgs>(args: SelectSubset<T, EscalaDorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscalaDorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EscalaDor.
     * @param {EscalaDorUpsertArgs} args - Arguments to update or create a EscalaDor.
     * @example
     * // Update or create a EscalaDor
     * const escalaDor = await prisma.escalaDor.upsert({
     *   create: {
     *     // ... data to create a EscalaDor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EscalaDor we want to update
     *   }
     * })
     */
    upsert<T extends EscalaDorUpsertArgs>(args: SelectSubset<T, EscalaDorUpsertArgs<ExtArgs>>): Prisma__EscalaDorClient<$Result.GetResult<Prisma.$EscalaDorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EscalaDors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscalaDorCountArgs} args - Arguments to filter EscalaDors to count.
     * @example
     * // Count the number of EscalaDors
     * const count = await prisma.escalaDor.count({
     *   where: {
     *     // ... the filter for the EscalaDors we want to count
     *   }
     * })
    **/
    count<T extends EscalaDorCountArgs>(
      args?: Subset<T, EscalaDorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscalaDorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EscalaDor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscalaDorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscalaDorAggregateArgs>(args: Subset<T, EscalaDorAggregateArgs>): Prisma.PrismaPromise<GetEscalaDorAggregateType<T>>

    /**
     * Group by EscalaDor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscalaDorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscalaDorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscalaDorGroupByArgs['orderBy'] }
        : { orderBy?: EscalaDorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscalaDorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscalaDorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EscalaDor model
   */
  readonly fields: EscalaDorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EscalaDor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscalaDorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sinaisVitais<T extends EscalaDor$sinaisVitaisArgs<ExtArgs> = {}>(args?: Subset<T, EscalaDor$sinaisVitaisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SinaisVitaisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EscalaDor model
   */
  interface EscalaDorFieldRefs {
    readonly id: FieldRef<"EscalaDor", 'Int'>
    readonly nome: FieldRef<"EscalaDor", 'String'>
    readonly descricao: FieldRef<"EscalaDor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EscalaDor findUnique
   */
  export type EscalaDorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscalaDor
     */
    select?: EscalaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EscalaDor
     */
    omit?: EscalaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaDorInclude<ExtArgs> | null
    /**
     * Filter, which EscalaDor to fetch.
     */
    where: EscalaDorWhereUniqueInput
  }

  /**
   * EscalaDor findUniqueOrThrow
   */
  export type EscalaDorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscalaDor
     */
    select?: EscalaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EscalaDor
     */
    omit?: EscalaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaDorInclude<ExtArgs> | null
    /**
     * Filter, which EscalaDor to fetch.
     */
    where: EscalaDorWhereUniqueInput
  }

  /**
   * EscalaDor findFirst
   */
  export type EscalaDorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscalaDor
     */
    select?: EscalaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EscalaDor
     */
    omit?: EscalaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaDorInclude<ExtArgs> | null
    /**
     * Filter, which EscalaDor to fetch.
     */
    where?: EscalaDorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscalaDors to fetch.
     */
    orderBy?: EscalaDorOrderByWithRelationInput | EscalaDorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscalaDors.
     */
    cursor?: EscalaDorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscalaDors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscalaDors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscalaDors.
     */
    distinct?: EscalaDorScalarFieldEnum | EscalaDorScalarFieldEnum[]
  }

  /**
   * EscalaDor findFirstOrThrow
   */
  export type EscalaDorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscalaDor
     */
    select?: EscalaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EscalaDor
     */
    omit?: EscalaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaDorInclude<ExtArgs> | null
    /**
     * Filter, which EscalaDor to fetch.
     */
    where?: EscalaDorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscalaDors to fetch.
     */
    orderBy?: EscalaDorOrderByWithRelationInput | EscalaDorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EscalaDors.
     */
    cursor?: EscalaDorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscalaDors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscalaDors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EscalaDors.
     */
    distinct?: EscalaDorScalarFieldEnum | EscalaDorScalarFieldEnum[]
  }

  /**
   * EscalaDor findMany
   */
  export type EscalaDorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscalaDor
     */
    select?: EscalaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EscalaDor
     */
    omit?: EscalaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaDorInclude<ExtArgs> | null
    /**
     * Filter, which EscalaDors to fetch.
     */
    where?: EscalaDorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EscalaDors to fetch.
     */
    orderBy?: EscalaDorOrderByWithRelationInput | EscalaDorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EscalaDors.
     */
    cursor?: EscalaDorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EscalaDors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EscalaDors.
     */
    skip?: number
    distinct?: EscalaDorScalarFieldEnum | EscalaDorScalarFieldEnum[]
  }

  /**
   * EscalaDor create
   */
  export type EscalaDorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscalaDor
     */
    select?: EscalaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EscalaDor
     */
    omit?: EscalaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaDorInclude<ExtArgs> | null
    /**
     * The data needed to create a EscalaDor.
     */
    data: XOR<EscalaDorCreateInput, EscalaDorUncheckedCreateInput>
  }

  /**
   * EscalaDor createMany
   */
  export type EscalaDorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EscalaDors.
     */
    data: EscalaDorCreateManyInput | EscalaDorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EscalaDor createManyAndReturn
   */
  export type EscalaDorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscalaDor
     */
    select?: EscalaDorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EscalaDor
     */
    omit?: EscalaDorOmit<ExtArgs> | null
    /**
     * The data used to create many EscalaDors.
     */
    data: EscalaDorCreateManyInput | EscalaDorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EscalaDor update
   */
  export type EscalaDorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscalaDor
     */
    select?: EscalaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EscalaDor
     */
    omit?: EscalaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaDorInclude<ExtArgs> | null
    /**
     * The data needed to update a EscalaDor.
     */
    data: XOR<EscalaDorUpdateInput, EscalaDorUncheckedUpdateInput>
    /**
     * Choose, which EscalaDor to update.
     */
    where: EscalaDorWhereUniqueInput
  }

  /**
   * EscalaDor updateMany
   */
  export type EscalaDorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EscalaDors.
     */
    data: XOR<EscalaDorUpdateManyMutationInput, EscalaDorUncheckedUpdateManyInput>
    /**
     * Filter which EscalaDors to update
     */
    where?: EscalaDorWhereInput
    /**
     * Limit how many EscalaDors to update.
     */
    limit?: number
  }

  /**
   * EscalaDor updateManyAndReturn
   */
  export type EscalaDorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscalaDor
     */
    select?: EscalaDorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EscalaDor
     */
    omit?: EscalaDorOmit<ExtArgs> | null
    /**
     * The data used to update EscalaDors.
     */
    data: XOR<EscalaDorUpdateManyMutationInput, EscalaDorUncheckedUpdateManyInput>
    /**
     * Filter which EscalaDors to update
     */
    where?: EscalaDorWhereInput
    /**
     * Limit how many EscalaDors to update.
     */
    limit?: number
  }

  /**
   * EscalaDor upsert
   */
  export type EscalaDorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscalaDor
     */
    select?: EscalaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EscalaDor
     */
    omit?: EscalaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaDorInclude<ExtArgs> | null
    /**
     * The filter to search for the EscalaDor to update in case it exists.
     */
    where: EscalaDorWhereUniqueInput
    /**
     * In case the EscalaDor found by the `where` argument doesn't exist, create a new EscalaDor with this data.
     */
    create: XOR<EscalaDorCreateInput, EscalaDorUncheckedCreateInput>
    /**
     * In case the EscalaDor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscalaDorUpdateInput, EscalaDorUncheckedUpdateInput>
  }

  /**
   * EscalaDor delete
   */
  export type EscalaDorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscalaDor
     */
    select?: EscalaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EscalaDor
     */
    omit?: EscalaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaDorInclude<ExtArgs> | null
    /**
     * Filter which EscalaDor to delete.
     */
    where: EscalaDorWhereUniqueInput
  }

  /**
   * EscalaDor deleteMany
   */
  export type EscalaDorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EscalaDors to delete
     */
    where?: EscalaDorWhereInput
    /**
     * Limit how many EscalaDors to delete.
     */
    limit?: number
  }

  /**
   * EscalaDor.sinaisVitais
   */
  export type EscalaDor$sinaisVitaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SinaisVitais
     */
    select?: SinaisVitaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SinaisVitais
     */
    omit?: SinaisVitaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SinaisVitaisInclude<ExtArgs> | null
    where?: SinaisVitaisWhereInput
    orderBy?: SinaisVitaisOrderByWithRelationInput | SinaisVitaisOrderByWithRelationInput[]
    cursor?: SinaisVitaisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SinaisVitaisScalarFieldEnum | SinaisVitaisScalarFieldEnum[]
  }

  /**
   * EscalaDor without action
   */
  export type EscalaDorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscalaDor
     */
    select?: EscalaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EscalaDor
     */
    omit?: EscalaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EscalaDorInclude<ExtArgs> | null
  }


  /**
   * Model Glasgow
   */

  export type AggregateGlasgow = {
    _count: GlasgowCountAggregateOutputType | null
    _avg: GlasgowAvgAggregateOutputType | null
    _sum: GlasgowSumAggregateOutputType | null
    _min: GlasgowMinAggregateOutputType | null
    _max: GlasgowMaxAggregateOutputType | null
  }

  export type GlasgowAvgAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    ocular: number | null
    verbal: number | null
    motora: number | null
    total: number | null
  }

  export type GlasgowSumAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    ocular: number | null
    verbal: number | null
    motora: number | null
    total: number | null
  }

  export type GlasgowMinAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    data: Date | null
    ocular: number | null
    verbal: number | null
    motora: number | null
    total: number | null
    observacao: string | null
  }

  export type GlasgowMaxAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    data: Date | null
    ocular: number | null
    verbal: number | null
    motora: number | null
    total: number | null
    observacao: string | null
  }

  export type GlasgowCountAggregateOutputType = {
    id: number
    cdAtendimento: number
    cdProfissional: number
    data: number
    ocular: number
    verbal: number
    motora: number
    total: number
    observacao: number
    _all: number
  }


  export type GlasgowAvgAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    ocular?: true
    verbal?: true
    motora?: true
    total?: true
  }

  export type GlasgowSumAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    ocular?: true
    verbal?: true
    motora?: true
    total?: true
  }

  export type GlasgowMinAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    data?: true
    ocular?: true
    verbal?: true
    motora?: true
    total?: true
    observacao?: true
  }

  export type GlasgowMaxAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    data?: true
    ocular?: true
    verbal?: true
    motora?: true
    total?: true
    observacao?: true
  }

  export type GlasgowCountAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    data?: true
    ocular?: true
    verbal?: true
    motora?: true
    total?: true
    observacao?: true
    _all?: true
  }

  export type GlasgowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Glasgow to aggregate.
     */
    where?: GlasgowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Glasgows to fetch.
     */
    orderBy?: GlasgowOrderByWithRelationInput | GlasgowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GlasgowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Glasgows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Glasgows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Glasgows
    **/
    _count?: true | GlasgowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GlasgowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GlasgowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GlasgowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GlasgowMaxAggregateInputType
  }

  export type GetGlasgowAggregateType<T extends GlasgowAggregateArgs> = {
        [P in keyof T & keyof AggregateGlasgow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGlasgow[P]>
      : GetScalarType<T[P], AggregateGlasgow[P]>
  }




  export type GlasgowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlasgowWhereInput
    orderBy?: GlasgowOrderByWithAggregationInput | GlasgowOrderByWithAggregationInput[]
    by: GlasgowScalarFieldEnum[] | GlasgowScalarFieldEnum
    having?: GlasgowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GlasgowCountAggregateInputType | true
    _avg?: GlasgowAvgAggregateInputType
    _sum?: GlasgowSumAggregateInputType
    _min?: GlasgowMinAggregateInputType
    _max?: GlasgowMaxAggregateInputType
  }

  export type GlasgowGroupByOutputType = {
    id: number
    cdAtendimento: number
    cdProfissional: number | null
    data: Date
    ocular: number
    verbal: number
    motora: number
    total: number
    observacao: string | null
    _count: GlasgowCountAggregateOutputType | null
    _avg: GlasgowAvgAggregateOutputType | null
    _sum: GlasgowSumAggregateOutputType | null
    _min: GlasgowMinAggregateOutputType | null
    _max: GlasgowMaxAggregateOutputType | null
  }

  type GetGlasgowGroupByPayload<T extends GlasgowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GlasgowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GlasgowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GlasgowGroupByOutputType[P]>
            : GetScalarType<T[P], GlasgowGroupByOutputType[P]>
        }
      >
    >


  export type GlasgowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    data?: boolean
    ocular?: boolean
    verbal?: boolean
    motora?: boolean
    total?: boolean
    observacao?: boolean
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | Glasgow$profissionalArgs<ExtArgs>
  }, ExtArgs["result"]["glasgow"]>

  export type GlasgowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    data?: boolean
    ocular?: boolean
    verbal?: boolean
    motora?: boolean
    total?: boolean
    observacao?: boolean
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | Glasgow$profissionalArgs<ExtArgs>
  }, ExtArgs["result"]["glasgow"]>

  export type GlasgowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    data?: boolean
    ocular?: boolean
    verbal?: boolean
    motora?: boolean
    total?: boolean
    observacao?: boolean
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | Glasgow$profissionalArgs<ExtArgs>
  }, ExtArgs["result"]["glasgow"]>

  export type GlasgowSelectScalar = {
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    data?: boolean
    ocular?: boolean
    verbal?: boolean
    motora?: boolean
    total?: boolean
    observacao?: boolean
  }

  export type GlasgowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdAtendimento" | "cdProfissional" | "data" | "ocular" | "verbal" | "motora" | "total" | "observacao", ExtArgs["result"]["glasgow"]>
  export type GlasgowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | Glasgow$profissionalArgs<ExtArgs>
  }
  export type GlasgowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | Glasgow$profissionalArgs<ExtArgs>
  }
  export type GlasgowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | Glasgow$profissionalArgs<ExtArgs>
  }

  export type $GlasgowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Glasgow"
    objects: {
      atendimento: Prisma.$AtendimentoPayload<ExtArgs>
      profissional: Prisma.$ProfissionalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdAtendimento: number
      cdProfissional: number | null
      data: Date
      ocular: number
      verbal: number
      motora: number
      total: number
      observacao: string | null
    }, ExtArgs["result"]["glasgow"]>
    composites: {}
  }

  type GlasgowGetPayload<S extends boolean | null | undefined | GlasgowDefaultArgs> = $Result.GetResult<Prisma.$GlasgowPayload, S>

  type GlasgowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GlasgowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GlasgowCountAggregateInputType | true
    }

  export interface GlasgowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Glasgow'], meta: { name: 'Glasgow' } }
    /**
     * Find zero or one Glasgow that matches the filter.
     * @param {GlasgowFindUniqueArgs} args - Arguments to find a Glasgow
     * @example
     * // Get one Glasgow
     * const glasgow = await prisma.glasgow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GlasgowFindUniqueArgs>(args: SelectSubset<T, GlasgowFindUniqueArgs<ExtArgs>>): Prisma__GlasgowClient<$Result.GetResult<Prisma.$GlasgowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Glasgow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GlasgowFindUniqueOrThrowArgs} args - Arguments to find a Glasgow
     * @example
     * // Get one Glasgow
     * const glasgow = await prisma.glasgow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GlasgowFindUniqueOrThrowArgs>(args: SelectSubset<T, GlasgowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GlasgowClient<$Result.GetResult<Prisma.$GlasgowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Glasgow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlasgowFindFirstArgs} args - Arguments to find a Glasgow
     * @example
     * // Get one Glasgow
     * const glasgow = await prisma.glasgow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GlasgowFindFirstArgs>(args?: SelectSubset<T, GlasgowFindFirstArgs<ExtArgs>>): Prisma__GlasgowClient<$Result.GetResult<Prisma.$GlasgowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Glasgow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlasgowFindFirstOrThrowArgs} args - Arguments to find a Glasgow
     * @example
     * // Get one Glasgow
     * const glasgow = await prisma.glasgow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GlasgowFindFirstOrThrowArgs>(args?: SelectSubset<T, GlasgowFindFirstOrThrowArgs<ExtArgs>>): Prisma__GlasgowClient<$Result.GetResult<Prisma.$GlasgowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Glasgows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlasgowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Glasgows
     * const glasgows = await prisma.glasgow.findMany()
     * 
     * // Get first 10 Glasgows
     * const glasgows = await prisma.glasgow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const glasgowWithIdOnly = await prisma.glasgow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GlasgowFindManyArgs>(args?: SelectSubset<T, GlasgowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlasgowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Glasgow.
     * @param {GlasgowCreateArgs} args - Arguments to create a Glasgow.
     * @example
     * // Create one Glasgow
     * const Glasgow = await prisma.glasgow.create({
     *   data: {
     *     // ... data to create a Glasgow
     *   }
     * })
     * 
     */
    create<T extends GlasgowCreateArgs>(args: SelectSubset<T, GlasgowCreateArgs<ExtArgs>>): Prisma__GlasgowClient<$Result.GetResult<Prisma.$GlasgowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Glasgows.
     * @param {GlasgowCreateManyArgs} args - Arguments to create many Glasgows.
     * @example
     * // Create many Glasgows
     * const glasgow = await prisma.glasgow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GlasgowCreateManyArgs>(args?: SelectSubset<T, GlasgowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Glasgows and returns the data saved in the database.
     * @param {GlasgowCreateManyAndReturnArgs} args - Arguments to create many Glasgows.
     * @example
     * // Create many Glasgows
     * const glasgow = await prisma.glasgow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Glasgows and only return the `id`
     * const glasgowWithIdOnly = await prisma.glasgow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GlasgowCreateManyAndReturnArgs>(args?: SelectSubset<T, GlasgowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlasgowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Glasgow.
     * @param {GlasgowDeleteArgs} args - Arguments to delete one Glasgow.
     * @example
     * // Delete one Glasgow
     * const Glasgow = await prisma.glasgow.delete({
     *   where: {
     *     // ... filter to delete one Glasgow
     *   }
     * })
     * 
     */
    delete<T extends GlasgowDeleteArgs>(args: SelectSubset<T, GlasgowDeleteArgs<ExtArgs>>): Prisma__GlasgowClient<$Result.GetResult<Prisma.$GlasgowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Glasgow.
     * @param {GlasgowUpdateArgs} args - Arguments to update one Glasgow.
     * @example
     * // Update one Glasgow
     * const glasgow = await prisma.glasgow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GlasgowUpdateArgs>(args: SelectSubset<T, GlasgowUpdateArgs<ExtArgs>>): Prisma__GlasgowClient<$Result.GetResult<Prisma.$GlasgowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Glasgows.
     * @param {GlasgowDeleteManyArgs} args - Arguments to filter Glasgows to delete.
     * @example
     * // Delete a few Glasgows
     * const { count } = await prisma.glasgow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GlasgowDeleteManyArgs>(args?: SelectSubset<T, GlasgowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Glasgows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlasgowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Glasgows
     * const glasgow = await prisma.glasgow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GlasgowUpdateManyArgs>(args: SelectSubset<T, GlasgowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Glasgows and returns the data updated in the database.
     * @param {GlasgowUpdateManyAndReturnArgs} args - Arguments to update many Glasgows.
     * @example
     * // Update many Glasgows
     * const glasgow = await prisma.glasgow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Glasgows and only return the `id`
     * const glasgowWithIdOnly = await prisma.glasgow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GlasgowUpdateManyAndReturnArgs>(args: SelectSubset<T, GlasgowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlasgowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Glasgow.
     * @param {GlasgowUpsertArgs} args - Arguments to update or create a Glasgow.
     * @example
     * // Update or create a Glasgow
     * const glasgow = await prisma.glasgow.upsert({
     *   create: {
     *     // ... data to create a Glasgow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Glasgow we want to update
     *   }
     * })
     */
    upsert<T extends GlasgowUpsertArgs>(args: SelectSubset<T, GlasgowUpsertArgs<ExtArgs>>): Prisma__GlasgowClient<$Result.GetResult<Prisma.$GlasgowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Glasgows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlasgowCountArgs} args - Arguments to filter Glasgows to count.
     * @example
     * // Count the number of Glasgows
     * const count = await prisma.glasgow.count({
     *   where: {
     *     // ... the filter for the Glasgows we want to count
     *   }
     * })
    **/
    count<T extends GlasgowCountArgs>(
      args?: Subset<T, GlasgowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GlasgowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Glasgow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlasgowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GlasgowAggregateArgs>(args: Subset<T, GlasgowAggregateArgs>): Prisma.PrismaPromise<GetGlasgowAggregateType<T>>

    /**
     * Group by Glasgow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlasgowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GlasgowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GlasgowGroupByArgs['orderBy'] }
        : { orderBy?: GlasgowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GlasgowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGlasgowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Glasgow model
   */
  readonly fields: GlasgowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Glasgow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GlasgowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    atendimento<T extends AtendimentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AtendimentoDefaultArgs<ExtArgs>>): Prisma__AtendimentoClient<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profissional<T extends Glasgow$profissionalArgs<ExtArgs> = {}>(args?: Subset<T, Glasgow$profissionalArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Glasgow model
   */
  interface GlasgowFieldRefs {
    readonly id: FieldRef<"Glasgow", 'Int'>
    readonly cdAtendimento: FieldRef<"Glasgow", 'Int'>
    readonly cdProfissional: FieldRef<"Glasgow", 'Int'>
    readonly data: FieldRef<"Glasgow", 'DateTime'>
    readonly ocular: FieldRef<"Glasgow", 'Int'>
    readonly verbal: FieldRef<"Glasgow", 'Int'>
    readonly motora: FieldRef<"Glasgow", 'Int'>
    readonly total: FieldRef<"Glasgow", 'Int'>
    readonly observacao: FieldRef<"Glasgow", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Glasgow findUnique
   */
  export type GlasgowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Glasgow
     */
    select?: GlasgowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Glasgow
     */
    omit?: GlasgowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlasgowInclude<ExtArgs> | null
    /**
     * Filter, which Glasgow to fetch.
     */
    where: GlasgowWhereUniqueInput
  }

  /**
   * Glasgow findUniqueOrThrow
   */
  export type GlasgowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Glasgow
     */
    select?: GlasgowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Glasgow
     */
    omit?: GlasgowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlasgowInclude<ExtArgs> | null
    /**
     * Filter, which Glasgow to fetch.
     */
    where: GlasgowWhereUniqueInput
  }

  /**
   * Glasgow findFirst
   */
  export type GlasgowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Glasgow
     */
    select?: GlasgowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Glasgow
     */
    omit?: GlasgowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlasgowInclude<ExtArgs> | null
    /**
     * Filter, which Glasgow to fetch.
     */
    where?: GlasgowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Glasgows to fetch.
     */
    orderBy?: GlasgowOrderByWithRelationInput | GlasgowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Glasgows.
     */
    cursor?: GlasgowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Glasgows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Glasgows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Glasgows.
     */
    distinct?: GlasgowScalarFieldEnum | GlasgowScalarFieldEnum[]
  }

  /**
   * Glasgow findFirstOrThrow
   */
  export type GlasgowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Glasgow
     */
    select?: GlasgowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Glasgow
     */
    omit?: GlasgowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlasgowInclude<ExtArgs> | null
    /**
     * Filter, which Glasgow to fetch.
     */
    where?: GlasgowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Glasgows to fetch.
     */
    orderBy?: GlasgowOrderByWithRelationInput | GlasgowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Glasgows.
     */
    cursor?: GlasgowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Glasgows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Glasgows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Glasgows.
     */
    distinct?: GlasgowScalarFieldEnum | GlasgowScalarFieldEnum[]
  }

  /**
   * Glasgow findMany
   */
  export type GlasgowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Glasgow
     */
    select?: GlasgowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Glasgow
     */
    omit?: GlasgowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlasgowInclude<ExtArgs> | null
    /**
     * Filter, which Glasgows to fetch.
     */
    where?: GlasgowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Glasgows to fetch.
     */
    orderBy?: GlasgowOrderByWithRelationInput | GlasgowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Glasgows.
     */
    cursor?: GlasgowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Glasgows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Glasgows.
     */
    skip?: number
    distinct?: GlasgowScalarFieldEnum | GlasgowScalarFieldEnum[]
  }

  /**
   * Glasgow create
   */
  export type GlasgowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Glasgow
     */
    select?: GlasgowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Glasgow
     */
    omit?: GlasgowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlasgowInclude<ExtArgs> | null
    /**
     * The data needed to create a Glasgow.
     */
    data: XOR<GlasgowCreateInput, GlasgowUncheckedCreateInput>
  }

  /**
   * Glasgow createMany
   */
  export type GlasgowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Glasgows.
     */
    data: GlasgowCreateManyInput | GlasgowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Glasgow createManyAndReturn
   */
  export type GlasgowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Glasgow
     */
    select?: GlasgowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Glasgow
     */
    omit?: GlasgowOmit<ExtArgs> | null
    /**
     * The data used to create many Glasgows.
     */
    data: GlasgowCreateManyInput | GlasgowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlasgowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Glasgow update
   */
  export type GlasgowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Glasgow
     */
    select?: GlasgowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Glasgow
     */
    omit?: GlasgowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlasgowInclude<ExtArgs> | null
    /**
     * The data needed to update a Glasgow.
     */
    data: XOR<GlasgowUpdateInput, GlasgowUncheckedUpdateInput>
    /**
     * Choose, which Glasgow to update.
     */
    where: GlasgowWhereUniqueInput
  }

  /**
   * Glasgow updateMany
   */
  export type GlasgowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Glasgows.
     */
    data: XOR<GlasgowUpdateManyMutationInput, GlasgowUncheckedUpdateManyInput>
    /**
     * Filter which Glasgows to update
     */
    where?: GlasgowWhereInput
    /**
     * Limit how many Glasgows to update.
     */
    limit?: number
  }

  /**
   * Glasgow updateManyAndReturn
   */
  export type GlasgowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Glasgow
     */
    select?: GlasgowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Glasgow
     */
    omit?: GlasgowOmit<ExtArgs> | null
    /**
     * The data used to update Glasgows.
     */
    data: XOR<GlasgowUpdateManyMutationInput, GlasgowUncheckedUpdateManyInput>
    /**
     * Filter which Glasgows to update
     */
    where?: GlasgowWhereInput
    /**
     * Limit how many Glasgows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlasgowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Glasgow upsert
   */
  export type GlasgowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Glasgow
     */
    select?: GlasgowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Glasgow
     */
    omit?: GlasgowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlasgowInclude<ExtArgs> | null
    /**
     * The filter to search for the Glasgow to update in case it exists.
     */
    where: GlasgowWhereUniqueInput
    /**
     * In case the Glasgow found by the `where` argument doesn't exist, create a new Glasgow with this data.
     */
    create: XOR<GlasgowCreateInput, GlasgowUncheckedCreateInput>
    /**
     * In case the Glasgow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GlasgowUpdateInput, GlasgowUncheckedUpdateInput>
  }

  /**
   * Glasgow delete
   */
  export type GlasgowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Glasgow
     */
    select?: GlasgowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Glasgow
     */
    omit?: GlasgowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlasgowInclude<ExtArgs> | null
    /**
     * Filter which Glasgow to delete.
     */
    where: GlasgowWhereUniqueInput
  }

  /**
   * Glasgow deleteMany
   */
  export type GlasgowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Glasgows to delete
     */
    where?: GlasgowWhereInput
    /**
     * Limit how many Glasgows to delete.
     */
    limit?: number
  }

  /**
   * Glasgow.profissional
   */
  export type Glasgow$profissionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    where?: ProfissionalWhereInput
  }

  /**
   * Glasgow without action
   */
  export type GlasgowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Glasgow
     */
    select?: GlasgowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Glasgow
     */
    omit?: GlasgowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlasgowInclude<ExtArgs> | null
  }


  /**
   * Model AfericaoClinica
   */

  export type AggregateAfericaoClinica = {
    _count: AfericaoClinicaCountAggregateOutputType | null
    _avg: AfericaoClinicaAvgAggregateOutputType | null
    _sum: AfericaoClinicaSumAggregateOutputType | null
    _min: AfericaoClinicaMinAggregateOutputType | null
    _max: AfericaoClinicaMaxAggregateOutputType | null
  }

  export type AfericaoClinicaAvgAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    idRegistro: number | null
  }

  export type AfericaoClinicaSumAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    idRegistro: number | null
  }

  export type AfericaoClinicaMinAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    escala: string | null
    idRegistro: number | null
    data: Date | null
  }

  export type AfericaoClinicaMaxAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    escala: string | null
    idRegistro: number | null
    data: Date | null
  }

  export type AfericaoClinicaCountAggregateOutputType = {
    id: number
    cdAtendimento: number
    cdProfissional: number
    escala: number
    idRegistro: number
    data: number
    _all: number
  }


  export type AfericaoClinicaAvgAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    idRegistro?: true
  }

  export type AfericaoClinicaSumAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    idRegistro?: true
  }

  export type AfericaoClinicaMinAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    escala?: true
    idRegistro?: true
    data?: true
  }

  export type AfericaoClinicaMaxAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    escala?: true
    idRegistro?: true
    data?: true
  }

  export type AfericaoClinicaCountAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    escala?: true
    idRegistro?: true
    data?: true
    _all?: true
  }

  export type AfericaoClinicaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AfericaoClinica to aggregate.
     */
    where?: AfericaoClinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AfericaoClinicas to fetch.
     */
    orderBy?: AfericaoClinicaOrderByWithRelationInput | AfericaoClinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AfericaoClinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AfericaoClinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AfericaoClinicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AfericaoClinicas
    **/
    _count?: true | AfericaoClinicaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AfericaoClinicaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AfericaoClinicaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AfericaoClinicaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AfericaoClinicaMaxAggregateInputType
  }

  export type GetAfericaoClinicaAggregateType<T extends AfericaoClinicaAggregateArgs> = {
        [P in keyof T & keyof AggregateAfericaoClinica]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAfericaoClinica[P]>
      : GetScalarType<T[P], AggregateAfericaoClinica[P]>
  }




  export type AfericaoClinicaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AfericaoClinicaWhereInput
    orderBy?: AfericaoClinicaOrderByWithAggregationInput | AfericaoClinicaOrderByWithAggregationInput[]
    by: AfericaoClinicaScalarFieldEnum[] | AfericaoClinicaScalarFieldEnum
    having?: AfericaoClinicaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AfericaoClinicaCountAggregateInputType | true
    _avg?: AfericaoClinicaAvgAggregateInputType
    _sum?: AfericaoClinicaSumAggregateInputType
    _min?: AfericaoClinicaMinAggregateInputType
    _max?: AfericaoClinicaMaxAggregateInputType
  }

  export type AfericaoClinicaGroupByOutputType = {
    id: number
    cdAtendimento: number
    cdProfissional: number | null
    escala: string
    idRegistro: number
    data: Date
    _count: AfericaoClinicaCountAggregateOutputType | null
    _avg: AfericaoClinicaAvgAggregateOutputType | null
    _sum: AfericaoClinicaSumAggregateOutputType | null
    _min: AfericaoClinicaMinAggregateOutputType | null
    _max: AfericaoClinicaMaxAggregateOutputType | null
  }

  type GetAfericaoClinicaGroupByPayload<T extends AfericaoClinicaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AfericaoClinicaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AfericaoClinicaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AfericaoClinicaGroupByOutputType[P]>
            : GetScalarType<T[P], AfericaoClinicaGroupByOutputType[P]>
        }
      >
    >


  export type AfericaoClinicaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    escala?: boolean
    idRegistro?: boolean
    data?: boolean
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | AfericaoClinica$profissionalArgs<ExtArgs>
  }, ExtArgs["result"]["afericaoClinica"]>

  export type AfericaoClinicaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    escala?: boolean
    idRegistro?: boolean
    data?: boolean
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | AfericaoClinica$profissionalArgs<ExtArgs>
  }, ExtArgs["result"]["afericaoClinica"]>

  export type AfericaoClinicaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    escala?: boolean
    idRegistro?: boolean
    data?: boolean
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | AfericaoClinica$profissionalArgs<ExtArgs>
  }, ExtArgs["result"]["afericaoClinica"]>

  export type AfericaoClinicaSelectScalar = {
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    escala?: boolean
    idRegistro?: boolean
    data?: boolean
  }

  export type AfericaoClinicaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdAtendimento" | "cdProfissional" | "escala" | "idRegistro" | "data", ExtArgs["result"]["afericaoClinica"]>
  export type AfericaoClinicaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | AfericaoClinica$profissionalArgs<ExtArgs>
  }
  export type AfericaoClinicaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | AfericaoClinica$profissionalArgs<ExtArgs>
  }
  export type AfericaoClinicaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | AfericaoClinica$profissionalArgs<ExtArgs>
  }

  export type $AfericaoClinicaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AfericaoClinica"
    objects: {
      atendimento: Prisma.$AtendimentoPayload<ExtArgs>
      profissional: Prisma.$ProfissionalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdAtendimento: number
      cdProfissional: number | null
      escala: string
      idRegistro: number
      data: Date
    }, ExtArgs["result"]["afericaoClinica"]>
    composites: {}
  }

  type AfericaoClinicaGetPayload<S extends boolean | null | undefined | AfericaoClinicaDefaultArgs> = $Result.GetResult<Prisma.$AfericaoClinicaPayload, S>

  type AfericaoClinicaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AfericaoClinicaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AfericaoClinicaCountAggregateInputType | true
    }

  export interface AfericaoClinicaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AfericaoClinica'], meta: { name: 'AfericaoClinica' } }
    /**
     * Find zero or one AfericaoClinica that matches the filter.
     * @param {AfericaoClinicaFindUniqueArgs} args - Arguments to find a AfericaoClinica
     * @example
     * // Get one AfericaoClinica
     * const afericaoClinica = await prisma.afericaoClinica.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AfericaoClinicaFindUniqueArgs>(args: SelectSubset<T, AfericaoClinicaFindUniqueArgs<ExtArgs>>): Prisma__AfericaoClinicaClient<$Result.GetResult<Prisma.$AfericaoClinicaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AfericaoClinica that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AfericaoClinicaFindUniqueOrThrowArgs} args - Arguments to find a AfericaoClinica
     * @example
     * // Get one AfericaoClinica
     * const afericaoClinica = await prisma.afericaoClinica.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AfericaoClinicaFindUniqueOrThrowArgs>(args: SelectSubset<T, AfericaoClinicaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AfericaoClinicaClient<$Result.GetResult<Prisma.$AfericaoClinicaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AfericaoClinica that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AfericaoClinicaFindFirstArgs} args - Arguments to find a AfericaoClinica
     * @example
     * // Get one AfericaoClinica
     * const afericaoClinica = await prisma.afericaoClinica.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AfericaoClinicaFindFirstArgs>(args?: SelectSubset<T, AfericaoClinicaFindFirstArgs<ExtArgs>>): Prisma__AfericaoClinicaClient<$Result.GetResult<Prisma.$AfericaoClinicaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AfericaoClinica that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AfericaoClinicaFindFirstOrThrowArgs} args - Arguments to find a AfericaoClinica
     * @example
     * // Get one AfericaoClinica
     * const afericaoClinica = await prisma.afericaoClinica.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AfericaoClinicaFindFirstOrThrowArgs>(args?: SelectSubset<T, AfericaoClinicaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AfericaoClinicaClient<$Result.GetResult<Prisma.$AfericaoClinicaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AfericaoClinicas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AfericaoClinicaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AfericaoClinicas
     * const afericaoClinicas = await prisma.afericaoClinica.findMany()
     * 
     * // Get first 10 AfericaoClinicas
     * const afericaoClinicas = await prisma.afericaoClinica.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const afericaoClinicaWithIdOnly = await prisma.afericaoClinica.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AfericaoClinicaFindManyArgs>(args?: SelectSubset<T, AfericaoClinicaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AfericaoClinicaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AfericaoClinica.
     * @param {AfericaoClinicaCreateArgs} args - Arguments to create a AfericaoClinica.
     * @example
     * // Create one AfericaoClinica
     * const AfericaoClinica = await prisma.afericaoClinica.create({
     *   data: {
     *     // ... data to create a AfericaoClinica
     *   }
     * })
     * 
     */
    create<T extends AfericaoClinicaCreateArgs>(args: SelectSubset<T, AfericaoClinicaCreateArgs<ExtArgs>>): Prisma__AfericaoClinicaClient<$Result.GetResult<Prisma.$AfericaoClinicaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AfericaoClinicas.
     * @param {AfericaoClinicaCreateManyArgs} args - Arguments to create many AfericaoClinicas.
     * @example
     * // Create many AfericaoClinicas
     * const afericaoClinica = await prisma.afericaoClinica.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AfericaoClinicaCreateManyArgs>(args?: SelectSubset<T, AfericaoClinicaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AfericaoClinicas and returns the data saved in the database.
     * @param {AfericaoClinicaCreateManyAndReturnArgs} args - Arguments to create many AfericaoClinicas.
     * @example
     * // Create many AfericaoClinicas
     * const afericaoClinica = await prisma.afericaoClinica.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AfericaoClinicas and only return the `id`
     * const afericaoClinicaWithIdOnly = await prisma.afericaoClinica.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AfericaoClinicaCreateManyAndReturnArgs>(args?: SelectSubset<T, AfericaoClinicaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AfericaoClinicaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AfericaoClinica.
     * @param {AfericaoClinicaDeleteArgs} args - Arguments to delete one AfericaoClinica.
     * @example
     * // Delete one AfericaoClinica
     * const AfericaoClinica = await prisma.afericaoClinica.delete({
     *   where: {
     *     // ... filter to delete one AfericaoClinica
     *   }
     * })
     * 
     */
    delete<T extends AfericaoClinicaDeleteArgs>(args: SelectSubset<T, AfericaoClinicaDeleteArgs<ExtArgs>>): Prisma__AfericaoClinicaClient<$Result.GetResult<Prisma.$AfericaoClinicaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AfericaoClinica.
     * @param {AfericaoClinicaUpdateArgs} args - Arguments to update one AfericaoClinica.
     * @example
     * // Update one AfericaoClinica
     * const afericaoClinica = await prisma.afericaoClinica.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AfericaoClinicaUpdateArgs>(args: SelectSubset<T, AfericaoClinicaUpdateArgs<ExtArgs>>): Prisma__AfericaoClinicaClient<$Result.GetResult<Prisma.$AfericaoClinicaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AfericaoClinicas.
     * @param {AfericaoClinicaDeleteManyArgs} args - Arguments to filter AfericaoClinicas to delete.
     * @example
     * // Delete a few AfericaoClinicas
     * const { count } = await prisma.afericaoClinica.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AfericaoClinicaDeleteManyArgs>(args?: SelectSubset<T, AfericaoClinicaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AfericaoClinicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AfericaoClinicaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AfericaoClinicas
     * const afericaoClinica = await prisma.afericaoClinica.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AfericaoClinicaUpdateManyArgs>(args: SelectSubset<T, AfericaoClinicaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AfericaoClinicas and returns the data updated in the database.
     * @param {AfericaoClinicaUpdateManyAndReturnArgs} args - Arguments to update many AfericaoClinicas.
     * @example
     * // Update many AfericaoClinicas
     * const afericaoClinica = await prisma.afericaoClinica.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AfericaoClinicas and only return the `id`
     * const afericaoClinicaWithIdOnly = await prisma.afericaoClinica.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AfericaoClinicaUpdateManyAndReturnArgs>(args: SelectSubset<T, AfericaoClinicaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AfericaoClinicaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AfericaoClinica.
     * @param {AfericaoClinicaUpsertArgs} args - Arguments to update or create a AfericaoClinica.
     * @example
     * // Update or create a AfericaoClinica
     * const afericaoClinica = await prisma.afericaoClinica.upsert({
     *   create: {
     *     // ... data to create a AfericaoClinica
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AfericaoClinica we want to update
     *   }
     * })
     */
    upsert<T extends AfericaoClinicaUpsertArgs>(args: SelectSubset<T, AfericaoClinicaUpsertArgs<ExtArgs>>): Prisma__AfericaoClinicaClient<$Result.GetResult<Prisma.$AfericaoClinicaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AfericaoClinicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AfericaoClinicaCountArgs} args - Arguments to filter AfericaoClinicas to count.
     * @example
     * // Count the number of AfericaoClinicas
     * const count = await prisma.afericaoClinica.count({
     *   where: {
     *     // ... the filter for the AfericaoClinicas we want to count
     *   }
     * })
    **/
    count<T extends AfericaoClinicaCountArgs>(
      args?: Subset<T, AfericaoClinicaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AfericaoClinicaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AfericaoClinica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AfericaoClinicaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AfericaoClinicaAggregateArgs>(args: Subset<T, AfericaoClinicaAggregateArgs>): Prisma.PrismaPromise<GetAfericaoClinicaAggregateType<T>>

    /**
     * Group by AfericaoClinica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AfericaoClinicaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AfericaoClinicaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AfericaoClinicaGroupByArgs['orderBy'] }
        : { orderBy?: AfericaoClinicaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AfericaoClinicaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAfericaoClinicaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AfericaoClinica model
   */
  readonly fields: AfericaoClinicaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AfericaoClinica.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AfericaoClinicaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    atendimento<T extends AtendimentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AtendimentoDefaultArgs<ExtArgs>>): Prisma__AtendimentoClient<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profissional<T extends AfericaoClinica$profissionalArgs<ExtArgs> = {}>(args?: Subset<T, AfericaoClinica$profissionalArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AfericaoClinica model
   */
  interface AfericaoClinicaFieldRefs {
    readonly id: FieldRef<"AfericaoClinica", 'Int'>
    readonly cdAtendimento: FieldRef<"AfericaoClinica", 'Int'>
    readonly cdProfissional: FieldRef<"AfericaoClinica", 'Int'>
    readonly escala: FieldRef<"AfericaoClinica", 'String'>
    readonly idRegistro: FieldRef<"AfericaoClinica", 'Int'>
    readonly data: FieldRef<"AfericaoClinica", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AfericaoClinica findUnique
   */
  export type AfericaoClinicaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfericaoClinica
     */
    select?: AfericaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfericaoClinica
     */
    omit?: AfericaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfericaoClinicaInclude<ExtArgs> | null
    /**
     * Filter, which AfericaoClinica to fetch.
     */
    where: AfericaoClinicaWhereUniqueInput
  }

  /**
   * AfericaoClinica findUniqueOrThrow
   */
  export type AfericaoClinicaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfericaoClinica
     */
    select?: AfericaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfericaoClinica
     */
    omit?: AfericaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfericaoClinicaInclude<ExtArgs> | null
    /**
     * Filter, which AfericaoClinica to fetch.
     */
    where: AfericaoClinicaWhereUniqueInput
  }

  /**
   * AfericaoClinica findFirst
   */
  export type AfericaoClinicaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfericaoClinica
     */
    select?: AfericaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfericaoClinica
     */
    omit?: AfericaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfericaoClinicaInclude<ExtArgs> | null
    /**
     * Filter, which AfericaoClinica to fetch.
     */
    where?: AfericaoClinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AfericaoClinicas to fetch.
     */
    orderBy?: AfericaoClinicaOrderByWithRelationInput | AfericaoClinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AfericaoClinicas.
     */
    cursor?: AfericaoClinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AfericaoClinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AfericaoClinicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AfericaoClinicas.
     */
    distinct?: AfericaoClinicaScalarFieldEnum | AfericaoClinicaScalarFieldEnum[]
  }

  /**
   * AfericaoClinica findFirstOrThrow
   */
  export type AfericaoClinicaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfericaoClinica
     */
    select?: AfericaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfericaoClinica
     */
    omit?: AfericaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfericaoClinicaInclude<ExtArgs> | null
    /**
     * Filter, which AfericaoClinica to fetch.
     */
    where?: AfericaoClinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AfericaoClinicas to fetch.
     */
    orderBy?: AfericaoClinicaOrderByWithRelationInput | AfericaoClinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AfericaoClinicas.
     */
    cursor?: AfericaoClinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AfericaoClinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AfericaoClinicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AfericaoClinicas.
     */
    distinct?: AfericaoClinicaScalarFieldEnum | AfericaoClinicaScalarFieldEnum[]
  }

  /**
   * AfericaoClinica findMany
   */
  export type AfericaoClinicaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfericaoClinica
     */
    select?: AfericaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfericaoClinica
     */
    omit?: AfericaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfericaoClinicaInclude<ExtArgs> | null
    /**
     * Filter, which AfericaoClinicas to fetch.
     */
    where?: AfericaoClinicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AfericaoClinicas to fetch.
     */
    orderBy?: AfericaoClinicaOrderByWithRelationInput | AfericaoClinicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AfericaoClinicas.
     */
    cursor?: AfericaoClinicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AfericaoClinicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AfericaoClinicas.
     */
    skip?: number
    distinct?: AfericaoClinicaScalarFieldEnum | AfericaoClinicaScalarFieldEnum[]
  }

  /**
   * AfericaoClinica create
   */
  export type AfericaoClinicaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfericaoClinica
     */
    select?: AfericaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfericaoClinica
     */
    omit?: AfericaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfericaoClinicaInclude<ExtArgs> | null
    /**
     * The data needed to create a AfericaoClinica.
     */
    data: XOR<AfericaoClinicaCreateInput, AfericaoClinicaUncheckedCreateInput>
  }

  /**
   * AfericaoClinica createMany
   */
  export type AfericaoClinicaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AfericaoClinicas.
     */
    data: AfericaoClinicaCreateManyInput | AfericaoClinicaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AfericaoClinica createManyAndReturn
   */
  export type AfericaoClinicaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfericaoClinica
     */
    select?: AfericaoClinicaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AfericaoClinica
     */
    omit?: AfericaoClinicaOmit<ExtArgs> | null
    /**
     * The data used to create many AfericaoClinicas.
     */
    data: AfericaoClinicaCreateManyInput | AfericaoClinicaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfericaoClinicaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AfericaoClinica update
   */
  export type AfericaoClinicaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfericaoClinica
     */
    select?: AfericaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfericaoClinica
     */
    omit?: AfericaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfericaoClinicaInclude<ExtArgs> | null
    /**
     * The data needed to update a AfericaoClinica.
     */
    data: XOR<AfericaoClinicaUpdateInput, AfericaoClinicaUncheckedUpdateInput>
    /**
     * Choose, which AfericaoClinica to update.
     */
    where: AfericaoClinicaWhereUniqueInput
  }

  /**
   * AfericaoClinica updateMany
   */
  export type AfericaoClinicaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AfericaoClinicas.
     */
    data: XOR<AfericaoClinicaUpdateManyMutationInput, AfericaoClinicaUncheckedUpdateManyInput>
    /**
     * Filter which AfericaoClinicas to update
     */
    where?: AfericaoClinicaWhereInput
    /**
     * Limit how many AfericaoClinicas to update.
     */
    limit?: number
  }

  /**
   * AfericaoClinica updateManyAndReturn
   */
  export type AfericaoClinicaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfericaoClinica
     */
    select?: AfericaoClinicaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AfericaoClinica
     */
    omit?: AfericaoClinicaOmit<ExtArgs> | null
    /**
     * The data used to update AfericaoClinicas.
     */
    data: XOR<AfericaoClinicaUpdateManyMutationInput, AfericaoClinicaUncheckedUpdateManyInput>
    /**
     * Filter which AfericaoClinicas to update
     */
    where?: AfericaoClinicaWhereInput
    /**
     * Limit how many AfericaoClinicas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfericaoClinicaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AfericaoClinica upsert
   */
  export type AfericaoClinicaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfericaoClinica
     */
    select?: AfericaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfericaoClinica
     */
    omit?: AfericaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfericaoClinicaInclude<ExtArgs> | null
    /**
     * The filter to search for the AfericaoClinica to update in case it exists.
     */
    where: AfericaoClinicaWhereUniqueInput
    /**
     * In case the AfericaoClinica found by the `where` argument doesn't exist, create a new AfericaoClinica with this data.
     */
    create: XOR<AfericaoClinicaCreateInput, AfericaoClinicaUncheckedCreateInput>
    /**
     * In case the AfericaoClinica was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AfericaoClinicaUpdateInput, AfericaoClinicaUncheckedUpdateInput>
  }

  /**
   * AfericaoClinica delete
   */
  export type AfericaoClinicaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfericaoClinica
     */
    select?: AfericaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfericaoClinica
     */
    omit?: AfericaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfericaoClinicaInclude<ExtArgs> | null
    /**
     * Filter which AfericaoClinica to delete.
     */
    where: AfericaoClinicaWhereUniqueInput
  }

  /**
   * AfericaoClinica deleteMany
   */
  export type AfericaoClinicaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AfericaoClinicas to delete
     */
    where?: AfericaoClinicaWhereInput
    /**
     * Limit how many AfericaoClinicas to delete.
     */
    limit?: number
  }

  /**
   * AfericaoClinica.profissional
   */
  export type AfericaoClinica$profissionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    where?: ProfissionalWhereInput
  }

  /**
   * AfericaoClinica without action
   */
  export type AfericaoClinicaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfericaoClinica
     */
    select?: AfericaoClinicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfericaoClinica
     */
    omit?: AfericaoClinicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfericaoClinicaInclude<ExtArgs> | null
  }


  /**
   * Model EvaDor
   */

  export type AggregateEvaDor = {
    _count: EvaDorCountAggregateOutputType | null
    _avg: EvaDorAvgAggregateOutputType | null
    _sum: EvaDorSumAggregateOutputType | null
    _min: EvaDorMinAggregateOutputType | null
    _max: EvaDorMaxAggregateOutputType | null
  }

  export type EvaDorAvgAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    valor: number | null
  }

  export type EvaDorSumAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    valor: number | null
  }

  export type EvaDorMinAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    data: Date | null
    valor: number | null
    observacao: string | null
  }

  export type EvaDorMaxAggregateOutputType = {
    id: number | null
    cdAtendimento: number | null
    cdProfissional: number | null
    data: Date | null
    valor: number | null
    observacao: string | null
  }

  export type EvaDorCountAggregateOutputType = {
    id: number
    cdAtendimento: number
    cdProfissional: number
    data: number
    valor: number
    observacao: number
    _all: number
  }


  export type EvaDorAvgAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    valor?: true
  }

  export type EvaDorSumAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    valor?: true
  }

  export type EvaDorMinAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    data?: true
    valor?: true
    observacao?: true
  }

  export type EvaDorMaxAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    data?: true
    valor?: true
    observacao?: true
  }

  export type EvaDorCountAggregateInputType = {
    id?: true
    cdAtendimento?: true
    cdProfissional?: true
    data?: true
    valor?: true
    observacao?: true
    _all?: true
  }

  export type EvaDorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaDor to aggregate.
     */
    where?: EvaDorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaDors to fetch.
     */
    orderBy?: EvaDorOrderByWithRelationInput | EvaDorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaDorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaDors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaDors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvaDors
    **/
    _count?: true | EvaDorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaDorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaDorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaDorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaDorMaxAggregateInputType
  }

  export type GetEvaDorAggregateType<T extends EvaDorAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaDor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaDor[P]>
      : GetScalarType<T[P], AggregateEvaDor[P]>
  }




  export type EvaDorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaDorWhereInput
    orderBy?: EvaDorOrderByWithAggregationInput | EvaDorOrderByWithAggregationInput[]
    by: EvaDorScalarFieldEnum[] | EvaDorScalarFieldEnum
    having?: EvaDorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaDorCountAggregateInputType | true
    _avg?: EvaDorAvgAggregateInputType
    _sum?: EvaDorSumAggregateInputType
    _min?: EvaDorMinAggregateInputType
    _max?: EvaDorMaxAggregateInputType
  }

  export type EvaDorGroupByOutputType = {
    id: number
    cdAtendimento: number
    cdProfissional: number | null
    data: Date
    valor: number
    observacao: string | null
    _count: EvaDorCountAggregateOutputType | null
    _avg: EvaDorAvgAggregateOutputType | null
    _sum: EvaDorSumAggregateOutputType | null
    _min: EvaDorMinAggregateOutputType | null
    _max: EvaDorMaxAggregateOutputType | null
  }

  type GetEvaDorGroupByPayload<T extends EvaDorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaDorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaDorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaDorGroupByOutputType[P]>
            : GetScalarType<T[P], EvaDorGroupByOutputType[P]>
        }
      >
    >


  export type EvaDorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    data?: boolean
    valor?: boolean
    observacao?: boolean
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | EvaDor$profissionalArgs<ExtArgs>
  }, ExtArgs["result"]["evaDor"]>

  export type EvaDorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    data?: boolean
    valor?: boolean
    observacao?: boolean
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | EvaDor$profissionalArgs<ExtArgs>
  }, ExtArgs["result"]["evaDor"]>

  export type EvaDorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    data?: boolean
    valor?: boolean
    observacao?: boolean
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | EvaDor$profissionalArgs<ExtArgs>
  }, ExtArgs["result"]["evaDor"]>

  export type EvaDorSelectScalar = {
    id?: boolean
    cdAtendimento?: boolean
    cdProfissional?: boolean
    data?: boolean
    valor?: boolean
    observacao?: boolean
  }

  export type EvaDorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdAtendimento" | "cdProfissional" | "data" | "valor" | "observacao", ExtArgs["result"]["evaDor"]>
  export type EvaDorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | EvaDor$profissionalArgs<ExtArgs>
  }
  export type EvaDorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | EvaDor$profissionalArgs<ExtArgs>
  }
  export type EvaDorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    atendimento?: boolean | AtendimentoDefaultArgs<ExtArgs>
    profissional?: boolean | EvaDor$profissionalArgs<ExtArgs>
  }

  export type $EvaDorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvaDor"
    objects: {
      atendimento: Prisma.$AtendimentoPayload<ExtArgs>
      profissional: Prisma.$ProfissionalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdAtendimento: number
      cdProfissional: number | null
      data: Date
      valor: number
      observacao: string | null
    }, ExtArgs["result"]["evaDor"]>
    composites: {}
  }

  type EvaDorGetPayload<S extends boolean | null | undefined | EvaDorDefaultArgs> = $Result.GetResult<Prisma.$EvaDorPayload, S>

  type EvaDorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvaDorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvaDorCountAggregateInputType | true
    }

  export interface EvaDorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvaDor'], meta: { name: 'EvaDor' } }
    /**
     * Find zero or one EvaDor that matches the filter.
     * @param {EvaDorFindUniqueArgs} args - Arguments to find a EvaDor
     * @example
     * // Get one EvaDor
     * const evaDor = await prisma.evaDor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaDorFindUniqueArgs>(args: SelectSubset<T, EvaDorFindUniqueArgs<ExtArgs>>): Prisma__EvaDorClient<$Result.GetResult<Prisma.$EvaDorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EvaDor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvaDorFindUniqueOrThrowArgs} args - Arguments to find a EvaDor
     * @example
     * // Get one EvaDor
     * const evaDor = await prisma.evaDor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaDorFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaDorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaDorClient<$Result.GetResult<Prisma.$EvaDorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvaDor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaDorFindFirstArgs} args - Arguments to find a EvaDor
     * @example
     * // Get one EvaDor
     * const evaDor = await prisma.evaDor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaDorFindFirstArgs>(args?: SelectSubset<T, EvaDorFindFirstArgs<ExtArgs>>): Prisma__EvaDorClient<$Result.GetResult<Prisma.$EvaDorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvaDor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaDorFindFirstOrThrowArgs} args - Arguments to find a EvaDor
     * @example
     * // Get one EvaDor
     * const evaDor = await prisma.evaDor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaDorFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaDorFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaDorClient<$Result.GetResult<Prisma.$EvaDorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EvaDors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaDorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvaDors
     * const evaDors = await prisma.evaDor.findMany()
     * 
     * // Get first 10 EvaDors
     * const evaDors = await prisma.evaDor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaDorWithIdOnly = await prisma.evaDor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaDorFindManyArgs>(args?: SelectSubset<T, EvaDorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaDorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EvaDor.
     * @param {EvaDorCreateArgs} args - Arguments to create a EvaDor.
     * @example
     * // Create one EvaDor
     * const EvaDor = await prisma.evaDor.create({
     *   data: {
     *     // ... data to create a EvaDor
     *   }
     * })
     * 
     */
    create<T extends EvaDorCreateArgs>(args: SelectSubset<T, EvaDorCreateArgs<ExtArgs>>): Prisma__EvaDorClient<$Result.GetResult<Prisma.$EvaDorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EvaDors.
     * @param {EvaDorCreateManyArgs} args - Arguments to create many EvaDors.
     * @example
     * // Create many EvaDors
     * const evaDor = await prisma.evaDor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaDorCreateManyArgs>(args?: SelectSubset<T, EvaDorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvaDors and returns the data saved in the database.
     * @param {EvaDorCreateManyAndReturnArgs} args - Arguments to create many EvaDors.
     * @example
     * // Create many EvaDors
     * const evaDor = await prisma.evaDor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvaDors and only return the `id`
     * const evaDorWithIdOnly = await prisma.evaDor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaDorCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaDorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaDorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EvaDor.
     * @param {EvaDorDeleteArgs} args - Arguments to delete one EvaDor.
     * @example
     * // Delete one EvaDor
     * const EvaDor = await prisma.evaDor.delete({
     *   where: {
     *     // ... filter to delete one EvaDor
     *   }
     * })
     * 
     */
    delete<T extends EvaDorDeleteArgs>(args: SelectSubset<T, EvaDorDeleteArgs<ExtArgs>>): Prisma__EvaDorClient<$Result.GetResult<Prisma.$EvaDorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EvaDor.
     * @param {EvaDorUpdateArgs} args - Arguments to update one EvaDor.
     * @example
     * // Update one EvaDor
     * const evaDor = await prisma.evaDor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaDorUpdateArgs>(args: SelectSubset<T, EvaDorUpdateArgs<ExtArgs>>): Prisma__EvaDorClient<$Result.GetResult<Prisma.$EvaDorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EvaDors.
     * @param {EvaDorDeleteManyArgs} args - Arguments to filter EvaDors to delete.
     * @example
     * // Delete a few EvaDors
     * const { count } = await prisma.evaDor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaDorDeleteManyArgs>(args?: SelectSubset<T, EvaDorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaDors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaDorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvaDors
     * const evaDor = await prisma.evaDor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaDorUpdateManyArgs>(args: SelectSubset<T, EvaDorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaDors and returns the data updated in the database.
     * @param {EvaDorUpdateManyAndReturnArgs} args - Arguments to update many EvaDors.
     * @example
     * // Update many EvaDors
     * const evaDor = await prisma.evaDor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EvaDors and only return the `id`
     * const evaDorWithIdOnly = await prisma.evaDor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvaDorUpdateManyAndReturnArgs>(args: SelectSubset<T, EvaDorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaDorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EvaDor.
     * @param {EvaDorUpsertArgs} args - Arguments to update or create a EvaDor.
     * @example
     * // Update or create a EvaDor
     * const evaDor = await prisma.evaDor.upsert({
     *   create: {
     *     // ... data to create a EvaDor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvaDor we want to update
     *   }
     * })
     */
    upsert<T extends EvaDorUpsertArgs>(args: SelectSubset<T, EvaDorUpsertArgs<ExtArgs>>): Prisma__EvaDorClient<$Result.GetResult<Prisma.$EvaDorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EvaDors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaDorCountArgs} args - Arguments to filter EvaDors to count.
     * @example
     * // Count the number of EvaDors
     * const count = await prisma.evaDor.count({
     *   where: {
     *     // ... the filter for the EvaDors we want to count
     *   }
     * })
    **/
    count<T extends EvaDorCountArgs>(
      args?: Subset<T, EvaDorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaDorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvaDor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaDorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaDorAggregateArgs>(args: Subset<T, EvaDorAggregateArgs>): Prisma.PrismaPromise<GetEvaDorAggregateType<T>>

    /**
     * Group by EvaDor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaDorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaDorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaDorGroupByArgs['orderBy'] }
        : { orderBy?: EvaDorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaDorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaDorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvaDor model
   */
  readonly fields: EvaDorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvaDor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaDorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    atendimento<T extends AtendimentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AtendimentoDefaultArgs<ExtArgs>>): Prisma__AtendimentoClient<$Result.GetResult<Prisma.$AtendimentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profissional<T extends EvaDor$profissionalArgs<ExtArgs> = {}>(args?: Subset<T, EvaDor$profissionalArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvaDor model
   */
  interface EvaDorFieldRefs {
    readonly id: FieldRef<"EvaDor", 'Int'>
    readonly cdAtendimento: FieldRef<"EvaDor", 'Int'>
    readonly cdProfissional: FieldRef<"EvaDor", 'Int'>
    readonly data: FieldRef<"EvaDor", 'DateTime'>
    readonly valor: FieldRef<"EvaDor", 'Int'>
    readonly observacao: FieldRef<"EvaDor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EvaDor findUnique
   */
  export type EvaDorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaDor
     */
    select?: EvaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaDor
     */
    omit?: EvaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaDorInclude<ExtArgs> | null
    /**
     * Filter, which EvaDor to fetch.
     */
    where: EvaDorWhereUniqueInput
  }

  /**
   * EvaDor findUniqueOrThrow
   */
  export type EvaDorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaDor
     */
    select?: EvaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaDor
     */
    omit?: EvaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaDorInclude<ExtArgs> | null
    /**
     * Filter, which EvaDor to fetch.
     */
    where: EvaDorWhereUniqueInput
  }

  /**
   * EvaDor findFirst
   */
  export type EvaDorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaDor
     */
    select?: EvaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaDor
     */
    omit?: EvaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaDorInclude<ExtArgs> | null
    /**
     * Filter, which EvaDor to fetch.
     */
    where?: EvaDorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaDors to fetch.
     */
    orderBy?: EvaDorOrderByWithRelationInput | EvaDorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaDors.
     */
    cursor?: EvaDorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaDors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaDors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaDors.
     */
    distinct?: EvaDorScalarFieldEnum | EvaDorScalarFieldEnum[]
  }

  /**
   * EvaDor findFirstOrThrow
   */
  export type EvaDorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaDor
     */
    select?: EvaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaDor
     */
    omit?: EvaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaDorInclude<ExtArgs> | null
    /**
     * Filter, which EvaDor to fetch.
     */
    where?: EvaDorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaDors to fetch.
     */
    orderBy?: EvaDorOrderByWithRelationInput | EvaDorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaDors.
     */
    cursor?: EvaDorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaDors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaDors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaDors.
     */
    distinct?: EvaDorScalarFieldEnum | EvaDorScalarFieldEnum[]
  }

  /**
   * EvaDor findMany
   */
  export type EvaDorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaDor
     */
    select?: EvaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaDor
     */
    omit?: EvaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaDorInclude<ExtArgs> | null
    /**
     * Filter, which EvaDors to fetch.
     */
    where?: EvaDorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaDors to fetch.
     */
    orderBy?: EvaDorOrderByWithRelationInput | EvaDorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvaDors.
     */
    cursor?: EvaDorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaDors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaDors.
     */
    skip?: number
    distinct?: EvaDorScalarFieldEnum | EvaDorScalarFieldEnum[]
  }

  /**
   * EvaDor create
   */
  export type EvaDorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaDor
     */
    select?: EvaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaDor
     */
    omit?: EvaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaDorInclude<ExtArgs> | null
    /**
     * The data needed to create a EvaDor.
     */
    data: XOR<EvaDorCreateInput, EvaDorUncheckedCreateInput>
  }

  /**
   * EvaDor createMany
   */
  export type EvaDorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvaDors.
     */
    data: EvaDorCreateManyInput | EvaDorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvaDor createManyAndReturn
   */
  export type EvaDorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaDor
     */
    select?: EvaDorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvaDor
     */
    omit?: EvaDorOmit<ExtArgs> | null
    /**
     * The data used to create many EvaDors.
     */
    data: EvaDorCreateManyInput | EvaDorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaDorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvaDor update
   */
  export type EvaDorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaDor
     */
    select?: EvaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaDor
     */
    omit?: EvaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaDorInclude<ExtArgs> | null
    /**
     * The data needed to update a EvaDor.
     */
    data: XOR<EvaDorUpdateInput, EvaDorUncheckedUpdateInput>
    /**
     * Choose, which EvaDor to update.
     */
    where: EvaDorWhereUniqueInput
  }

  /**
   * EvaDor updateMany
   */
  export type EvaDorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvaDors.
     */
    data: XOR<EvaDorUpdateManyMutationInput, EvaDorUncheckedUpdateManyInput>
    /**
     * Filter which EvaDors to update
     */
    where?: EvaDorWhereInput
    /**
     * Limit how many EvaDors to update.
     */
    limit?: number
  }

  /**
   * EvaDor updateManyAndReturn
   */
  export type EvaDorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaDor
     */
    select?: EvaDorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvaDor
     */
    omit?: EvaDorOmit<ExtArgs> | null
    /**
     * The data used to update EvaDors.
     */
    data: XOR<EvaDorUpdateManyMutationInput, EvaDorUncheckedUpdateManyInput>
    /**
     * Filter which EvaDors to update
     */
    where?: EvaDorWhereInput
    /**
     * Limit how many EvaDors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaDorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvaDor upsert
   */
  export type EvaDorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaDor
     */
    select?: EvaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaDor
     */
    omit?: EvaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaDorInclude<ExtArgs> | null
    /**
     * The filter to search for the EvaDor to update in case it exists.
     */
    where: EvaDorWhereUniqueInput
    /**
     * In case the EvaDor found by the `where` argument doesn't exist, create a new EvaDor with this data.
     */
    create: XOR<EvaDorCreateInput, EvaDorUncheckedCreateInput>
    /**
     * In case the EvaDor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaDorUpdateInput, EvaDorUncheckedUpdateInput>
  }

  /**
   * EvaDor delete
   */
  export type EvaDorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaDor
     */
    select?: EvaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaDor
     */
    omit?: EvaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaDorInclude<ExtArgs> | null
    /**
     * Filter which EvaDor to delete.
     */
    where: EvaDorWhereUniqueInput
  }

  /**
   * EvaDor deleteMany
   */
  export type EvaDorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaDors to delete
     */
    where?: EvaDorWhereInput
    /**
     * Limit how many EvaDors to delete.
     */
    limit?: number
  }

  /**
   * EvaDor.profissional
   */
  export type EvaDor$profissionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    where?: ProfissionalWhereInput
  }

  /**
   * EvaDor without action
   */
  export type EvaDorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaDor
     */
    select?: EvaDorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaDor
     */
    omit?: EvaDorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaDorInclude<ExtArgs> | null
  }


  /**
   * Model UsuarioAuth
   */

  export type AggregateUsuarioAuth = {
    _count: UsuarioAuthCountAggregateOutputType | null
    _avg: UsuarioAuthAvgAggregateOutputType | null
    _sum: UsuarioAuthSumAggregateOutputType | null
    _min: UsuarioAuthMinAggregateOutputType | null
    _max: UsuarioAuthMaxAggregateOutputType | null
  }

  export type UsuarioAuthAvgAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdProfissional: number | null
    cdPaciente: number | null
  }

  export type UsuarioAuthSumAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    cdProfissional: number | null
    cdPaciente: number | null
  }

  export type UsuarioAuthMinAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    email: string | null
    senhaHash: string | null
    role: $Enums.RoleAuth | null
    cdProfissional: number | null
    cdPaciente: number | null
  }

  export type UsuarioAuthMaxAggregateOutputType = {
    id: number | null
    cdMaster: number | null
    email: string | null
    senhaHash: string | null
    role: $Enums.RoleAuth | null
    cdProfissional: number | null
    cdPaciente: number | null
  }

  export type UsuarioAuthCountAggregateOutputType = {
    id: number
    cdMaster: number
    email: number
    senhaHash: number
    role: number
    cdProfissional: number
    cdPaciente: number
    _all: number
  }


  export type UsuarioAuthAvgAggregateInputType = {
    id?: true
    cdMaster?: true
    cdProfissional?: true
    cdPaciente?: true
  }

  export type UsuarioAuthSumAggregateInputType = {
    id?: true
    cdMaster?: true
    cdProfissional?: true
    cdPaciente?: true
  }

  export type UsuarioAuthMinAggregateInputType = {
    id?: true
    cdMaster?: true
    email?: true
    senhaHash?: true
    role?: true
    cdProfissional?: true
    cdPaciente?: true
  }

  export type UsuarioAuthMaxAggregateInputType = {
    id?: true
    cdMaster?: true
    email?: true
    senhaHash?: true
    role?: true
    cdProfissional?: true
    cdPaciente?: true
  }

  export type UsuarioAuthCountAggregateInputType = {
    id?: true
    cdMaster?: true
    email?: true
    senhaHash?: true
    role?: true
    cdProfissional?: true
    cdPaciente?: true
    _all?: true
  }

  export type UsuarioAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuarioAuth to aggregate.
     */
    where?: UsuarioAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioAuths to fetch.
     */
    orderBy?: UsuarioAuthOrderByWithRelationInput | UsuarioAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsuarioAuths
    **/
    _count?: true | UsuarioAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAuthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioAuthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioAuthMaxAggregateInputType
  }

  export type GetUsuarioAuthAggregateType<T extends UsuarioAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarioAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarioAuth[P]>
      : GetScalarType<T[P], AggregateUsuarioAuth[P]>
  }




  export type UsuarioAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioAuthWhereInput
    orderBy?: UsuarioAuthOrderByWithAggregationInput | UsuarioAuthOrderByWithAggregationInput[]
    by: UsuarioAuthScalarFieldEnum[] | UsuarioAuthScalarFieldEnum
    having?: UsuarioAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioAuthCountAggregateInputType | true
    _avg?: UsuarioAuthAvgAggregateInputType
    _sum?: UsuarioAuthSumAggregateInputType
    _min?: UsuarioAuthMinAggregateInputType
    _max?: UsuarioAuthMaxAggregateInputType
  }

  export type UsuarioAuthGroupByOutputType = {
    id: number
    cdMaster: number
    email: string
    senhaHash: string
    role: $Enums.RoleAuth
    cdProfissional: number | null
    cdPaciente: number | null
    _count: UsuarioAuthCountAggregateOutputType | null
    _avg: UsuarioAuthAvgAggregateOutputType | null
    _sum: UsuarioAuthSumAggregateOutputType | null
    _min: UsuarioAuthMinAggregateOutputType | null
    _max: UsuarioAuthMaxAggregateOutputType | null
  }

  type GetUsuarioAuthGroupByPayload<T extends UsuarioAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioAuthGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioAuthGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    email?: boolean
    senhaHash?: boolean
    role?: boolean
    cdProfissional?: boolean
    cdPaciente?: boolean
    paciente?: boolean | UsuarioAuth$pacienteArgs<ExtArgs>
    master?: boolean | MasterDefaultArgs<ExtArgs>
    profissional?: boolean | UsuarioAuth$profissionalArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioAuth"]>

  export type UsuarioAuthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    email?: boolean
    senhaHash?: boolean
    role?: boolean
    cdProfissional?: boolean
    cdPaciente?: boolean
    paciente?: boolean | UsuarioAuth$pacienteArgs<ExtArgs>
    master?: boolean | MasterDefaultArgs<ExtArgs>
    profissional?: boolean | UsuarioAuth$profissionalArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioAuth"]>

  export type UsuarioAuthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cdMaster?: boolean
    email?: boolean
    senhaHash?: boolean
    role?: boolean
    cdProfissional?: boolean
    cdPaciente?: boolean
    paciente?: boolean | UsuarioAuth$pacienteArgs<ExtArgs>
    master?: boolean | MasterDefaultArgs<ExtArgs>
    profissional?: boolean | UsuarioAuth$profissionalArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioAuth"]>

  export type UsuarioAuthSelectScalar = {
    id?: boolean
    cdMaster?: boolean
    email?: boolean
    senhaHash?: boolean
    role?: boolean
    cdProfissional?: boolean
    cdPaciente?: boolean
  }

  export type UsuarioAuthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cdMaster" | "email" | "senhaHash" | "role" | "cdProfissional" | "cdPaciente", ExtArgs["result"]["usuarioAuth"]>
  export type UsuarioAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | UsuarioAuth$pacienteArgs<ExtArgs>
    master?: boolean | MasterDefaultArgs<ExtArgs>
    profissional?: boolean | UsuarioAuth$profissionalArgs<ExtArgs>
  }
  export type UsuarioAuthIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | UsuarioAuth$pacienteArgs<ExtArgs>
    master?: boolean | MasterDefaultArgs<ExtArgs>
    profissional?: boolean | UsuarioAuth$profissionalArgs<ExtArgs>
  }
  export type UsuarioAuthIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | UsuarioAuth$pacienteArgs<ExtArgs>
    master?: boolean | MasterDefaultArgs<ExtArgs>
    profissional?: boolean | UsuarioAuth$profissionalArgs<ExtArgs>
  }

  export type $UsuarioAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsuarioAuth"
    objects: {
      paciente: Prisma.$PacientePayload<ExtArgs> | null
      master: Prisma.$MasterPayload<ExtArgs>
      profissional: Prisma.$ProfissionalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cdMaster: number
      email: string
      senhaHash: string
      role: $Enums.RoleAuth
      cdProfissional: number | null
      cdPaciente: number | null
    }, ExtArgs["result"]["usuarioAuth"]>
    composites: {}
  }

  type UsuarioAuthGetPayload<S extends boolean | null | undefined | UsuarioAuthDefaultArgs> = $Result.GetResult<Prisma.$UsuarioAuthPayload, S>

  type UsuarioAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuarioAuthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioAuthCountAggregateInputType | true
    }

  export interface UsuarioAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsuarioAuth'], meta: { name: 'UsuarioAuth' } }
    /**
     * Find zero or one UsuarioAuth that matches the filter.
     * @param {UsuarioAuthFindUniqueArgs} args - Arguments to find a UsuarioAuth
     * @example
     * // Get one UsuarioAuth
     * const usuarioAuth = await prisma.usuarioAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioAuthFindUniqueArgs>(args: SelectSubset<T, UsuarioAuthFindUniqueArgs<ExtArgs>>): Prisma__UsuarioAuthClient<$Result.GetResult<Prisma.$UsuarioAuthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsuarioAuth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioAuthFindUniqueOrThrowArgs} args - Arguments to find a UsuarioAuth
     * @example
     * // Get one UsuarioAuth
     * const usuarioAuth = await prisma.usuarioAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioAuthClient<$Result.GetResult<Prisma.$UsuarioAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuarioAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAuthFindFirstArgs} args - Arguments to find a UsuarioAuth
     * @example
     * // Get one UsuarioAuth
     * const usuarioAuth = await prisma.usuarioAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioAuthFindFirstArgs>(args?: SelectSubset<T, UsuarioAuthFindFirstArgs<ExtArgs>>): Prisma__UsuarioAuthClient<$Result.GetResult<Prisma.$UsuarioAuthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuarioAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAuthFindFirstOrThrowArgs} args - Arguments to find a UsuarioAuth
     * @example
     * // Get one UsuarioAuth
     * const usuarioAuth = await prisma.usuarioAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioAuthClient<$Result.GetResult<Prisma.$UsuarioAuthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsuarioAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsuarioAuths
     * const usuarioAuths = await prisma.usuarioAuth.findMany()
     * 
     * // Get first 10 UsuarioAuths
     * const usuarioAuths = await prisma.usuarioAuth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioAuthWithIdOnly = await prisma.usuarioAuth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioAuthFindManyArgs>(args?: SelectSubset<T, UsuarioAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsuarioAuth.
     * @param {UsuarioAuthCreateArgs} args - Arguments to create a UsuarioAuth.
     * @example
     * // Create one UsuarioAuth
     * const UsuarioAuth = await prisma.usuarioAuth.create({
     *   data: {
     *     // ... data to create a UsuarioAuth
     *   }
     * })
     * 
     */
    create<T extends UsuarioAuthCreateArgs>(args: SelectSubset<T, UsuarioAuthCreateArgs<ExtArgs>>): Prisma__UsuarioAuthClient<$Result.GetResult<Prisma.$UsuarioAuthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsuarioAuths.
     * @param {UsuarioAuthCreateManyArgs} args - Arguments to create many UsuarioAuths.
     * @example
     * // Create many UsuarioAuths
     * const usuarioAuth = await prisma.usuarioAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioAuthCreateManyArgs>(args?: SelectSubset<T, UsuarioAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsuarioAuths and returns the data saved in the database.
     * @param {UsuarioAuthCreateManyAndReturnArgs} args - Arguments to create many UsuarioAuths.
     * @example
     * // Create many UsuarioAuths
     * const usuarioAuth = await prisma.usuarioAuth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsuarioAuths and only return the `id`
     * const usuarioAuthWithIdOnly = await prisma.usuarioAuth.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioAuthCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioAuthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioAuthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsuarioAuth.
     * @param {UsuarioAuthDeleteArgs} args - Arguments to delete one UsuarioAuth.
     * @example
     * // Delete one UsuarioAuth
     * const UsuarioAuth = await prisma.usuarioAuth.delete({
     *   where: {
     *     // ... filter to delete one UsuarioAuth
     *   }
     * })
     * 
     */
    delete<T extends UsuarioAuthDeleteArgs>(args: SelectSubset<T, UsuarioAuthDeleteArgs<ExtArgs>>): Prisma__UsuarioAuthClient<$Result.GetResult<Prisma.$UsuarioAuthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsuarioAuth.
     * @param {UsuarioAuthUpdateArgs} args - Arguments to update one UsuarioAuth.
     * @example
     * // Update one UsuarioAuth
     * const usuarioAuth = await prisma.usuarioAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioAuthUpdateArgs>(args: SelectSubset<T, UsuarioAuthUpdateArgs<ExtArgs>>): Prisma__UsuarioAuthClient<$Result.GetResult<Prisma.$UsuarioAuthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsuarioAuths.
     * @param {UsuarioAuthDeleteManyArgs} args - Arguments to filter UsuarioAuths to delete.
     * @example
     * // Delete a few UsuarioAuths
     * const { count } = await prisma.usuarioAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioAuthDeleteManyArgs>(args?: SelectSubset<T, UsuarioAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuarioAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsuarioAuths
     * const usuarioAuth = await prisma.usuarioAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioAuthUpdateManyArgs>(args: SelectSubset<T, UsuarioAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuarioAuths and returns the data updated in the database.
     * @param {UsuarioAuthUpdateManyAndReturnArgs} args - Arguments to update many UsuarioAuths.
     * @example
     * // Update many UsuarioAuths
     * const usuarioAuth = await prisma.usuarioAuth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsuarioAuths and only return the `id`
     * const usuarioAuthWithIdOnly = await prisma.usuarioAuth.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuarioAuthUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuarioAuthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioAuthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsuarioAuth.
     * @param {UsuarioAuthUpsertArgs} args - Arguments to update or create a UsuarioAuth.
     * @example
     * // Update or create a UsuarioAuth
     * const usuarioAuth = await prisma.usuarioAuth.upsert({
     *   create: {
     *     // ... data to create a UsuarioAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsuarioAuth we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioAuthUpsertArgs>(args: SelectSubset<T, UsuarioAuthUpsertArgs<ExtArgs>>): Prisma__UsuarioAuthClient<$Result.GetResult<Prisma.$UsuarioAuthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsuarioAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAuthCountArgs} args - Arguments to filter UsuarioAuths to count.
     * @example
     * // Count the number of UsuarioAuths
     * const count = await prisma.usuarioAuth.count({
     *   where: {
     *     // ... the filter for the UsuarioAuths we want to count
     *   }
     * })
    **/
    count<T extends UsuarioAuthCountArgs>(
      args?: Subset<T, UsuarioAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsuarioAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAuthAggregateArgs>(args: Subset<T, UsuarioAuthAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAuthAggregateType<T>>

    /**
     * Group by UsuarioAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioAuthGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsuarioAuth model
   */
  readonly fields: UsuarioAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsuarioAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paciente<T extends UsuarioAuth$pacienteArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioAuth$pacienteArgs<ExtArgs>>): Prisma__PacienteClient<$Result.GetResult<Prisma.$PacientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    master<T extends MasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MasterDefaultArgs<ExtArgs>>): Prisma__MasterClient<$Result.GetResult<Prisma.$MasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profissional<T extends UsuarioAuth$profissionalArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioAuth$profissionalArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsuarioAuth model
   */
  interface UsuarioAuthFieldRefs {
    readonly id: FieldRef<"UsuarioAuth", 'Int'>
    readonly cdMaster: FieldRef<"UsuarioAuth", 'Int'>
    readonly email: FieldRef<"UsuarioAuth", 'String'>
    readonly senhaHash: FieldRef<"UsuarioAuth", 'String'>
    readonly role: FieldRef<"UsuarioAuth", 'RoleAuth'>
    readonly cdProfissional: FieldRef<"UsuarioAuth", 'Int'>
    readonly cdPaciente: FieldRef<"UsuarioAuth", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UsuarioAuth findUnique
   */
  export type UsuarioAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioAuth
     */
    select?: UsuarioAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioAuth
     */
    omit?: UsuarioAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioAuthInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioAuth to fetch.
     */
    where: UsuarioAuthWhereUniqueInput
  }

  /**
   * UsuarioAuth findUniqueOrThrow
   */
  export type UsuarioAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioAuth
     */
    select?: UsuarioAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioAuth
     */
    omit?: UsuarioAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioAuthInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioAuth to fetch.
     */
    where: UsuarioAuthWhereUniqueInput
  }

  /**
   * UsuarioAuth findFirst
   */
  export type UsuarioAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioAuth
     */
    select?: UsuarioAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioAuth
     */
    omit?: UsuarioAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioAuthInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioAuth to fetch.
     */
    where?: UsuarioAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioAuths to fetch.
     */
    orderBy?: UsuarioAuthOrderByWithRelationInput | UsuarioAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuarioAuths.
     */
    cursor?: UsuarioAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuarioAuths.
     */
    distinct?: UsuarioAuthScalarFieldEnum | UsuarioAuthScalarFieldEnum[]
  }

  /**
   * UsuarioAuth findFirstOrThrow
   */
  export type UsuarioAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioAuth
     */
    select?: UsuarioAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioAuth
     */
    omit?: UsuarioAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioAuthInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioAuth to fetch.
     */
    where?: UsuarioAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioAuths to fetch.
     */
    orderBy?: UsuarioAuthOrderByWithRelationInput | UsuarioAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuarioAuths.
     */
    cursor?: UsuarioAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuarioAuths.
     */
    distinct?: UsuarioAuthScalarFieldEnum | UsuarioAuthScalarFieldEnum[]
  }

  /**
   * UsuarioAuth findMany
   */
  export type UsuarioAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioAuth
     */
    select?: UsuarioAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioAuth
     */
    omit?: UsuarioAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioAuthInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioAuths to fetch.
     */
    where?: UsuarioAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioAuths to fetch.
     */
    orderBy?: UsuarioAuthOrderByWithRelationInput | UsuarioAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsuarioAuths.
     */
    cursor?: UsuarioAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioAuths.
     */
    skip?: number
    distinct?: UsuarioAuthScalarFieldEnum | UsuarioAuthScalarFieldEnum[]
  }

  /**
   * UsuarioAuth create
   */
  export type UsuarioAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioAuth
     */
    select?: UsuarioAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioAuth
     */
    omit?: UsuarioAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a UsuarioAuth.
     */
    data: XOR<UsuarioAuthCreateInput, UsuarioAuthUncheckedCreateInput>
  }

  /**
   * UsuarioAuth createMany
   */
  export type UsuarioAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsuarioAuths.
     */
    data: UsuarioAuthCreateManyInput | UsuarioAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsuarioAuth createManyAndReturn
   */
  export type UsuarioAuthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioAuth
     */
    select?: UsuarioAuthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioAuth
     */
    omit?: UsuarioAuthOmit<ExtArgs> | null
    /**
     * The data used to create many UsuarioAuths.
     */
    data: UsuarioAuthCreateManyInput | UsuarioAuthCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioAuthIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsuarioAuth update
   */
  export type UsuarioAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioAuth
     */
    select?: UsuarioAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioAuth
     */
    omit?: UsuarioAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a UsuarioAuth.
     */
    data: XOR<UsuarioAuthUpdateInput, UsuarioAuthUncheckedUpdateInput>
    /**
     * Choose, which UsuarioAuth to update.
     */
    where: UsuarioAuthWhereUniqueInput
  }

  /**
   * UsuarioAuth updateMany
   */
  export type UsuarioAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsuarioAuths.
     */
    data: XOR<UsuarioAuthUpdateManyMutationInput, UsuarioAuthUncheckedUpdateManyInput>
    /**
     * Filter which UsuarioAuths to update
     */
    where?: UsuarioAuthWhereInput
    /**
     * Limit how many UsuarioAuths to update.
     */
    limit?: number
  }

  /**
   * UsuarioAuth updateManyAndReturn
   */
  export type UsuarioAuthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioAuth
     */
    select?: UsuarioAuthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioAuth
     */
    omit?: UsuarioAuthOmit<ExtArgs> | null
    /**
     * The data used to update UsuarioAuths.
     */
    data: XOR<UsuarioAuthUpdateManyMutationInput, UsuarioAuthUncheckedUpdateManyInput>
    /**
     * Filter which UsuarioAuths to update
     */
    where?: UsuarioAuthWhereInput
    /**
     * Limit how many UsuarioAuths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioAuthIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsuarioAuth upsert
   */
  export type UsuarioAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioAuth
     */
    select?: UsuarioAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioAuth
     */
    omit?: UsuarioAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the UsuarioAuth to update in case it exists.
     */
    where: UsuarioAuthWhereUniqueInput
    /**
     * In case the UsuarioAuth found by the `where` argument doesn't exist, create a new UsuarioAuth with this data.
     */
    create: XOR<UsuarioAuthCreateInput, UsuarioAuthUncheckedCreateInput>
    /**
     * In case the UsuarioAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioAuthUpdateInput, UsuarioAuthUncheckedUpdateInput>
  }

  /**
   * UsuarioAuth delete
   */
  export type UsuarioAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioAuth
     */
    select?: UsuarioAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioAuth
     */
    omit?: UsuarioAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioAuthInclude<ExtArgs> | null
    /**
     * Filter which UsuarioAuth to delete.
     */
    where: UsuarioAuthWhereUniqueInput
  }

  /**
   * UsuarioAuth deleteMany
   */
  export type UsuarioAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuarioAuths to delete
     */
    where?: UsuarioAuthWhereInput
    /**
     * Limit how many UsuarioAuths to delete.
     */
    limit?: number
  }

  /**
   * UsuarioAuth.paciente
   */
  export type UsuarioAuth$pacienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paciente
     */
    select?: PacienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paciente
     */
    omit?: PacienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PacienteInclude<ExtArgs> | null
    where?: PacienteWhereInput
  }

  /**
   * UsuarioAuth.profissional
   */
  export type UsuarioAuth$profissionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profissional
     */
    omit?: ProfissionalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    where?: ProfissionalWhereInput
  }

  /**
   * UsuarioAuth without action
   */
  export type UsuarioAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioAuth
     */
    select?: UsuarioAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioAuth
     */
    omit?: UsuarioAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioAuthInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const MasterScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    dtCadastro: 'dtCadastro',
    stInativo: 'stInativo'
  };

  export type MasterScalarFieldEnum = (typeof MasterScalarFieldEnum)[keyof typeof MasterScalarFieldEnum]


  export const PacienteScalarFieldEnum: {
    cdMaster: 'cdMaster',
    cdPaciente: 'cdPaciente',
    nome: 'nome',
    sexo: 'sexo',
    dtNascimento: 'dtNascimento',
    stInativo: 'stInativo',
    cdEscolaridade: 'cdEscolaridade',
    cdOcupacao: 'cdOcupacao'
  };

  export type PacienteScalarFieldEnum = (typeof PacienteScalarFieldEnum)[keyof typeof PacienteScalarFieldEnum]


  export const ProfissionalScalarFieldEnum: {
    id: 'id',
    cdMaster: 'cdMaster',
    nome: 'nome',
    sexo: 'sexo',
    conselho: 'conselho',
    stInativo: 'stInativo',
    cdOcupacao: 'cdOcupacao'
  };

  export type ProfissionalScalarFieldEnum = (typeof ProfissionalScalarFieldEnum)[keyof typeof ProfissionalScalarFieldEnum]


  export const EnderecoScalarFieldEnum: {
    id: 'id',
    logradouro: 'logradouro',
    numero: 'numero',
    complemento: 'complemento',
    cdBairro: 'cdBairro',
    cdCidade: 'cdCidade',
    cep: 'cep',
    stInativo: 'stInativo'
  };

  export type EnderecoScalarFieldEnum = (typeof EnderecoScalarFieldEnum)[keyof typeof EnderecoScalarFieldEnum]


  export const EnderecoPacienteScalarFieldEnum: {
    id: 'id',
    cdMaster: 'cdMaster',
    cdPaciente: 'cdPaciente',
    cdEndereco: 'cdEndereco'
  };

  export type EnderecoPacienteScalarFieldEnum = (typeof EnderecoPacienteScalarFieldEnum)[keyof typeof EnderecoPacienteScalarFieldEnum]


  export const EnderecoProfissionalScalarFieldEnum: {
    id: 'id',
    cdProf: 'cdProf',
    cdEndereco: 'cdEndereco'
  };

  export type EnderecoProfissionalScalarFieldEnum = (typeof EnderecoProfissionalScalarFieldEnum)[keyof typeof EnderecoProfissionalScalarFieldEnum]


  export const ContatoScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    numero: 'numero',
    stInativo: 'stInativo'
  };

  export type ContatoScalarFieldEnum = (typeof ContatoScalarFieldEnum)[keyof typeof ContatoScalarFieldEnum]


  export const ContatoPacienteScalarFieldEnum: {
    id: 'id',
    cdMaster: 'cdMaster',
    cdPaciente: 'cdPaciente',
    cdContato: 'cdContato'
  };

  export type ContatoPacienteScalarFieldEnum = (typeof ContatoPacienteScalarFieldEnum)[keyof typeof ContatoPacienteScalarFieldEnum]


  export const ContatoProfissionalScalarFieldEnum: {
    id: 'id',
    cdProf: 'cdProf',
    cdContato: 'cdContato'
  };

  export type ContatoProfissionalScalarFieldEnum = (typeof ContatoProfissionalScalarFieldEnum)[keyof typeof ContatoProfissionalScalarFieldEnum]


  export const AtendimentoScalarFieldEnum: {
    id: 'id',
    cdMaster: 'cdMaster',
    cdPaciente: 'cdPaciente',
    cdProfissional: 'cdProfissional',
    data: 'data',
    observacao: 'observacao'
  };

  export type AtendimentoScalarFieldEnum = (typeof AtendimentoScalarFieldEnum)[keyof typeof AtendimentoScalarFieldEnum]


  export const EvolucaoScalarFieldEnum: {
    id: 'id',
    cdAtendimento: 'cdAtendimento',
    cdProfissional: 'cdProfissional',
    data: 'data',
    texto: 'texto',
    pacienteCdMaster: 'pacienteCdMaster',
    pacienteCdPaciente: 'pacienteCdPaciente',
    tipoEvolucaoClinicaId: 'tipoEvolucaoClinicaId'
  };

  export type EvolucaoScalarFieldEnum = (typeof EvolucaoScalarFieldEnum)[keyof typeof EvolucaoScalarFieldEnum]


  export const PessoaRelacionadaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    telefone: 'telefone',
    stInativo: 'stInativo'
  };

  export type PessoaRelacionadaScalarFieldEnum = (typeof PessoaRelacionadaScalarFieldEnum)[keyof typeof PessoaRelacionadaScalarFieldEnum]


  export const ParentescoPacienteScalarFieldEnum: {
    id: 'id',
    cdMaster: 'cdMaster',
    cdPaciente: 'cdPaciente',
    cdPessoa: 'cdPessoa',
    parentesco: 'parentesco'
  };

  export type ParentescoPacienteScalarFieldEnum = (typeof ParentescoPacienteScalarFieldEnum)[keyof typeof ParentescoPacienteScalarFieldEnum]


  export const PlanoScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    stInativo: 'stInativo'
  };

  export type PlanoScalarFieldEnum = (typeof PlanoScalarFieldEnum)[keyof typeof PlanoScalarFieldEnum]


  export const MotivoScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    stInativo: 'stInativo'
  };

  export type MotivoScalarFieldEnum = (typeof MotivoScalarFieldEnum)[keyof typeof MotivoScalarFieldEnum]


  export const TipoProcedimentoScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    stInativo: 'stInativo'
  };

  export type TipoProcedimentoScalarFieldEnum = (typeof TipoProcedimentoScalarFieldEnum)[keyof typeof TipoProcedimentoScalarFieldEnum]


  export const TipoEvolucaoSimplesScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    stInativo: 'stInativo'
  };

  export type TipoEvolucaoSimplesScalarFieldEnum = (typeof TipoEvolucaoSimplesScalarFieldEnum)[keyof typeof TipoEvolucaoSimplesScalarFieldEnum]


  export const PaisScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    nacionalidade: 'nacionalidade',
    cdIbge: 'cdIbge'
  };

  export type PaisScalarFieldEnum = (typeof PaisScalarFieldEnum)[keyof typeof PaisScalarFieldEnum]


  export const UnidadeFederacaoScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    cdIbge: 'cdIbge'
  };

  export type UnidadeFederacaoScalarFieldEnum = (typeof UnidadeFederacaoScalarFieldEnum)[keyof typeof UnidadeFederacaoScalarFieldEnum]


  export const CidadeScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    cdUf: 'cdUf',
    cdPais: 'cdPais',
    cepGeral: 'cepGeral',
    cdIbge: 'cdIbge',
    stInativo: 'stInativo'
  };

  export type CidadeScalarFieldEnum = (typeof CidadeScalarFieldEnum)[keyof typeof CidadeScalarFieldEnum]


  export const EscolaridadeScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    stInativo: 'stInativo'
  };

  export type EscolaridadeScalarFieldEnum = (typeof EscolaridadeScalarFieldEnum)[keyof typeof EscolaridadeScalarFieldEnum]


  export const OcupacaoScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    cbo: 'cbo',
    stInativo: 'stInativo'
  };

  export type OcupacaoScalarFieldEnum = (typeof OcupacaoScalarFieldEnum)[keyof typeof OcupacaoScalarFieldEnum]


  export const DistritoScalarFieldEnum: {
    id: 'id',
    cdCidade: 'cdCidade',
    descricao: 'descricao',
    stInativo: 'stInativo'
  };

  export type DistritoScalarFieldEnum = (typeof DistritoScalarFieldEnum)[keyof typeof DistritoScalarFieldEnum]


  export const BairroScalarFieldEnum: {
    id: 'id',
    cdDistrito: 'cdDistrito',
    cdCidade: 'cdCidade',
    descricao: 'descricao',
    stInativo: 'stInativo'
  };

  export type BairroScalarFieldEnum = (typeof BairroScalarFieldEnum)[keyof typeof BairroScalarFieldEnum]


  export const EnderecoPessoaRelacionadaScalarFieldEnum: {
    id: 'id',
    cdPessoa: 'cdPessoa',
    cdEndereco: 'cdEndereco'
  };

  export type EnderecoPessoaRelacionadaScalarFieldEnum = (typeof EnderecoPessoaRelacionadaScalarFieldEnum)[keyof typeof EnderecoPessoaRelacionadaScalarFieldEnum]


  export const CidScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    descricao: 'descricao',
    versao: 'versao',
    stInativo: 'stInativo'
  };

  export type CidScalarFieldEnum = (typeof CidScalarFieldEnum)[keyof typeof CidScalarFieldEnum]


  export const DsmScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    descricao: 'descricao',
    versao: 'versao',
    stInativo: 'stInativo'
  };

  export type DsmScalarFieldEnum = (typeof DsmScalarFieldEnum)[keyof typeof DsmScalarFieldEnum]


  export const TipoEvolucaoClinicaScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    stInativo: 'stInativo'
  };

  export type TipoEvolucaoClinicaScalarFieldEnum = (typeof TipoEvolucaoClinicaScalarFieldEnum)[keyof typeof TipoEvolucaoClinicaScalarFieldEnum]


  export const EvolucaoCidScalarFieldEnum: {
    id: 'id',
    cdEvolucao: 'cdEvolucao',
    cdCid: 'cdCid'
  };

  export type EvolucaoCidScalarFieldEnum = (typeof EvolucaoCidScalarFieldEnum)[keyof typeof EvolucaoCidScalarFieldEnum]


  export const EvolucaoDsmScalarFieldEnum: {
    id: 'id',
    cdEvolucao: 'cdEvolucao',
    cdDsm: 'cdDsm'
  };

  export type EvolucaoDsmScalarFieldEnum = (typeof EvolucaoDsmScalarFieldEnum)[keyof typeof EvolucaoDsmScalarFieldEnum]


  export const SinaisVitaisScalarFieldEnum: {
    id: 'id',
    cdAtendimento: 'cdAtendimento',
    data: 'data',
    paSistolica: 'paSistolica',
    paDiastolica: 'paDiastolica',
    fc: 'fc',
    fr: 'fr',
    temperatura: 'temperatura',
    spo2: 'spo2',
    peso: 'peso',
    altura: 'altura',
    imc: 'imc',
    dor: 'dor',
    escalaDorId: 'escalaDorId',
    posicao: 'posicao',
    origem: 'origem',
    metadataRaw: 'metadataRaw'
  };

  export type SinaisVitaisScalarFieldEnum = (typeof SinaisVitaisScalarFieldEnum)[keyof typeof SinaisVitaisScalarFieldEnum]


  export const EscalaDorScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    descricao: 'descricao'
  };

  export type EscalaDorScalarFieldEnum = (typeof EscalaDorScalarFieldEnum)[keyof typeof EscalaDorScalarFieldEnum]


  export const GlasgowScalarFieldEnum: {
    id: 'id',
    cdAtendimento: 'cdAtendimento',
    cdProfissional: 'cdProfissional',
    data: 'data',
    ocular: 'ocular',
    verbal: 'verbal',
    motora: 'motora',
    total: 'total',
    observacao: 'observacao'
  };

  export type GlasgowScalarFieldEnum = (typeof GlasgowScalarFieldEnum)[keyof typeof GlasgowScalarFieldEnum]


  export const AfericaoClinicaScalarFieldEnum: {
    id: 'id',
    cdAtendimento: 'cdAtendimento',
    cdProfissional: 'cdProfissional',
    escala: 'escala',
    idRegistro: 'idRegistro',
    data: 'data'
  };

  export type AfericaoClinicaScalarFieldEnum = (typeof AfericaoClinicaScalarFieldEnum)[keyof typeof AfericaoClinicaScalarFieldEnum]


  export const EvaDorScalarFieldEnum: {
    id: 'id',
    cdAtendimento: 'cdAtendimento',
    cdProfissional: 'cdProfissional',
    data: 'data',
    valor: 'valor',
    observacao: 'observacao'
  };

  export type EvaDorScalarFieldEnum = (typeof EvaDorScalarFieldEnum)[keyof typeof EvaDorScalarFieldEnum]


  export const UsuarioAuthScalarFieldEnum: {
    id: 'id',
    cdMaster: 'cdMaster',
    email: 'email',
    senhaHash: 'senhaHash',
    role: 'role',
    cdProfissional: 'cdProfissional',
    cdPaciente: 'cdPaciente'
  };

  export type UsuarioAuthScalarFieldEnum = (typeof UsuarioAuthScalarFieldEnum)[keyof typeof UsuarioAuthScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'SimNao'
   */
  export type EnumSimNaoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimNao'>
    


  /**
   * Reference to a field of type 'SimNao[]'
   */
  export type ListEnumSimNaoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimNao[]'>
    


  /**
   * Reference to a field of type 'Sexo'
   */
  export type EnumSexoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sexo'>
    


  /**
   * Reference to a field of type 'Sexo[]'
   */
  export type ListEnumSexoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sexo[]'>
    


  /**
   * Reference to a field of type 'TipoFone'
   */
  export type EnumTipoFoneFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoFone'>
    


  /**
   * Reference to a field of type 'TipoFone[]'
   */
  export type ListEnumTipoFoneFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoFone[]'>
    


  /**
   * Reference to a field of type 'TipoParentesco'
   */
  export type EnumTipoParentescoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoParentesco'>
    


  /**
   * Reference to a field of type 'TipoParentesco[]'
   */
  export type ListEnumTipoParentescoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoParentesco[]'>
    


  /**
   * Reference to a field of type 'VersaoCid'
   */
  export type EnumVersaoCidFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VersaoCid'>
    


  /**
   * Reference to a field of type 'VersaoCid[]'
   */
  export type ListEnumVersaoCidFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VersaoCid[]'>
    


  /**
   * Reference to a field of type 'VersaoDsm'
   */
  export type EnumVersaoDsmFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VersaoDsm'>
    


  /**
   * Reference to a field of type 'VersaoDsm[]'
   */
  export type ListEnumVersaoDsmFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VersaoDsm[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'PosicaoPaciente'
   */
  export type EnumPosicaoPacienteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PosicaoPaciente'>
    


  /**
   * Reference to a field of type 'PosicaoPaciente[]'
   */
  export type ListEnumPosicaoPacienteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PosicaoPaciente[]'>
    


  /**
   * Reference to a field of type 'OrigemAfericao'
   */
  export type EnumOrigemAfericaoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrigemAfericao'>
    


  /**
   * Reference to a field of type 'OrigemAfericao[]'
   */
  export type ListEnumOrigemAfericaoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrigemAfericao[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'RoleAuth'
   */
  export type EnumRoleAuthFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleAuth'>
    


  /**
   * Reference to a field of type 'RoleAuth[]'
   */
  export type ListEnumRoleAuthFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleAuth[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type MasterWhereInput = {
    AND?: MasterWhereInput | MasterWhereInput[]
    OR?: MasterWhereInput[]
    NOT?: MasterWhereInput | MasterWhereInput[]
    id?: IntFilter<"Master"> | number
    nome?: StringFilter<"Master"> | string
    dtCadastro?: DateTimeFilter<"Master"> | Date | string
    stInativo?: EnumSimNaoNullableFilter<"Master"> | $Enums.SimNao | null
    pacientes?: PacienteListRelationFilter
    profissionais?: ProfissionalListRelationFilter
    usuarioAuths?: UsuarioAuthListRelationFilter
  }

  export type MasterOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    dtCadastro?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    pacientes?: PacienteOrderByRelationAggregateInput
    profissionais?: ProfissionalOrderByRelationAggregateInput
    usuarioAuths?: UsuarioAuthOrderByRelationAggregateInput
  }

  export type MasterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MasterWhereInput | MasterWhereInput[]
    OR?: MasterWhereInput[]
    NOT?: MasterWhereInput | MasterWhereInput[]
    nome?: StringFilter<"Master"> | string
    dtCadastro?: DateTimeFilter<"Master"> | Date | string
    stInativo?: EnumSimNaoNullableFilter<"Master"> | $Enums.SimNao | null
    pacientes?: PacienteListRelationFilter
    profissionais?: ProfissionalListRelationFilter
    usuarioAuths?: UsuarioAuthListRelationFilter
  }, "id">

  export type MasterOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    dtCadastro?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: MasterCountOrderByAggregateInput
    _avg?: MasterAvgOrderByAggregateInput
    _max?: MasterMaxOrderByAggregateInput
    _min?: MasterMinOrderByAggregateInput
    _sum?: MasterSumOrderByAggregateInput
  }

  export type MasterScalarWhereWithAggregatesInput = {
    AND?: MasterScalarWhereWithAggregatesInput | MasterScalarWhereWithAggregatesInput[]
    OR?: MasterScalarWhereWithAggregatesInput[]
    NOT?: MasterScalarWhereWithAggregatesInput | MasterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Master"> | number
    nome?: StringWithAggregatesFilter<"Master"> | string
    dtCadastro?: DateTimeWithAggregatesFilter<"Master"> | Date | string
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"Master"> | $Enums.SimNao | null
  }

  export type PacienteWhereInput = {
    AND?: PacienteWhereInput | PacienteWhereInput[]
    OR?: PacienteWhereInput[]
    NOT?: PacienteWhereInput | PacienteWhereInput[]
    cdMaster?: IntFilter<"Paciente"> | number
    cdPaciente?: IntFilter<"Paciente"> | number
    nome?: StringFilter<"Paciente"> | string
    sexo?: EnumSexoNullableFilter<"Paciente"> | $Enums.Sexo | null
    dtNascimento?: DateTimeNullableFilter<"Paciente"> | Date | string | null
    stInativo?: EnumSimNaoNullableFilter<"Paciente"> | $Enums.SimNao | null
    cdEscolaridade?: IntNullableFilter<"Paciente"> | number | null
    cdOcupacao?: IntNullableFilter<"Paciente"> | number | null
    atendimentos?: AtendimentoListRelationFilter
    contatos?: ContatoPacienteListRelationFilter
    enderecos?: EnderecoPacienteListRelationFilter
    evolucoes?: EvolucaoListRelationFilter
    escolaridade?: XOR<EscolaridadeNullableScalarRelationFilter, EscolaridadeWhereInput> | null
    master?: XOR<MasterScalarRelationFilter, MasterWhereInput>
    ocupacao?: XOR<OcupacaoNullableScalarRelationFilter, OcupacaoWhereInput> | null
    parentescoPacientes?: ParentescoPacienteListRelationFilter
    usuarioAuths?: UsuarioAuthListRelationFilter
  }

  export type PacienteOrderByWithRelationInput = {
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    nome?: SortOrder
    sexo?: SortOrderInput | SortOrder
    dtNascimento?: SortOrderInput | SortOrder
    stInativo?: SortOrderInput | SortOrder
    cdEscolaridade?: SortOrderInput | SortOrder
    cdOcupacao?: SortOrderInput | SortOrder
    atendimentos?: AtendimentoOrderByRelationAggregateInput
    contatos?: ContatoPacienteOrderByRelationAggregateInput
    enderecos?: EnderecoPacienteOrderByRelationAggregateInput
    evolucoes?: EvolucaoOrderByRelationAggregateInput
    escolaridade?: EscolaridadeOrderByWithRelationInput
    master?: MasterOrderByWithRelationInput
    ocupacao?: OcupacaoOrderByWithRelationInput
    parentescoPacientes?: ParentescoPacienteOrderByRelationAggregateInput
    usuarioAuths?: UsuarioAuthOrderByRelationAggregateInput
  }

  export type PacienteWhereUniqueInput = Prisma.AtLeast<{
    cdMaster_cdPaciente?: PacienteCdMasterCdPacienteCompoundUniqueInput
    AND?: PacienteWhereInput | PacienteWhereInput[]
    OR?: PacienteWhereInput[]
    NOT?: PacienteWhereInput | PacienteWhereInput[]
    cdMaster?: IntFilter<"Paciente"> | number
    cdPaciente?: IntFilter<"Paciente"> | number
    nome?: StringFilter<"Paciente"> | string
    sexo?: EnumSexoNullableFilter<"Paciente"> | $Enums.Sexo | null
    dtNascimento?: DateTimeNullableFilter<"Paciente"> | Date | string | null
    stInativo?: EnumSimNaoNullableFilter<"Paciente"> | $Enums.SimNao | null
    cdEscolaridade?: IntNullableFilter<"Paciente"> | number | null
    cdOcupacao?: IntNullableFilter<"Paciente"> | number | null
    atendimentos?: AtendimentoListRelationFilter
    contatos?: ContatoPacienteListRelationFilter
    enderecos?: EnderecoPacienteListRelationFilter
    evolucoes?: EvolucaoListRelationFilter
    escolaridade?: XOR<EscolaridadeNullableScalarRelationFilter, EscolaridadeWhereInput> | null
    master?: XOR<MasterScalarRelationFilter, MasterWhereInput>
    ocupacao?: XOR<OcupacaoNullableScalarRelationFilter, OcupacaoWhereInput> | null
    parentescoPacientes?: ParentescoPacienteListRelationFilter
    usuarioAuths?: UsuarioAuthListRelationFilter
  }, "cdMaster_cdPaciente">

  export type PacienteOrderByWithAggregationInput = {
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    nome?: SortOrder
    sexo?: SortOrderInput | SortOrder
    dtNascimento?: SortOrderInput | SortOrder
    stInativo?: SortOrderInput | SortOrder
    cdEscolaridade?: SortOrderInput | SortOrder
    cdOcupacao?: SortOrderInput | SortOrder
    _count?: PacienteCountOrderByAggregateInput
    _avg?: PacienteAvgOrderByAggregateInput
    _max?: PacienteMaxOrderByAggregateInput
    _min?: PacienteMinOrderByAggregateInput
    _sum?: PacienteSumOrderByAggregateInput
  }

  export type PacienteScalarWhereWithAggregatesInput = {
    AND?: PacienteScalarWhereWithAggregatesInput | PacienteScalarWhereWithAggregatesInput[]
    OR?: PacienteScalarWhereWithAggregatesInput[]
    NOT?: PacienteScalarWhereWithAggregatesInput | PacienteScalarWhereWithAggregatesInput[]
    cdMaster?: IntWithAggregatesFilter<"Paciente"> | number
    cdPaciente?: IntWithAggregatesFilter<"Paciente"> | number
    nome?: StringWithAggregatesFilter<"Paciente"> | string
    sexo?: EnumSexoNullableWithAggregatesFilter<"Paciente"> | $Enums.Sexo | null
    dtNascimento?: DateTimeNullableWithAggregatesFilter<"Paciente"> | Date | string | null
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"Paciente"> | $Enums.SimNao | null
    cdEscolaridade?: IntNullableWithAggregatesFilter<"Paciente"> | number | null
    cdOcupacao?: IntNullableWithAggregatesFilter<"Paciente"> | number | null
  }

  export type ProfissionalWhereInput = {
    AND?: ProfissionalWhereInput | ProfissionalWhereInput[]
    OR?: ProfissionalWhereInput[]
    NOT?: ProfissionalWhereInput | ProfissionalWhereInput[]
    id?: IntFilter<"Profissional"> | number
    cdMaster?: IntFilter<"Profissional"> | number
    nome?: StringFilter<"Profissional"> | string
    sexo?: EnumSexoNullableFilter<"Profissional"> | $Enums.Sexo | null
    conselho?: StringNullableFilter<"Profissional"> | string | null
    stInativo?: EnumSimNaoNullableFilter<"Profissional"> | $Enums.SimNao | null
    cdOcupacao?: IntNullableFilter<"Profissional"> | number | null
    afericoesClinicas?: AfericaoClinicaListRelationFilter
    atendimentos?: AtendimentoListRelationFilter
    contatos?: ContatoProfissionalListRelationFilter
    enderecos?: EnderecoProfissionalListRelationFilter
    evaDores?: EvaDorListRelationFilter
    evolucoes?: EvolucaoListRelationFilter
    glasgows?: GlasgowListRelationFilter
    master?: XOR<MasterScalarRelationFilter, MasterWhereInput>
    ocupacao?: XOR<OcupacaoNullableScalarRelationFilter, OcupacaoWhereInput> | null
    usuarioAuths?: UsuarioAuthListRelationFilter
  }

  export type ProfissionalOrderByWithRelationInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    nome?: SortOrder
    sexo?: SortOrderInput | SortOrder
    conselho?: SortOrderInput | SortOrder
    stInativo?: SortOrderInput | SortOrder
    cdOcupacao?: SortOrderInput | SortOrder
    afericoesClinicas?: AfericaoClinicaOrderByRelationAggregateInput
    atendimentos?: AtendimentoOrderByRelationAggregateInput
    contatos?: ContatoProfissionalOrderByRelationAggregateInput
    enderecos?: EnderecoProfissionalOrderByRelationAggregateInput
    evaDores?: EvaDorOrderByRelationAggregateInput
    evolucoes?: EvolucaoOrderByRelationAggregateInput
    glasgows?: GlasgowOrderByRelationAggregateInput
    master?: MasterOrderByWithRelationInput
    ocupacao?: OcupacaoOrderByWithRelationInput
    usuarioAuths?: UsuarioAuthOrderByRelationAggregateInput
  }

  export type ProfissionalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProfissionalWhereInput | ProfissionalWhereInput[]
    OR?: ProfissionalWhereInput[]
    NOT?: ProfissionalWhereInput | ProfissionalWhereInput[]
    cdMaster?: IntFilter<"Profissional"> | number
    nome?: StringFilter<"Profissional"> | string
    sexo?: EnumSexoNullableFilter<"Profissional"> | $Enums.Sexo | null
    conselho?: StringNullableFilter<"Profissional"> | string | null
    stInativo?: EnumSimNaoNullableFilter<"Profissional"> | $Enums.SimNao | null
    cdOcupacao?: IntNullableFilter<"Profissional"> | number | null
    afericoesClinicas?: AfericaoClinicaListRelationFilter
    atendimentos?: AtendimentoListRelationFilter
    contatos?: ContatoProfissionalListRelationFilter
    enderecos?: EnderecoProfissionalListRelationFilter
    evaDores?: EvaDorListRelationFilter
    evolucoes?: EvolucaoListRelationFilter
    glasgows?: GlasgowListRelationFilter
    master?: XOR<MasterScalarRelationFilter, MasterWhereInput>
    ocupacao?: XOR<OcupacaoNullableScalarRelationFilter, OcupacaoWhereInput> | null
    usuarioAuths?: UsuarioAuthListRelationFilter
  }, "id">

  export type ProfissionalOrderByWithAggregationInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    nome?: SortOrder
    sexo?: SortOrderInput | SortOrder
    conselho?: SortOrderInput | SortOrder
    stInativo?: SortOrderInput | SortOrder
    cdOcupacao?: SortOrderInput | SortOrder
    _count?: ProfissionalCountOrderByAggregateInput
    _avg?: ProfissionalAvgOrderByAggregateInput
    _max?: ProfissionalMaxOrderByAggregateInput
    _min?: ProfissionalMinOrderByAggregateInput
    _sum?: ProfissionalSumOrderByAggregateInput
  }

  export type ProfissionalScalarWhereWithAggregatesInput = {
    AND?: ProfissionalScalarWhereWithAggregatesInput | ProfissionalScalarWhereWithAggregatesInput[]
    OR?: ProfissionalScalarWhereWithAggregatesInput[]
    NOT?: ProfissionalScalarWhereWithAggregatesInput | ProfissionalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Profissional"> | number
    cdMaster?: IntWithAggregatesFilter<"Profissional"> | number
    nome?: StringWithAggregatesFilter<"Profissional"> | string
    sexo?: EnumSexoNullableWithAggregatesFilter<"Profissional"> | $Enums.Sexo | null
    conselho?: StringNullableWithAggregatesFilter<"Profissional"> | string | null
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"Profissional"> | $Enums.SimNao | null
    cdOcupacao?: IntNullableWithAggregatesFilter<"Profissional"> | number | null
  }

  export type EnderecoWhereInput = {
    AND?: EnderecoWhereInput | EnderecoWhereInput[]
    OR?: EnderecoWhereInput[]
    NOT?: EnderecoWhereInput | EnderecoWhereInput[]
    id?: IntFilter<"Endereco"> | number
    logradouro?: StringFilter<"Endereco"> | string
    numero?: StringNullableFilter<"Endereco"> | string | null
    complemento?: StringNullableFilter<"Endereco"> | string | null
    cdBairro?: IntFilter<"Endereco"> | number
    cdCidade?: IntFilter<"Endereco"> | number
    cep?: StringFilter<"Endereco"> | string
    stInativo?: EnumSimNaoNullableFilter<"Endereco"> | $Enums.SimNao | null
    bairro?: XOR<BairroScalarRelationFilter, BairroWhereInput>
    cidade?: XOR<CidadeScalarRelationFilter, CidadeWhereInput>
    pacientes?: EnderecoPacienteListRelationFilter
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaListRelationFilter
    profissionais?: EnderecoProfissionalListRelationFilter
  }

  export type EnderecoOrderByWithRelationInput = {
    id?: SortOrder
    logradouro?: SortOrder
    numero?: SortOrderInput | SortOrder
    complemento?: SortOrderInput | SortOrder
    cdBairro?: SortOrder
    cdCidade?: SortOrder
    cep?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    bairro?: BairroOrderByWithRelationInput
    cidade?: CidadeOrderByWithRelationInput
    pacientes?: EnderecoPacienteOrderByRelationAggregateInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaOrderByRelationAggregateInput
    profissionais?: EnderecoProfissionalOrderByRelationAggregateInput
  }

  export type EnderecoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EnderecoWhereInput | EnderecoWhereInput[]
    OR?: EnderecoWhereInput[]
    NOT?: EnderecoWhereInput | EnderecoWhereInput[]
    logradouro?: StringFilter<"Endereco"> | string
    numero?: StringNullableFilter<"Endereco"> | string | null
    complemento?: StringNullableFilter<"Endereco"> | string | null
    cdBairro?: IntFilter<"Endereco"> | number
    cdCidade?: IntFilter<"Endereco"> | number
    cep?: StringFilter<"Endereco"> | string
    stInativo?: EnumSimNaoNullableFilter<"Endereco"> | $Enums.SimNao | null
    bairro?: XOR<BairroScalarRelationFilter, BairroWhereInput>
    cidade?: XOR<CidadeScalarRelationFilter, CidadeWhereInput>
    pacientes?: EnderecoPacienteListRelationFilter
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaListRelationFilter
    profissionais?: EnderecoProfissionalListRelationFilter
  }, "id">

  export type EnderecoOrderByWithAggregationInput = {
    id?: SortOrder
    logradouro?: SortOrder
    numero?: SortOrderInput | SortOrder
    complemento?: SortOrderInput | SortOrder
    cdBairro?: SortOrder
    cdCidade?: SortOrder
    cep?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: EnderecoCountOrderByAggregateInput
    _avg?: EnderecoAvgOrderByAggregateInput
    _max?: EnderecoMaxOrderByAggregateInput
    _min?: EnderecoMinOrderByAggregateInput
    _sum?: EnderecoSumOrderByAggregateInput
  }

  export type EnderecoScalarWhereWithAggregatesInput = {
    AND?: EnderecoScalarWhereWithAggregatesInput | EnderecoScalarWhereWithAggregatesInput[]
    OR?: EnderecoScalarWhereWithAggregatesInput[]
    NOT?: EnderecoScalarWhereWithAggregatesInput | EnderecoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Endereco"> | number
    logradouro?: StringWithAggregatesFilter<"Endereco"> | string
    numero?: StringNullableWithAggregatesFilter<"Endereco"> | string | null
    complemento?: StringNullableWithAggregatesFilter<"Endereco"> | string | null
    cdBairro?: IntWithAggregatesFilter<"Endereco"> | number
    cdCidade?: IntWithAggregatesFilter<"Endereco"> | number
    cep?: StringWithAggregatesFilter<"Endereco"> | string
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"Endereco"> | $Enums.SimNao | null
  }

  export type EnderecoPacienteWhereInput = {
    AND?: EnderecoPacienteWhereInput | EnderecoPacienteWhereInput[]
    OR?: EnderecoPacienteWhereInput[]
    NOT?: EnderecoPacienteWhereInput | EnderecoPacienteWhereInput[]
    id?: IntFilter<"EnderecoPaciente"> | number
    cdMaster?: IntFilter<"EnderecoPaciente"> | number
    cdPaciente?: IntFilter<"EnderecoPaciente"> | number
    cdEndereco?: IntFilter<"EnderecoPaciente"> | number
    endereco?: XOR<EnderecoScalarRelationFilter, EnderecoWhereInput>
    paciente?: XOR<PacienteScalarRelationFilter, PacienteWhereInput>
  }

  export type EnderecoPacienteOrderByWithRelationInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdEndereco?: SortOrder
    endereco?: EnderecoOrderByWithRelationInput
    paciente?: PacienteOrderByWithRelationInput
  }

  export type EnderecoPacienteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EnderecoPacienteWhereInput | EnderecoPacienteWhereInput[]
    OR?: EnderecoPacienteWhereInput[]
    NOT?: EnderecoPacienteWhereInput | EnderecoPacienteWhereInput[]
    cdMaster?: IntFilter<"EnderecoPaciente"> | number
    cdPaciente?: IntFilter<"EnderecoPaciente"> | number
    cdEndereco?: IntFilter<"EnderecoPaciente"> | number
    endereco?: XOR<EnderecoScalarRelationFilter, EnderecoWhereInput>
    paciente?: XOR<PacienteScalarRelationFilter, PacienteWhereInput>
  }, "id">

  export type EnderecoPacienteOrderByWithAggregationInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdEndereco?: SortOrder
    _count?: EnderecoPacienteCountOrderByAggregateInput
    _avg?: EnderecoPacienteAvgOrderByAggregateInput
    _max?: EnderecoPacienteMaxOrderByAggregateInput
    _min?: EnderecoPacienteMinOrderByAggregateInput
    _sum?: EnderecoPacienteSumOrderByAggregateInput
  }

  export type EnderecoPacienteScalarWhereWithAggregatesInput = {
    AND?: EnderecoPacienteScalarWhereWithAggregatesInput | EnderecoPacienteScalarWhereWithAggregatesInput[]
    OR?: EnderecoPacienteScalarWhereWithAggregatesInput[]
    NOT?: EnderecoPacienteScalarWhereWithAggregatesInput | EnderecoPacienteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EnderecoPaciente"> | number
    cdMaster?: IntWithAggregatesFilter<"EnderecoPaciente"> | number
    cdPaciente?: IntWithAggregatesFilter<"EnderecoPaciente"> | number
    cdEndereco?: IntWithAggregatesFilter<"EnderecoPaciente"> | number
  }

  export type EnderecoProfissionalWhereInput = {
    AND?: EnderecoProfissionalWhereInput | EnderecoProfissionalWhereInput[]
    OR?: EnderecoProfissionalWhereInput[]
    NOT?: EnderecoProfissionalWhereInput | EnderecoProfissionalWhereInput[]
    id?: IntFilter<"EnderecoProfissional"> | number
    cdProf?: IntFilter<"EnderecoProfissional"> | number
    cdEndereco?: IntFilter<"EnderecoProfissional"> | number
    endereco?: XOR<EnderecoScalarRelationFilter, EnderecoWhereInput>
    profissional?: XOR<ProfissionalScalarRelationFilter, ProfissionalWhereInput>
  }

  export type EnderecoProfissionalOrderByWithRelationInput = {
    id?: SortOrder
    cdProf?: SortOrder
    cdEndereco?: SortOrder
    endereco?: EnderecoOrderByWithRelationInput
    profissional?: ProfissionalOrderByWithRelationInput
  }

  export type EnderecoProfissionalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EnderecoProfissionalWhereInput | EnderecoProfissionalWhereInput[]
    OR?: EnderecoProfissionalWhereInput[]
    NOT?: EnderecoProfissionalWhereInput | EnderecoProfissionalWhereInput[]
    cdProf?: IntFilter<"EnderecoProfissional"> | number
    cdEndereco?: IntFilter<"EnderecoProfissional"> | number
    endereco?: XOR<EnderecoScalarRelationFilter, EnderecoWhereInput>
    profissional?: XOR<ProfissionalScalarRelationFilter, ProfissionalWhereInput>
  }, "id">

  export type EnderecoProfissionalOrderByWithAggregationInput = {
    id?: SortOrder
    cdProf?: SortOrder
    cdEndereco?: SortOrder
    _count?: EnderecoProfissionalCountOrderByAggregateInput
    _avg?: EnderecoProfissionalAvgOrderByAggregateInput
    _max?: EnderecoProfissionalMaxOrderByAggregateInput
    _min?: EnderecoProfissionalMinOrderByAggregateInput
    _sum?: EnderecoProfissionalSumOrderByAggregateInput
  }

  export type EnderecoProfissionalScalarWhereWithAggregatesInput = {
    AND?: EnderecoProfissionalScalarWhereWithAggregatesInput | EnderecoProfissionalScalarWhereWithAggregatesInput[]
    OR?: EnderecoProfissionalScalarWhereWithAggregatesInput[]
    NOT?: EnderecoProfissionalScalarWhereWithAggregatesInput | EnderecoProfissionalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EnderecoProfissional"> | number
    cdProf?: IntWithAggregatesFilter<"EnderecoProfissional"> | number
    cdEndereco?: IntWithAggregatesFilter<"EnderecoProfissional"> | number
  }

  export type ContatoWhereInput = {
    AND?: ContatoWhereInput | ContatoWhereInput[]
    OR?: ContatoWhereInput[]
    NOT?: ContatoWhereInput | ContatoWhereInput[]
    id?: IntFilter<"Contato"> | number
    tipo?: EnumTipoFoneFilter<"Contato"> | $Enums.TipoFone
    numero?: StringFilter<"Contato"> | string
    stInativo?: EnumSimNaoNullableFilter<"Contato"> | $Enums.SimNao | null
    pacientes?: ContatoPacienteListRelationFilter
    profissionais?: ContatoProfissionalListRelationFilter
  }

  export type ContatoOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    numero?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    pacientes?: ContatoPacienteOrderByRelationAggregateInput
    profissionais?: ContatoProfissionalOrderByRelationAggregateInput
  }

  export type ContatoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContatoWhereInput | ContatoWhereInput[]
    OR?: ContatoWhereInput[]
    NOT?: ContatoWhereInput | ContatoWhereInput[]
    tipo?: EnumTipoFoneFilter<"Contato"> | $Enums.TipoFone
    numero?: StringFilter<"Contato"> | string
    stInativo?: EnumSimNaoNullableFilter<"Contato"> | $Enums.SimNao | null
    pacientes?: ContatoPacienteListRelationFilter
    profissionais?: ContatoProfissionalListRelationFilter
  }, "id">

  export type ContatoOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    numero?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: ContatoCountOrderByAggregateInput
    _avg?: ContatoAvgOrderByAggregateInput
    _max?: ContatoMaxOrderByAggregateInput
    _min?: ContatoMinOrderByAggregateInput
    _sum?: ContatoSumOrderByAggregateInput
  }

  export type ContatoScalarWhereWithAggregatesInput = {
    AND?: ContatoScalarWhereWithAggregatesInput | ContatoScalarWhereWithAggregatesInput[]
    OR?: ContatoScalarWhereWithAggregatesInput[]
    NOT?: ContatoScalarWhereWithAggregatesInput | ContatoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contato"> | number
    tipo?: EnumTipoFoneWithAggregatesFilter<"Contato"> | $Enums.TipoFone
    numero?: StringWithAggregatesFilter<"Contato"> | string
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"Contato"> | $Enums.SimNao | null
  }

  export type ContatoPacienteWhereInput = {
    AND?: ContatoPacienteWhereInput | ContatoPacienteWhereInput[]
    OR?: ContatoPacienteWhereInput[]
    NOT?: ContatoPacienteWhereInput | ContatoPacienteWhereInput[]
    id?: IntFilter<"ContatoPaciente"> | number
    cdMaster?: IntFilter<"ContatoPaciente"> | number
    cdPaciente?: IntFilter<"ContatoPaciente"> | number
    cdContato?: IntFilter<"ContatoPaciente"> | number
    contato?: XOR<ContatoScalarRelationFilter, ContatoWhereInput>
    paciente?: XOR<PacienteScalarRelationFilter, PacienteWhereInput>
  }

  export type ContatoPacienteOrderByWithRelationInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdContato?: SortOrder
    contato?: ContatoOrderByWithRelationInput
    paciente?: PacienteOrderByWithRelationInput
  }

  export type ContatoPacienteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContatoPacienteWhereInput | ContatoPacienteWhereInput[]
    OR?: ContatoPacienteWhereInput[]
    NOT?: ContatoPacienteWhereInput | ContatoPacienteWhereInput[]
    cdMaster?: IntFilter<"ContatoPaciente"> | number
    cdPaciente?: IntFilter<"ContatoPaciente"> | number
    cdContato?: IntFilter<"ContatoPaciente"> | number
    contato?: XOR<ContatoScalarRelationFilter, ContatoWhereInput>
    paciente?: XOR<PacienteScalarRelationFilter, PacienteWhereInput>
  }, "id">

  export type ContatoPacienteOrderByWithAggregationInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdContato?: SortOrder
    _count?: ContatoPacienteCountOrderByAggregateInput
    _avg?: ContatoPacienteAvgOrderByAggregateInput
    _max?: ContatoPacienteMaxOrderByAggregateInput
    _min?: ContatoPacienteMinOrderByAggregateInput
    _sum?: ContatoPacienteSumOrderByAggregateInput
  }

  export type ContatoPacienteScalarWhereWithAggregatesInput = {
    AND?: ContatoPacienteScalarWhereWithAggregatesInput | ContatoPacienteScalarWhereWithAggregatesInput[]
    OR?: ContatoPacienteScalarWhereWithAggregatesInput[]
    NOT?: ContatoPacienteScalarWhereWithAggregatesInput | ContatoPacienteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContatoPaciente"> | number
    cdMaster?: IntWithAggregatesFilter<"ContatoPaciente"> | number
    cdPaciente?: IntWithAggregatesFilter<"ContatoPaciente"> | number
    cdContato?: IntWithAggregatesFilter<"ContatoPaciente"> | number
  }

  export type ContatoProfissionalWhereInput = {
    AND?: ContatoProfissionalWhereInput | ContatoProfissionalWhereInput[]
    OR?: ContatoProfissionalWhereInput[]
    NOT?: ContatoProfissionalWhereInput | ContatoProfissionalWhereInput[]
    id?: IntFilter<"ContatoProfissional"> | number
    cdProf?: IntFilter<"ContatoProfissional"> | number
    cdContato?: IntFilter<"ContatoProfissional"> | number
    contato?: XOR<ContatoScalarRelationFilter, ContatoWhereInput>
    profissional?: XOR<ProfissionalScalarRelationFilter, ProfissionalWhereInput>
  }

  export type ContatoProfissionalOrderByWithRelationInput = {
    id?: SortOrder
    cdProf?: SortOrder
    cdContato?: SortOrder
    contato?: ContatoOrderByWithRelationInput
    profissional?: ProfissionalOrderByWithRelationInput
  }

  export type ContatoProfissionalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContatoProfissionalWhereInput | ContatoProfissionalWhereInput[]
    OR?: ContatoProfissionalWhereInput[]
    NOT?: ContatoProfissionalWhereInput | ContatoProfissionalWhereInput[]
    cdProf?: IntFilter<"ContatoProfissional"> | number
    cdContato?: IntFilter<"ContatoProfissional"> | number
    contato?: XOR<ContatoScalarRelationFilter, ContatoWhereInput>
    profissional?: XOR<ProfissionalScalarRelationFilter, ProfissionalWhereInput>
  }, "id">

  export type ContatoProfissionalOrderByWithAggregationInput = {
    id?: SortOrder
    cdProf?: SortOrder
    cdContato?: SortOrder
    _count?: ContatoProfissionalCountOrderByAggregateInput
    _avg?: ContatoProfissionalAvgOrderByAggregateInput
    _max?: ContatoProfissionalMaxOrderByAggregateInput
    _min?: ContatoProfissionalMinOrderByAggregateInput
    _sum?: ContatoProfissionalSumOrderByAggregateInput
  }

  export type ContatoProfissionalScalarWhereWithAggregatesInput = {
    AND?: ContatoProfissionalScalarWhereWithAggregatesInput | ContatoProfissionalScalarWhereWithAggregatesInput[]
    OR?: ContatoProfissionalScalarWhereWithAggregatesInput[]
    NOT?: ContatoProfissionalScalarWhereWithAggregatesInput | ContatoProfissionalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContatoProfissional"> | number
    cdProf?: IntWithAggregatesFilter<"ContatoProfissional"> | number
    cdContato?: IntWithAggregatesFilter<"ContatoProfissional"> | number
  }

  export type AtendimentoWhereInput = {
    AND?: AtendimentoWhereInput | AtendimentoWhereInput[]
    OR?: AtendimentoWhereInput[]
    NOT?: AtendimentoWhereInput | AtendimentoWhereInput[]
    id?: IntFilter<"Atendimento"> | number
    cdMaster?: IntFilter<"Atendimento"> | number
    cdPaciente?: IntFilter<"Atendimento"> | number
    cdProfissional?: IntFilter<"Atendimento"> | number
    data?: DateTimeFilter<"Atendimento"> | Date | string
    observacao?: StringNullableFilter<"Atendimento"> | string | null
    afericoesClinicas?: AfericaoClinicaListRelationFilter
    paciente?: XOR<PacienteScalarRelationFilter, PacienteWhereInput>
    profissional?: XOR<ProfissionalScalarRelationFilter, ProfissionalWhereInput>
    evaDores?: EvaDorListRelationFilter
    evolucoes?: EvolucaoListRelationFilter
    glasgows?: GlasgowListRelationFilter
    sinaisVitais?: SinaisVitaisListRelationFilter
  }

  export type AtendimentoOrderByWithRelationInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdProfissional?: SortOrder
    data?: SortOrder
    observacao?: SortOrderInput | SortOrder
    afericoesClinicas?: AfericaoClinicaOrderByRelationAggregateInput
    paciente?: PacienteOrderByWithRelationInput
    profissional?: ProfissionalOrderByWithRelationInput
    evaDores?: EvaDorOrderByRelationAggregateInput
    evolucoes?: EvolucaoOrderByRelationAggregateInput
    glasgows?: GlasgowOrderByRelationAggregateInput
    sinaisVitais?: SinaisVitaisOrderByRelationAggregateInput
  }

  export type AtendimentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AtendimentoWhereInput | AtendimentoWhereInput[]
    OR?: AtendimentoWhereInput[]
    NOT?: AtendimentoWhereInput | AtendimentoWhereInput[]
    cdMaster?: IntFilter<"Atendimento"> | number
    cdPaciente?: IntFilter<"Atendimento"> | number
    cdProfissional?: IntFilter<"Atendimento"> | number
    data?: DateTimeFilter<"Atendimento"> | Date | string
    observacao?: StringNullableFilter<"Atendimento"> | string | null
    afericoesClinicas?: AfericaoClinicaListRelationFilter
    paciente?: XOR<PacienteScalarRelationFilter, PacienteWhereInput>
    profissional?: XOR<ProfissionalScalarRelationFilter, ProfissionalWhereInput>
    evaDores?: EvaDorListRelationFilter
    evolucoes?: EvolucaoListRelationFilter
    glasgows?: GlasgowListRelationFilter
    sinaisVitais?: SinaisVitaisListRelationFilter
  }, "id">

  export type AtendimentoOrderByWithAggregationInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdProfissional?: SortOrder
    data?: SortOrder
    observacao?: SortOrderInput | SortOrder
    _count?: AtendimentoCountOrderByAggregateInput
    _avg?: AtendimentoAvgOrderByAggregateInput
    _max?: AtendimentoMaxOrderByAggregateInput
    _min?: AtendimentoMinOrderByAggregateInput
    _sum?: AtendimentoSumOrderByAggregateInput
  }

  export type AtendimentoScalarWhereWithAggregatesInput = {
    AND?: AtendimentoScalarWhereWithAggregatesInput | AtendimentoScalarWhereWithAggregatesInput[]
    OR?: AtendimentoScalarWhereWithAggregatesInput[]
    NOT?: AtendimentoScalarWhereWithAggregatesInput | AtendimentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Atendimento"> | number
    cdMaster?: IntWithAggregatesFilter<"Atendimento"> | number
    cdPaciente?: IntWithAggregatesFilter<"Atendimento"> | number
    cdProfissional?: IntWithAggregatesFilter<"Atendimento"> | number
    data?: DateTimeWithAggregatesFilter<"Atendimento"> | Date | string
    observacao?: StringNullableWithAggregatesFilter<"Atendimento"> | string | null
  }

  export type EvolucaoWhereInput = {
    AND?: EvolucaoWhereInput | EvolucaoWhereInput[]
    OR?: EvolucaoWhereInput[]
    NOT?: EvolucaoWhereInput | EvolucaoWhereInput[]
    id?: IntFilter<"Evolucao"> | number
    cdAtendimento?: IntFilter<"Evolucao"> | number
    cdProfissional?: IntNullableFilter<"Evolucao"> | number | null
    data?: DateTimeFilter<"Evolucao"> | Date | string
    texto?: StringFilter<"Evolucao"> | string
    pacienteCdMaster?: IntNullableFilter<"Evolucao"> | number | null
    pacienteCdPaciente?: IntNullableFilter<"Evolucao"> | number | null
    tipoEvolucaoClinicaId?: IntNullableFilter<"Evolucao"> | number | null
    atendimento?: XOR<AtendimentoScalarRelationFilter, AtendimentoWhereInput>
    profissional?: XOR<ProfissionalNullableScalarRelationFilter, ProfissionalWhereInput> | null
    paciente?: XOR<PacienteNullableScalarRelationFilter, PacienteWhereInput> | null
    tipoEvolucaoClinica?: XOR<TipoEvolucaoClinicaNullableScalarRelationFilter, TipoEvolucaoClinicaWhereInput> | null
    cid?: EvolucaoCidListRelationFilter
    dsm?: EvolucaoDsmListRelationFilter
  }

  export type EvolucaoOrderByWithRelationInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrderInput | SortOrder
    data?: SortOrder
    texto?: SortOrder
    pacienteCdMaster?: SortOrderInput | SortOrder
    pacienteCdPaciente?: SortOrderInput | SortOrder
    tipoEvolucaoClinicaId?: SortOrderInput | SortOrder
    atendimento?: AtendimentoOrderByWithRelationInput
    profissional?: ProfissionalOrderByWithRelationInput
    paciente?: PacienteOrderByWithRelationInput
    tipoEvolucaoClinica?: TipoEvolucaoClinicaOrderByWithRelationInput
    cid?: EvolucaoCidOrderByRelationAggregateInput
    dsm?: EvolucaoDsmOrderByRelationAggregateInput
  }

  export type EvolucaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EvolucaoWhereInput | EvolucaoWhereInput[]
    OR?: EvolucaoWhereInput[]
    NOT?: EvolucaoWhereInput | EvolucaoWhereInput[]
    cdAtendimento?: IntFilter<"Evolucao"> | number
    cdProfissional?: IntNullableFilter<"Evolucao"> | number | null
    data?: DateTimeFilter<"Evolucao"> | Date | string
    texto?: StringFilter<"Evolucao"> | string
    pacienteCdMaster?: IntNullableFilter<"Evolucao"> | number | null
    pacienteCdPaciente?: IntNullableFilter<"Evolucao"> | number | null
    tipoEvolucaoClinicaId?: IntNullableFilter<"Evolucao"> | number | null
    atendimento?: XOR<AtendimentoScalarRelationFilter, AtendimentoWhereInput>
    profissional?: XOR<ProfissionalNullableScalarRelationFilter, ProfissionalWhereInput> | null
    paciente?: XOR<PacienteNullableScalarRelationFilter, PacienteWhereInput> | null
    tipoEvolucaoClinica?: XOR<TipoEvolucaoClinicaNullableScalarRelationFilter, TipoEvolucaoClinicaWhereInput> | null
    cid?: EvolucaoCidListRelationFilter
    dsm?: EvolucaoDsmListRelationFilter
  }, "id">

  export type EvolucaoOrderByWithAggregationInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrderInput | SortOrder
    data?: SortOrder
    texto?: SortOrder
    pacienteCdMaster?: SortOrderInput | SortOrder
    pacienteCdPaciente?: SortOrderInput | SortOrder
    tipoEvolucaoClinicaId?: SortOrderInput | SortOrder
    _count?: EvolucaoCountOrderByAggregateInput
    _avg?: EvolucaoAvgOrderByAggregateInput
    _max?: EvolucaoMaxOrderByAggregateInput
    _min?: EvolucaoMinOrderByAggregateInput
    _sum?: EvolucaoSumOrderByAggregateInput
  }

  export type EvolucaoScalarWhereWithAggregatesInput = {
    AND?: EvolucaoScalarWhereWithAggregatesInput | EvolucaoScalarWhereWithAggregatesInput[]
    OR?: EvolucaoScalarWhereWithAggregatesInput[]
    NOT?: EvolucaoScalarWhereWithAggregatesInput | EvolucaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Evolucao"> | number
    cdAtendimento?: IntWithAggregatesFilter<"Evolucao"> | number
    cdProfissional?: IntNullableWithAggregatesFilter<"Evolucao"> | number | null
    data?: DateTimeWithAggregatesFilter<"Evolucao"> | Date | string
    texto?: StringWithAggregatesFilter<"Evolucao"> | string
    pacienteCdMaster?: IntNullableWithAggregatesFilter<"Evolucao"> | number | null
    pacienteCdPaciente?: IntNullableWithAggregatesFilter<"Evolucao"> | number | null
    tipoEvolucaoClinicaId?: IntNullableWithAggregatesFilter<"Evolucao"> | number | null
  }

  export type PessoaRelacionadaWhereInput = {
    AND?: PessoaRelacionadaWhereInput | PessoaRelacionadaWhereInput[]
    OR?: PessoaRelacionadaWhereInput[]
    NOT?: PessoaRelacionadaWhereInput | PessoaRelacionadaWhereInput[]
    id?: IntFilter<"PessoaRelacionada"> | number
    nome?: StringFilter<"PessoaRelacionada"> | string
    telefone?: StringNullableFilter<"PessoaRelacionada"> | string | null
    stInativo?: EnumSimNaoNullableFilter<"PessoaRelacionada"> | $Enums.SimNao | null
    enderecos?: EnderecoPessoaRelacionadaListRelationFilter
    parentescos?: ParentescoPacienteListRelationFilter
  }

  export type PessoaRelacionadaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrderInput | SortOrder
    stInativo?: SortOrderInput | SortOrder
    enderecos?: EnderecoPessoaRelacionadaOrderByRelationAggregateInput
    parentescos?: ParentescoPacienteOrderByRelationAggregateInput
  }

  export type PessoaRelacionadaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PessoaRelacionadaWhereInput | PessoaRelacionadaWhereInput[]
    OR?: PessoaRelacionadaWhereInput[]
    NOT?: PessoaRelacionadaWhereInput | PessoaRelacionadaWhereInput[]
    nome?: StringFilter<"PessoaRelacionada"> | string
    telefone?: StringNullableFilter<"PessoaRelacionada"> | string | null
    stInativo?: EnumSimNaoNullableFilter<"PessoaRelacionada"> | $Enums.SimNao | null
    enderecos?: EnderecoPessoaRelacionadaListRelationFilter
    parentescos?: ParentescoPacienteListRelationFilter
  }, "id">

  export type PessoaRelacionadaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrderInput | SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: PessoaRelacionadaCountOrderByAggregateInput
    _avg?: PessoaRelacionadaAvgOrderByAggregateInput
    _max?: PessoaRelacionadaMaxOrderByAggregateInput
    _min?: PessoaRelacionadaMinOrderByAggregateInput
    _sum?: PessoaRelacionadaSumOrderByAggregateInput
  }

  export type PessoaRelacionadaScalarWhereWithAggregatesInput = {
    AND?: PessoaRelacionadaScalarWhereWithAggregatesInput | PessoaRelacionadaScalarWhereWithAggregatesInput[]
    OR?: PessoaRelacionadaScalarWhereWithAggregatesInput[]
    NOT?: PessoaRelacionadaScalarWhereWithAggregatesInput | PessoaRelacionadaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PessoaRelacionada"> | number
    nome?: StringWithAggregatesFilter<"PessoaRelacionada"> | string
    telefone?: StringNullableWithAggregatesFilter<"PessoaRelacionada"> | string | null
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"PessoaRelacionada"> | $Enums.SimNao | null
  }

  export type ParentescoPacienteWhereInput = {
    AND?: ParentescoPacienteWhereInput | ParentescoPacienteWhereInput[]
    OR?: ParentescoPacienteWhereInput[]
    NOT?: ParentescoPacienteWhereInput | ParentescoPacienteWhereInput[]
    id?: IntFilter<"ParentescoPaciente"> | number
    cdMaster?: IntFilter<"ParentescoPaciente"> | number
    cdPaciente?: IntFilter<"ParentescoPaciente"> | number
    cdPessoa?: IntFilter<"ParentescoPaciente"> | number
    parentesco?: EnumTipoParentescoFilter<"ParentescoPaciente"> | $Enums.TipoParentesco
    paciente?: XOR<PacienteScalarRelationFilter, PacienteWhereInput>
    pessoaRelacionada?: XOR<PessoaRelacionadaScalarRelationFilter, PessoaRelacionadaWhereInput>
  }

  export type ParentescoPacienteOrderByWithRelationInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdPessoa?: SortOrder
    parentesco?: SortOrder
    paciente?: PacienteOrderByWithRelationInput
    pessoaRelacionada?: PessoaRelacionadaOrderByWithRelationInput
  }

  export type ParentescoPacienteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ParentescoPacienteWhereInput | ParentescoPacienteWhereInput[]
    OR?: ParentescoPacienteWhereInput[]
    NOT?: ParentescoPacienteWhereInput | ParentescoPacienteWhereInput[]
    cdMaster?: IntFilter<"ParentescoPaciente"> | number
    cdPaciente?: IntFilter<"ParentescoPaciente"> | number
    cdPessoa?: IntFilter<"ParentescoPaciente"> | number
    parentesco?: EnumTipoParentescoFilter<"ParentescoPaciente"> | $Enums.TipoParentesco
    paciente?: XOR<PacienteScalarRelationFilter, PacienteWhereInput>
    pessoaRelacionada?: XOR<PessoaRelacionadaScalarRelationFilter, PessoaRelacionadaWhereInput>
  }, "id">

  export type ParentescoPacienteOrderByWithAggregationInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdPessoa?: SortOrder
    parentesco?: SortOrder
    _count?: ParentescoPacienteCountOrderByAggregateInput
    _avg?: ParentescoPacienteAvgOrderByAggregateInput
    _max?: ParentescoPacienteMaxOrderByAggregateInput
    _min?: ParentescoPacienteMinOrderByAggregateInput
    _sum?: ParentescoPacienteSumOrderByAggregateInput
  }

  export type ParentescoPacienteScalarWhereWithAggregatesInput = {
    AND?: ParentescoPacienteScalarWhereWithAggregatesInput | ParentescoPacienteScalarWhereWithAggregatesInput[]
    OR?: ParentescoPacienteScalarWhereWithAggregatesInput[]
    NOT?: ParentescoPacienteScalarWhereWithAggregatesInput | ParentescoPacienteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ParentescoPaciente"> | number
    cdMaster?: IntWithAggregatesFilter<"ParentescoPaciente"> | number
    cdPaciente?: IntWithAggregatesFilter<"ParentescoPaciente"> | number
    cdPessoa?: IntWithAggregatesFilter<"ParentescoPaciente"> | number
    parentesco?: EnumTipoParentescoWithAggregatesFilter<"ParentescoPaciente"> | $Enums.TipoParentesco
  }

  export type PlanoWhereInput = {
    AND?: PlanoWhereInput | PlanoWhereInput[]
    OR?: PlanoWhereInput[]
    NOT?: PlanoWhereInput | PlanoWhereInput[]
    id?: IntFilter<"Plano"> | number
    descricao?: StringFilter<"Plano"> | string
    stInativo?: EnumSimNaoNullableFilter<"Plano"> | $Enums.SimNao | null
  }

  export type PlanoOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
  }

  export type PlanoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlanoWhereInput | PlanoWhereInput[]
    OR?: PlanoWhereInput[]
    NOT?: PlanoWhereInput | PlanoWhereInput[]
    descricao?: StringFilter<"Plano"> | string
    stInativo?: EnumSimNaoNullableFilter<"Plano"> | $Enums.SimNao | null
  }, "id">

  export type PlanoOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: PlanoCountOrderByAggregateInput
    _avg?: PlanoAvgOrderByAggregateInput
    _max?: PlanoMaxOrderByAggregateInput
    _min?: PlanoMinOrderByAggregateInput
    _sum?: PlanoSumOrderByAggregateInput
  }

  export type PlanoScalarWhereWithAggregatesInput = {
    AND?: PlanoScalarWhereWithAggregatesInput | PlanoScalarWhereWithAggregatesInput[]
    OR?: PlanoScalarWhereWithAggregatesInput[]
    NOT?: PlanoScalarWhereWithAggregatesInput | PlanoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Plano"> | number
    descricao?: StringWithAggregatesFilter<"Plano"> | string
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"Plano"> | $Enums.SimNao | null
  }

  export type MotivoWhereInput = {
    AND?: MotivoWhereInput | MotivoWhereInput[]
    OR?: MotivoWhereInput[]
    NOT?: MotivoWhereInput | MotivoWhereInput[]
    id?: IntFilter<"Motivo"> | number
    descricao?: StringFilter<"Motivo"> | string
    stInativo?: EnumSimNaoNullableFilter<"Motivo"> | $Enums.SimNao | null
  }

  export type MotivoOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
  }

  export type MotivoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MotivoWhereInput | MotivoWhereInput[]
    OR?: MotivoWhereInput[]
    NOT?: MotivoWhereInput | MotivoWhereInput[]
    descricao?: StringFilter<"Motivo"> | string
    stInativo?: EnumSimNaoNullableFilter<"Motivo"> | $Enums.SimNao | null
  }, "id">

  export type MotivoOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: MotivoCountOrderByAggregateInput
    _avg?: MotivoAvgOrderByAggregateInput
    _max?: MotivoMaxOrderByAggregateInput
    _min?: MotivoMinOrderByAggregateInput
    _sum?: MotivoSumOrderByAggregateInput
  }

  export type MotivoScalarWhereWithAggregatesInput = {
    AND?: MotivoScalarWhereWithAggregatesInput | MotivoScalarWhereWithAggregatesInput[]
    OR?: MotivoScalarWhereWithAggregatesInput[]
    NOT?: MotivoScalarWhereWithAggregatesInput | MotivoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Motivo"> | number
    descricao?: StringWithAggregatesFilter<"Motivo"> | string
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"Motivo"> | $Enums.SimNao | null
  }

  export type TipoProcedimentoWhereInput = {
    AND?: TipoProcedimentoWhereInput | TipoProcedimentoWhereInput[]
    OR?: TipoProcedimentoWhereInput[]
    NOT?: TipoProcedimentoWhereInput | TipoProcedimentoWhereInput[]
    id?: IntFilter<"TipoProcedimento"> | number
    descricao?: StringFilter<"TipoProcedimento"> | string
    stInativo?: EnumSimNaoNullableFilter<"TipoProcedimento"> | $Enums.SimNao | null
  }

  export type TipoProcedimentoOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
  }

  export type TipoProcedimentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TipoProcedimentoWhereInput | TipoProcedimentoWhereInput[]
    OR?: TipoProcedimentoWhereInput[]
    NOT?: TipoProcedimentoWhereInput | TipoProcedimentoWhereInput[]
    descricao?: StringFilter<"TipoProcedimento"> | string
    stInativo?: EnumSimNaoNullableFilter<"TipoProcedimento"> | $Enums.SimNao | null
  }, "id">

  export type TipoProcedimentoOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: TipoProcedimentoCountOrderByAggregateInput
    _avg?: TipoProcedimentoAvgOrderByAggregateInput
    _max?: TipoProcedimentoMaxOrderByAggregateInput
    _min?: TipoProcedimentoMinOrderByAggregateInput
    _sum?: TipoProcedimentoSumOrderByAggregateInput
  }

  export type TipoProcedimentoScalarWhereWithAggregatesInput = {
    AND?: TipoProcedimentoScalarWhereWithAggregatesInput | TipoProcedimentoScalarWhereWithAggregatesInput[]
    OR?: TipoProcedimentoScalarWhereWithAggregatesInput[]
    NOT?: TipoProcedimentoScalarWhereWithAggregatesInput | TipoProcedimentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TipoProcedimento"> | number
    descricao?: StringWithAggregatesFilter<"TipoProcedimento"> | string
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"TipoProcedimento"> | $Enums.SimNao | null
  }

  export type TipoEvolucaoSimplesWhereInput = {
    AND?: TipoEvolucaoSimplesWhereInput | TipoEvolucaoSimplesWhereInput[]
    OR?: TipoEvolucaoSimplesWhereInput[]
    NOT?: TipoEvolucaoSimplesWhereInput | TipoEvolucaoSimplesWhereInput[]
    id?: IntFilter<"TipoEvolucaoSimples"> | number
    descricao?: StringFilter<"TipoEvolucaoSimples"> | string
    stInativo?: EnumSimNaoNullableFilter<"TipoEvolucaoSimples"> | $Enums.SimNao | null
  }

  export type TipoEvolucaoSimplesOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
  }

  export type TipoEvolucaoSimplesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TipoEvolucaoSimplesWhereInput | TipoEvolucaoSimplesWhereInput[]
    OR?: TipoEvolucaoSimplesWhereInput[]
    NOT?: TipoEvolucaoSimplesWhereInput | TipoEvolucaoSimplesWhereInput[]
    descricao?: StringFilter<"TipoEvolucaoSimples"> | string
    stInativo?: EnumSimNaoNullableFilter<"TipoEvolucaoSimples"> | $Enums.SimNao | null
  }, "id">

  export type TipoEvolucaoSimplesOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: TipoEvolucaoSimplesCountOrderByAggregateInput
    _avg?: TipoEvolucaoSimplesAvgOrderByAggregateInput
    _max?: TipoEvolucaoSimplesMaxOrderByAggregateInput
    _min?: TipoEvolucaoSimplesMinOrderByAggregateInput
    _sum?: TipoEvolucaoSimplesSumOrderByAggregateInput
  }

  export type TipoEvolucaoSimplesScalarWhereWithAggregatesInput = {
    AND?: TipoEvolucaoSimplesScalarWhereWithAggregatesInput | TipoEvolucaoSimplesScalarWhereWithAggregatesInput[]
    OR?: TipoEvolucaoSimplesScalarWhereWithAggregatesInput[]
    NOT?: TipoEvolucaoSimplesScalarWhereWithAggregatesInput | TipoEvolucaoSimplesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TipoEvolucaoSimples"> | number
    descricao?: StringWithAggregatesFilter<"TipoEvolucaoSimples"> | string
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"TipoEvolucaoSimples"> | $Enums.SimNao | null
  }

  export type PaisWhereInput = {
    AND?: PaisWhereInput | PaisWhereInput[]
    OR?: PaisWhereInput[]
    NOT?: PaisWhereInput | PaisWhereInput[]
    id?: IntFilter<"Pais"> | number
    descricao?: StringFilter<"Pais"> | string
    nacionalidade?: StringNullableFilter<"Pais"> | string | null
    cdIbge?: IntNullableFilter<"Pais"> | number | null
    cidades?: CidadeListRelationFilter
  }

  export type PaisOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    nacionalidade?: SortOrderInput | SortOrder
    cdIbge?: SortOrderInput | SortOrder
    cidades?: CidadeOrderByRelationAggregateInput
  }

  export type PaisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaisWhereInput | PaisWhereInput[]
    OR?: PaisWhereInput[]
    NOT?: PaisWhereInput | PaisWhereInput[]
    descricao?: StringFilter<"Pais"> | string
    nacionalidade?: StringNullableFilter<"Pais"> | string | null
    cdIbge?: IntNullableFilter<"Pais"> | number | null
    cidades?: CidadeListRelationFilter
  }, "id">

  export type PaisOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    nacionalidade?: SortOrderInput | SortOrder
    cdIbge?: SortOrderInput | SortOrder
    _count?: PaisCountOrderByAggregateInput
    _avg?: PaisAvgOrderByAggregateInput
    _max?: PaisMaxOrderByAggregateInput
    _min?: PaisMinOrderByAggregateInput
    _sum?: PaisSumOrderByAggregateInput
  }

  export type PaisScalarWhereWithAggregatesInput = {
    AND?: PaisScalarWhereWithAggregatesInput | PaisScalarWhereWithAggregatesInput[]
    OR?: PaisScalarWhereWithAggregatesInput[]
    NOT?: PaisScalarWhereWithAggregatesInput | PaisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pais"> | number
    descricao?: StringWithAggregatesFilter<"Pais"> | string
    nacionalidade?: StringNullableWithAggregatesFilter<"Pais"> | string | null
    cdIbge?: IntNullableWithAggregatesFilter<"Pais"> | number | null
  }

  export type UnidadeFederacaoWhereInput = {
    AND?: UnidadeFederacaoWhereInput | UnidadeFederacaoWhereInput[]
    OR?: UnidadeFederacaoWhereInput[]
    NOT?: UnidadeFederacaoWhereInput | UnidadeFederacaoWhereInput[]
    id?: StringFilter<"UnidadeFederacao"> | string
    descricao?: StringFilter<"UnidadeFederacao"> | string
    cdIbge?: IntNullableFilter<"UnidadeFederacao"> | number | null
    cidades?: CidadeListRelationFilter
  }

  export type UnidadeFederacaoOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    cdIbge?: SortOrderInput | SortOrder
    cidades?: CidadeOrderByRelationAggregateInput
  }

  export type UnidadeFederacaoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnidadeFederacaoWhereInput | UnidadeFederacaoWhereInput[]
    OR?: UnidadeFederacaoWhereInput[]
    NOT?: UnidadeFederacaoWhereInput | UnidadeFederacaoWhereInput[]
    descricao?: StringFilter<"UnidadeFederacao"> | string
    cdIbge?: IntNullableFilter<"UnidadeFederacao"> | number | null
    cidades?: CidadeListRelationFilter
  }, "id">

  export type UnidadeFederacaoOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    cdIbge?: SortOrderInput | SortOrder
    _count?: UnidadeFederacaoCountOrderByAggregateInput
    _avg?: UnidadeFederacaoAvgOrderByAggregateInput
    _max?: UnidadeFederacaoMaxOrderByAggregateInput
    _min?: UnidadeFederacaoMinOrderByAggregateInput
    _sum?: UnidadeFederacaoSumOrderByAggregateInput
  }

  export type UnidadeFederacaoScalarWhereWithAggregatesInput = {
    AND?: UnidadeFederacaoScalarWhereWithAggregatesInput | UnidadeFederacaoScalarWhereWithAggregatesInput[]
    OR?: UnidadeFederacaoScalarWhereWithAggregatesInput[]
    NOT?: UnidadeFederacaoScalarWhereWithAggregatesInput | UnidadeFederacaoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnidadeFederacao"> | string
    descricao?: StringWithAggregatesFilter<"UnidadeFederacao"> | string
    cdIbge?: IntNullableWithAggregatesFilter<"UnidadeFederacao"> | number | null
  }

  export type CidadeWhereInput = {
    AND?: CidadeWhereInput | CidadeWhereInput[]
    OR?: CidadeWhereInput[]
    NOT?: CidadeWhereInput | CidadeWhereInput[]
    id?: IntFilter<"Cidade"> | number
    descricao?: StringFilter<"Cidade"> | string
    cdUf?: StringFilter<"Cidade"> | string
    cdPais?: IntFilter<"Cidade"> | number
    cepGeral?: StringNullableFilter<"Cidade"> | string | null
    cdIbge?: IntNullableFilter<"Cidade"> | number | null
    stInativo?: EnumSimNaoNullableFilter<"Cidade"> | $Enums.SimNao | null
    bairros?: BairroListRelationFilter
    pais?: XOR<PaisScalarRelationFilter, PaisWhereInput>
    uf?: XOR<UnidadeFederacaoScalarRelationFilter, UnidadeFederacaoWhereInput>
    distritos?: DistritoListRelationFilter
    enderecos?: EnderecoListRelationFilter
  }

  export type CidadeOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    cdUf?: SortOrder
    cdPais?: SortOrder
    cepGeral?: SortOrderInput | SortOrder
    cdIbge?: SortOrderInput | SortOrder
    stInativo?: SortOrderInput | SortOrder
    bairros?: BairroOrderByRelationAggregateInput
    pais?: PaisOrderByWithRelationInput
    uf?: UnidadeFederacaoOrderByWithRelationInput
    distritos?: DistritoOrderByRelationAggregateInput
    enderecos?: EnderecoOrderByRelationAggregateInput
  }

  export type CidadeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CidadeWhereInput | CidadeWhereInput[]
    OR?: CidadeWhereInput[]
    NOT?: CidadeWhereInput | CidadeWhereInput[]
    descricao?: StringFilter<"Cidade"> | string
    cdUf?: StringFilter<"Cidade"> | string
    cdPais?: IntFilter<"Cidade"> | number
    cepGeral?: StringNullableFilter<"Cidade"> | string | null
    cdIbge?: IntNullableFilter<"Cidade"> | number | null
    stInativo?: EnumSimNaoNullableFilter<"Cidade"> | $Enums.SimNao | null
    bairros?: BairroListRelationFilter
    pais?: XOR<PaisScalarRelationFilter, PaisWhereInput>
    uf?: XOR<UnidadeFederacaoScalarRelationFilter, UnidadeFederacaoWhereInput>
    distritos?: DistritoListRelationFilter
    enderecos?: EnderecoListRelationFilter
  }, "id">

  export type CidadeOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    cdUf?: SortOrder
    cdPais?: SortOrder
    cepGeral?: SortOrderInput | SortOrder
    cdIbge?: SortOrderInput | SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: CidadeCountOrderByAggregateInput
    _avg?: CidadeAvgOrderByAggregateInput
    _max?: CidadeMaxOrderByAggregateInput
    _min?: CidadeMinOrderByAggregateInput
    _sum?: CidadeSumOrderByAggregateInput
  }

  export type CidadeScalarWhereWithAggregatesInput = {
    AND?: CidadeScalarWhereWithAggregatesInput | CidadeScalarWhereWithAggregatesInput[]
    OR?: CidadeScalarWhereWithAggregatesInput[]
    NOT?: CidadeScalarWhereWithAggregatesInput | CidadeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cidade"> | number
    descricao?: StringWithAggregatesFilter<"Cidade"> | string
    cdUf?: StringWithAggregatesFilter<"Cidade"> | string
    cdPais?: IntWithAggregatesFilter<"Cidade"> | number
    cepGeral?: StringNullableWithAggregatesFilter<"Cidade"> | string | null
    cdIbge?: IntNullableWithAggregatesFilter<"Cidade"> | number | null
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"Cidade"> | $Enums.SimNao | null
  }

  export type EscolaridadeWhereInput = {
    AND?: EscolaridadeWhereInput | EscolaridadeWhereInput[]
    OR?: EscolaridadeWhereInput[]
    NOT?: EscolaridadeWhereInput | EscolaridadeWhereInput[]
    id?: IntFilter<"Escolaridade"> | number
    descricao?: StringFilter<"Escolaridade"> | string
    stInativo?: EnumSimNaoNullableFilter<"Escolaridade"> | $Enums.SimNao | null
    pacientes?: PacienteListRelationFilter
  }

  export type EscolaridadeOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    pacientes?: PacienteOrderByRelationAggregateInput
  }

  export type EscolaridadeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EscolaridadeWhereInput | EscolaridadeWhereInput[]
    OR?: EscolaridadeWhereInput[]
    NOT?: EscolaridadeWhereInput | EscolaridadeWhereInput[]
    descricao?: StringFilter<"Escolaridade"> | string
    stInativo?: EnumSimNaoNullableFilter<"Escolaridade"> | $Enums.SimNao | null
    pacientes?: PacienteListRelationFilter
  }, "id">

  export type EscolaridadeOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: EscolaridadeCountOrderByAggregateInput
    _avg?: EscolaridadeAvgOrderByAggregateInput
    _max?: EscolaridadeMaxOrderByAggregateInput
    _min?: EscolaridadeMinOrderByAggregateInput
    _sum?: EscolaridadeSumOrderByAggregateInput
  }

  export type EscolaridadeScalarWhereWithAggregatesInput = {
    AND?: EscolaridadeScalarWhereWithAggregatesInput | EscolaridadeScalarWhereWithAggregatesInput[]
    OR?: EscolaridadeScalarWhereWithAggregatesInput[]
    NOT?: EscolaridadeScalarWhereWithAggregatesInput | EscolaridadeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Escolaridade"> | number
    descricao?: StringWithAggregatesFilter<"Escolaridade"> | string
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"Escolaridade"> | $Enums.SimNao | null
  }

  export type OcupacaoWhereInput = {
    AND?: OcupacaoWhereInput | OcupacaoWhereInput[]
    OR?: OcupacaoWhereInput[]
    NOT?: OcupacaoWhereInput | OcupacaoWhereInput[]
    id?: IntFilter<"Ocupacao"> | number
    descricao?: StringFilter<"Ocupacao"> | string
    cbo?: StringNullableFilter<"Ocupacao"> | string | null
    stInativo?: EnumSimNaoNullableFilter<"Ocupacao"> | $Enums.SimNao | null
    pacientes?: PacienteListRelationFilter
    profissionals?: ProfissionalListRelationFilter
  }

  export type OcupacaoOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    cbo?: SortOrderInput | SortOrder
    stInativo?: SortOrderInput | SortOrder
    pacientes?: PacienteOrderByRelationAggregateInput
    profissionals?: ProfissionalOrderByRelationAggregateInput
  }

  export type OcupacaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OcupacaoWhereInput | OcupacaoWhereInput[]
    OR?: OcupacaoWhereInput[]
    NOT?: OcupacaoWhereInput | OcupacaoWhereInput[]
    descricao?: StringFilter<"Ocupacao"> | string
    cbo?: StringNullableFilter<"Ocupacao"> | string | null
    stInativo?: EnumSimNaoNullableFilter<"Ocupacao"> | $Enums.SimNao | null
    pacientes?: PacienteListRelationFilter
    profissionals?: ProfissionalListRelationFilter
  }, "id">

  export type OcupacaoOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    cbo?: SortOrderInput | SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: OcupacaoCountOrderByAggregateInput
    _avg?: OcupacaoAvgOrderByAggregateInput
    _max?: OcupacaoMaxOrderByAggregateInput
    _min?: OcupacaoMinOrderByAggregateInput
    _sum?: OcupacaoSumOrderByAggregateInput
  }

  export type OcupacaoScalarWhereWithAggregatesInput = {
    AND?: OcupacaoScalarWhereWithAggregatesInput | OcupacaoScalarWhereWithAggregatesInput[]
    OR?: OcupacaoScalarWhereWithAggregatesInput[]
    NOT?: OcupacaoScalarWhereWithAggregatesInput | OcupacaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ocupacao"> | number
    descricao?: StringWithAggregatesFilter<"Ocupacao"> | string
    cbo?: StringNullableWithAggregatesFilter<"Ocupacao"> | string | null
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"Ocupacao"> | $Enums.SimNao | null
  }

  export type DistritoWhereInput = {
    AND?: DistritoWhereInput | DistritoWhereInput[]
    OR?: DistritoWhereInput[]
    NOT?: DistritoWhereInput | DistritoWhereInput[]
    id?: IntFilter<"Distrito"> | number
    cdCidade?: IntFilter<"Distrito"> | number
    descricao?: StringFilter<"Distrito"> | string
    stInativo?: EnumSimNaoNullableFilter<"Distrito"> | $Enums.SimNao | null
    bairros?: BairroListRelationFilter
    cidade?: XOR<CidadeScalarRelationFilter, CidadeWhereInput>
  }

  export type DistritoOrderByWithRelationInput = {
    id?: SortOrder
    cdCidade?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    bairros?: BairroOrderByRelationAggregateInput
    cidade?: CidadeOrderByWithRelationInput
  }

  export type DistritoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DistritoWhereInput | DistritoWhereInput[]
    OR?: DistritoWhereInput[]
    NOT?: DistritoWhereInput | DistritoWhereInput[]
    cdCidade?: IntFilter<"Distrito"> | number
    descricao?: StringFilter<"Distrito"> | string
    stInativo?: EnumSimNaoNullableFilter<"Distrito"> | $Enums.SimNao | null
    bairros?: BairroListRelationFilter
    cidade?: XOR<CidadeScalarRelationFilter, CidadeWhereInput>
  }, "id">

  export type DistritoOrderByWithAggregationInput = {
    id?: SortOrder
    cdCidade?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: DistritoCountOrderByAggregateInput
    _avg?: DistritoAvgOrderByAggregateInput
    _max?: DistritoMaxOrderByAggregateInput
    _min?: DistritoMinOrderByAggregateInput
    _sum?: DistritoSumOrderByAggregateInput
  }

  export type DistritoScalarWhereWithAggregatesInput = {
    AND?: DistritoScalarWhereWithAggregatesInput | DistritoScalarWhereWithAggregatesInput[]
    OR?: DistritoScalarWhereWithAggregatesInput[]
    NOT?: DistritoScalarWhereWithAggregatesInput | DistritoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Distrito"> | number
    cdCidade?: IntWithAggregatesFilter<"Distrito"> | number
    descricao?: StringWithAggregatesFilter<"Distrito"> | string
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"Distrito"> | $Enums.SimNao | null
  }

  export type BairroWhereInput = {
    AND?: BairroWhereInput | BairroWhereInput[]
    OR?: BairroWhereInput[]
    NOT?: BairroWhereInput | BairroWhereInput[]
    id?: IntFilter<"Bairro"> | number
    cdDistrito?: IntNullableFilter<"Bairro"> | number | null
    cdCidade?: IntFilter<"Bairro"> | number
    descricao?: StringFilter<"Bairro"> | string
    stInativo?: EnumSimNaoNullableFilter<"Bairro"> | $Enums.SimNao | null
    cidade?: XOR<CidadeScalarRelationFilter, CidadeWhereInput>
    distrito?: XOR<DistritoNullableScalarRelationFilter, DistritoWhereInput> | null
    enderecos?: EnderecoListRelationFilter
  }

  export type BairroOrderByWithRelationInput = {
    id?: SortOrder
    cdDistrito?: SortOrderInput | SortOrder
    cdCidade?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    cidade?: CidadeOrderByWithRelationInput
    distrito?: DistritoOrderByWithRelationInput
    enderecos?: EnderecoOrderByRelationAggregateInput
  }

  export type BairroWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BairroWhereInput | BairroWhereInput[]
    OR?: BairroWhereInput[]
    NOT?: BairroWhereInput | BairroWhereInput[]
    cdDistrito?: IntNullableFilter<"Bairro"> | number | null
    cdCidade?: IntFilter<"Bairro"> | number
    descricao?: StringFilter<"Bairro"> | string
    stInativo?: EnumSimNaoNullableFilter<"Bairro"> | $Enums.SimNao | null
    cidade?: XOR<CidadeScalarRelationFilter, CidadeWhereInput>
    distrito?: XOR<DistritoNullableScalarRelationFilter, DistritoWhereInput> | null
    enderecos?: EnderecoListRelationFilter
  }, "id">

  export type BairroOrderByWithAggregationInput = {
    id?: SortOrder
    cdDistrito?: SortOrderInput | SortOrder
    cdCidade?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: BairroCountOrderByAggregateInput
    _avg?: BairroAvgOrderByAggregateInput
    _max?: BairroMaxOrderByAggregateInput
    _min?: BairroMinOrderByAggregateInput
    _sum?: BairroSumOrderByAggregateInput
  }

  export type BairroScalarWhereWithAggregatesInput = {
    AND?: BairroScalarWhereWithAggregatesInput | BairroScalarWhereWithAggregatesInput[]
    OR?: BairroScalarWhereWithAggregatesInput[]
    NOT?: BairroScalarWhereWithAggregatesInput | BairroScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bairro"> | number
    cdDistrito?: IntNullableWithAggregatesFilter<"Bairro"> | number | null
    cdCidade?: IntWithAggregatesFilter<"Bairro"> | number
    descricao?: StringWithAggregatesFilter<"Bairro"> | string
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"Bairro"> | $Enums.SimNao | null
  }

  export type EnderecoPessoaRelacionadaWhereInput = {
    AND?: EnderecoPessoaRelacionadaWhereInput | EnderecoPessoaRelacionadaWhereInput[]
    OR?: EnderecoPessoaRelacionadaWhereInput[]
    NOT?: EnderecoPessoaRelacionadaWhereInput | EnderecoPessoaRelacionadaWhereInput[]
    id?: IntFilter<"EnderecoPessoaRelacionada"> | number
    cdPessoa?: IntFilter<"EnderecoPessoaRelacionada"> | number
    cdEndereco?: IntFilter<"EnderecoPessoaRelacionada"> | number
    endereco?: XOR<EnderecoScalarRelationFilter, EnderecoWhereInput>
    pessoaRelacionada?: XOR<PessoaRelacionadaScalarRelationFilter, PessoaRelacionadaWhereInput>
  }

  export type EnderecoPessoaRelacionadaOrderByWithRelationInput = {
    id?: SortOrder
    cdPessoa?: SortOrder
    cdEndereco?: SortOrder
    endereco?: EnderecoOrderByWithRelationInput
    pessoaRelacionada?: PessoaRelacionadaOrderByWithRelationInput
  }

  export type EnderecoPessoaRelacionadaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EnderecoPessoaRelacionadaWhereInput | EnderecoPessoaRelacionadaWhereInput[]
    OR?: EnderecoPessoaRelacionadaWhereInput[]
    NOT?: EnderecoPessoaRelacionadaWhereInput | EnderecoPessoaRelacionadaWhereInput[]
    cdPessoa?: IntFilter<"EnderecoPessoaRelacionada"> | number
    cdEndereco?: IntFilter<"EnderecoPessoaRelacionada"> | number
    endereco?: XOR<EnderecoScalarRelationFilter, EnderecoWhereInput>
    pessoaRelacionada?: XOR<PessoaRelacionadaScalarRelationFilter, PessoaRelacionadaWhereInput>
  }, "id">

  export type EnderecoPessoaRelacionadaOrderByWithAggregationInput = {
    id?: SortOrder
    cdPessoa?: SortOrder
    cdEndereco?: SortOrder
    _count?: EnderecoPessoaRelacionadaCountOrderByAggregateInput
    _avg?: EnderecoPessoaRelacionadaAvgOrderByAggregateInput
    _max?: EnderecoPessoaRelacionadaMaxOrderByAggregateInput
    _min?: EnderecoPessoaRelacionadaMinOrderByAggregateInput
    _sum?: EnderecoPessoaRelacionadaSumOrderByAggregateInput
  }

  export type EnderecoPessoaRelacionadaScalarWhereWithAggregatesInput = {
    AND?: EnderecoPessoaRelacionadaScalarWhereWithAggregatesInput | EnderecoPessoaRelacionadaScalarWhereWithAggregatesInput[]
    OR?: EnderecoPessoaRelacionadaScalarWhereWithAggregatesInput[]
    NOT?: EnderecoPessoaRelacionadaScalarWhereWithAggregatesInput | EnderecoPessoaRelacionadaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EnderecoPessoaRelacionada"> | number
    cdPessoa?: IntWithAggregatesFilter<"EnderecoPessoaRelacionada"> | number
    cdEndereco?: IntWithAggregatesFilter<"EnderecoPessoaRelacionada"> | number
  }

  export type CidWhereInput = {
    AND?: CidWhereInput | CidWhereInput[]
    OR?: CidWhereInput[]
    NOT?: CidWhereInput | CidWhereInput[]
    id?: IntFilter<"Cid"> | number
    codigo?: StringFilter<"Cid"> | string
    descricao?: StringFilter<"Cid"> | string
    versao?: EnumVersaoCidFilter<"Cid"> | $Enums.VersaoCid
    stInativo?: EnumSimNaoNullableFilter<"Cid"> | $Enums.SimNao | null
    evolucaoCids?: EvolucaoCidListRelationFilter
  }

  export type CidOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    versao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    evolucaoCids?: EvolucaoCidOrderByRelationAggregateInput
  }

  export type CidWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codigo_versao?: CidCodigoVersaoCompoundUniqueInput
    AND?: CidWhereInput | CidWhereInput[]
    OR?: CidWhereInput[]
    NOT?: CidWhereInput | CidWhereInput[]
    codigo?: StringFilter<"Cid"> | string
    descricao?: StringFilter<"Cid"> | string
    versao?: EnumVersaoCidFilter<"Cid"> | $Enums.VersaoCid
    stInativo?: EnumSimNaoNullableFilter<"Cid"> | $Enums.SimNao | null
    evolucaoCids?: EvolucaoCidListRelationFilter
  }, "id" | "codigo_versao">

  export type CidOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    versao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: CidCountOrderByAggregateInput
    _avg?: CidAvgOrderByAggregateInput
    _max?: CidMaxOrderByAggregateInput
    _min?: CidMinOrderByAggregateInput
    _sum?: CidSumOrderByAggregateInput
  }

  export type CidScalarWhereWithAggregatesInput = {
    AND?: CidScalarWhereWithAggregatesInput | CidScalarWhereWithAggregatesInput[]
    OR?: CidScalarWhereWithAggregatesInput[]
    NOT?: CidScalarWhereWithAggregatesInput | CidScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cid"> | number
    codigo?: StringWithAggregatesFilter<"Cid"> | string
    descricao?: StringWithAggregatesFilter<"Cid"> | string
    versao?: EnumVersaoCidWithAggregatesFilter<"Cid"> | $Enums.VersaoCid
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"Cid"> | $Enums.SimNao | null
  }

  export type DsmWhereInput = {
    AND?: DsmWhereInput | DsmWhereInput[]
    OR?: DsmWhereInput[]
    NOT?: DsmWhereInput | DsmWhereInput[]
    id?: IntFilter<"Dsm"> | number
    codigo?: StringFilter<"Dsm"> | string
    descricao?: StringFilter<"Dsm"> | string
    versao?: EnumVersaoDsmFilter<"Dsm"> | $Enums.VersaoDsm
    stInativo?: EnumSimNaoNullableFilter<"Dsm"> | $Enums.SimNao | null
    evolucaoDsms?: EvolucaoDsmListRelationFilter
  }

  export type DsmOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    versao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    evolucaoDsms?: EvolucaoDsmOrderByRelationAggregateInput
  }

  export type DsmWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codigo_versao?: DsmCodigoVersaoCompoundUniqueInput
    AND?: DsmWhereInput | DsmWhereInput[]
    OR?: DsmWhereInput[]
    NOT?: DsmWhereInput | DsmWhereInput[]
    codigo?: StringFilter<"Dsm"> | string
    descricao?: StringFilter<"Dsm"> | string
    versao?: EnumVersaoDsmFilter<"Dsm"> | $Enums.VersaoDsm
    stInativo?: EnumSimNaoNullableFilter<"Dsm"> | $Enums.SimNao | null
    evolucaoDsms?: EvolucaoDsmListRelationFilter
  }, "id" | "codigo_versao">

  export type DsmOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    versao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: DsmCountOrderByAggregateInput
    _avg?: DsmAvgOrderByAggregateInput
    _max?: DsmMaxOrderByAggregateInput
    _min?: DsmMinOrderByAggregateInput
    _sum?: DsmSumOrderByAggregateInput
  }

  export type DsmScalarWhereWithAggregatesInput = {
    AND?: DsmScalarWhereWithAggregatesInput | DsmScalarWhereWithAggregatesInput[]
    OR?: DsmScalarWhereWithAggregatesInput[]
    NOT?: DsmScalarWhereWithAggregatesInput | DsmScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Dsm"> | number
    codigo?: StringWithAggregatesFilter<"Dsm"> | string
    descricao?: StringWithAggregatesFilter<"Dsm"> | string
    versao?: EnumVersaoDsmWithAggregatesFilter<"Dsm"> | $Enums.VersaoDsm
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"Dsm"> | $Enums.SimNao | null
  }

  export type TipoEvolucaoClinicaWhereInput = {
    AND?: TipoEvolucaoClinicaWhereInput | TipoEvolucaoClinicaWhereInput[]
    OR?: TipoEvolucaoClinicaWhereInput[]
    NOT?: TipoEvolucaoClinicaWhereInput | TipoEvolucaoClinicaWhereInput[]
    id?: IntFilter<"TipoEvolucaoClinica"> | number
    descricao?: StringFilter<"TipoEvolucaoClinica"> | string
    stInativo?: EnumSimNaoNullableFilter<"TipoEvolucaoClinica"> | $Enums.SimNao | null
    evolucaos?: EvolucaoListRelationFilter
  }

  export type TipoEvolucaoClinicaOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    evolucaos?: EvolucaoOrderByRelationAggregateInput
  }

  export type TipoEvolucaoClinicaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TipoEvolucaoClinicaWhereInput | TipoEvolucaoClinicaWhereInput[]
    OR?: TipoEvolucaoClinicaWhereInput[]
    NOT?: TipoEvolucaoClinicaWhereInput | TipoEvolucaoClinicaWhereInput[]
    descricao?: StringFilter<"TipoEvolucaoClinica"> | string
    stInativo?: EnumSimNaoNullableFilter<"TipoEvolucaoClinica"> | $Enums.SimNao | null
    evolucaos?: EvolucaoListRelationFilter
  }, "id">

  export type TipoEvolucaoClinicaOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrderInput | SortOrder
    _count?: TipoEvolucaoClinicaCountOrderByAggregateInput
    _avg?: TipoEvolucaoClinicaAvgOrderByAggregateInput
    _max?: TipoEvolucaoClinicaMaxOrderByAggregateInput
    _min?: TipoEvolucaoClinicaMinOrderByAggregateInput
    _sum?: TipoEvolucaoClinicaSumOrderByAggregateInput
  }

  export type TipoEvolucaoClinicaScalarWhereWithAggregatesInput = {
    AND?: TipoEvolucaoClinicaScalarWhereWithAggregatesInput | TipoEvolucaoClinicaScalarWhereWithAggregatesInput[]
    OR?: TipoEvolucaoClinicaScalarWhereWithAggregatesInput[]
    NOT?: TipoEvolucaoClinicaScalarWhereWithAggregatesInput | TipoEvolucaoClinicaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TipoEvolucaoClinica"> | number
    descricao?: StringWithAggregatesFilter<"TipoEvolucaoClinica"> | string
    stInativo?: EnumSimNaoNullableWithAggregatesFilter<"TipoEvolucaoClinica"> | $Enums.SimNao | null
  }

  export type EvolucaoCidWhereInput = {
    AND?: EvolucaoCidWhereInput | EvolucaoCidWhereInput[]
    OR?: EvolucaoCidWhereInput[]
    NOT?: EvolucaoCidWhereInput | EvolucaoCidWhereInput[]
    id?: IntFilter<"EvolucaoCid"> | number
    cdEvolucao?: IntFilter<"EvolucaoCid"> | number
    cdCid?: IntFilter<"EvolucaoCid"> | number
    cid?: XOR<CidScalarRelationFilter, CidWhereInput>
    evolucao?: XOR<EvolucaoScalarRelationFilter, EvolucaoWhereInput>
  }

  export type EvolucaoCidOrderByWithRelationInput = {
    id?: SortOrder
    cdEvolucao?: SortOrder
    cdCid?: SortOrder
    cid?: CidOrderByWithRelationInput
    evolucao?: EvolucaoOrderByWithRelationInput
  }

  export type EvolucaoCidWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EvolucaoCidWhereInput | EvolucaoCidWhereInput[]
    OR?: EvolucaoCidWhereInput[]
    NOT?: EvolucaoCidWhereInput | EvolucaoCidWhereInput[]
    cdEvolucao?: IntFilter<"EvolucaoCid"> | number
    cdCid?: IntFilter<"EvolucaoCid"> | number
    cid?: XOR<CidScalarRelationFilter, CidWhereInput>
    evolucao?: XOR<EvolucaoScalarRelationFilter, EvolucaoWhereInput>
  }, "id">

  export type EvolucaoCidOrderByWithAggregationInput = {
    id?: SortOrder
    cdEvolucao?: SortOrder
    cdCid?: SortOrder
    _count?: EvolucaoCidCountOrderByAggregateInput
    _avg?: EvolucaoCidAvgOrderByAggregateInput
    _max?: EvolucaoCidMaxOrderByAggregateInput
    _min?: EvolucaoCidMinOrderByAggregateInput
    _sum?: EvolucaoCidSumOrderByAggregateInput
  }

  export type EvolucaoCidScalarWhereWithAggregatesInput = {
    AND?: EvolucaoCidScalarWhereWithAggregatesInput | EvolucaoCidScalarWhereWithAggregatesInput[]
    OR?: EvolucaoCidScalarWhereWithAggregatesInput[]
    NOT?: EvolucaoCidScalarWhereWithAggregatesInput | EvolucaoCidScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EvolucaoCid"> | number
    cdEvolucao?: IntWithAggregatesFilter<"EvolucaoCid"> | number
    cdCid?: IntWithAggregatesFilter<"EvolucaoCid"> | number
  }

  export type EvolucaoDsmWhereInput = {
    AND?: EvolucaoDsmWhereInput | EvolucaoDsmWhereInput[]
    OR?: EvolucaoDsmWhereInput[]
    NOT?: EvolucaoDsmWhereInput | EvolucaoDsmWhereInput[]
    id?: IntFilter<"EvolucaoDsm"> | number
    cdEvolucao?: IntFilter<"EvolucaoDsm"> | number
    cdDsm?: IntFilter<"EvolucaoDsm"> | number
    dsm?: XOR<DsmScalarRelationFilter, DsmWhereInput>
    evolucao?: XOR<EvolucaoScalarRelationFilter, EvolucaoWhereInput>
  }

  export type EvolucaoDsmOrderByWithRelationInput = {
    id?: SortOrder
    cdEvolucao?: SortOrder
    cdDsm?: SortOrder
    dsm?: DsmOrderByWithRelationInput
    evolucao?: EvolucaoOrderByWithRelationInput
  }

  export type EvolucaoDsmWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EvolucaoDsmWhereInput | EvolucaoDsmWhereInput[]
    OR?: EvolucaoDsmWhereInput[]
    NOT?: EvolucaoDsmWhereInput | EvolucaoDsmWhereInput[]
    cdEvolucao?: IntFilter<"EvolucaoDsm"> | number
    cdDsm?: IntFilter<"EvolucaoDsm"> | number
    dsm?: XOR<DsmScalarRelationFilter, DsmWhereInput>
    evolucao?: XOR<EvolucaoScalarRelationFilter, EvolucaoWhereInput>
  }, "id">

  export type EvolucaoDsmOrderByWithAggregationInput = {
    id?: SortOrder
    cdEvolucao?: SortOrder
    cdDsm?: SortOrder
    _count?: EvolucaoDsmCountOrderByAggregateInput
    _avg?: EvolucaoDsmAvgOrderByAggregateInput
    _max?: EvolucaoDsmMaxOrderByAggregateInput
    _min?: EvolucaoDsmMinOrderByAggregateInput
    _sum?: EvolucaoDsmSumOrderByAggregateInput
  }

  export type EvolucaoDsmScalarWhereWithAggregatesInput = {
    AND?: EvolucaoDsmScalarWhereWithAggregatesInput | EvolucaoDsmScalarWhereWithAggregatesInput[]
    OR?: EvolucaoDsmScalarWhereWithAggregatesInput[]
    NOT?: EvolucaoDsmScalarWhereWithAggregatesInput | EvolucaoDsmScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EvolucaoDsm"> | number
    cdEvolucao?: IntWithAggregatesFilter<"EvolucaoDsm"> | number
    cdDsm?: IntWithAggregatesFilter<"EvolucaoDsm"> | number
  }

  export type SinaisVitaisWhereInput = {
    AND?: SinaisVitaisWhereInput | SinaisVitaisWhereInput[]
    OR?: SinaisVitaisWhereInput[]
    NOT?: SinaisVitaisWhereInput | SinaisVitaisWhereInput[]
    id?: IntFilter<"SinaisVitais"> | number
    cdAtendimento?: IntFilter<"SinaisVitais"> | number
    data?: DateTimeFilter<"SinaisVitais"> | Date | string
    paSistolica?: IntNullableFilter<"SinaisVitais"> | number | null
    paDiastolica?: IntNullableFilter<"SinaisVitais"> | number | null
    fc?: IntNullableFilter<"SinaisVitais"> | number | null
    fr?: IntNullableFilter<"SinaisVitais"> | number | null
    temperatura?: DecimalNullableFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    spo2?: IntNullableFilter<"SinaisVitais"> | number | null
    peso?: DecimalNullableFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    altura?: DecimalNullableFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    imc?: DecimalNullableFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    dor?: IntNullableFilter<"SinaisVitais"> | number | null
    escalaDorId?: IntNullableFilter<"SinaisVitais"> | number | null
    posicao?: EnumPosicaoPacienteNullableFilter<"SinaisVitais"> | $Enums.PosicaoPaciente | null
    origem?: EnumOrigemAfericaoNullableFilter<"SinaisVitais"> | $Enums.OrigemAfericao | null
    metadataRaw?: JsonNullableFilter<"SinaisVitais">
    atendimento?: XOR<AtendimentoScalarRelationFilter, AtendimentoWhereInput>
    escalaDor?: XOR<EscalaDorNullableScalarRelationFilter, EscalaDorWhereInput> | null
  }

  export type SinaisVitaisOrderByWithRelationInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    data?: SortOrder
    paSistolica?: SortOrderInput | SortOrder
    paDiastolica?: SortOrderInput | SortOrder
    fc?: SortOrderInput | SortOrder
    fr?: SortOrderInput | SortOrder
    temperatura?: SortOrderInput | SortOrder
    spo2?: SortOrderInput | SortOrder
    peso?: SortOrderInput | SortOrder
    altura?: SortOrderInput | SortOrder
    imc?: SortOrderInput | SortOrder
    dor?: SortOrderInput | SortOrder
    escalaDorId?: SortOrderInput | SortOrder
    posicao?: SortOrderInput | SortOrder
    origem?: SortOrderInput | SortOrder
    metadataRaw?: SortOrderInput | SortOrder
    atendimento?: AtendimentoOrderByWithRelationInput
    escalaDor?: EscalaDorOrderByWithRelationInput
  }

  export type SinaisVitaisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SinaisVitaisWhereInput | SinaisVitaisWhereInput[]
    OR?: SinaisVitaisWhereInput[]
    NOT?: SinaisVitaisWhereInput | SinaisVitaisWhereInput[]
    cdAtendimento?: IntFilter<"SinaisVitais"> | number
    data?: DateTimeFilter<"SinaisVitais"> | Date | string
    paSistolica?: IntNullableFilter<"SinaisVitais"> | number | null
    paDiastolica?: IntNullableFilter<"SinaisVitais"> | number | null
    fc?: IntNullableFilter<"SinaisVitais"> | number | null
    fr?: IntNullableFilter<"SinaisVitais"> | number | null
    temperatura?: DecimalNullableFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    spo2?: IntNullableFilter<"SinaisVitais"> | number | null
    peso?: DecimalNullableFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    altura?: DecimalNullableFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    imc?: DecimalNullableFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    dor?: IntNullableFilter<"SinaisVitais"> | number | null
    escalaDorId?: IntNullableFilter<"SinaisVitais"> | number | null
    posicao?: EnumPosicaoPacienteNullableFilter<"SinaisVitais"> | $Enums.PosicaoPaciente | null
    origem?: EnumOrigemAfericaoNullableFilter<"SinaisVitais"> | $Enums.OrigemAfericao | null
    metadataRaw?: JsonNullableFilter<"SinaisVitais">
    atendimento?: XOR<AtendimentoScalarRelationFilter, AtendimentoWhereInput>
    escalaDor?: XOR<EscalaDorNullableScalarRelationFilter, EscalaDorWhereInput> | null
  }, "id">

  export type SinaisVitaisOrderByWithAggregationInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    data?: SortOrder
    paSistolica?: SortOrderInput | SortOrder
    paDiastolica?: SortOrderInput | SortOrder
    fc?: SortOrderInput | SortOrder
    fr?: SortOrderInput | SortOrder
    temperatura?: SortOrderInput | SortOrder
    spo2?: SortOrderInput | SortOrder
    peso?: SortOrderInput | SortOrder
    altura?: SortOrderInput | SortOrder
    imc?: SortOrderInput | SortOrder
    dor?: SortOrderInput | SortOrder
    escalaDorId?: SortOrderInput | SortOrder
    posicao?: SortOrderInput | SortOrder
    origem?: SortOrderInput | SortOrder
    metadataRaw?: SortOrderInput | SortOrder
    _count?: SinaisVitaisCountOrderByAggregateInput
    _avg?: SinaisVitaisAvgOrderByAggregateInput
    _max?: SinaisVitaisMaxOrderByAggregateInput
    _min?: SinaisVitaisMinOrderByAggregateInput
    _sum?: SinaisVitaisSumOrderByAggregateInput
  }

  export type SinaisVitaisScalarWhereWithAggregatesInput = {
    AND?: SinaisVitaisScalarWhereWithAggregatesInput | SinaisVitaisScalarWhereWithAggregatesInput[]
    OR?: SinaisVitaisScalarWhereWithAggregatesInput[]
    NOT?: SinaisVitaisScalarWhereWithAggregatesInput | SinaisVitaisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SinaisVitais"> | number
    cdAtendimento?: IntWithAggregatesFilter<"SinaisVitais"> | number
    data?: DateTimeWithAggregatesFilter<"SinaisVitais"> | Date | string
    paSistolica?: IntNullableWithAggregatesFilter<"SinaisVitais"> | number | null
    paDiastolica?: IntNullableWithAggregatesFilter<"SinaisVitais"> | number | null
    fc?: IntNullableWithAggregatesFilter<"SinaisVitais"> | number | null
    fr?: IntNullableWithAggregatesFilter<"SinaisVitais"> | number | null
    temperatura?: DecimalNullableWithAggregatesFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    spo2?: IntNullableWithAggregatesFilter<"SinaisVitais"> | number | null
    peso?: DecimalNullableWithAggregatesFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    altura?: DecimalNullableWithAggregatesFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    imc?: DecimalNullableWithAggregatesFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    dor?: IntNullableWithAggregatesFilter<"SinaisVitais"> | number | null
    escalaDorId?: IntNullableWithAggregatesFilter<"SinaisVitais"> | number | null
    posicao?: EnumPosicaoPacienteNullableWithAggregatesFilter<"SinaisVitais"> | $Enums.PosicaoPaciente | null
    origem?: EnumOrigemAfericaoNullableWithAggregatesFilter<"SinaisVitais"> | $Enums.OrigemAfericao | null
    metadataRaw?: JsonNullableWithAggregatesFilter<"SinaisVitais">
  }

  export type EscalaDorWhereInput = {
    AND?: EscalaDorWhereInput | EscalaDorWhereInput[]
    OR?: EscalaDorWhereInput[]
    NOT?: EscalaDorWhereInput | EscalaDorWhereInput[]
    id?: IntFilter<"EscalaDor"> | number
    nome?: StringFilter<"EscalaDor"> | string
    descricao?: StringNullableFilter<"EscalaDor"> | string | null
    sinaisVitais?: SinaisVitaisListRelationFilter
  }

  export type EscalaDorOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    sinaisVitais?: SinaisVitaisOrderByRelationAggregateInput
  }

  export type EscalaDorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EscalaDorWhereInput | EscalaDorWhereInput[]
    OR?: EscalaDorWhereInput[]
    NOT?: EscalaDorWhereInput | EscalaDorWhereInput[]
    nome?: StringFilter<"EscalaDor"> | string
    descricao?: StringNullableFilter<"EscalaDor"> | string | null
    sinaisVitais?: SinaisVitaisListRelationFilter
  }, "id">

  export type EscalaDorOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    _count?: EscalaDorCountOrderByAggregateInput
    _avg?: EscalaDorAvgOrderByAggregateInput
    _max?: EscalaDorMaxOrderByAggregateInput
    _min?: EscalaDorMinOrderByAggregateInput
    _sum?: EscalaDorSumOrderByAggregateInput
  }

  export type EscalaDorScalarWhereWithAggregatesInput = {
    AND?: EscalaDorScalarWhereWithAggregatesInput | EscalaDorScalarWhereWithAggregatesInput[]
    OR?: EscalaDorScalarWhereWithAggregatesInput[]
    NOT?: EscalaDorScalarWhereWithAggregatesInput | EscalaDorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EscalaDor"> | number
    nome?: StringWithAggregatesFilter<"EscalaDor"> | string
    descricao?: StringNullableWithAggregatesFilter<"EscalaDor"> | string | null
  }

  export type GlasgowWhereInput = {
    AND?: GlasgowWhereInput | GlasgowWhereInput[]
    OR?: GlasgowWhereInput[]
    NOT?: GlasgowWhereInput | GlasgowWhereInput[]
    id?: IntFilter<"Glasgow"> | number
    cdAtendimento?: IntFilter<"Glasgow"> | number
    cdProfissional?: IntNullableFilter<"Glasgow"> | number | null
    data?: DateTimeFilter<"Glasgow"> | Date | string
    ocular?: IntFilter<"Glasgow"> | number
    verbal?: IntFilter<"Glasgow"> | number
    motora?: IntFilter<"Glasgow"> | number
    total?: IntFilter<"Glasgow"> | number
    observacao?: StringNullableFilter<"Glasgow"> | string | null
    atendimento?: XOR<AtendimentoScalarRelationFilter, AtendimentoWhereInput>
    profissional?: XOR<ProfissionalNullableScalarRelationFilter, ProfissionalWhereInput> | null
  }

  export type GlasgowOrderByWithRelationInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrderInput | SortOrder
    data?: SortOrder
    ocular?: SortOrder
    verbal?: SortOrder
    motora?: SortOrder
    total?: SortOrder
    observacao?: SortOrderInput | SortOrder
    atendimento?: AtendimentoOrderByWithRelationInput
    profissional?: ProfissionalOrderByWithRelationInput
  }

  export type GlasgowWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GlasgowWhereInput | GlasgowWhereInput[]
    OR?: GlasgowWhereInput[]
    NOT?: GlasgowWhereInput | GlasgowWhereInput[]
    cdAtendimento?: IntFilter<"Glasgow"> | number
    cdProfissional?: IntNullableFilter<"Glasgow"> | number | null
    data?: DateTimeFilter<"Glasgow"> | Date | string
    ocular?: IntFilter<"Glasgow"> | number
    verbal?: IntFilter<"Glasgow"> | number
    motora?: IntFilter<"Glasgow"> | number
    total?: IntFilter<"Glasgow"> | number
    observacao?: StringNullableFilter<"Glasgow"> | string | null
    atendimento?: XOR<AtendimentoScalarRelationFilter, AtendimentoWhereInput>
    profissional?: XOR<ProfissionalNullableScalarRelationFilter, ProfissionalWhereInput> | null
  }, "id">

  export type GlasgowOrderByWithAggregationInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrderInput | SortOrder
    data?: SortOrder
    ocular?: SortOrder
    verbal?: SortOrder
    motora?: SortOrder
    total?: SortOrder
    observacao?: SortOrderInput | SortOrder
    _count?: GlasgowCountOrderByAggregateInput
    _avg?: GlasgowAvgOrderByAggregateInput
    _max?: GlasgowMaxOrderByAggregateInput
    _min?: GlasgowMinOrderByAggregateInput
    _sum?: GlasgowSumOrderByAggregateInput
  }

  export type GlasgowScalarWhereWithAggregatesInput = {
    AND?: GlasgowScalarWhereWithAggregatesInput | GlasgowScalarWhereWithAggregatesInput[]
    OR?: GlasgowScalarWhereWithAggregatesInput[]
    NOT?: GlasgowScalarWhereWithAggregatesInput | GlasgowScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Glasgow"> | number
    cdAtendimento?: IntWithAggregatesFilter<"Glasgow"> | number
    cdProfissional?: IntNullableWithAggregatesFilter<"Glasgow"> | number | null
    data?: DateTimeWithAggregatesFilter<"Glasgow"> | Date | string
    ocular?: IntWithAggregatesFilter<"Glasgow"> | number
    verbal?: IntWithAggregatesFilter<"Glasgow"> | number
    motora?: IntWithAggregatesFilter<"Glasgow"> | number
    total?: IntWithAggregatesFilter<"Glasgow"> | number
    observacao?: StringNullableWithAggregatesFilter<"Glasgow"> | string | null
  }

  export type AfericaoClinicaWhereInput = {
    AND?: AfericaoClinicaWhereInput | AfericaoClinicaWhereInput[]
    OR?: AfericaoClinicaWhereInput[]
    NOT?: AfericaoClinicaWhereInput | AfericaoClinicaWhereInput[]
    id?: IntFilter<"AfericaoClinica"> | number
    cdAtendimento?: IntFilter<"AfericaoClinica"> | number
    cdProfissional?: IntNullableFilter<"AfericaoClinica"> | number | null
    escala?: StringFilter<"AfericaoClinica"> | string
    idRegistro?: IntFilter<"AfericaoClinica"> | number
    data?: DateTimeFilter<"AfericaoClinica"> | Date | string
    atendimento?: XOR<AtendimentoScalarRelationFilter, AtendimentoWhereInput>
    profissional?: XOR<ProfissionalNullableScalarRelationFilter, ProfissionalWhereInput> | null
  }

  export type AfericaoClinicaOrderByWithRelationInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrderInput | SortOrder
    escala?: SortOrder
    idRegistro?: SortOrder
    data?: SortOrder
    atendimento?: AtendimentoOrderByWithRelationInput
    profissional?: ProfissionalOrderByWithRelationInput
  }

  export type AfericaoClinicaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AfericaoClinicaWhereInput | AfericaoClinicaWhereInput[]
    OR?: AfericaoClinicaWhereInput[]
    NOT?: AfericaoClinicaWhereInput | AfericaoClinicaWhereInput[]
    cdAtendimento?: IntFilter<"AfericaoClinica"> | number
    cdProfissional?: IntNullableFilter<"AfericaoClinica"> | number | null
    escala?: StringFilter<"AfericaoClinica"> | string
    idRegistro?: IntFilter<"AfericaoClinica"> | number
    data?: DateTimeFilter<"AfericaoClinica"> | Date | string
    atendimento?: XOR<AtendimentoScalarRelationFilter, AtendimentoWhereInput>
    profissional?: XOR<ProfissionalNullableScalarRelationFilter, ProfissionalWhereInput> | null
  }, "id">

  export type AfericaoClinicaOrderByWithAggregationInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrderInput | SortOrder
    escala?: SortOrder
    idRegistro?: SortOrder
    data?: SortOrder
    _count?: AfericaoClinicaCountOrderByAggregateInput
    _avg?: AfericaoClinicaAvgOrderByAggregateInput
    _max?: AfericaoClinicaMaxOrderByAggregateInput
    _min?: AfericaoClinicaMinOrderByAggregateInput
    _sum?: AfericaoClinicaSumOrderByAggregateInput
  }

  export type AfericaoClinicaScalarWhereWithAggregatesInput = {
    AND?: AfericaoClinicaScalarWhereWithAggregatesInput | AfericaoClinicaScalarWhereWithAggregatesInput[]
    OR?: AfericaoClinicaScalarWhereWithAggregatesInput[]
    NOT?: AfericaoClinicaScalarWhereWithAggregatesInput | AfericaoClinicaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AfericaoClinica"> | number
    cdAtendimento?: IntWithAggregatesFilter<"AfericaoClinica"> | number
    cdProfissional?: IntNullableWithAggregatesFilter<"AfericaoClinica"> | number | null
    escala?: StringWithAggregatesFilter<"AfericaoClinica"> | string
    idRegistro?: IntWithAggregatesFilter<"AfericaoClinica"> | number
    data?: DateTimeWithAggregatesFilter<"AfericaoClinica"> | Date | string
  }

  export type EvaDorWhereInput = {
    AND?: EvaDorWhereInput | EvaDorWhereInput[]
    OR?: EvaDorWhereInput[]
    NOT?: EvaDorWhereInput | EvaDorWhereInput[]
    id?: IntFilter<"EvaDor"> | number
    cdAtendimento?: IntFilter<"EvaDor"> | number
    cdProfissional?: IntNullableFilter<"EvaDor"> | number | null
    data?: DateTimeFilter<"EvaDor"> | Date | string
    valor?: IntFilter<"EvaDor"> | number
    observacao?: StringNullableFilter<"EvaDor"> | string | null
    atendimento?: XOR<AtendimentoScalarRelationFilter, AtendimentoWhereInput>
    profissional?: XOR<ProfissionalNullableScalarRelationFilter, ProfissionalWhereInput> | null
  }

  export type EvaDorOrderByWithRelationInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrderInput | SortOrder
    data?: SortOrder
    valor?: SortOrder
    observacao?: SortOrderInput | SortOrder
    atendimento?: AtendimentoOrderByWithRelationInput
    profissional?: ProfissionalOrderByWithRelationInput
  }

  export type EvaDorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EvaDorWhereInput | EvaDorWhereInput[]
    OR?: EvaDorWhereInput[]
    NOT?: EvaDorWhereInput | EvaDorWhereInput[]
    cdAtendimento?: IntFilter<"EvaDor"> | number
    cdProfissional?: IntNullableFilter<"EvaDor"> | number | null
    data?: DateTimeFilter<"EvaDor"> | Date | string
    valor?: IntFilter<"EvaDor"> | number
    observacao?: StringNullableFilter<"EvaDor"> | string | null
    atendimento?: XOR<AtendimentoScalarRelationFilter, AtendimentoWhereInput>
    profissional?: XOR<ProfissionalNullableScalarRelationFilter, ProfissionalWhereInput> | null
  }, "id">

  export type EvaDorOrderByWithAggregationInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrderInput | SortOrder
    data?: SortOrder
    valor?: SortOrder
    observacao?: SortOrderInput | SortOrder
    _count?: EvaDorCountOrderByAggregateInput
    _avg?: EvaDorAvgOrderByAggregateInput
    _max?: EvaDorMaxOrderByAggregateInput
    _min?: EvaDorMinOrderByAggregateInput
    _sum?: EvaDorSumOrderByAggregateInput
  }

  export type EvaDorScalarWhereWithAggregatesInput = {
    AND?: EvaDorScalarWhereWithAggregatesInput | EvaDorScalarWhereWithAggregatesInput[]
    OR?: EvaDorScalarWhereWithAggregatesInput[]
    NOT?: EvaDorScalarWhereWithAggregatesInput | EvaDorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EvaDor"> | number
    cdAtendimento?: IntWithAggregatesFilter<"EvaDor"> | number
    cdProfissional?: IntNullableWithAggregatesFilter<"EvaDor"> | number | null
    data?: DateTimeWithAggregatesFilter<"EvaDor"> | Date | string
    valor?: IntWithAggregatesFilter<"EvaDor"> | number
    observacao?: StringNullableWithAggregatesFilter<"EvaDor"> | string | null
  }

  export type UsuarioAuthWhereInput = {
    AND?: UsuarioAuthWhereInput | UsuarioAuthWhereInput[]
    OR?: UsuarioAuthWhereInput[]
    NOT?: UsuarioAuthWhereInput | UsuarioAuthWhereInput[]
    id?: IntFilter<"UsuarioAuth"> | number
    cdMaster?: IntFilter<"UsuarioAuth"> | number
    email?: StringFilter<"UsuarioAuth"> | string
    senhaHash?: StringFilter<"UsuarioAuth"> | string
    role?: EnumRoleAuthFilter<"UsuarioAuth"> | $Enums.RoleAuth
    cdProfissional?: IntNullableFilter<"UsuarioAuth"> | number | null
    cdPaciente?: IntNullableFilter<"UsuarioAuth"> | number | null
    paciente?: XOR<PacienteNullableScalarRelationFilter, PacienteWhereInput> | null
    master?: XOR<MasterScalarRelationFilter, MasterWhereInput>
    profissional?: XOR<ProfissionalNullableScalarRelationFilter, ProfissionalWhereInput> | null
  }

  export type UsuarioAuthOrderByWithRelationInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    email?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    cdProfissional?: SortOrderInput | SortOrder
    cdPaciente?: SortOrderInput | SortOrder
    paciente?: PacienteOrderByWithRelationInput
    master?: MasterOrderByWithRelationInput
    profissional?: ProfissionalOrderByWithRelationInput
  }

  export type UsuarioAuthWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cdMaster_email?: UsuarioAuthCdMasterEmailCompoundUniqueInput
    AND?: UsuarioAuthWhereInput | UsuarioAuthWhereInput[]
    OR?: UsuarioAuthWhereInput[]
    NOT?: UsuarioAuthWhereInput | UsuarioAuthWhereInput[]
    cdMaster?: IntFilter<"UsuarioAuth"> | number
    email?: StringFilter<"UsuarioAuth"> | string
    senhaHash?: StringFilter<"UsuarioAuth"> | string
    role?: EnumRoleAuthFilter<"UsuarioAuth"> | $Enums.RoleAuth
    cdProfissional?: IntNullableFilter<"UsuarioAuth"> | number | null
    cdPaciente?: IntNullableFilter<"UsuarioAuth"> | number | null
    paciente?: XOR<PacienteNullableScalarRelationFilter, PacienteWhereInput> | null
    master?: XOR<MasterScalarRelationFilter, MasterWhereInput>
    profissional?: XOR<ProfissionalNullableScalarRelationFilter, ProfissionalWhereInput> | null
  }, "id" | "cdMaster_email">

  export type UsuarioAuthOrderByWithAggregationInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    email?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    cdProfissional?: SortOrderInput | SortOrder
    cdPaciente?: SortOrderInput | SortOrder
    _count?: UsuarioAuthCountOrderByAggregateInput
    _avg?: UsuarioAuthAvgOrderByAggregateInput
    _max?: UsuarioAuthMaxOrderByAggregateInput
    _min?: UsuarioAuthMinOrderByAggregateInput
    _sum?: UsuarioAuthSumOrderByAggregateInput
  }

  export type UsuarioAuthScalarWhereWithAggregatesInput = {
    AND?: UsuarioAuthScalarWhereWithAggregatesInput | UsuarioAuthScalarWhereWithAggregatesInput[]
    OR?: UsuarioAuthScalarWhereWithAggregatesInput[]
    NOT?: UsuarioAuthScalarWhereWithAggregatesInput | UsuarioAuthScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UsuarioAuth"> | number
    cdMaster?: IntWithAggregatesFilter<"UsuarioAuth"> | number
    email?: StringWithAggregatesFilter<"UsuarioAuth"> | string
    senhaHash?: StringWithAggregatesFilter<"UsuarioAuth"> | string
    role?: EnumRoleAuthWithAggregatesFilter<"UsuarioAuth"> | $Enums.RoleAuth
    cdProfissional?: IntNullableWithAggregatesFilter<"UsuarioAuth"> | number | null
    cdPaciente?: IntNullableWithAggregatesFilter<"UsuarioAuth"> | number | null
  }

  export type MasterCreateInput = {
    nome: string
    dtCadastro?: Date | string
    stInativo?: $Enums.SimNao | null
    pacientes?: PacienteCreateNestedManyWithoutMasterInput
    profissionais?: ProfissionalCreateNestedManyWithoutMasterInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutMasterInput
  }

  export type MasterUncheckedCreateInput = {
    id?: number
    nome: string
    dtCadastro?: Date | string
    stInativo?: $Enums.SimNao | null
    pacientes?: PacienteUncheckedCreateNestedManyWithoutMasterInput
    profissionais?: ProfissionalUncheckedCreateNestedManyWithoutMasterInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutMasterInput
  }

  export type MasterUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    dtCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: PacienteUpdateManyWithoutMasterNestedInput
    profissionais?: ProfissionalUpdateManyWithoutMasterNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutMasterNestedInput
  }

  export type MasterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dtCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: PacienteUncheckedUpdateManyWithoutMasterNestedInput
    profissionais?: ProfissionalUncheckedUpdateManyWithoutMasterNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type MasterCreateManyInput = {
    id?: number
    nome: string
    dtCadastro?: Date | string
    stInativo?: $Enums.SimNao | null
  }

  export type MasterUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    dtCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type MasterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dtCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type PacienteCreateInput = {
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    atendimentos?: AtendimentoCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoCreateNestedManyWithoutPacienteInput
    escolaridade?: EscolaridadeCreateNestedOneWithoutPacientesInput
    master: MasterCreateNestedOneWithoutPacientesInput
    ocupacao?: OcupacaoCreateNestedOneWithoutPacientesInput
    parentescoPacientes?: ParentescoPacienteCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutPacienteInput
  }

  export type PacienteUncheckedCreateInput = {
    cdMaster: number
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    cdEscolaridade?: number | null
    cdOcupacao?: number | null
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutPacienteInput
    parentescoPacientes?: ParentescoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type PacienteUpdateInput = {
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    atendimentos?: AtendimentoUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutPacienteNestedInput
    escolaridade?: EscolaridadeUpdateOneWithoutPacientesNestedInput
    master?: MasterUpdateOneRequiredWithoutPacientesNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutPacientesNestedInput
    parentescoPacientes?: ParentescoPacienteUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateInput = {
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdEscolaridade?: NullableIntFieldUpdateOperationsInput | number | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutPacienteNestedInput
    parentescoPacientes?: ParentescoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteCreateManyInput = {
    cdMaster: number
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    cdEscolaridade?: number | null
    cdOcupacao?: number | null
  }

  export type PacienteUpdateManyMutationInput = {
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type PacienteUncheckedUpdateManyInput = {
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdEscolaridade?: NullableIntFieldUpdateOperationsInput | number | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfissionalCreateInput = {
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowCreateNestedManyWithoutProfissionalInput
    master: MasterCreateNestedOneWithoutProfissionaisInput
    ocupacao?: OcupacaoCreateNestedOneWithoutProfissionalsInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalUncheckedCreateInput = {
    id?: number
    cdMaster: number
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    cdOcupacao?: number | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutProfissionalInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUpdateManyWithoutProfissionalNestedInput
    master?: MasterUpdateOneRequiredWithoutProfissionaisNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutProfissionalsNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutProfissionalNestedInput
  }

  export type ProfissionalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutProfissionalNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutProfissionalNestedInput
  }

  export type ProfissionalCreateManyInput = {
    id?: number
    cdMaster: number
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    cdOcupacao?: number | null
  }

  export type ProfissionalUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type ProfissionalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EnderecoCreateInput = {
    logradouro: string
    numero?: string | null
    complemento?: string | null
    cep: string
    stInativo?: $Enums.SimNao | null
    bairro: BairroCreateNestedOneWithoutEnderecosInput
    cidade: CidadeCreateNestedOneWithoutEnderecosInput
    pacientes?: EnderecoPacienteCreateNestedManyWithoutEnderecoInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaCreateNestedManyWithoutEnderecoInput
    profissionais?: EnderecoProfissionalCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoUncheckedCreateInput = {
    id?: number
    logradouro: string
    numero?: string | null
    complemento?: string | null
    cdBairro: number
    cdCidade: number
    cep: string
    stInativo?: $Enums.SimNao | null
    pacientes?: EnderecoPacienteUncheckedCreateNestedManyWithoutEnderecoInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaUncheckedCreateNestedManyWithoutEnderecoInput
    profissionais?: EnderecoProfissionalUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoUpdateInput = {
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairro?: BairroUpdateOneRequiredWithoutEnderecosNestedInput
    cidade?: CidadeUpdateOneRequiredWithoutEnderecosNestedInput
    pacientes?: EnderecoPacienteUpdateManyWithoutEnderecoNestedInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaUpdateManyWithoutEnderecoNestedInput
    profissionais?: EnderecoProfissionalUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cdBairro?: IntFieldUpdateOperationsInput | number
    cdCidade?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: EnderecoPacienteUncheckedUpdateManyWithoutEnderecoNestedInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaUncheckedUpdateManyWithoutEnderecoNestedInput
    profissionais?: EnderecoProfissionalUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoCreateManyInput = {
    id?: number
    logradouro: string
    numero?: string | null
    complemento?: string | null
    cdBairro: number
    cdCidade: number
    cep: string
    stInativo?: $Enums.SimNao | null
  }

  export type EnderecoUpdateManyMutationInput = {
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type EnderecoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cdBairro?: IntFieldUpdateOperationsInput | number
    cdCidade?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type EnderecoPacienteCreateInput = {
    endereco: EnderecoCreateNestedOneWithoutPacientesInput
    paciente: PacienteCreateNestedOneWithoutEnderecosInput
  }

  export type EnderecoPacienteUncheckedCreateInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    cdEndereco: number
  }

  export type EnderecoPacienteUpdateInput = {
    endereco?: EnderecoUpdateOneRequiredWithoutPacientesNestedInput
    paciente?: PacienteUpdateOneRequiredWithoutEnderecosNestedInput
  }

  export type EnderecoPacienteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    cdEndereco?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoPacienteCreateManyInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    cdEndereco: number
  }

  export type EnderecoPacienteUpdateManyMutationInput = {

  }

  export type EnderecoPacienteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    cdEndereco?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoProfissionalCreateInput = {
    endereco: EnderecoCreateNestedOneWithoutProfissionaisInput
    profissional: ProfissionalCreateNestedOneWithoutEnderecosInput
  }

  export type EnderecoProfissionalUncheckedCreateInput = {
    id?: number
    cdProf: number
    cdEndereco: number
  }

  export type EnderecoProfissionalUpdateInput = {
    endereco?: EnderecoUpdateOneRequiredWithoutProfissionaisNestedInput
    profissional?: ProfissionalUpdateOneRequiredWithoutEnderecosNestedInput
  }

  export type EnderecoProfissionalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProf?: IntFieldUpdateOperationsInput | number
    cdEndereco?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoProfissionalCreateManyInput = {
    id?: number
    cdProf: number
    cdEndereco: number
  }

  export type EnderecoProfissionalUpdateManyMutationInput = {

  }

  export type EnderecoProfissionalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProf?: IntFieldUpdateOperationsInput | number
    cdEndereco?: IntFieldUpdateOperationsInput | number
  }

  export type ContatoCreateInput = {
    tipo: $Enums.TipoFone
    numero: string
    stInativo?: $Enums.SimNao | null
    pacientes?: ContatoPacienteCreateNestedManyWithoutContatoInput
    profissionais?: ContatoProfissionalCreateNestedManyWithoutContatoInput
  }

  export type ContatoUncheckedCreateInput = {
    id?: number
    tipo: $Enums.TipoFone
    numero: string
    stInativo?: $Enums.SimNao | null
    pacientes?: ContatoPacienteUncheckedCreateNestedManyWithoutContatoInput
    profissionais?: ContatoProfissionalUncheckedCreateNestedManyWithoutContatoInput
  }

  export type ContatoUpdateInput = {
    tipo?: EnumTipoFoneFieldUpdateOperationsInput | $Enums.TipoFone
    numero?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: ContatoPacienteUpdateManyWithoutContatoNestedInput
    profissionais?: ContatoProfissionalUpdateManyWithoutContatoNestedInput
  }

  export type ContatoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoFoneFieldUpdateOperationsInput | $Enums.TipoFone
    numero?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: ContatoPacienteUncheckedUpdateManyWithoutContatoNestedInput
    profissionais?: ContatoProfissionalUncheckedUpdateManyWithoutContatoNestedInput
  }

  export type ContatoCreateManyInput = {
    id?: number
    tipo: $Enums.TipoFone
    numero: string
    stInativo?: $Enums.SimNao | null
  }

  export type ContatoUpdateManyMutationInput = {
    tipo?: EnumTipoFoneFieldUpdateOperationsInput | $Enums.TipoFone
    numero?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type ContatoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoFoneFieldUpdateOperationsInput | $Enums.TipoFone
    numero?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type ContatoPacienteCreateInput = {
    contato: ContatoCreateNestedOneWithoutPacientesInput
    paciente: PacienteCreateNestedOneWithoutContatosInput
  }

  export type ContatoPacienteUncheckedCreateInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    cdContato: number
  }

  export type ContatoPacienteUpdateInput = {
    contato?: ContatoUpdateOneRequiredWithoutPacientesNestedInput
    paciente?: PacienteUpdateOneRequiredWithoutContatosNestedInput
  }

  export type ContatoPacienteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    cdContato?: IntFieldUpdateOperationsInput | number
  }

  export type ContatoPacienteCreateManyInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    cdContato: number
  }

  export type ContatoPacienteUpdateManyMutationInput = {

  }

  export type ContatoPacienteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    cdContato?: IntFieldUpdateOperationsInput | number
  }

  export type ContatoProfissionalCreateInput = {
    contato: ContatoCreateNestedOneWithoutProfissionaisInput
    profissional: ProfissionalCreateNestedOneWithoutContatosInput
  }

  export type ContatoProfissionalUncheckedCreateInput = {
    id?: number
    cdProf: number
    cdContato: number
  }

  export type ContatoProfissionalUpdateInput = {
    contato?: ContatoUpdateOneRequiredWithoutProfissionaisNestedInput
    profissional?: ProfissionalUpdateOneRequiredWithoutContatosNestedInput
  }

  export type ContatoProfissionalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProf?: IntFieldUpdateOperationsInput | number
    cdContato?: IntFieldUpdateOperationsInput | number
  }

  export type ContatoProfissionalCreateManyInput = {
    id?: number
    cdProf: number
    cdContato: number
  }

  export type ContatoProfissionalUpdateManyMutationInput = {

  }

  export type ContatoProfissionalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProf?: IntFieldUpdateOperationsInput | number
    cdContato?: IntFieldUpdateOperationsInput | number
  }

  export type AtendimentoCreateInput = {
    data: Date | string
    observacao?: string | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutAtendimentoInput
    paciente: PacienteCreateNestedOneWithoutAtendimentosInput
    profissional: ProfissionalCreateNestedOneWithoutAtendimentosInput
    evaDores?: EvaDorCreateNestedManyWithoutAtendimentoInput
    evolucoes?: EvolucaoCreateNestedManyWithoutAtendimentoInput
    glasgows?: GlasgowCreateNestedManyWithoutAtendimentoInput
    sinaisVitais?: SinaisVitaisCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoUncheckedCreateInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    cdProfissional: number
    data: Date | string
    observacao?: string | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutAtendimentoInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutAtendimentoInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutAtendimentoInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutAtendimentoInput
    sinaisVitais?: SinaisVitaisUncheckedCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoUpdateInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutAtendimentoNestedInput
    paciente?: PacienteUpdateOneRequiredWithoutAtendimentosNestedInput
    profissional?: ProfissionalUpdateOneRequiredWithoutAtendimentosNestedInput
    evaDores?: EvaDorUpdateManyWithoutAtendimentoNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutAtendimentoNestedInput
    glasgows?: GlasgowUpdateManyWithoutAtendimentoNestedInput
    sinaisVitais?: SinaisVitaisUpdateManyWithoutAtendimentoNestedInput
  }

  export type AtendimentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    cdProfissional?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutAtendimentoNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutAtendimentoNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutAtendimentoNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutAtendimentoNestedInput
    sinaisVitais?: SinaisVitaisUncheckedUpdateManyWithoutAtendimentoNestedInput
  }

  export type AtendimentoCreateManyInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    cdProfissional: number
    data: Date | string
    observacao?: string | null
  }

  export type AtendimentoUpdateManyMutationInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AtendimentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    cdProfissional?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvolucaoCreateInput = {
    data: Date | string
    texto: string
    atendimento: AtendimentoCreateNestedOneWithoutEvolucoesInput
    profissional?: ProfissionalCreateNestedOneWithoutEvolucoesInput
    paciente?: PacienteCreateNestedOneWithoutEvolucoesInput
    tipoEvolucaoClinica?: TipoEvolucaoClinicaCreateNestedOneWithoutEvolucaosInput
    cid?: EvolucaoCidCreateNestedManyWithoutEvolucaoInput
    dsm?: EvolucaoDsmCreateNestedManyWithoutEvolucaoInput
  }

  export type EvolucaoUncheckedCreateInput = {
    id?: number
    cdAtendimento: number
    cdProfissional?: number | null
    data: Date | string
    texto: string
    pacienteCdMaster?: number | null
    pacienteCdPaciente?: number | null
    tipoEvolucaoClinicaId?: number | null
    cid?: EvolucaoCidUncheckedCreateNestedManyWithoutEvolucaoInput
    dsm?: EvolucaoDsmUncheckedCreateNestedManyWithoutEvolucaoInput
  }

  export type EvolucaoUpdateInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    atendimento?: AtendimentoUpdateOneRequiredWithoutEvolucoesNestedInput
    profissional?: ProfissionalUpdateOneWithoutEvolucoesNestedInput
    paciente?: PacienteUpdateOneWithoutEvolucoesNestedInput
    tipoEvolucaoClinica?: TipoEvolucaoClinicaUpdateOneWithoutEvolucaosNestedInput
    cid?: EvolucaoCidUpdateManyWithoutEvolucaoNestedInput
    dsm?: EvolucaoDsmUpdateManyWithoutEvolucaoNestedInput
  }

  export type EvolucaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    pacienteCdMaster?: NullableIntFieldUpdateOperationsInput | number | null
    pacienteCdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
    tipoEvolucaoClinicaId?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: EvolucaoCidUncheckedUpdateManyWithoutEvolucaoNestedInput
    dsm?: EvolucaoDsmUncheckedUpdateManyWithoutEvolucaoNestedInput
  }

  export type EvolucaoCreateManyInput = {
    id?: number
    cdAtendimento: number
    cdProfissional?: number | null
    data: Date | string
    texto: string
    pacienteCdMaster?: number | null
    pacienteCdPaciente?: number | null
    tipoEvolucaoClinicaId?: number | null
  }

  export type EvolucaoUpdateManyMutationInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
  }

  export type EvolucaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    pacienteCdMaster?: NullableIntFieldUpdateOperationsInput | number | null
    pacienteCdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
    tipoEvolucaoClinicaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PessoaRelacionadaCreateInput = {
    nome: string
    telefone?: string | null
    stInativo?: $Enums.SimNao | null
    enderecos?: EnderecoPessoaRelacionadaCreateNestedManyWithoutPessoaRelacionadaInput
    parentescos?: ParentescoPacienteCreateNestedManyWithoutPessoaRelacionadaInput
  }

  export type PessoaRelacionadaUncheckedCreateInput = {
    id?: number
    nome: string
    telefone?: string | null
    stInativo?: $Enums.SimNao | null
    enderecos?: EnderecoPessoaRelacionadaUncheckedCreateNestedManyWithoutPessoaRelacionadaInput
    parentescos?: ParentescoPacienteUncheckedCreateNestedManyWithoutPessoaRelacionadaInput
  }

  export type PessoaRelacionadaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    enderecos?: EnderecoPessoaRelacionadaUpdateManyWithoutPessoaRelacionadaNestedInput
    parentescos?: ParentescoPacienteUpdateManyWithoutPessoaRelacionadaNestedInput
  }

  export type PessoaRelacionadaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    enderecos?: EnderecoPessoaRelacionadaUncheckedUpdateManyWithoutPessoaRelacionadaNestedInput
    parentescos?: ParentescoPacienteUncheckedUpdateManyWithoutPessoaRelacionadaNestedInput
  }

  export type PessoaRelacionadaCreateManyInput = {
    id?: number
    nome: string
    telefone?: string | null
    stInativo?: $Enums.SimNao | null
  }

  export type PessoaRelacionadaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type PessoaRelacionadaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type ParentescoPacienteCreateInput = {
    parentesco: $Enums.TipoParentesco
    paciente: PacienteCreateNestedOneWithoutParentescoPacientesInput
    pessoaRelacionada: PessoaRelacionadaCreateNestedOneWithoutParentescosInput
  }

  export type ParentescoPacienteUncheckedCreateInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    cdPessoa: number
    parentesco: $Enums.TipoParentesco
  }

  export type ParentescoPacienteUpdateInput = {
    parentesco?: EnumTipoParentescoFieldUpdateOperationsInput | $Enums.TipoParentesco
    paciente?: PacienteUpdateOneRequiredWithoutParentescoPacientesNestedInput
    pessoaRelacionada?: PessoaRelacionadaUpdateOneRequiredWithoutParentescosNestedInput
  }

  export type ParentescoPacienteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    cdPessoa?: IntFieldUpdateOperationsInput | number
    parentesco?: EnumTipoParentescoFieldUpdateOperationsInput | $Enums.TipoParentesco
  }

  export type ParentescoPacienteCreateManyInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    cdPessoa: number
    parentesco: $Enums.TipoParentesco
  }

  export type ParentescoPacienteUpdateManyMutationInput = {
    parentesco?: EnumTipoParentescoFieldUpdateOperationsInput | $Enums.TipoParentesco
  }

  export type ParentescoPacienteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    cdPessoa?: IntFieldUpdateOperationsInput | number
    parentesco?: EnumTipoParentescoFieldUpdateOperationsInput | $Enums.TipoParentesco
  }

  export type PlanoCreateInput = {
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type PlanoUncheckedCreateInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type PlanoUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type PlanoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type PlanoCreateManyInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type PlanoUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type PlanoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type MotivoCreateInput = {
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type MotivoUncheckedCreateInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type MotivoUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type MotivoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type MotivoCreateManyInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type MotivoUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type MotivoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type TipoProcedimentoCreateInput = {
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type TipoProcedimentoUncheckedCreateInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type TipoProcedimentoUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type TipoProcedimentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type TipoProcedimentoCreateManyInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type TipoProcedimentoUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type TipoProcedimentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type TipoEvolucaoSimplesCreateInput = {
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type TipoEvolucaoSimplesUncheckedCreateInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type TipoEvolucaoSimplesUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type TipoEvolucaoSimplesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type TipoEvolucaoSimplesCreateManyInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type TipoEvolucaoSimplesUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type TipoEvolucaoSimplesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type PaisCreateInput = {
    descricao: string
    nacionalidade?: string | null
    cdIbge?: number | null
    cidades?: CidadeCreateNestedManyWithoutPaisInput
  }

  export type PaisUncheckedCreateInput = {
    id?: number
    descricao: string
    nacionalidade?: string | null
    cdIbge?: number | null
    cidades?: CidadeUncheckedCreateNestedManyWithoutPaisInput
  }

  export type PaisUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    nacionalidade?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    cidades?: CidadeUpdateManyWithoutPaisNestedInput
  }

  export type PaisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    nacionalidade?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    cidades?: CidadeUncheckedUpdateManyWithoutPaisNestedInput
  }

  export type PaisCreateManyInput = {
    id?: number
    descricao: string
    nacionalidade?: string | null
    cdIbge?: number | null
  }

  export type PaisUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    nacionalidade?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    nacionalidade?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UnidadeFederacaoCreateInput = {
    id: string
    descricao: string
    cdIbge?: number | null
    cidades?: CidadeCreateNestedManyWithoutUfInput
  }

  export type UnidadeFederacaoUncheckedCreateInput = {
    id: string
    descricao: string
    cdIbge?: number | null
    cidades?: CidadeUncheckedCreateNestedManyWithoutUfInput
  }

  export type UnidadeFederacaoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    cidades?: CidadeUpdateManyWithoutUfNestedInput
  }

  export type UnidadeFederacaoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    cidades?: CidadeUncheckedUpdateManyWithoutUfNestedInput
  }

  export type UnidadeFederacaoCreateManyInput = {
    id: string
    descricao: string
    cdIbge?: number | null
  }

  export type UnidadeFederacaoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UnidadeFederacaoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CidadeCreateInput = {
    descricao: string
    cepGeral?: string | null
    cdIbge?: number | null
    stInativo?: $Enums.SimNao | null
    bairros?: BairroCreateNestedManyWithoutCidadeInput
    pais: PaisCreateNestedOneWithoutCidadesInput
    uf: UnidadeFederacaoCreateNestedOneWithoutCidadesInput
    distritos?: DistritoCreateNestedManyWithoutCidadeInput
    enderecos?: EnderecoCreateNestedManyWithoutCidadeInput
  }

  export type CidadeUncheckedCreateInput = {
    id?: number
    descricao: string
    cdUf: string
    cdPais: number
    cepGeral?: string | null
    cdIbge?: number | null
    stInativo?: $Enums.SimNao | null
    bairros?: BairroUncheckedCreateNestedManyWithoutCidadeInput
    distritos?: DistritoUncheckedCreateNestedManyWithoutCidadeInput
    enderecos?: EnderecoUncheckedCreateNestedManyWithoutCidadeInput
  }

  export type CidadeUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairros?: BairroUpdateManyWithoutCidadeNestedInput
    pais?: PaisUpdateOneRequiredWithoutCidadesNestedInput
    uf?: UnidadeFederacaoUpdateOneRequiredWithoutCidadesNestedInput
    distritos?: DistritoUpdateManyWithoutCidadeNestedInput
    enderecos?: EnderecoUpdateManyWithoutCidadeNestedInput
  }

  export type CidadeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    cdUf?: StringFieldUpdateOperationsInput | string
    cdPais?: IntFieldUpdateOperationsInput | number
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairros?: BairroUncheckedUpdateManyWithoutCidadeNestedInput
    distritos?: DistritoUncheckedUpdateManyWithoutCidadeNestedInput
    enderecos?: EnderecoUncheckedUpdateManyWithoutCidadeNestedInput
  }

  export type CidadeCreateManyInput = {
    id?: number
    descricao: string
    cdUf: string
    cdPais: number
    cepGeral?: string | null
    cdIbge?: number | null
    stInativo?: $Enums.SimNao | null
  }

  export type CidadeUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type CidadeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    cdUf?: StringFieldUpdateOperationsInput | string
    cdPais?: IntFieldUpdateOperationsInput | number
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type EscolaridadeCreateInput = {
    descricao: string
    stInativo?: $Enums.SimNao | null
    pacientes?: PacienteCreateNestedManyWithoutEscolaridadeInput
  }

  export type EscolaridadeUncheckedCreateInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
    pacientes?: PacienteUncheckedCreateNestedManyWithoutEscolaridadeInput
  }

  export type EscolaridadeUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: PacienteUpdateManyWithoutEscolaridadeNestedInput
  }

  export type EscolaridadeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: PacienteUncheckedUpdateManyWithoutEscolaridadeNestedInput
  }

  export type EscolaridadeCreateManyInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type EscolaridadeUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type EscolaridadeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type OcupacaoCreateInput = {
    descricao: string
    cbo?: string | null
    stInativo?: $Enums.SimNao | null
    pacientes?: PacienteCreateNestedManyWithoutOcupacaoInput
    profissionals?: ProfissionalCreateNestedManyWithoutOcupacaoInput
  }

  export type OcupacaoUncheckedCreateInput = {
    id?: number
    descricao: string
    cbo?: string | null
    stInativo?: $Enums.SimNao | null
    pacientes?: PacienteUncheckedCreateNestedManyWithoutOcupacaoInput
    profissionals?: ProfissionalUncheckedCreateNestedManyWithoutOcupacaoInput
  }

  export type OcupacaoUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    cbo?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: PacienteUpdateManyWithoutOcupacaoNestedInput
    profissionals?: ProfissionalUpdateManyWithoutOcupacaoNestedInput
  }

  export type OcupacaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    cbo?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: PacienteUncheckedUpdateManyWithoutOcupacaoNestedInput
    profissionals?: ProfissionalUncheckedUpdateManyWithoutOcupacaoNestedInput
  }

  export type OcupacaoCreateManyInput = {
    id?: number
    descricao: string
    cbo?: string | null
    stInativo?: $Enums.SimNao | null
  }

  export type OcupacaoUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    cbo?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type OcupacaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    cbo?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type DistritoCreateInput = {
    descricao: string
    stInativo?: $Enums.SimNao | null
    bairros?: BairroCreateNestedManyWithoutDistritoInput
    cidade: CidadeCreateNestedOneWithoutDistritosInput
  }

  export type DistritoUncheckedCreateInput = {
    id?: number
    cdCidade: number
    descricao: string
    stInativo?: $Enums.SimNao | null
    bairros?: BairroUncheckedCreateNestedManyWithoutDistritoInput
  }

  export type DistritoUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairros?: BairroUpdateManyWithoutDistritoNestedInput
    cidade?: CidadeUpdateOneRequiredWithoutDistritosNestedInput
  }

  export type DistritoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdCidade?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairros?: BairroUncheckedUpdateManyWithoutDistritoNestedInput
  }

  export type DistritoCreateManyInput = {
    id?: number
    cdCidade: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type DistritoUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type DistritoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdCidade?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type BairroCreateInput = {
    descricao: string
    stInativo?: $Enums.SimNao | null
    cidade: CidadeCreateNestedOneWithoutBairrosInput
    distrito?: DistritoCreateNestedOneWithoutBairrosInput
    enderecos?: EnderecoCreateNestedManyWithoutBairroInput
  }

  export type BairroUncheckedCreateInput = {
    id?: number
    cdDistrito?: number | null
    cdCidade: number
    descricao: string
    stInativo?: $Enums.SimNao | null
    enderecos?: EnderecoUncheckedCreateNestedManyWithoutBairroInput
  }

  export type BairroUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cidade?: CidadeUpdateOneRequiredWithoutBairrosNestedInput
    distrito?: DistritoUpdateOneWithoutBairrosNestedInput
    enderecos?: EnderecoUpdateManyWithoutBairroNestedInput
  }

  export type BairroUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdDistrito?: NullableIntFieldUpdateOperationsInput | number | null
    cdCidade?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    enderecos?: EnderecoUncheckedUpdateManyWithoutBairroNestedInput
  }

  export type BairroCreateManyInput = {
    id?: number
    cdDistrito?: number | null
    cdCidade: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type BairroUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type BairroUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdDistrito?: NullableIntFieldUpdateOperationsInput | number | null
    cdCidade?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type EnderecoPessoaRelacionadaCreateInput = {
    endereco: EnderecoCreateNestedOneWithoutEnderecoPessoaRelacionadasInput
    pessoaRelacionada: PessoaRelacionadaCreateNestedOneWithoutEnderecosInput
  }

  export type EnderecoPessoaRelacionadaUncheckedCreateInput = {
    id?: number
    cdPessoa: number
    cdEndereco: number
  }

  export type EnderecoPessoaRelacionadaUpdateInput = {
    endereco?: EnderecoUpdateOneRequiredWithoutEnderecoPessoaRelacionadasNestedInput
    pessoaRelacionada?: PessoaRelacionadaUpdateOneRequiredWithoutEnderecosNestedInput
  }

  export type EnderecoPessoaRelacionadaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdPessoa?: IntFieldUpdateOperationsInput | number
    cdEndereco?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoPessoaRelacionadaCreateManyInput = {
    id?: number
    cdPessoa: number
    cdEndereco: number
  }

  export type EnderecoPessoaRelacionadaUpdateManyMutationInput = {

  }

  export type EnderecoPessoaRelacionadaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdPessoa?: IntFieldUpdateOperationsInput | number
    cdEndereco?: IntFieldUpdateOperationsInput | number
  }

  export type CidCreateInput = {
    codigo: string
    descricao: string
    versao: $Enums.VersaoCid
    stInativo?: $Enums.SimNao | null
    evolucaoCids?: EvolucaoCidCreateNestedManyWithoutCidInput
  }

  export type CidUncheckedCreateInput = {
    id?: number
    codigo: string
    descricao: string
    versao: $Enums.VersaoCid
    stInativo?: $Enums.SimNao | null
    evolucaoCids?: EvolucaoCidUncheckedCreateNestedManyWithoutCidInput
  }

  export type CidUpdateInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    versao?: EnumVersaoCidFieldUpdateOperationsInput | $Enums.VersaoCid
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    evolucaoCids?: EvolucaoCidUpdateManyWithoutCidNestedInput
  }

  export type CidUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    versao?: EnumVersaoCidFieldUpdateOperationsInput | $Enums.VersaoCid
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    evolucaoCids?: EvolucaoCidUncheckedUpdateManyWithoutCidNestedInput
  }

  export type CidCreateManyInput = {
    id?: number
    codigo: string
    descricao: string
    versao: $Enums.VersaoCid
    stInativo?: $Enums.SimNao | null
  }

  export type CidUpdateManyMutationInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    versao?: EnumVersaoCidFieldUpdateOperationsInput | $Enums.VersaoCid
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type CidUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    versao?: EnumVersaoCidFieldUpdateOperationsInput | $Enums.VersaoCid
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type DsmCreateInput = {
    codigo: string
    descricao: string
    versao: $Enums.VersaoDsm
    stInativo?: $Enums.SimNao | null
    evolucaoDsms?: EvolucaoDsmCreateNestedManyWithoutDsmInput
  }

  export type DsmUncheckedCreateInput = {
    id?: number
    codigo: string
    descricao: string
    versao: $Enums.VersaoDsm
    stInativo?: $Enums.SimNao | null
    evolucaoDsms?: EvolucaoDsmUncheckedCreateNestedManyWithoutDsmInput
  }

  export type DsmUpdateInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    versao?: EnumVersaoDsmFieldUpdateOperationsInput | $Enums.VersaoDsm
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    evolucaoDsms?: EvolucaoDsmUpdateManyWithoutDsmNestedInput
  }

  export type DsmUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    versao?: EnumVersaoDsmFieldUpdateOperationsInput | $Enums.VersaoDsm
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    evolucaoDsms?: EvolucaoDsmUncheckedUpdateManyWithoutDsmNestedInput
  }

  export type DsmCreateManyInput = {
    id?: number
    codigo: string
    descricao: string
    versao: $Enums.VersaoDsm
    stInativo?: $Enums.SimNao | null
  }

  export type DsmUpdateManyMutationInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    versao?: EnumVersaoDsmFieldUpdateOperationsInput | $Enums.VersaoDsm
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type DsmUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    versao?: EnumVersaoDsmFieldUpdateOperationsInput | $Enums.VersaoDsm
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type TipoEvolucaoClinicaCreateInput = {
    descricao: string
    stInativo?: $Enums.SimNao | null
    evolucaos?: EvolucaoCreateNestedManyWithoutTipoEvolucaoClinicaInput
  }

  export type TipoEvolucaoClinicaUncheckedCreateInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
    evolucaos?: EvolucaoUncheckedCreateNestedManyWithoutTipoEvolucaoClinicaInput
  }

  export type TipoEvolucaoClinicaUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    evolucaos?: EvolucaoUpdateManyWithoutTipoEvolucaoClinicaNestedInput
  }

  export type TipoEvolucaoClinicaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    evolucaos?: EvolucaoUncheckedUpdateManyWithoutTipoEvolucaoClinicaNestedInput
  }

  export type TipoEvolucaoClinicaCreateManyInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type TipoEvolucaoClinicaUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type TipoEvolucaoClinicaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type EvolucaoCidCreateInput = {
    cid: CidCreateNestedOneWithoutEvolucaoCidsInput
    evolucao: EvolucaoCreateNestedOneWithoutCidInput
  }

  export type EvolucaoCidUncheckedCreateInput = {
    id?: number
    cdEvolucao: number
    cdCid: number
  }

  export type EvolucaoCidUpdateInput = {
    cid?: CidUpdateOneRequiredWithoutEvolucaoCidsNestedInput
    evolucao?: EvolucaoUpdateOneRequiredWithoutCidNestedInput
  }

  export type EvolucaoCidUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdEvolucao?: IntFieldUpdateOperationsInput | number
    cdCid?: IntFieldUpdateOperationsInput | number
  }

  export type EvolucaoCidCreateManyInput = {
    id?: number
    cdEvolucao: number
    cdCid: number
  }

  export type EvolucaoCidUpdateManyMutationInput = {

  }

  export type EvolucaoCidUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdEvolucao?: IntFieldUpdateOperationsInput | number
    cdCid?: IntFieldUpdateOperationsInput | number
  }

  export type EvolucaoDsmCreateInput = {
    dsm: DsmCreateNestedOneWithoutEvolucaoDsmsInput
    evolucao: EvolucaoCreateNestedOneWithoutDsmInput
  }

  export type EvolucaoDsmUncheckedCreateInput = {
    id?: number
    cdEvolucao: number
    cdDsm: number
  }

  export type EvolucaoDsmUpdateInput = {
    dsm?: DsmUpdateOneRequiredWithoutEvolucaoDsmsNestedInput
    evolucao?: EvolucaoUpdateOneRequiredWithoutDsmNestedInput
  }

  export type EvolucaoDsmUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdEvolucao?: IntFieldUpdateOperationsInput | number
    cdDsm?: IntFieldUpdateOperationsInput | number
  }

  export type EvolucaoDsmCreateManyInput = {
    id?: number
    cdEvolucao: number
    cdDsm: number
  }

  export type EvolucaoDsmUpdateManyMutationInput = {

  }

  export type EvolucaoDsmUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdEvolucao?: IntFieldUpdateOperationsInput | number
    cdDsm?: IntFieldUpdateOperationsInput | number
  }

  export type SinaisVitaisCreateInput = {
    data?: Date | string
    paSistolica?: number | null
    paDiastolica?: number | null
    fc?: number | null
    fr?: number | null
    temperatura?: Decimal | DecimalJsLike | number | string | null
    spo2?: number | null
    peso?: Decimal | DecimalJsLike | number | string | null
    altura?: Decimal | DecimalJsLike | number | string | null
    imc?: Decimal | DecimalJsLike | number | string | null
    dor?: number | null
    posicao?: $Enums.PosicaoPaciente | null
    origem?: $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
    atendimento: AtendimentoCreateNestedOneWithoutSinaisVitaisInput
    escalaDor?: EscalaDorCreateNestedOneWithoutSinaisVitaisInput
  }

  export type SinaisVitaisUncheckedCreateInput = {
    id?: number
    cdAtendimento: number
    data?: Date | string
    paSistolica?: number | null
    paDiastolica?: number | null
    fc?: number | null
    fr?: number | null
    temperatura?: Decimal | DecimalJsLike | number | string | null
    spo2?: number | null
    peso?: Decimal | DecimalJsLike | number | string | null
    altura?: Decimal | DecimalJsLike | number | string | null
    imc?: Decimal | DecimalJsLike | number | string | null
    dor?: number | null
    escalaDorId?: number | null
    posicao?: $Enums.PosicaoPaciente | null
    origem?: $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SinaisVitaisUpdateInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    paSistolica?: NullableIntFieldUpdateOperationsInput | number | null
    paDiastolica?: NullableIntFieldUpdateOperationsInput | number | null
    fc?: NullableIntFieldUpdateOperationsInput | number | null
    fr?: NullableIntFieldUpdateOperationsInput | number | null
    temperatura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    altura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dor?: NullableIntFieldUpdateOperationsInput | number | null
    posicao?: NullableEnumPosicaoPacienteFieldUpdateOperationsInput | $Enums.PosicaoPaciente | null
    origem?: NullableEnumOrigemAfericaoFieldUpdateOperationsInput | $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
    atendimento?: AtendimentoUpdateOneRequiredWithoutSinaisVitaisNestedInput
    escalaDor?: EscalaDorUpdateOneWithoutSinaisVitaisNestedInput
  }

  export type SinaisVitaisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    paSistolica?: NullableIntFieldUpdateOperationsInput | number | null
    paDiastolica?: NullableIntFieldUpdateOperationsInput | number | null
    fc?: NullableIntFieldUpdateOperationsInput | number | null
    fr?: NullableIntFieldUpdateOperationsInput | number | null
    temperatura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    altura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dor?: NullableIntFieldUpdateOperationsInput | number | null
    escalaDorId?: NullableIntFieldUpdateOperationsInput | number | null
    posicao?: NullableEnumPosicaoPacienteFieldUpdateOperationsInput | $Enums.PosicaoPaciente | null
    origem?: NullableEnumOrigemAfericaoFieldUpdateOperationsInput | $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SinaisVitaisCreateManyInput = {
    id?: number
    cdAtendimento: number
    data?: Date | string
    paSistolica?: number | null
    paDiastolica?: number | null
    fc?: number | null
    fr?: number | null
    temperatura?: Decimal | DecimalJsLike | number | string | null
    spo2?: number | null
    peso?: Decimal | DecimalJsLike | number | string | null
    altura?: Decimal | DecimalJsLike | number | string | null
    imc?: Decimal | DecimalJsLike | number | string | null
    dor?: number | null
    escalaDorId?: number | null
    posicao?: $Enums.PosicaoPaciente | null
    origem?: $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SinaisVitaisUpdateManyMutationInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    paSistolica?: NullableIntFieldUpdateOperationsInput | number | null
    paDiastolica?: NullableIntFieldUpdateOperationsInput | number | null
    fc?: NullableIntFieldUpdateOperationsInput | number | null
    fr?: NullableIntFieldUpdateOperationsInput | number | null
    temperatura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    altura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dor?: NullableIntFieldUpdateOperationsInput | number | null
    posicao?: NullableEnumPosicaoPacienteFieldUpdateOperationsInput | $Enums.PosicaoPaciente | null
    origem?: NullableEnumOrigemAfericaoFieldUpdateOperationsInput | $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SinaisVitaisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    paSistolica?: NullableIntFieldUpdateOperationsInput | number | null
    paDiastolica?: NullableIntFieldUpdateOperationsInput | number | null
    fc?: NullableIntFieldUpdateOperationsInput | number | null
    fr?: NullableIntFieldUpdateOperationsInput | number | null
    temperatura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    altura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dor?: NullableIntFieldUpdateOperationsInput | number | null
    escalaDorId?: NullableIntFieldUpdateOperationsInput | number | null
    posicao?: NullableEnumPosicaoPacienteFieldUpdateOperationsInput | $Enums.PosicaoPaciente | null
    origem?: NullableEnumOrigemAfericaoFieldUpdateOperationsInput | $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EscalaDorCreateInput = {
    nome: string
    descricao?: string | null
    sinaisVitais?: SinaisVitaisCreateNestedManyWithoutEscalaDorInput
  }

  export type EscalaDorUncheckedCreateInput = {
    id?: number
    nome: string
    descricao?: string | null
    sinaisVitais?: SinaisVitaisUncheckedCreateNestedManyWithoutEscalaDorInput
  }

  export type EscalaDorUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    sinaisVitais?: SinaisVitaisUpdateManyWithoutEscalaDorNestedInput
  }

  export type EscalaDorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    sinaisVitais?: SinaisVitaisUncheckedUpdateManyWithoutEscalaDorNestedInput
  }

  export type EscalaDorCreateManyInput = {
    id?: number
    nome: string
    descricao?: string | null
  }

  export type EscalaDorUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EscalaDorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GlasgowCreateInput = {
    data?: Date | string
    ocular: number
    verbal: number
    motora: number
    total: number
    observacao?: string | null
    atendimento: AtendimentoCreateNestedOneWithoutGlasgowsInput
    profissional?: ProfissionalCreateNestedOneWithoutGlasgowsInput
  }

  export type GlasgowUncheckedCreateInput = {
    id?: number
    cdAtendimento: number
    cdProfissional?: number | null
    data?: Date | string
    ocular: number
    verbal: number
    motora: number
    total: number
    observacao?: string | null
  }

  export type GlasgowUpdateInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    ocular?: IntFieldUpdateOperationsInput | number
    verbal?: IntFieldUpdateOperationsInput | number
    motora?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    atendimento?: AtendimentoUpdateOneRequiredWithoutGlasgowsNestedInput
    profissional?: ProfissionalUpdateOneWithoutGlasgowsNestedInput
  }

  export type GlasgowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    ocular?: IntFieldUpdateOperationsInput | number
    verbal?: IntFieldUpdateOperationsInput | number
    motora?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GlasgowCreateManyInput = {
    id?: number
    cdAtendimento: number
    cdProfissional?: number | null
    data?: Date | string
    ocular: number
    verbal: number
    motora: number
    total: number
    observacao?: string | null
  }

  export type GlasgowUpdateManyMutationInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    ocular?: IntFieldUpdateOperationsInput | number
    verbal?: IntFieldUpdateOperationsInput | number
    motora?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GlasgowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    ocular?: IntFieldUpdateOperationsInput | number
    verbal?: IntFieldUpdateOperationsInput | number
    motora?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AfericaoClinicaCreateInput = {
    escala: string
    idRegistro: number
    data?: Date | string
    atendimento: AtendimentoCreateNestedOneWithoutAfericoesClinicasInput
    profissional?: ProfissionalCreateNestedOneWithoutAfericoesClinicasInput
  }

  export type AfericaoClinicaUncheckedCreateInput = {
    id?: number
    cdAtendimento: number
    cdProfissional?: number | null
    escala: string
    idRegistro: number
    data?: Date | string
  }

  export type AfericaoClinicaUpdateInput = {
    escala?: StringFieldUpdateOperationsInput | string
    idRegistro?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    atendimento?: AtendimentoUpdateOneRequiredWithoutAfericoesClinicasNestedInput
    profissional?: ProfissionalUpdateOneWithoutAfericoesClinicasNestedInput
  }

  export type AfericaoClinicaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    escala?: StringFieldUpdateOperationsInput | string
    idRegistro?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AfericaoClinicaCreateManyInput = {
    id?: number
    cdAtendimento: number
    cdProfissional?: number | null
    escala: string
    idRegistro: number
    data?: Date | string
  }

  export type AfericaoClinicaUpdateManyMutationInput = {
    escala?: StringFieldUpdateOperationsInput | string
    idRegistro?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AfericaoClinicaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    escala?: StringFieldUpdateOperationsInput | string
    idRegistro?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaDorCreateInput = {
    data?: Date | string
    valor: number
    observacao?: string | null
    atendimento: AtendimentoCreateNestedOneWithoutEvaDoresInput
    profissional?: ProfissionalCreateNestedOneWithoutEvaDoresInput
  }

  export type EvaDorUncheckedCreateInput = {
    id?: number
    cdAtendimento: number
    cdProfissional?: number | null
    data?: Date | string
    valor: number
    observacao?: string | null
  }

  export type EvaDorUpdateInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    atendimento?: AtendimentoUpdateOneRequiredWithoutEvaDoresNestedInput
    profissional?: ProfissionalUpdateOneWithoutEvaDoresNestedInput
  }

  export type EvaDorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvaDorCreateManyInput = {
    id?: number
    cdAtendimento: number
    cdProfissional?: number | null
    data?: Date | string
    valor: number
    observacao?: string | null
  }

  export type EvaDorUpdateManyMutationInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvaDorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuarioAuthCreateInput = {
    email: string
    senhaHash: string
    role?: $Enums.RoleAuth
    paciente?: PacienteCreateNestedOneWithoutUsuarioAuthsInput
    master: MasterCreateNestedOneWithoutUsuarioAuthsInput
    profissional?: ProfissionalCreateNestedOneWithoutUsuarioAuthsInput
  }

  export type UsuarioAuthUncheckedCreateInput = {
    id?: number
    cdMaster: number
    email: string
    senhaHash: string
    role?: $Enums.RoleAuth
    cdProfissional?: number | null
    cdPaciente?: number | null
  }

  export type UsuarioAuthUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAuthFieldUpdateOperationsInput | $Enums.RoleAuth
    paciente?: PacienteUpdateOneWithoutUsuarioAuthsNestedInput
    master?: MasterUpdateOneRequiredWithoutUsuarioAuthsNestedInput
    profissional?: ProfissionalUpdateOneWithoutUsuarioAuthsNestedInput
  }

  export type UsuarioAuthUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAuthFieldUpdateOperationsInput | $Enums.RoleAuth
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    cdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsuarioAuthCreateManyInput = {
    id?: number
    cdMaster: number
    email: string
    senhaHash: string
    role?: $Enums.RoleAuth
    cdProfissional?: number | null
    cdPaciente?: number | null
  }

  export type UsuarioAuthUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAuthFieldUpdateOperationsInput | $Enums.RoleAuth
  }

  export type UsuarioAuthUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAuthFieldUpdateOperationsInput | $Enums.RoleAuth
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    cdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumSimNaoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SimNao | EnumSimNaoFieldRefInput<$PrismaModel> | null
    in?: $Enums.SimNao[] | ListEnumSimNaoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SimNao[] | ListEnumSimNaoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSimNaoNullableFilter<$PrismaModel> | $Enums.SimNao | null
  }

  export type PacienteListRelationFilter = {
    every?: PacienteWhereInput
    some?: PacienteWhereInput
    none?: PacienteWhereInput
  }

  export type ProfissionalListRelationFilter = {
    every?: ProfissionalWhereInput
    some?: ProfissionalWhereInput
    none?: ProfissionalWhereInput
  }

  export type UsuarioAuthListRelationFilter = {
    every?: UsuarioAuthWhereInput
    some?: UsuarioAuthWhereInput
    none?: UsuarioAuthWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PacienteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfissionalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioAuthOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MasterCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    dtCadastro?: SortOrder
    stInativo?: SortOrder
  }

  export type MasterAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MasterMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    dtCadastro?: SortOrder
    stInativo?: SortOrder
  }

  export type MasterMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    dtCadastro?: SortOrder
    stInativo?: SortOrder
  }

  export type MasterSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumSimNaoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimNao | EnumSimNaoFieldRefInput<$PrismaModel> | null
    in?: $Enums.SimNao[] | ListEnumSimNaoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SimNao[] | ListEnumSimNaoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSimNaoNullableWithAggregatesFilter<$PrismaModel> | $Enums.SimNao | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSimNaoNullableFilter<$PrismaModel>
    _max?: NestedEnumSimNaoNullableFilter<$PrismaModel>
  }

  export type EnumSexoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexoNullableFilter<$PrismaModel> | $Enums.Sexo | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AtendimentoListRelationFilter = {
    every?: AtendimentoWhereInput
    some?: AtendimentoWhereInput
    none?: AtendimentoWhereInput
  }

  export type ContatoPacienteListRelationFilter = {
    every?: ContatoPacienteWhereInput
    some?: ContatoPacienteWhereInput
    none?: ContatoPacienteWhereInput
  }

  export type EnderecoPacienteListRelationFilter = {
    every?: EnderecoPacienteWhereInput
    some?: EnderecoPacienteWhereInput
    none?: EnderecoPacienteWhereInput
  }

  export type EvolucaoListRelationFilter = {
    every?: EvolucaoWhereInput
    some?: EvolucaoWhereInput
    none?: EvolucaoWhereInput
  }

  export type EscolaridadeNullableScalarRelationFilter = {
    is?: EscolaridadeWhereInput | null
    isNot?: EscolaridadeWhereInput | null
  }

  export type MasterScalarRelationFilter = {
    is?: MasterWhereInput
    isNot?: MasterWhereInput
  }

  export type OcupacaoNullableScalarRelationFilter = {
    is?: OcupacaoWhereInput | null
    isNot?: OcupacaoWhereInput | null
  }

  export type ParentescoPacienteListRelationFilter = {
    every?: ParentescoPacienteWhereInput
    some?: ParentescoPacienteWhereInput
    none?: ParentescoPacienteWhereInput
  }

  export type AtendimentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContatoPacienteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnderecoPacienteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvolucaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParentescoPacienteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PacienteCdMasterCdPacienteCompoundUniqueInput = {
    cdMaster: number
    cdPaciente: number
  }

  export type PacienteCountOrderByAggregateInput = {
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    nome?: SortOrder
    sexo?: SortOrder
    dtNascimento?: SortOrder
    stInativo?: SortOrder
    cdEscolaridade?: SortOrder
    cdOcupacao?: SortOrder
  }

  export type PacienteAvgOrderByAggregateInput = {
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdEscolaridade?: SortOrder
    cdOcupacao?: SortOrder
  }

  export type PacienteMaxOrderByAggregateInput = {
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    nome?: SortOrder
    sexo?: SortOrder
    dtNascimento?: SortOrder
    stInativo?: SortOrder
    cdEscolaridade?: SortOrder
    cdOcupacao?: SortOrder
  }

  export type PacienteMinOrderByAggregateInput = {
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    nome?: SortOrder
    sexo?: SortOrder
    dtNascimento?: SortOrder
    stInativo?: SortOrder
    cdEscolaridade?: SortOrder
    cdOcupacao?: SortOrder
  }

  export type PacienteSumOrderByAggregateInput = {
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdEscolaridade?: SortOrder
    cdOcupacao?: SortOrder
  }

  export type EnumSexoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexoNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sexo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSexoNullableFilter<$PrismaModel>
    _max?: NestedEnumSexoNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type AfericaoClinicaListRelationFilter = {
    every?: AfericaoClinicaWhereInput
    some?: AfericaoClinicaWhereInput
    none?: AfericaoClinicaWhereInput
  }

  export type ContatoProfissionalListRelationFilter = {
    every?: ContatoProfissionalWhereInput
    some?: ContatoProfissionalWhereInput
    none?: ContatoProfissionalWhereInput
  }

  export type EnderecoProfissionalListRelationFilter = {
    every?: EnderecoProfissionalWhereInput
    some?: EnderecoProfissionalWhereInput
    none?: EnderecoProfissionalWhereInput
  }

  export type EvaDorListRelationFilter = {
    every?: EvaDorWhereInput
    some?: EvaDorWhereInput
    none?: EvaDorWhereInput
  }

  export type GlasgowListRelationFilter = {
    every?: GlasgowWhereInput
    some?: GlasgowWhereInput
    none?: GlasgowWhereInput
  }

  export type AfericaoClinicaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContatoProfissionalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnderecoProfissionalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaDorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GlasgowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfissionalCountOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    nome?: SortOrder
    sexo?: SortOrder
    conselho?: SortOrder
    stInativo?: SortOrder
    cdOcupacao?: SortOrder
  }

  export type ProfissionalAvgOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdOcupacao?: SortOrder
  }

  export type ProfissionalMaxOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    nome?: SortOrder
    sexo?: SortOrder
    conselho?: SortOrder
    stInativo?: SortOrder
    cdOcupacao?: SortOrder
  }

  export type ProfissionalMinOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    nome?: SortOrder
    sexo?: SortOrder
    conselho?: SortOrder
    stInativo?: SortOrder
    cdOcupacao?: SortOrder
  }

  export type ProfissionalSumOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdOcupacao?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BairroScalarRelationFilter = {
    is?: BairroWhereInput
    isNot?: BairroWhereInput
  }

  export type CidadeScalarRelationFilter = {
    is?: CidadeWhereInput
    isNot?: CidadeWhereInput
  }

  export type EnderecoPessoaRelacionadaListRelationFilter = {
    every?: EnderecoPessoaRelacionadaWhereInput
    some?: EnderecoPessoaRelacionadaWhereInput
    none?: EnderecoPessoaRelacionadaWhereInput
  }

  export type EnderecoPessoaRelacionadaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnderecoCountOrderByAggregateInput = {
    id?: SortOrder
    logradouro?: SortOrder
    numero?: SortOrder
    complemento?: SortOrder
    cdBairro?: SortOrder
    cdCidade?: SortOrder
    cep?: SortOrder
    stInativo?: SortOrder
  }

  export type EnderecoAvgOrderByAggregateInput = {
    id?: SortOrder
    cdBairro?: SortOrder
    cdCidade?: SortOrder
  }

  export type EnderecoMaxOrderByAggregateInput = {
    id?: SortOrder
    logradouro?: SortOrder
    numero?: SortOrder
    complemento?: SortOrder
    cdBairro?: SortOrder
    cdCidade?: SortOrder
    cep?: SortOrder
    stInativo?: SortOrder
  }

  export type EnderecoMinOrderByAggregateInput = {
    id?: SortOrder
    logradouro?: SortOrder
    numero?: SortOrder
    complemento?: SortOrder
    cdBairro?: SortOrder
    cdCidade?: SortOrder
    cep?: SortOrder
    stInativo?: SortOrder
  }

  export type EnderecoSumOrderByAggregateInput = {
    id?: SortOrder
    cdBairro?: SortOrder
    cdCidade?: SortOrder
  }

  export type EnderecoScalarRelationFilter = {
    is?: EnderecoWhereInput
    isNot?: EnderecoWhereInput
  }

  export type PacienteScalarRelationFilter = {
    is?: PacienteWhereInput
    isNot?: PacienteWhereInput
  }

  export type EnderecoPacienteCountOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdEndereco?: SortOrder
  }

  export type EnderecoPacienteAvgOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdEndereco?: SortOrder
  }

  export type EnderecoPacienteMaxOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdEndereco?: SortOrder
  }

  export type EnderecoPacienteMinOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdEndereco?: SortOrder
  }

  export type EnderecoPacienteSumOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdEndereco?: SortOrder
  }

  export type ProfissionalScalarRelationFilter = {
    is?: ProfissionalWhereInput
    isNot?: ProfissionalWhereInput
  }

  export type EnderecoProfissionalCountOrderByAggregateInput = {
    id?: SortOrder
    cdProf?: SortOrder
    cdEndereco?: SortOrder
  }

  export type EnderecoProfissionalAvgOrderByAggregateInput = {
    id?: SortOrder
    cdProf?: SortOrder
    cdEndereco?: SortOrder
  }

  export type EnderecoProfissionalMaxOrderByAggregateInput = {
    id?: SortOrder
    cdProf?: SortOrder
    cdEndereco?: SortOrder
  }

  export type EnderecoProfissionalMinOrderByAggregateInput = {
    id?: SortOrder
    cdProf?: SortOrder
    cdEndereco?: SortOrder
  }

  export type EnderecoProfissionalSumOrderByAggregateInput = {
    id?: SortOrder
    cdProf?: SortOrder
    cdEndereco?: SortOrder
  }

  export type EnumTipoFoneFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoFone | EnumTipoFoneFieldRefInput<$PrismaModel>
    in?: $Enums.TipoFone[] | ListEnumTipoFoneFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoFone[] | ListEnumTipoFoneFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoFoneFilter<$PrismaModel> | $Enums.TipoFone
  }

  export type ContatoCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    numero?: SortOrder
    stInativo?: SortOrder
  }

  export type ContatoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContatoMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    numero?: SortOrder
    stInativo?: SortOrder
  }

  export type ContatoMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    numero?: SortOrder
    stInativo?: SortOrder
  }

  export type ContatoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTipoFoneWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoFone | EnumTipoFoneFieldRefInput<$PrismaModel>
    in?: $Enums.TipoFone[] | ListEnumTipoFoneFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoFone[] | ListEnumTipoFoneFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoFoneWithAggregatesFilter<$PrismaModel> | $Enums.TipoFone
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoFoneFilter<$PrismaModel>
    _max?: NestedEnumTipoFoneFilter<$PrismaModel>
  }

  export type ContatoScalarRelationFilter = {
    is?: ContatoWhereInput
    isNot?: ContatoWhereInput
  }

  export type ContatoPacienteCountOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdContato?: SortOrder
  }

  export type ContatoPacienteAvgOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdContato?: SortOrder
  }

  export type ContatoPacienteMaxOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdContato?: SortOrder
  }

  export type ContatoPacienteMinOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdContato?: SortOrder
  }

  export type ContatoPacienteSumOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdContato?: SortOrder
  }

  export type ContatoProfissionalCountOrderByAggregateInput = {
    id?: SortOrder
    cdProf?: SortOrder
    cdContato?: SortOrder
  }

  export type ContatoProfissionalAvgOrderByAggregateInput = {
    id?: SortOrder
    cdProf?: SortOrder
    cdContato?: SortOrder
  }

  export type ContatoProfissionalMaxOrderByAggregateInput = {
    id?: SortOrder
    cdProf?: SortOrder
    cdContato?: SortOrder
  }

  export type ContatoProfissionalMinOrderByAggregateInput = {
    id?: SortOrder
    cdProf?: SortOrder
    cdContato?: SortOrder
  }

  export type ContatoProfissionalSumOrderByAggregateInput = {
    id?: SortOrder
    cdProf?: SortOrder
    cdContato?: SortOrder
  }

  export type SinaisVitaisListRelationFilter = {
    every?: SinaisVitaisWhereInput
    some?: SinaisVitaisWhereInput
    none?: SinaisVitaisWhereInput
  }

  export type SinaisVitaisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AtendimentoCountOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdProfissional?: SortOrder
    data?: SortOrder
    observacao?: SortOrder
  }

  export type AtendimentoAvgOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdProfissional?: SortOrder
  }

  export type AtendimentoMaxOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdProfissional?: SortOrder
    data?: SortOrder
    observacao?: SortOrder
  }

  export type AtendimentoMinOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdProfissional?: SortOrder
    data?: SortOrder
    observacao?: SortOrder
  }

  export type AtendimentoSumOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdProfissional?: SortOrder
  }

  export type AtendimentoScalarRelationFilter = {
    is?: AtendimentoWhereInput
    isNot?: AtendimentoWhereInput
  }

  export type ProfissionalNullableScalarRelationFilter = {
    is?: ProfissionalWhereInput | null
    isNot?: ProfissionalWhereInput | null
  }

  export type PacienteNullableScalarRelationFilter = {
    is?: PacienteWhereInput | null
    isNot?: PacienteWhereInput | null
  }

  export type TipoEvolucaoClinicaNullableScalarRelationFilter = {
    is?: TipoEvolucaoClinicaWhereInput | null
    isNot?: TipoEvolucaoClinicaWhereInput | null
  }

  export type EvolucaoCidListRelationFilter = {
    every?: EvolucaoCidWhereInput
    some?: EvolucaoCidWhereInput
    none?: EvolucaoCidWhereInput
  }

  export type EvolucaoDsmListRelationFilter = {
    every?: EvolucaoDsmWhereInput
    some?: EvolucaoDsmWhereInput
    none?: EvolucaoDsmWhereInput
  }

  export type EvolucaoCidOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvolucaoDsmOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvolucaoCountOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    data?: SortOrder
    texto?: SortOrder
    pacienteCdMaster?: SortOrder
    pacienteCdPaciente?: SortOrder
    tipoEvolucaoClinicaId?: SortOrder
  }

  export type EvolucaoAvgOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    pacienteCdMaster?: SortOrder
    pacienteCdPaciente?: SortOrder
    tipoEvolucaoClinicaId?: SortOrder
  }

  export type EvolucaoMaxOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    data?: SortOrder
    texto?: SortOrder
    pacienteCdMaster?: SortOrder
    pacienteCdPaciente?: SortOrder
    tipoEvolucaoClinicaId?: SortOrder
  }

  export type EvolucaoMinOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    data?: SortOrder
    texto?: SortOrder
    pacienteCdMaster?: SortOrder
    pacienteCdPaciente?: SortOrder
    tipoEvolucaoClinicaId?: SortOrder
  }

  export type EvolucaoSumOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    pacienteCdMaster?: SortOrder
    pacienteCdPaciente?: SortOrder
    tipoEvolucaoClinicaId?: SortOrder
  }

  export type PessoaRelacionadaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
    stInativo?: SortOrder
  }

  export type PessoaRelacionadaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PessoaRelacionadaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
    stInativo?: SortOrder
  }

  export type PessoaRelacionadaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    telefone?: SortOrder
    stInativo?: SortOrder
  }

  export type PessoaRelacionadaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTipoParentescoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoParentesco | EnumTipoParentescoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoParentesco[] | ListEnumTipoParentescoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoParentesco[] | ListEnumTipoParentescoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoParentescoFilter<$PrismaModel> | $Enums.TipoParentesco
  }

  export type PessoaRelacionadaScalarRelationFilter = {
    is?: PessoaRelacionadaWhereInput
    isNot?: PessoaRelacionadaWhereInput
  }

  export type ParentescoPacienteCountOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdPessoa?: SortOrder
    parentesco?: SortOrder
  }

  export type ParentescoPacienteAvgOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdPessoa?: SortOrder
  }

  export type ParentescoPacienteMaxOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdPessoa?: SortOrder
    parentesco?: SortOrder
  }

  export type ParentescoPacienteMinOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdPessoa?: SortOrder
    parentesco?: SortOrder
  }

  export type ParentescoPacienteSumOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdPaciente?: SortOrder
    cdPessoa?: SortOrder
  }

  export type EnumTipoParentescoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoParentesco | EnumTipoParentescoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoParentesco[] | ListEnumTipoParentescoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoParentesco[] | ListEnumTipoParentescoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoParentescoWithAggregatesFilter<$PrismaModel> | $Enums.TipoParentesco
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoParentescoFilter<$PrismaModel>
    _max?: NestedEnumTipoParentescoFilter<$PrismaModel>
  }

  export type PlanoCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type PlanoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlanoMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type PlanoMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type PlanoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MotivoCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type MotivoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MotivoMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type MotivoMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type MotivoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoProcedimentoCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type TipoProcedimentoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoProcedimentoMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type TipoProcedimentoMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type TipoProcedimentoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoEvolucaoSimplesCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type TipoEvolucaoSimplesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoEvolucaoSimplesMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type TipoEvolucaoSimplesMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type TipoEvolucaoSimplesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CidadeListRelationFilter = {
    every?: CidadeWhereInput
    some?: CidadeWhereInput
    none?: CidadeWhereInput
  }

  export type CidadeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaisCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    nacionalidade?: SortOrder
    cdIbge?: SortOrder
  }

  export type PaisAvgOrderByAggregateInput = {
    id?: SortOrder
    cdIbge?: SortOrder
  }

  export type PaisMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    nacionalidade?: SortOrder
    cdIbge?: SortOrder
  }

  export type PaisMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    nacionalidade?: SortOrder
    cdIbge?: SortOrder
  }

  export type PaisSumOrderByAggregateInput = {
    id?: SortOrder
    cdIbge?: SortOrder
  }

  export type UnidadeFederacaoCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    cdIbge?: SortOrder
  }

  export type UnidadeFederacaoAvgOrderByAggregateInput = {
    cdIbge?: SortOrder
  }

  export type UnidadeFederacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    cdIbge?: SortOrder
  }

  export type UnidadeFederacaoMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    cdIbge?: SortOrder
  }

  export type UnidadeFederacaoSumOrderByAggregateInput = {
    cdIbge?: SortOrder
  }

  export type BairroListRelationFilter = {
    every?: BairroWhereInput
    some?: BairroWhereInput
    none?: BairroWhereInput
  }

  export type PaisScalarRelationFilter = {
    is?: PaisWhereInput
    isNot?: PaisWhereInput
  }

  export type UnidadeFederacaoScalarRelationFilter = {
    is?: UnidadeFederacaoWhereInput
    isNot?: UnidadeFederacaoWhereInput
  }

  export type DistritoListRelationFilter = {
    every?: DistritoWhereInput
    some?: DistritoWhereInput
    none?: DistritoWhereInput
  }

  export type EnderecoListRelationFilter = {
    every?: EnderecoWhereInput
    some?: EnderecoWhereInput
    none?: EnderecoWhereInput
  }

  export type BairroOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DistritoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnderecoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CidadeCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    cdUf?: SortOrder
    cdPais?: SortOrder
    cepGeral?: SortOrder
    cdIbge?: SortOrder
    stInativo?: SortOrder
  }

  export type CidadeAvgOrderByAggregateInput = {
    id?: SortOrder
    cdPais?: SortOrder
    cdIbge?: SortOrder
  }

  export type CidadeMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    cdUf?: SortOrder
    cdPais?: SortOrder
    cepGeral?: SortOrder
    cdIbge?: SortOrder
    stInativo?: SortOrder
  }

  export type CidadeMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    cdUf?: SortOrder
    cdPais?: SortOrder
    cepGeral?: SortOrder
    cdIbge?: SortOrder
    stInativo?: SortOrder
  }

  export type CidadeSumOrderByAggregateInput = {
    id?: SortOrder
    cdPais?: SortOrder
    cdIbge?: SortOrder
  }

  export type EscolaridadeCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type EscolaridadeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EscolaridadeMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type EscolaridadeMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type EscolaridadeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OcupacaoCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    cbo?: SortOrder
    stInativo?: SortOrder
  }

  export type OcupacaoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OcupacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    cbo?: SortOrder
    stInativo?: SortOrder
  }

  export type OcupacaoMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    cbo?: SortOrder
    stInativo?: SortOrder
  }

  export type OcupacaoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DistritoCountOrderByAggregateInput = {
    id?: SortOrder
    cdCidade?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type DistritoAvgOrderByAggregateInput = {
    id?: SortOrder
    cdCidade?: SortOrder
  }

  export type DistritoMaxOrderByAggregateInput = {
    id?: SortOrder
    cdCidade?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type DistritoMinOrderByAggregateInput = {
    id?: SortOrder
    cdCidade?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type DistritoSumOrderByAggregateInput = {
    id?: SortOrder
    cdCidade?: SortOrder
  }

  export type DistritoNullableScalarRelationFilter = {
    is?: DistritoWhereInput | null
    isNot?: DistritoWhereInput | null
  }

  export type BairroCountOrderByAggregateInput = {
    id?: SortOrder
    cdDistrito?: SortOrder
    cdCidade?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type BairroAvgOrderByAggregateInput = {
    id?: SortOrder
    cdDistrito?: SortOrder
    cdCidade?: SortOrder
  }

  export type BairroMaxOrderByAggregateInput = {
    id?: SortOrder
    cdDistrito?: SortOrder
    cdCidade?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type BairroMinOrderByAggregateInput = {
    id?: SortOrder
    cdDistrito?: SortOrder
    cdCidade?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type BairroSumOrderByAggregateInput = {
    id?: SortOrder
    cdDistrito?: SortOrder
    cdCidade?: SortOrder
  }

  export type EnderecoPessoaRelacionadaCountOrderByAggregateInput = {
    id?: SortOrder
    cdPessoa?: SortOrder
    cdEndereco?: SortOrder
  }

  export type EnderecoPessoaRelacionadaAvgOrderByAggregateInput = {
    id?: SortOrder
    cdPessoa?: SortOrder
    cdEndereco?: SortOrder
  }

  export type EnderecoPessoaRelacionadaMaxOrderByAggregateInput = {
    id?: SortOrder
    cdPessoa?: SortOrder
    cdEndereco?: SortOrder
  }

  export type EnderecoPessoaRelacionadaMinOrderByAggregateInput = {
    id?: SortOrder
    cdPessoa?: SortOrder
    cdEndereco?: SortOrder
  }

  export type EnderecoPessoaRelacionadaSumOrderByAggregateInput = {
    id?: SortOrder
    cdPessoa?: SortOrder
    cdEndereco?: SortOrder
  }

  export type EnumVersaoCidFilter<$PrismaModel = never> = {
    equals?: $Enums.VersaoCid | EnumVersaoCidFieldRefInput<$PrismaModel>
    in?: $Enums.VersaoCid[] | ListEnumVersaoCidFieldRefInput<$PrismaModel>
    notIn?: $Enums.VersaoCid[] | ListEnumVersaoCidFieldRefInput<$PrismaModel>
    not?: NestedEnumVersaoCidFilter<$PrismaModel> | $Enums.VersaoCid
  }

  export type CidCodigoVersaoCompoundUniqueInput = {
    codigo: string
    versao: $Enums.VersaoCid
  }

  export type CidCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    versao?: SortOrder
    stInativo?: SortOrder
  }

  export type CidAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CidMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    versao?: SortOrder
    stInativo?: SortOrder
  }

  export type CidMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    versao?: SortOrder
    stInativo?: SortOrder
  }

  export type CidSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumVersaoCidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VersaoCid | EnumVersaoCidFieldRefInput<$PrismaModel>
    in?: $Enums.VersaoCid[] | ListEnumVersaoCidFieldRefInput<$PrismaModel>
    notIn?: $Enums.VersaoCid[] | ListEnumVersaoCidFieldRefInput<$PrismaModel>
    not?: NestedEnumVersaoCidWithAggregatesFilter<$PrismaModel> | $Enums.VersaoCid
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVersaoCidFilter<$PrismaModel>
    _max?: NestedEnumVersaoCidFilter<$PrismaModel>
  }

  export type EnumVersaoDsmFilter<$PrismaModel = never> = {
    equals?: $Enums.VersaoDsm | EnumVersaoDsmFieldRefInput<$PrismaModel>
    in?: $Enums.VersaoDsm[] | ListEnumVersaoDsmFieldRefInput<$PrismaModel>
    notIn?: $Enums.VersaoDsm[] | ListEnumVersaoDsmFieldRefInput<$PrismaModel>
    not?: NestedEnumVersaoDsmFilter<$PrismaModel> | $Enums.VersaoDsm
  }

  export type DsmCodigoVersaoCompoundUniqueInput = {
    codigo: string
    versao: $Enums.VersaoDsm
  }

  export type DsmCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    versao?: SortOrder
    stInativo?: SortOrder
  }

  export type DsmAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DsmMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    versao?: SortOrder
    stInativo?: SortOrder
  }

  export type DsmMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    versao?: SortOrder
    stInativo?: SortOrder
  }

  export type DsmSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumVersaoDsmWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VersaoDsm | EnumVersaoDsmFieldRefInput<$PrismaModel>
    in?: $Enums.VersaoDsm[] | ListEnumVersaoDsmFieldRefInput<$PrismaModel>
    notIn?: $Enums.VersaoDsm[] | ListEnumVersaoDsmFieldRefInput<$PrismaModel>
    not?: NestedEnumVersaoDsmWithAggregatesFilter<$PrismaModel> | $Enums.VersaoDsm
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVersaoDsmFilter<$PrismaModel>
    _max?: NestedEnumVersaoDsmFilter<$PrismaModel>
  }

  export type TipoEvolucaoClinicaCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type TipoEvolucaoClinicaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoEvolucaoClinicaMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type TipoEvolucaoClinicaMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    stInativo?: SortOrder
  }

  export type TipoEvolucaoClinicaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CidScalarRelationFilter = {
    is?: CidWhereInput
    isNot?: CidWhereInput
  }

  export type EvolucaoScalarRelationFilter = {
    is?: EvolucaoWhereInput
    isNot?: EvolucaoWhereInput
  }

  export type EvolucaoCidCountOrderByAggregateInput = {
    id?: SortOrder
    cdEvolucao?: SortOrder
    cdCid?: SortOrder
  }

  export type EvolucaoCidAvgOrderByAggregateInput = {
    id?: SortOrder
    cdEvolucao?: SortOrder
    cdCid?: SortOrder
  }

  export type EvolucaoCidMaxOrderByAggregateInput = {
    id?: SortOrder
    cdEvolucao?: SortOrder
    cdCid?: SortOrder
  }

  export type EvolucaoCidMinOrderByAggregateInput = {
    id?: SortOrder
    cdEvolucao?: SortOrder
    cdCid?: SortOrder
  }

  export type EvolucaoCidSumOrderByAggregateInput = {
    id?: SortOrder
    cdEvolucao?: SortOrder
    cdCid?: SortOrder
  }

  export type DsmScalarRelationFilter = {
    is?: DsmWhereInput
    isNot?: DsmWhereInput
  }

  export type EvolucaoDsmCountOrderByAggregateInput = {
    id?: SortOrder
    cdEvolucao?: SortOrder
    cdDsm?: SortOrder
  }

  export type EvolucaoDsmAvgOrderByAggregateInput = {
    id?: SortOrder
    cdEvolucao?: SortOrder
    cdDsm?: SortOrder
  }

  export type EvolucaoDsmMaxOrderByAggregateInput = {
    id?: SortOrder
    cdEvolucao?: SortOrder
    cdDsm?: SortOrder
  }

  export type EvolucaoDsmMinOrderByAggregateInput = {
    id?: SortOrder
    cdEvolucao?: SortOrder
    cdDsm?: SortOrder
  }

  export type EvolucaoDsmSumOrderByAggregateInput = {
    id?: SortOrder
    cdEvolucao?: SortOrder
    cdDsm?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumPosicaoPacienteNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PosicaoPaciente | EnumPosicaoPacienteFieldRefInput<$PrismaModel> | null
    in?: $Enums.PosicaoPaciente[] | ListEnumPosicaoPacienteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PosicaoPaciente[] | ListEnumPosicaoPacienteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPosicaoPacienteNullableFilter<$PrismaModel> | $Enums.PosicaoPaciente | null
  }

  export type EnumOrigemAfericaoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrigemAfericao | EnumOrigemAfericaoFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrigemAfericao[] | ListEnumOrigemAfericaoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrigemAfericao[] | ListEnumOrigemAfericaoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrigemAfericaoNullableFilter<$PrismaModel> | $Enums.OrigemAfericao | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EscalaDorNullableScalarRelationFilter = {
    is?: EscalaDorWhereInput | null
    isNot?: EscalaDorWhereInput | null
  }

  export type SinaisVitaisCountOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    data?: SortOrder
    paSistolica?: SortOrder
    paDiastolica?: SortOrder
    fc?: SortOrder
    fr?: SortOrder
    temperatura?: SortOrder
    spo2?: SortOrder
    peso?: SortOrder
    altura?: SortOrder
    imc?: SortOrder
    dor?: SortOrder
    escalaDorId?: SortOrder
    posicao?: SortOrder
    origem?: SortOrder
    metadataRaw?: SortOrder
  }

  export type SinaisVitaisAvgOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    paSistolica?: SortOrder
    paDiastolica?: SortOrder
    fc?: SortOrder
    fr?: SortOrder
    temperatura?: SortOrder
    spo2?: SortOrder
    peso?: SortOrder
    altura?: SortOrder
    imc?: SortOrder
    dor?: SortOrder
    escalaDorId?: SortOrder
  }

  export type SinaisVitaisMaxOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    data?: SortOrder
    paSistolica?: SortOrder
    paDiastolica?: SortOrder
    fc?: SortOrder
    fr?: SortOrder
    temperatura?: SortOrder
    spo2?: SortOrder
    peso?: SortOrder
    altura?: SortOrder
    imc?: SortOrder
    dor?: SortOrder
    escalaDorId?: SortOrder
    posicao?: SortOrder
    origem?: SortOrder
  }

  export type SinaisVitaisMinOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    data?: SortOrder
    paSistolica?: SortOrder
    paDiastolica?: SortOrder
    fc?: SortOrder
    fr?: SortOrder
    temperatura?: SortOrder
    spo2?: SortOrder
    peso?: SortOrder
    altura?: SortOrder
    imc?: SortOrder
    dor?: SortOrder
    escalaDorId?: SortOrder
    posicao?: SortOrder
    origem?: SortOrder
  }

  export type SinaisVitaisSumOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    paSistolica?: SortOrder
    paDiastolica?: SortOrder
    fc?: SortOrder
    fr?: SortOrder
    temperatura?: SortOrder
    spo2?: SortOrder
    peso?: SortOrder
    altura?: SortOrder
    imc?: SortOrder
    dor?: SortOrder
    escalaDorId?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumPosicaoPacienteNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PosicaoPaciente | EnumPosicaoPacienteFieldRefInput<$PrismaModel> | null
    in?: $Enums.PosicaoPaciente[] | ListEnumPosicaoPacienteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PosicaoPaciente[] | ListEnumPosicaoPacienteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPosicaoPacienteNullableWithAggregatesFilter<$PrismaModel> | $Enums.PosicaoPaciente | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPosicaoPacienteNullableFilter<$PrismaModel>
    _max?: NestedEnumPosicaoPacienteNullableFilter<$PrismaModel>
  }

  export type EnumOrigemAfericaoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrigemAfericao | EnumOrigemAfericaoFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrigemAfericao[] | ListEnumOrigemAfericaoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrigemAfericao[] | ListEnumOrigemAfericaoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrigemAfericaoNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrigemAfericao | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrigemAfericaoNullableFilter<$PrismaModel>
    _max?: NestedEnumOrigemAfericaoNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EscalaDorCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type EscalaDorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EscalaDorMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type EscalaDorMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
  }

  export type EscalaDorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GlasgowCountOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    data?: SortOrder
    ocular?: SortOrder
    verbal?: SortOrder
    motora?: SortOrder
    total?: SortOrder
    observacao?: SortOrder
  }

  export type GlasgowAvgOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    ocular?: SortOrder
    verbal?: SortOrder
    motora?: SortOrder
    total?: SortOrder
  }

  export type GlasgowMaxOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    data?: SortOrder
    ocular?: SortOrder
    verbal?: SortOrder
    motora?: SortOrder
    total?: SortOrder
    observacao?: SortOrder
  }

  export type GlasgowMinOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    data?: SortOrder
    ocular?: SortOrder
    verbal?: SortOrder
    motora?: SortOrder
    total?: SortOrder
    observacao?: SortOrder
  }

  export type GlasgowSumOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    ocular?: SortOrder
    verbal?: SortOrder
    motora?: SortOrder
    total?: SortOrder
  }

  export type AfericaoClinicaCountOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    escala?: SortOrder
    idRegistro?: SortOrder
    data?: SortOrder
  }

  export type AfericaoClinicaAvgOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    idRegistro?: SortOrder
  }

  export type AfericaoClinicaMaxOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    escala?: SortOrder
    idRegistro?: SortOrder
    data?: SortOrder
  }

  export type AfericaoClinicaMinOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    escala?: SortOrder
    idRegistro?: SortOrder
    data?: SortOrder
  }

  export type AfericaoClinicaSumOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    idRegistro?: SortOrder
  }

  export type EvaDorCountOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    data?: SortOrder
    valor?: SortOrder
    observacao?: SortOrder
  }

  export type EvaDorAvgOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    valor?: SortOrder
  }

  export type EvaDorMaxOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    data?: SortOrder
    valor?: SortOrder
    observacao?: SortOrder
  }

  export type EvaDorMinOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    data?: SortOrder
    valor?: SortOrder
    observacao?: SortOrder
  }

  export type EvaDorSumOrderByAggregateInput = {
    id?: SortOrder
    cdAtendimento?: SortOrder
    cdProfissional?: SortOrder
    valor?: SortOrder
  }

  export type EnumRoleAuthFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleAuth | EnumRoleAuthFieldRefInput<$PrismaModel>
    in?: $Enums.RoleAuth[] | ListEnumRoleAuthFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleAuth[] | ListEnumRoleAuthFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleAuthFilter<$PrismaModel> | $Enums.RoleAuth
  }

  export type UsuarioAuthCdMasterEmailCompoundUniqueInput = {
    cdMaster: number
    email: string
  }

  export type UsuarioAuthCountOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    email?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    cdProfissional?: SortOrder
    cdPaciente?: SortOrder
  }

  export type UsuarioAuthAvgOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdProfissional?: SortOrder
    cdPaciente?: SortOrder
  }

  export type UsuarioAuthMaxOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    email?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    cdProfissional?: SortOrder
    cdPaciente?: SortOrder
  }

  export type UsuarioAuthMinOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    email?: SortOrder
    senhaHash?: SortOrder
    role?: SortOrder
    cdProfissional?: SortOrder
    cdPaciente?: SortOrder
  }

  export type UsuarioAuthSumOrderByAggregateInput = {
    id?: SortOrder
    cdMaster?: SortOrder
    cdProfissional?: SortOrder
    cdPaciente?: SortOrder
  }

  export type EnumRoleAuthWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleAuth | EnumRoleAuthFieldRefInput<$PrismaModel>
    in?: $Enums.RoleAuth[] | ListEnumRoleAuthFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleAuth[] | ListEnumRoleAuthFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleAuthWithAggregatesFilter<$PrismaModel> | $Enums.RoleAuth
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleAuthFilter<$PrismaModel>
    _max?: NestedEnumRoleAuthFilter<$PrismaModel>
  }

  export type PacienteCreateNestedManyWithoutMasterInput = {
    create?: XOR<PacienteCreateWithoutMasterInput, PacienteUncheckedCreateWithoutMasterInput> | PacienteCreateWithoutMasterInput[] | PacienteUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutMasterInput | PacienteCreateOrConnectWithoutMasterInput[]
    createMany?: PacienteCreateManyMasterInputEnvelope
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
  }

  export type ProfissionalCreateNestedManyWithoutMasterInput = {
    create?: XOR<ProfissionalCreateWithoutMasterInput, ProfissionalUncheckedCreateWithoutMasterInput> | ProfissionalCreateWithoutMasterInput[] | ProfissionalUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: ProfissionalCreateOrConnectWithoutMasterInput | ProfissionalCreateOrConnectWithoutMasterInput[]
    createMany?: ProfissionalCreateManyMasterInputEnvelope
    connect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
  }

  export type UsuarioAuthCreateNestedManyWithoutMasterInput = {
    create?: XOR<UsuarioAuthCreateWithoutMasterInput, UsuarioAuthUncheckedCreateWithoutMasterInput> | UsuarioAuthCreateWithoutMasterInput[] | UsuarioAuthUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: UsuarioAuthCreateOrConnectWithoutMasterInput | UsuarioAuthCreateOrConnectWithoutMasterInput[]
    createMany?: UsuarioAuthCreateManyMasterInputEnvelope
    connect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
  }

  export type PacienteUncheckedCreateNestedManyWithoutMasterInput = {
    create?: XOR<PacienteCreateWithoutMasterInput, PacienteUncheckedCreateWithoutMasterInput> | PacienteCreateWithoutMasterInput[] | PacienteUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutMasterInput | PacienteCreateOrConnectWithoutMasterInput[]
    createMany?: PacienteCreateManyMasterInputEnvelope
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
  }

  export type ProfissionalUncheckedCreateNestedManyWithoutMasterInput = {
    create?: XOR<ProfissionalCreateWithoutMasterInput, ProfissionalUncheckedCreateWithoutMasterInput> | ProfissionalCreateWithoutMasterInput[] | ProfissionalUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: ProfissionalCreateOrConnectWithoutMasterInput | ProfissionalCreateOrConnectWithoutMasterInput[]
    createMany?: ProfissionalCreateManyMasterInputEnvelope
    connect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
  }

  export type UsuarioAuthUncheckedCreateNestedManyWithoutMasterInput = {
    create?: XOR<UsuarioAuthCreateWithoutMasterInput, UsuarioAuthUncheckedCreateWithoutMasterInput> | UsuarioAuthCreateWithoutMasterInput[] | UsuarioAuthUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: UsuarioAuthCreateOrConnectWithoutMasterInput | UsuarioAuthCreateOrConnectWithoutMasterInput[]
    createMany?: UsuarioAuthCreateManyMasterInputEnvelope
    connect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableEnumSimNaoFieldUpdateOperationsInput = {
    set?: $Enums.SimNao | null
  }

  export type PacienteUpdateManyWithoutMasterNestedInput = {
    create?: XOR<PacienteCreateWithoutMasterInput, PacienteUncheckedCreateWithoutMasterInput> | PacienteCreateWithoutMasterInput[] | PacienteUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutMasterInput | PacienteCreateOrConnectWithoutMasterInput[]
    upsert?: PacienteUpsertWithWhereUniqueWithoutMasterInput | PacienteUpsertWithWhereUniqueWithoutMasterInput[]
    createMany?: PacienteCreateManyMasterInputEnvelope
    set?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    disconnect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    delete?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    update?: PacienteUpdateWithWhereUniqueWithoutMasterInput | PacienteUpdateWithWhereUniqueWithoutMasterInput[]
    updateMany?: PacienteUpdateManyWithWhereWithoutMasterInput | PacienteUpdateManyWithWhereWithoutMasterInput[]
    deleteMany?: PacienteScalarWhereInput | PacienteScalarWhereInput[]
  }

  export type ProfissionalUpdateManyWithoutMasterNestedInput = {
    create?: XOR<ProfissionalCreateWithoutMasterInput, ProfissionalUncheckedCreateWithoutMasterInput> | ProfissionalCreateWithoutMasterInput[] | ProfissionalUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: ProfissionalCreateOrConnectWithoutMasterInput | ProfissionalCreateOrConnectWithoutMasterInput[]
    upsert?: ProfissionalUpsertWithWhereUniqueWithoutMasterInput | ProfissionalUpsertWithWhereUniqueWithoutMasterInput[]
    createMany?: ProfissionalCreateManyMasterInputEnvelope
    set?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    disconnect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    delete?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    connect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    update?: ProfissionalUpdateWithWhereUniqueWithoutMasterInput | ProfissionalUpdateWithWhereUniqueWithoutMasterInput[]
    updateMany?: ProfissionalUpdateManyWithWhereWithoutMasterInput | ProfissionalUpdateManyWithWhereWithoutMasterInput[]
    deleteMany?: ProfissionalScalarWhereInput | ProfissionalScalarWhereInput[]
  }

  export type UsuarioAuthUpdateManyWithoutMasterNestedInput = {
    create?: XOR<UsuarioAuthCreateWithoutMasterInput, UsuarioAuthUncheckedCreateWithoutMasterInput> | UsuarioAuthCreateWithoutMasterInput[] | UsuarioAuthUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: UsuarioAuthCreateOrConnectWithoutMasterInput | UsuarioAuthCreateOrConnectWithoutMasterInput[]
    upsert?: UsuarioAuthUpsertWithWhereUniqueWithoutMasterInput | UsuarioAuthUpsertWithWhereUniqueWithoutMasterInput[]
    createMany?: UsuarioAuthCreateManyMasterInputEnvelope
    set?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    disconnect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    delete?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    connect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    update?: UsuarioAuthUpdateWithWhereUniqueWithoutMasterInput | UsuarioAuthUpdateWithWhereUniqueWithoutMasterInput[]
    updateMany?: UsuarioAuthUpdateManyWithWhereWithoutMasterInput | UsuarioAuthUpdateManyWithWhereWithoutMasterInput[]
    deleteMany?: UsuarioAuthScalarWhereInput | UsuarioAuthScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PacienteUncheckedUpdateManyWithoutMasterNestedInput = {
    create?: XOR<PacienteCreateWithoutMasterInput, PacienteUncheckedCreateWithoutMasterInput> | PacienteCreateWithoutMasterInput[] | PacienteUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutMasterInput | PacienteCreateOrConnectWithoutMasterInput[]
    upsert?: PacienteUpsertWithWhereUniqueWithoutMasterInput | PacienteUpsertWithWhereUniqueWithoutMasterInput[]
    createMany?: PacienteCreateManyMasterInputEnvelope
    set?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    disconnect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    delete?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    update?: PacienteUpdateWithWhereUniqueWithoutMasterInput | PacienteUpdateWithWhereUniqueWithoutMasterInput[]
    updateMany?: PacienteUpdateManyWithWhereWithoutMasterInput | PacienteUpdateManyWithWhereWithoutMasterInput[]
    deleteMany?: PacienteScalarWhereInput | PacienteScalarWhereInput[]
  }

  export type ProfissionalUncheckedUpdateManyWithoutMasterNestedInput = {
    create?: XOR<ProfissionalCreateWithoutMasterInput, ProfissionalUncheckedCreateWithoutMasterInput> | ProfissionalCreateWithoutMasterInput[] | ProfissionalUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: ProfissionalCreateOrConnectWithoutMasterInput | ProfissionalCreateOrConnectWithoutMasterInput[]
    upsert?: ProfissionalUpsertWithWhereUniqueWithoutMasterInput | ProfissionalUpsertWithWhereUniqueWithoutMasterInput[]
    createMany?: ProfissionalCreateManyMasterInputEnvelope
    set?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    disconnect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    delete?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    connect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    update?: ProfissionalUpdateWithWhereUniqueWithoutMasterInput | ProfissionalUpdateWithWhereUniqueWithoutMasterInput[]
    updateMany?: ProfissionalUpdateManyWithWhereWithoutMasterInput | ProfissionalUpdateManyWithWhereWithoutMasterInput[]
    deleteMany?: ProfissionalScalarWhereInput | ProfissionalScalarWhereInput[]
  }

  export type UsuarioAuthUncheckedUpdateManyWithoutMasterNestedInput = {
    create?: XOR<UsuarioAuthCreateWithoutMasterInput, UsuarioAuthUncheckedCreateWithoutMasterInput> | UsuarioAuthCreateWithoutMasterInput[] | UsuarioAuthUncheckedCreateWithoutMasterInput[]
    connectOrCreate?: UsuarioAuthCreateOrConnectWithoutMasterInput | UsuarioAuthCreateOrConnectWithoutMasterInput[]
    upsert?: UsuarioAuthUpsertWithWhereUniqueWithoutMasterInput | UsuarioAuthUpsertWithWhereUniqueWithoutMasterInput[]
    createMany?: UsuarioAuthCreateManyMasterInputEnvelope
    set?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    disconnect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    delete?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    connect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    update?: UsuarioAuthUpdateWithWhereUniqueWithoutMasterInput | UsuarioAuthUpdateWithWhereUniqueWithoutMasterInput[]
    updateMany?: UsuarioAuthUpdateManyWithWhereWithoutMasterInput | UsuarioAuthUpdateManyWithWhereWithoutMasterInput[]
    deleteMany?: UsuarioAuthScalarWhereInput | UsuarioAuthScalarWhereInput[]
  }

  export type AtendimentoCreateNestedManyWithoutPacienteInput = {
    create?: XOR<AtendimentoCreateWithoutPacienteInput, AtendimentoUncheckedCreateWithoutPacienteInput> | AtendimentoCreateWithoutPacienteInput[] | AtendimentoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: AtendimentoCreateOrConnectWithoutPacienteInput | AtendimentoCreateOrConnectWithoutPacienteInput[]
    createMany?: AtendimentoCreateManyPacienteInputEnvelope
    connect?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
  }

  export type ContatoPacienteCreateNestedManyWithoutPacienteInput = {
    create?: XOR<ContatoPacienteCreateWithoutPacienteInput, ContatoPacienteUncheckedCreateWithoutPacienteInput> | ContatoPacienteCreateWithoutPacienteInput[] | ContatoPacienteUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ContatoPacienteCreateOrConnectWithoutPacienteInput | ContatoPacienteCreateOrConnectWithoutPacienteInput[]
    createMany?: ContatoPacienteCreateManyPacienteInputEnvelope
    connect?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
  }

  export type EnderecoPacienteCreateNestedManyWithoutPacienteInput = {
    create?: XOR<EnderecoPacienteCreateWithoutPacienteInput, EnderecoPacienteUncheckedCreateWithoutPacienteInput> | EnderecoPacienteCreateWithoutPacienteInput[] | EnderecoPacienteUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: EnderecoPacienteCreateOrConnectWithoutPacienteInput | EnderecoPacienteCreateOrConnectWithoutPacienteInput[]
    createMany?: EnderecoPacienteCreateManyPacienteInputEnvelope
    connect?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
  }

  export type EvolucaoCreateNestedManyWithoutPacienteInput = {
    create?: XOR<EvolucaoCreateWithoutPacienteInput, EvolucaoUncheckedCreateWithoutPacienteInput> | EvolucaoCreateWithoutPacienteInput[] | EvolucaoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutPacienteInput | EvolucaoCreateOrConnectWithoutPacienteInput[]
    createMany?: EvolucaoCreateManyPacienteInputEnvelope
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
  }

  export type EscolaridadeCreateNestedOneWithoutPacientesInput = {
    create?: XOR<EscolaridadeCreateWithoutPacientesInput, EscolaridadeUncheckedCreateWithoutPacientesInput>
    connectOrCreate?: EscolaridadeCreateOrConnectWithoutPacientesInput
    connect?: EscolaridadeWhereUniqueInput
  }

  export type MasterCreateNestedOneWithoutPacientesInput = {
    create?: XOR<MasterCreateWithoutPacientesInput, MasterUncheckedCreateWithoutPacientesInput>
    connectOrCreate?: MasterCreateOrConnectWithoutPacientesInput
    connect?: MasterWhereUniqueInput
  }

  export type OcupacaoCreateNestedOneWithoutPacientesInput = {
    create?: XOR<OcupacaoCreateWithoutPacientesInput, OcupacaoUncheckedCreateWithoutPacientesInput>
    connectOrCreate?: OcupacaoCreateOrConnectWithoutPacientesInput
    connect?: OcupacaoWhereUniqueInput
  }

  export type ParentescoPacienteCreateNestedManyWithoutPacienteInput = {
    create?: XOR<ParentescoPacienteCreateWithoutPacienteInput, ParentescoPacienteUncheckedCreateWithoutPacienteInput> | ParentescoPacienteCreateWithoutPacienteInput[] | ParentescoPacienteUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ParentescoPacienteCreateOrConnectWithoutPacienteInput | ParentescoPacienteCreateOrConnectWithoutPacienteInput[]
    createMany?: ParentescoPacienteCreateManyPacienteInputEnvelope
    connect?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
  }

  export type UsuarioAuthCreateNestedManyWithoutPacienteInput = {
    create?: XOR<UsuarioAuthCreateWithoutPacienteInput, UsuarioAuthUncheckedCreateWithoutPacienteInput> | UsuarioAuthCreateWithoutPacienteInput[] | UsuarioAuthUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: UsuarioAuthCreateOrConnectWithoutPacienteInput | UsuarioAuthCreateOrConnectWithoutPacienteInput[]
    createMany?: UsuarioAuthCreateManyPacienteInputEnvelope
    connect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
  }

  export type AtendimentoUncheckedCreateNestedManyWithoutPacienteInput = {
    create?: XOR<AtendimentoCreateWithoutPacienteInput, AtendimentoUncheckedCreateWithoutPacienteInput> | AtendimentoCreateWithoutPacienteInput[] | AtendimentoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: AtendimentoCreateOrConnectWithoutPacienteInput | AtendimentoCreateOrConnectWithoutPacienteInput[]
    createMany?: AtendimentoCreateManyPacienteInputEnvelope
    connect?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
  }

  export type ContatoPacienteUncheckedCreateNestedManyWithoutPacienteInput = {
    create?: XOR<ContatoPacienteCreateWithoutPacienteInput, ContatoPacienteUncheckedCreateWithoutPacienteInput> | ContatoPacienteCreateWithoutPacienteInput[] | ContatoPacienteUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ContatoPacienteCreateOrConnectWithoutPacienteInput | ContatoPacienteCreateOrConnectWithoutPacienteInput[]
    createMany?: ContatoPacienteCreateManyPacienteInputEnvelope
    connect?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
  }

  export type EnderecoPacienteUncheckedCreateNestedManyWithoutPacienteInput = {
    create?: XOR<EnderecoPacienteCreateWithoutPacienteInput, EnderecoPacienteUncheckedCreateWithoutPacienteInput> | EnderecoPacienteCreateWithoutPacienteInput[] | EnderecoPacienteUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: EnderecoPacienteCreateOrConnectWithoutPacienteInput | EnderecoPacienteCreateOrConnectWithoutPacienteInput[]
    createMany?: EnderecoPacienteCreateManyPacienteInputEnvelope
    connect?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
  }

  export type EvolucaoUncheckedCreateNestedManyWithoutPacienteInput = {
    create?: XOR<EvolucaoCreateWithoutPacienteInput, EvolucaoUncheckedCreateWithoutPacienteInput> | EvolucaoCreateWithoutPacienteInput[] | EvolucaoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutPacienteInput | EvolucaoCreateOrConnectWithoutPacienteInput[]
    createMany?: EvolucaoCreateManyPacienteInputEnvelope
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
  }

  export type ParentescoPacienteUncheckedCreateNestedManyWithoutPacienteInput = {
    create?: XOR<ParentescoPacienteCreateWithoutPacienteInput, ParentescoPacienteUncheckedCreateWithoutPacienteInput> | ParentescoPacienteCreateWithoutPacienteInput[] | ParentescoPacienteUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ParentescoPacienteCreateOrConnectWithoutPacienteInput | ParentescoPacienteCreateOrConnectWithoutPacienteInput[]
    createMany?: ParentescoPacienteCreateManyPacienteInputEnvelope
    connect?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
  }

  export type UsuarioAuthUncheckedCreateNestedManyWithoutPacienteInput = {
    create?: XOR<UsuarioAuthCreateWithoutPacienteInput, UsuarioAuthUncheckedCreateWithoutPacienteInput> | UsuarioAuthCreateWithoutPacienteInput[] | UsuarioAuthUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: UsuarioAuthCreateOrConnectWithoutPacienteInput | UsuarioAuthCreateOrConnectWithoutPacienteInput[]
    createMany?: UsuarioAuthCreateManyPacienteInputEnvelope
    connect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
  }

  export type NullableEnumSexoFieldUpdateOperationsInput = {
    set?: $Enums.Sexo | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AtendimentoUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<AtendimentoCreateWithoutPacienteInput, AtendimentoUncheckedCreateWithoutPacienteInput> | AtendimentoCreateWithoutPacienteInput[] | AtendimentoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: AtendimentoCreateOrConnectWithoutPacienteInput | AtendimentoCreateOrConnectWithoutPacienteInput[]
    upsert?: AtendimentoUpsertWithWhereUniqueWithoutPacienteInput | AtendimentoUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: AtendimentoCreateManyPacienteInputEnvelope
    set?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    disconnect?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    delete?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    connect?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    update?: AtendimentoUpdateWithWhereUniqueWithoutPacienteInput | AtendimentoUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: AtendimentoUpdateManyWithWhereWithoutPacienteInput | AtendimentoUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: AtendimentoScalarWhereInput | AtendimentoScalarWhereInput[]
  }

  export type ContatoPacienteUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<ContatoPacienteCreateWithoutPacienteInput, ContatoPacienteUncheckedCreateWithoutPacienteInput> | ContatoPacienteCreateWithoutPacienteInput[] | ContatoPacienteUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ContatoPacienteCreateOrConnectWithoutPacienteInput | ContatoPacienteCreateOrConnectWithoutPacienteInput[]
    upsert?: ContatoPacienteUpsertWithWhereUniqueWithoutPacienteInput | ContatoPacienteUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: ContatoPacienteCreateManyPacienteInputEnvelope
    set?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    disconnect?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    delete?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    connect?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    update?: ContatoPacienteUpdateWithWhereUniqueWithoutPacienteInput | ContatoPacienteUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: ContatoPacienteUpdateManyWithWhereWithoutPacienteInput | ContatoPacienteUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: ContatoPacienteScalarWhereInput | ContatoPacienteScalarWhereInput[]
  }

  export type EnderecoPacienteUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<EnderecoPacienteCreateWithoutPacienteInput, EnderecoPacienteUncheckedCreateWithoutPacienteInput> | EnderecoPacienteCreateWithoutPacienteInput[] | EnderecoPacienteUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: EnderecoPacienteCreateOrConnectWithoutPacienteInput | EnderecoPacienteCreateOrConnectWithoutPacienteInput[]
    upsert?: EnderecoPacienteUpsertWithWhereUniqueWithoutPacienteInput | EnderecoPacienteUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: EnderecoPacienteCreateManyPacienteInputEnvelope
    set?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    disconnect?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    delete?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    connect?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    update?: EnderecoPacienteUpdateWithWhereUniqueWithoutPacienteInput | EnderecoPacienteUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: EnderecoPacienteUpdateManyWithWhereWithoutPacienteInput | EnderecoPacienteUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: EnderecoPacienteScalarWhereInput | EnderecoPacienteScalarWhereInput[]
  }

  export type EvolucaoUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<EvolucaoCreateWithoutPacienteInput, EvolucaoUncheckedCreateWithoutPacienteInput> | EvolucaoCreateWithoutPacienteInput[] | EvolucaoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutPacienteInput | EvolucaoCreateOrConnectWithoutPacienteInput[]
    upsert?: EvolucaoUpsertWithWhereUniqueWithoutPacienteInput | EvolucaoUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: EvolucaoCreateManyPacienteInputEnvelope
    set?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    disconnect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    delete?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    update?: EvolucaoUpdateWithWhereUniqueWithoutPacienteInput | EvolucaoUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: EvolucaoUpdateManyWithWhereWithoutPacienteInput | EvolucaoUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: EvolucaoScalarWhereInput | EvolucaoScalarWhereInput[]
  }

  export type EscolaridadeUpdateOneWithoutPacientesNestedInput = {
    create?: XOR<EscolaridadeCreateWithoutPacientesInput, EscolaridadeUncheckedCreateWithoutPacientesInput>
    connectOrCreate?: EscolaridadeCreateOrConnectWithoutPacientesInput
    upsert?: EscolaridadeUpsertWithoutPacientesInput
    disconnect?: EscolaridadeWhereInput | boolean
    delete?: EscolaridadeWhereInput | boolean
    connect?: EscolaridadeWhereUniqueInput
    update?: XOR<XOR<EscolaridadeUpdateToOneWithWhereWithoutPacientesInput, EscolaridadeUpdateWithoutPacientesInput>, EscolaridadeUncheckedUpdateWithoutPacientesInput>
  }

  export type MasterUpdateOneRequiredWithoutPacientesNestedInput = {
    create?: XOR<MasterCreateWithoutPacientesInput, MasterUncheckedCreateWithoutPacientesInput>
    connectOrCreate?: MasterCreateOrConnectWithoutPacientesInput
    upsert?: MasterUpsertWithoutPacientesInput
    connect?: MasterWhereUniqueInput
    update?: XOR<XOR<MasterUpdateToOneWithWhereWithoutPacientesInput, MasterUpdateWithoutPacientesInput>, MasterUncheckedUpdateWithoutPacientesInput>
  }

  export type OcupacaoUpdateOneWithoutPacientesNestedInput = {
    create?: XOR<OcupacaoCreateWithoutPacientesInput, OcupacaoUncheckedCreateWithoutPacientesInput>
    connectOrCreate?: OcupacaoCreateOrConnectWithoutPacientesInput
    upsert?: OcupacaoUpsertWithoutPacientesInput
    disconnect?: OcupacaoWhereInput | boolean
    delete?: OcupacaoWhereInput | boolean
    connect?: OcupacaoWhereUniqueInput
    update?: XOR<XOR<OcupacaoUpdateToOneWithWhereWithoutPacientesInput, OcupacaoUpdateWithoutPacientesInput>, OcupacaoUncheckedUpdateWithoutPacientesInput>
  }

  export type ParentescoPacienteUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<ParentescoPacienteCreateWithoutPacienteInput, ParentescoPacienteUncheckedCreateWithoutPacienteInput> | ParentescoPacienteCreateWithoutPacienteInput[] | ParentescoPacienteUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ParentescoPacienteCreateOrConnectWithoutPacienteInput | ParentescoPacienteCreateOrConnectWithoutPacienteInput[]
    upsert?: ParentescoPacienteUpsertWithWhereUniqueWithoutPacienteInput | ParentescoPacienteUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: ParentescoPacienteCreateManyPacienteInputEnvelope
    set?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    disconnect?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    delete?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    connect?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    update?: ParentescoPacienteUpdateWithWhereUniqueWithoutPacienteInput | ParentescoPacienteUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: ParentescoPacienteUpdateManyWithWhereWithoutPacienteInput | ParentescoPacienteUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: ParentescoPacienteScalarWhereInput | ParentescoPacienteScalarWhereInput[]
  }

  export type UsuarioAuthUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<UsuarioAuthCreateWithoutPacienteInput, UsuarioAuthUncheckedCreateWithoutPacienteInput> | UsuarioAuthCreateWithoutPacienteInput[] | UsuarioAuthUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: UsuarioAuthCreateOrConnectWithoutPacienteInput | UsuarioAuthCreateOrConnectWithoutPacienteInput[]
    upsert?: UsuarioAuthUpsertWithWhereUniqueWithoutPacienteInput | UsuarioAuthUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: UsuarioAuthCreateManyPacienteInputEnvelope
    set?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    disconnect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    delete?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    connect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    update?: UsuarioAuthUpdateWithWhereUniqueWithoutPacienteInput | UsuarioAuthUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: UsuarioAuthUpdateManyWithWhereWithoutPacienteInput | UsuarioAuthUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: UsuarioAuthScalarWhereInput | UsuarioAuthScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AtendimentoUncheckedUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<AtendimentoCreateWithoutPacienteInput, AtendimentoUncheckedCreateWithoutPacienteInput> | AtendimentoCreateWithoutPacienteInput[] | AtendimentoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: AtendimentoCreateOrConnectWithoutPacienteInput | AtendimentoCreateOrConnectWithoutPacienteInput[]
    upsert?: AtendimentoUpsertWithWhereUniqueWithoutPacienteInput | AtendimentoUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: AtendimentoCreateManyPacienteInputEnvelope
    set?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    disconnect?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    delete?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    connect?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    update?: AtendimentoUpdateWithWhereUniqueWithoutPacienteInput | AtendimentoUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: AtendimentoUpdateManyWithWhereWithoutPacienteInput | AtendimentoUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: AtendimentoScalarWhereInput | AtendimentoScalarWhereInput[]
  }

  export type ContatoPacienteUncheckedUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<ContatoPacienteCreateWithoutPacienteInput, ContatoPacienteUncheckedCreateWithoutPacienteInput> | ContatoPacienteCreateWithoutPacienteInput[] | ContatoPacienteUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ContatoPacienteCreateOrConnectWithoutPacienteInput | ContatoPacienteCreateOrConnectWithoutPacienteInput[]
    upsert?: ContatoPacienteUpsertWithWhereUniqueWithoutPacienteInput | ContatoPacienteUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: ContatoPacienteCreateManyPacienteInputEnvelope
    set?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    disconnect?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    delete?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    connect?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    update?: ContatoPacienteUpdateWithWhereUniqueWithoutPacienteInput | ContatoPacienteUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: ContatoPacienteUpdateManyWithWhereWithoutPacienteInput | ContatoPacienteUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: ContatoPacienteScalarWhereInput | ContatoPacienteScalarWhereInput[]
  }

  export type EnderecoPacienteUncheckedUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<EnderecoPacienteCreateWithoutPacienteInput, EnderecoPacienteUncheckedCreateWithoutPacienteInput> | EnderecoPacienteCreateWithoutPacienteInput[] | EnderecoPacienteUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: EnderecoPacienteCreateOrConnectWithoutPacienteInput | EnderecoPacienteCreateOrConnectWithoutPacienteInput[]
    upsert?: EnderecoPacienteUpsertWithWhereUniqueWithoutPacienteInput | EnderecoPacienteUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: EnderecoPacienteCreateManyPacienteInputEnvelope
    set?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    disconnect?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    delete?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    connect?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    update?: EnderecoPacienteUpdateWithWhereUniqueWithoutPacienteInput | EnderecoPacienteUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: EnderecoPacienteUpdateManyWithWhereWithoutPacienteInput | EnderecoPacienteUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: EnderecoPacienteScalarWhereInput | EnderecoPacienteScalarWhereInput[]
  }

  export type EvolucaoUncheckedUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<EvolucaoCreateWithoutPacienteInput, EvolucaoUncheckedCreateWithoutPacienteInput> | EvolucaoCreateWithoutPacienteInput[] | EvolucaoUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutPacienteInput | EvolucaoCreateOrConnectWithoutPacienteInput[]
    upsert?: EvolucaoUpsertWithWhereUniqueWithoutPacienteInput | EvolucaoUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: EvolucaoCreateManyPacienteInputEnvelope
    set?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    disconnect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    delete?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    update?: EvolucaoUpdateWithWhereUniqueWithoutPacienteInput | EvolucaoUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: EvolucaoUpdateManyWithWhereWithoutPacienteInput | EvolucaoUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: EvolucaoScalarWhereInput | EvolucaoScalarWhereInput[]
  }

  export type ParentescoPacienteUncheckedUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<ParentescoPacienteCreateWithoutPacienteInput, ParentescoPacienteUncheckedCreateWithoutPacienteInput> | ParentescoPacienteCreateWithoutPacienteInput[] | ParentescoPacienteUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ParentescoPacienteCreateOrConnectWithoutPacienteInput | ParentescoPacienteCreateOrConnectWithoutPacienteInput[]
    upsert?: ParentescoPacienteUpsertWithWhereUniqueWithoutPacienteInput | ParentescoPacienteUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: ParentescoPacienteCreateManyPacienteInputEnvelope
    set?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    disconnect?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    delete?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    connect?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    update?: ParentescoPacienteUpdateWithWhereUniqueWithoutPacienteInput | ParentescoPacienteUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: ParentescoPacienteUpdateManyWithWhereWithoutPacienteInput | ParentescoPacienteUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: ParentescoPacienteScalarWhereInput | ParentescoPacienteScalarWhereInput[]
  }

  export type UsuarioAuthUncheckedUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<UsuarioAuthCreateWithoutPacienteInput, UsuarioAuthUncheckedCreateWithoutPacienteInput> | UsuarioAuthCreateWithoutPacienteInput[] | UsuarioAuthUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: UsuarioAuthCreateOrConnectWithoutPacienteInput | UsuarioAuthCreateOrConnectWithoutPacienteInput[]
    upsert?: UsuarioAuthUpsertWithWhereUniqueWithoutPacienteInput | UsuarioAuthUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: UsuarioAuthCreateManyPacienteInputEnvelope
    set?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    disconnect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    delete?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    connect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    update?: UsuarioAuthUpdateWithWhereUniqueWithoutPacienteInput | UsuarioAuthUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: UsuarioAuthUpdateManyWithWhereWithoutPacienteInput | UsuarioAuthUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: UsuarioAuthScalarWhereInput | UsuarioAuthScalarWhereInput[]
  }

  export type AfericaoClinicaCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<AfericaoClinicaCreateWithoutProfissionalInput, AfericaoClinicaUncheckedCreateWithoutProfissionalInput> | AfericaoClinicaCreateWithoutProfissionalInput[] | AfericaoClinicaUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: AfericaoClinicaCreateOrConnectWithoutProfissionalInput | AfericaoClinicaCreateOrConnectWithoutProfissionalInput[]
    createMany?: AfericaoClinicaCreateManyProfissionalInputEnvelope
    connect?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
  }

  export type AtendimentoCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<AtendimentoCreateWithoutProfissionalInput, AtendimentoUncheckedCreateWithoutProfissionalInput> | AtendimentoCreateWithoutProfissionalInput[] | AtendimentoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: AtendimentoCreateOrConnectWithoutProfissionalInput | AtendimentoCreateOrConnectWithoutProfissionalInput[]
    createMany?: AtendimentoCreateManyProfissionalInputEnvelope
    connect?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
  }

  export type ContatoProfissionalCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<ContatoProfissionalCreateWithoutProfissionalInput, ContatoProfissionalUncheckedCreateWithoutProfissionalInput> | ContatoProfissionalCreateWithoutProfissionalInput[] | ContatoProfissionalUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: ContatoProfissionalCreateOrConnectWithoutProfissionalInput | ContatoProfissionalCreateOrConnectWithoutProfissionalInput[]
    createMany?: ContatoProfissionalCreateManyProfissionalInputEnvelope
    connect?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
  }

  export type EnderecoProfissionalCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<EnderecoProfissionalCreateWithoutProfissionalInput, EnderecoProfissionalUncheckedCreateWithoutProfissionalInput> | EnderecoProfissionalCreateWithoutProfissionalInput[] | EnderecoProfissionalUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: EnderecoProfissionalCreateOrConnectWithoutProfissionalInput | EnderecoProfissionalCreateOrConnectWithoutProfissionalInput[]
    createMany?: EnderecoProfissionalCreateManyProfissionalInputEnvelope
    connect?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
  }

  export type EvaDorCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<EvaDorCreateWithoutProfissionalInput, EvaDorUncheckedCreateWithoutProfissionalInput> | EvaDorCreateWithoutProfissionalInput[] | EvaDorUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: EvaDorCreateOrConnectWithoutProfissionalInput | EvaDorCreateOrConnectWithoutProfissionalInput[]
    createMany?: EvaDorCreateManyProfissionalInputEnvelope
    connect?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
  }

  export type EvolucaoCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<EvolucaoCreateWithoutProfissionalInput, EvolucaoUncheckedCreateWithoutProfissionalInput> | EvolucaoCreateWithoutProfissionalInput[] | EvolucaoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutProfissionalInput | EvolucaoCreateOrConnectWithoutProfissionalInput[]
    createMany?: EvolucaoCreateManyProfissionalInputEnvelope
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
  }

  export type GlasgowCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<GlasgowCreateWithoutProfissionalInput, GlasgowUncheckedCreateWithoutProfissionalInput> | GlasgowCreateWithoutProfissionalInput[] | GlasgowUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: GlasgowCreateOrConnectWithoutProfissionalInput | GlasgowCreateOrConnectWithoutProfissionalInput[]
    createMany?: GlasgowCreateManyProfissionalInputEnvelope
    connect?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
  }

  export type MasterCreateNestedOneWithoutProfissionaisInput = {
    create?: XOR<MasterCreateWithoutProfissionaisInput, MasterUncheckedCreateWithoutProfissionaisInput>
    connectOrCreate?: MasterCreateOrConnectWithoutProfissionaisInput
    connect?: MasterWhereUniqueInput
  }

  export type OcupacaoCreateNestedOneWithoutProfissionalsInput = {
    create?: XOR<OcupacaoCreateWithoutProfissionalsInput, OcupacaoUncheckedCreateWithoutProfissionalsInput>
    connectOrCreate?: OcupacaoCreateOrConnectWithoutProfissionalsInput
    connect?: OcupacaoWhereUniqueInput
  }

  export type UsuarioAuthCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<UsuarioAuthCreateWithoutProfissionalInput, UsuarioAuthUncheckedCreateWithoutProfissionalInput> | UsuarioAuthCreateWithoutProfissionalInput[] | UsuarioAuthUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: UsuarioAuthCreateOrConnectWithoutProfissionalInput | UsuarioAuthCreateOrConnectWithoutProfissionalInput[]
    createMany?: UsuarioAuthCreateManyProfissionalInputEnvelope
    connect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
  }

  export type AfericaoClinicaUncheckedCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<AfericaoClinicaCreateWithoutProfissionalInput, AfericaoClinicaUncheckedCreateWithoutProfissionalInput> | AfericaoClinicaCreateWithoutProfissionalInput[] | AfericaoClinicaUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: AfericaoClinicaCreateOrConnectWithoutProfissionalInput | AfericaoClinicaCreateOrConnectWithoutProfissionalInput[]
    createMany?: AfericaoClinicaCreateManyProfissionalInputEnvelope
    connect?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
  }

  export type AtendimentoUncheckedCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<AtendimentoCreateWithoutProfissionalInput, AtendimentoUncheckedCreateWithoutProfissionalInput> | AtendimentoCreateWithoutProfissionalInput[] | AtendimentoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: AtendimentoCreateOrConnectWithoutProfissionalInput | AtendimentoCreateOrConnectWithoutProfissionalInput[]
    createMany?: AtendimentoCreateManyProfissionalInputEnvelope
    connect?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
  }

  export type ContatoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<ContatoProfissionalCreateWithoutProfissionalInput, ContatoProfissionalUncheckedCreateWithoutProfissionalInput> | ContatoProfissionalCreateWithoutProfissionalInput[] | ContatoProfissionalUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: ContatoProfissionalCreateOrConnectWithoutProfissionalInput | ContatoProfissionalCreateOrConnectWithoutProfissionalInput[]
    createMany?: ContatoProfissionalCreateManyProfissionalInputEnvelope
    connect?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
  }

  export type EnderecoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<EnderecoProfissionalCreateWithoutProfissionalInput, EnderecoProfissionalUncheckedCreateWithoutProfissionalInput> | EnderecoProfissionalCreateWithoutProfissionalInput[] | EnderecoProfissionalUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: EnderecoProfissionalCreateOrConnectWithoutProfissionalInput | EnderecoProfissionalCreateOrConnectWithoutProfissionalInput[]
    createMany?: EnderecoProfissionalCreateManyProfissionalInputEnvelope
    connect?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
  }

  export type EvaDorUncheckedCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<EvaDorCreateWithoutProfissionalInput, EvaDorUncheckedCreateWithoutProfissionalInput> | EvaDorCreateWithoutProfissionalInput[] | EvaDorUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: EvaDorCreateOrConnectWithoutProfissionalInput | EvaDorCreateOrConnectWithoutProfissionalInput[]
    createMany?: EvaDorCreateManyProfissionalInputEnvelope
    connect?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
  }

  export type EvolucaoUncheckedCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<EvolucaoCreateWithoutProfissionalInput, EvolucaoUncheckedCreateWithoutProfissionalInput> | EvolucaoCreateWithoutProfissionalInput[] | EvolucaoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutProfissionalInput | EvolucaoCreateOrConnectWithoutProfissionalInput[]
    createMany?: EvolucaoCreateManyProfissionalInputEnvelope
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
  }

  export type GlasgowUncheckedCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<GlasgowCreateWithoutProfissionalInput, GlasgowUncheckedCreateWithoutProfissionalInput> | GlasgowCreateWithoutProfissionalInput[] | GlasgowUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: GlasgowCreateOrConnectWithoutProfissionalInput | GlasgowCreateOrConnectWithoutProfissionalInput[]
    createMany?: GlasgowCreateManyProfissionalInputEnvelope
    connect?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
  }

  export type UsuarioAuthUncheckedCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<UsuarioAuthCreateWithoutProfissionalInput, UsuarioAuthUncheckedCreateWithoutProfissionalInput> | UsuarioAuthCreateWithoutProfissionalInput[] | UsuarioAuthUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: UsuarioAuthCreateOrConnectWithoutProfissionalInput | UsuarioAuthCreateOrConnectWithoutProfissionalInput[]
    createMany?: UsuarioAuthCreateManyProfissionalInputEnvelope
    connect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AfericaoClinicaUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<AfericaoClinicaCreateWithoutProfissionalInput, AfericaoClinicaUncheckedCreateWithoutProfissionalInput> | AfericaoClinicaCreateWithoutProfissionalInput[] | AfericaoClinicaUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: AfericaoClinicaCreateOrConnectWithoutProfissionalInput | AfericaoClinicaCreateOrConnectWithoutProfissionalInput[]
    upsert?: AfericaoClinicaUpsertWithWhereUniqueWithoutProfissionalInput | AfericaoClinicaUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: AfericaoClinicaCreateManyProfissionalInputEnvelope
    set?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    disconnect?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    delete?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    connect?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    update?: AfericaoClinicaUpdateWithWhereUniqueWithoutProfissionalInput | AfericaoClinicaUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: AfericaoClinicaUpdateManyWithWhereWithoutProfissionalInput | AfericaoClinicaUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: AfericaoClinicaScalarWhereInput | AfericaoClinicaScalarWhereInput[]
  }

  export type AtendimentoUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<AtendimentoCreateWithoutProfissionalInput, AtendimentoUncheckedCreateWithoutProfissionalInput> | AtendimentoCreateWithoutProfissionalInput[] | AtendimentoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: AtendimentoCreateOrConnectWithoutProfissionalInput | AtendimentoCreateOrConnectWithoutProfissionalInput[]
    upsert?: AtendimentoUpsertWithWhereUniqueWithoutProfissionalInput | AtendimentoUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: AtendimentoCreateManyProfissionalInputEnvelope
    set?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    disconnect?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    delete?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    connect?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    update?: AtendimentoUpdateWithWhereUniqueWithoutProfissionalInput | AtendimentoUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: AtendimentoUpdateManyWithWhereWithoutProfissionalInput | AtendimentoUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: AtendimentoScalarWhereInput | AtendimentoScalarWhereInput[]
  }

  export type ContatoProfissionalUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<ContatoProfissionalCreateWithoutProfissionalInput, ContatoProfissionalUncheckedCreateWithoutProfissionalInput> | ContatoProfissionalCreateWithoutProfissionalInput[] | ContatoProfissionalUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: ContatoProfissionalCreateOrConnectWithoutProfissionalInput | ContatoProfissionalCreateOrConnectWithoutProfissionalInput[]
    upsert?: ContatoProfissionalUpsertWithWhereUniqueWithoutProfissionalInput | ContatoProfissionalUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: ContatoProfissionalCreateManyProfissionalInputEnvelope
    set?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    disconnect?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    delete?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    connect?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    update?: ContatoProfissionalUpdateWithWhereUniqueWithoutProfissionalInput | ContatoProfissionalUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: ContatoProfissionalUpdateManyWithWhereWithoutProfissionalInput | ContatoProfissionalUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: ContatoProfissionalScalarWhereInput | ContatoProfissionalScalarWhereInput[]
  }

  export type EnderecoProfissionalUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<EnderecoProfissionalCreateWithoutProfissionalInput, EnderecoProfissionalUncheckedCreateWithoutProfissionalInput> | EnderecoProfissionalCreateWithoutProfissionalInput[] | EnderecoProfissionalUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: EnderecoProfissionalCreateOrConnectWithoutProfissionalInput | EnderecoProfissionalCreateOrConnectWithoutProfissionalInput[]
    upsert?: EnderecoProfissionalUpsertWithWhereUniqueWithoutProfissionalInput | EnderecoProfissionalUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: EnderecoProfissionalCreateManyProfissionalInputEnvelope
    set?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    disconnect?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    delete?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    connect?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    update?: EnderecoProfissionalUpdateWithWhereUniqueWithoutProfissionalInput | EnderecoProfissionalUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: EnderecoProfissionalUpdateManyWithWhereWithoutProfissionalInput | EnderecoProfissionalUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: EnderecoProfissionalScalarWhereInput | EnderecoProfissionalScalarWhereInput[]
  }

  export type EvaDorUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<EvaDorCreateWithoutProfissionalInput, EvaDorUncheckedCreateWithoutProfissionalInput> | EvaDorCreateWithoutProfissionalInput[] | EvaDorUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: EvaDorCreateOrConnectWithoutProfissionalInput | EvaDorCreateOrConnectWithoutProfissionalInput[]
    upsert?: EvaDorUpsertWithWhereUniqueWithoutProfissionalInput | EvaDorUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: EvaDorCreateManyProfissionalInputEnvelope
    set?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    disconnect?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    delete?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    connect?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    update?: EvaDorUpdateWithWhereUniqueWithoutProfissionalInput | EvaDorUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: EvaDorUpdateManyWithWhereWithoutProfissionalInput | EvaDorUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: EvaDorScalarWhereInput | EvaDorScalarWhereInput[]
  }

  export type EvolucaoUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<EvolucaoCreateWithoutProfissionalInput, EvolucaoUncheckedCreateWithoutProfissionalInput> | EvolucaoCreateWithoutProfissionalInput[] | EvolucaoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutProfissionalInput | EvolucaoCreateOrConnectWithoutProfissionalInput[]
    upsert?: EvolucaoUpsertWithWhereUniqueWithoutProfissionalInput | EvolucaoUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: EvolucaoCreateManyProfissionalInputEnvelope
    set?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    disconnect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    delete?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    update?: EvolucaoUpdateWithWhereUniqueWithoutProfissionalInput | EvolucaoUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: EvolucaoUpdateManyWithWhereWithoutProfissionalInput | EvolucaoUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: EvolucaoScalarWhereInput | EvolucaoScalarWhereInput[]
  }

  export type GlasgowUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<GlasgowCreateWithoutProfissionalInput, GlasgowUncheckedCreateWithoutProfissionalInput> | GlasgowCreateWithoutProfissionalInput[] | GlasgowUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: GlasgowCreateOrConnectWithoutProfissionalInput | GlasgowCreateOrConnectWithoutProfissionalInput[]
    upsert?: GlasgowUpsertWithWhereUniqueWithoutProfissionalInput | GlasgowUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: GlasgowCreateManyProfissionalInputEnvelope
    set?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    disconnect?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    delete?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    connect?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    update?: GlasgowUpdateWithWhereUniqueWithoutProfissionalInput | GlasgowUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: GlasgowUpdateManyWithWhereWithoutProfissionalInput | GlasgowUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: GlasgowScalarWhereInput | GlasgowScalarWhereInput[]
  }

  export type MasterUpdateOneRequiredWithoutProfissionaisNestedInput = {
    create?: XOR<MasterCreateWithoutProfissionaisInput, MasterUncheckedCreateWithoutProfissionaisInput>
    connectOrCreate?: MasterCreateOrConnectWithoutProfissionaisInput
    upsert?: MasterUpsertWithoutProfissionaisInput
    connect?: MasterWhereUniqueInput
    update?: XOR<XOR<MasterUpdateToOneWithWhereWithoutProfissionaisInput, MasterUpdateWithoutProfissionaisInput>, MasterUncheckedUpdateWithoutProfissionaisInput>
  }

  export type OcupacaoUpdateOneWithoutProfissionalsNestedInput = {
    create?: XOR<OcupacaoCreateWithoutProfissionalsInput, OcupacaoUncheckedCreateWithoutProfissionalsInput>
    connectOrCreate?: OcupacaoCreateOrConnectWithoutProfissionalsInput
    upsert?: OcupacaoUpsertWithoutProfissionalsInput
    disconnect?: OcupacaoWhereInput | boolean
    delete?: OcupacaoWhereInput | boolean
    connect?: OcupacaoWhereUniqueInput
    update?: XOR<XOR<OcupacaoUpdateToOneWithWhereWithoutProfissionalsInput, OcupacaoUpdateWithoutProfissionalsInput>, OcupacaoUncheckedUpdateWithoutProfissionalsInput>
  }

  export type UsuarioAuthUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<UsuarioAuthCreateWithoutProfissionalInput, UsuarioAuthUncheckedCreateWithoutProfissionalInput> | UsuarioAuthCreateWithoutProfissionalInput[] | UsuarioAuthUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: UsuarioAuthCreateOrConnectWithoutProfissionalInput | UsuarioAuthCreateOrConnectWithoutProfissionalInput[]
    upsert?: UsuarioAuthUpsertWithWhereUniqueWithoutProfissionalInput | UsuarioAuthUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: UsuarioAuthCreateManyProfissionalInputEnvelope
    set?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    disconnect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    delete?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    connect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    update?: UsuarioAuthUpdateWithWhereUniqueWithoutProfissionalInput | UsuarioAuthUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: UsuarioAuthUpdateManyWithWhereWithoutProfissionalInput | UsuarioAuthUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: UsuarioAuthScalarWhereInput | UsuarioAuthScalarWhereInput[]
  }

  export type AfericaoClinicaUncheckedUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<AfericaoClinicaCreateWithoutProfissionalInput, AfericaoClinicaUncheckedCreateWithoutProfissionalInput> | AfericaoClinicaCreateWithoutProfissionalInput[] | AfericaoClinicaUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: AfericaoClinicaCreateOrConnectWithoutProfissionalInput | AfericaoClinicaCreateOrConnectWithoutProfissionalInput[]
    upsert?: AfericaoClinicaUpsertWithWhereUniqueWithoutProfissionalInput | AfericaoClinicaUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: AfericaoClinicaCreateManyProfissionalInputEnvelope
    set?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    disconnect?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    delete?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    connect?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    update?: AfericaoClinicaUpdateWithWhereUniqueWithoutProfissionalInput | AfericaoClinicaUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: AfericaoClinicaUpdateManyWithWhereWithoutProfissionalInput | AfericaoClinicaUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: AfericaoClinicaScalarWhereInput | AfericaoClinicaScalarWhereInput[]
  }

  export type AtendimentoUncheckedUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<AtendimentoCreateWithoutProfissionalInput, AtendimentoUncheckedCreateWithoutProfissionalInput> | AtendimentoCreateWithoutProfissionalInput[] | AtendimentoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: AtendimentoCreateOrConnectWithoutProfissionalInput | AtendimentoCreateOrConnectWithoutProfissionalInput[]
    upsert?: AtendimentoUpsertWithWhereUniqueWithoutProfissionalInput | AtendimentoUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: AtendimentoCreateManyProfissionalInputEnvelope
    set?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    disconnect?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    delete?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    connect?: AtendimentoWhereUniqueInput | AtendimentoWhereUniqueInput[]
    update?: AtendimentoUpdateWithWhereUniqueWithoutProfissionalInput | AtendimentoUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: AtendimentoUpdateManyWithWhereWithoutProfissionalInput | AtendimentoUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: AtendimentoScalarWhereInput | AtendimentoScalarWhereInput[]
  }

  export type ContatoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<ContatoProfissionalCreateWithoutProfissionalInput, ContatoProfissionalUncheckedCreateWithoutProfissionalInput> | ContatoProfissionalCreateWithoutProfissionalInput[] | ContatoProfissionalUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: ContatoProfissionalCreateOrConnectWithoutProfissionalInput | ContatoProfissionalCreateOrConnectWithoutProfissionalInput[]
    upsert?: ContatoProfissionalUpsertWithWhereUniqueWithoutProfissionalInput | ContatoProfissionalUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: ContatoProfissionalCreateManyProfissionalInputEnvelope
    set?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    disconnect?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    delete?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    connect?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    update?: ContatoProfissionalUpdateWithWhereUniqueWithoutProfissionalInput | ContatoProfissionalUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: ContatoProfissionalUpdateManyWithWhereWithoutProfissionalInput | ContatoProfissionalUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: ContatoProfissionalScalarWhereInput | ContatoProfissionalScalarWhereInput[]
  }

  export type EnderecoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<EnderecoProfissionalCreateWithoutProfissionalInput, EnderecoProfissionalUncheckedCreateWithoutProfissionalInput> | EnderecoProfissionalCreateWithoutProfissionalInput[] | EnderecoProfissionalUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: EnderecoProfissionalCreateOrConnectWithoutProfissionalInput | EnderecoProfissionalCreateOrConnectWithoutProfissionalInput[]
    upsert?: EnderecoProfissionalUpsertWithWhereUniqueWithoutProfissionalInput | EnderecoProfissionalUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: EnderecoProfissionalCreateManyProfissionalInputEnvelope
    set?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    disconnect?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    delete?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    connect?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    update?: EnderecoProfissionalUpdateWithWhereUniqueWithoutProfissionalInput | EnderecoProfissionalUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: EnderecoProfissionalUpdateManyWithWhereWithoutProfissionalInput | EnderecoProfissionalUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: EnderecoProfissionalScalarWhereInput | EnderecoProfissionalScalarWhereInput[]
  }

  export type EvaDorUncheckedUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<EvaDorCreateWithoutProfissionalInput, EvaDorUncheckedCreateWithoutProfissionalInput> | EvaDorCreateWithoutProfissionalInput[] | EvaDorUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: EvaDorCreateOrConnectWithoutProfissionalInput | EvaDorCreateOrConnectWithoutProfissionalInput[]
    upsert?: EvaDorUpsertWithWhereUniqueWithoutProfissionalInput | EvaDorUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: EvaDorCreateManyProfissionalInputEnvelope
    set?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    disconnect?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    delete?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    connect?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    update?: EvaDorUpdateWithWhereUniqueWithoutProfissionalInput | EvaDorUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: EvaDorUpdateManyWithWhereWithoutProfissionalInput | EvaDorUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: EvaDorScalarWhereInput | EvaDorScalarWhereInput[]
  }

  export type EvolucaoUncheckedUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<EvolucaoCreateWithoutProfissionalInput, EvolucaoUncheckedCreateWithoutProfissionalInput> | EvolucaoCreateWithoutProfissionalInput[] | EvolucaoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutProfissionalInput | EvolucaoCreateOrConnectWithoutProfissionalInput[]
    upsert?: EvolucaoUpsertWithWhereUniqueWithoutProfissionalInput | EvolucaoUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: EvolucaoCreateManyProfissionalInputEnvelope
    set?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    disconnect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    delete?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    update?: EvolucaoUpdateWithWhereUniqueWithoutProfissionalInput | EvolucaoUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: EvolucaoUpdateManyWithWhereWithoutProfissionalInput | EvolucaoUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: EvolucaoScalarWhereInput | EvolucaoScalarWhereInput[]
  }

  export type GlasgowUncheckedUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<GlasgowCreateWithoutProfissionalInput, GlasgowUncheckedCreateWithoutProfissionalInput> | GlasgowCreateWithoutProfissionalInput[] | GlasgowUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: GlasgowCreateOrConnectWithoutProfissionalInput | GlasgowCreateOrConnectWithoutProfissionalInput[]
    upsert?: GlasgowUpsertWithWhereUniqueWithoutProfissionalInput | GlasgowUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: GlasgowCreateManyProfissionalInputEnvelope
    set?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    disconnect?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    delete?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    connect?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    update?: GlasgowUpdateWithWhereUniqueWithoutProfissionalInput | GlasgowUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: GlasgowUpdateManyWithWhereWithoutProfissionalInput | GlasgowUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: GlasgowScalarWhereInput | GlasgowScalarWhereInput[]
  }

  export type UsuarioAuthUncheckedUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<UsuarioAuthCreateWithoutProfissionalInput, UsuarioAuthUncheckedCreateWithoutProfissionalInput> | UsuarioAuthCreateWithoutProfissionalInput[] | UsuarioAuthUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: UsuarioAuthCreateOrConnectWithoutProfissionalInput | UsuarioAuthCreateOrConnectWithoutProfissionalInput[]
    upsert?: UsuarioAuthUpsertWithWhereUniqueWithoutProfissionalInput | UsuarioAuthUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: UsuarioAuthCreateManyProfissionalInputEnvelope
    set?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    disconnect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    delete?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    connect?: UsuarioAuthWhereUniqueInput | UsuarioAuthWhereUniqueInput[]
    update?: UsuarioAuthUpdateWithWhereUniqueWithoutProfissionalInput | UsuarioAuthUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: UsuarioAuthUpdateManyWithWhereWithoutProfissionalInput | UsuarioAuthUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: UsuarioAuthScalarWhereInput | UsuarioAuthScalarWhereInput[]
  }

  export type BairroCreateNestedOneWithoutEnderecosInput = {
    create?: XOR<BairroCreateWithoutEnderecosInput, BairroUncheckedCreateWithoutEnderecosInput>
    connectOrCreate?: BairroCreateOrConnectWithoutEnderecosInput
    connect?: BairroWhereUniqueInput
  }

  export type CidadeCreateNestedOneWithoutEnderecosInput = {
    create?: XOR<CidadeCreateWithoutEnderecosInput, CidadeUncheckedCreateWithoutEnderecosInput>
    connectOrCreate?: CidadeCreateOrConnectWithoutEnderecosInput
    connect?: CidadeWhereUniqueInput
  }

  export type EnderecoPacienteCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<EnderecoPacienteCreateWithoutEnderecoInput, EnderecoPacienteUncheckedCreateWithoutEnderecoInput> | EnderecoPacienteCreateWithoutEnderecoInput[] | EnderecoPacienteUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EnderecoPacienteCreateOrConnectWithoutEnderecoInput | EnderecoPacienteCreateOrConnectWithoutEnderecoInput[]
    createMany?: EnderecoPacienteCreateManyEnderecoInputEnvelope
    connect?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
  }

  export type EnderecoPessoaRelacionadaCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<EnderecoPessoaRelacionadaCreateWithoutEnderecoInput, EnderecoPessoaRelacionadaUncheckedCreateWithoutEnderecoInput> | EnderecoPessoaRelacionadaCreateWithoutEnderecoInput[] | EnderecoPessoaRelacionadaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EnderecoPessoaRelacionadaCreateOrConnectWithoutEnderecoInput | EnderecoPessoaRelacionadaCreateOrConnectWithoutEnderecoInput[]
    createMany?: EnderecoPessoaRelacionadaCreateManyEnderecoInputEnvelope
    connect?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
  }

  export type EnderecoProfissionalCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<EnderecoProfissionalCreateWithoutEnderecoInput, EnderecoProfissionalUncheckedCreateWithoutEnderecoInput> | EnderecoProfissionalCreateWithoutEnderecoInput[] | EnderecoProfissionalUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EnderecoProfissionalCreateOrConnectWithoutEnderecoInput | EnderecoProfissionalCreateOrConnectWithoutEnderecoInput[]
    createMany?: EnderecoProfissionalCreateManyEnderecoInputEnvelope
    connect?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
  }

  export type EnderecoPacienteUncheckedCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<EnderecoPacienteCreateWithoutEnderecoInput, EnderecoPacienteUncheckedCreateWithoutEnderecoInput> | EnderecoPacienteCreateWithoutEnderecoInput[] | EnderecoPacienteUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EnderecoPacienteCreateOrConnectWithoutEnderecoInput | EnderecoPacienteCreateOrConnectWithoutEnderecoInput[]
    createMany?: EnderecoPacienteCreateManyEnderecoInputEnvelope
    connect?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
  }

  export type EnderecoPessoaRelacionadaUncheckedCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<EnderecoPessoaRelacionadaCreateWithoutEnderecoInput, EnderecoPessoaRelacionadaUncheckedCreateWithoutEnderecoInput> | EnderecoPessoaRelacionadaCreateWithoutEnderecoInput[] | EnderecoPessoaRelacionadaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EnderecoPessoaRelacionadaCreateOrConnectWithoutEnderecoInput | EnderecoPessoaRelacionadaCreateOrConnectWithoutEnderecoInput[]
    createMany?: EnderecoPessoaRelacionadaCreateManyEnderecoInputEnvelope
    connect?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
  }

  export type EnderecoProfissionalUncheckedCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<EnderecoProfissionalCreateWithoutEnderecoInput, EnderecoProfissionalUncheckedCreateWithoutEnderecoInput> | EnderecoProfissionalCreateWithoutEnderecoInput[] | EnderecoProfissionalUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EnderecoProfissionalCreateOrConnectWithoutEnderecoInput | EnderecoProfissionalCreateOrConnectWithoutEnderecoInput[]
    createMany?: EnderecoProfissionalCreateManyEnderecoInputEnvelope
    connect?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
  }

  export type BairroUpdateOneRequiredWithoutEnderecosNestedInput = {
    create?: XOR<BairroCreateWithoutEnderecosInput, BairroUncheckedCreateWithoutEnderecosInput>
    connectOrCreate?: BairroCreateOrConnectWithoutEnderecosInput
    upsert?: BairroUpsertWithoutEnderecosInput
    connect?: BairroWhereUniqueInput
    update?: XOR<XOR<BairroUpdateToOneWithWhereWithoutEnderecosInput, BairroUpdateWithoutEnderecosInput>, BairroUncheckedUpdateWithoutEnderecosInput>
  }

  export type CidadeUpdateOneRequiredWithoutEnderecosNestedInput = {
    create?: XOR<CidadeCreateWithoutEnderecosInput, CidadeUncheckedCreateWithoutEnderecosInput>
    connectOrCreate?: CidadeCreateOrConnectWithoutEnderecosInput
    upsert?: CidadeUpsertWithoutEnderecosInput
    connect?: CidadeWhereUniqueInput
    update?: XOR<XOR<CidadeUpdateToOneWithWhereWithoutEnderecosInput, CidadeUpdateWithoutEnderecosInput>, CidadeUncheckedUpdateWithoutEnderecosInput>
  }

  export type EnderecoPacienteUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<EnderecoPacienteCreateWithoutEnderecoInput, EnderecoPacienteUncheckedCreateWithoutEnderecoInput> | EnderecoPacienteCreateWithoutEnderecoInput[] | EnderecoPacienteUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EnderecoPacienteCreateOrConnectWithoutEnderecoInput | EnderecoPacienteCreateOrConnectWithoutEnderecoInput[]
    upsert?: EnderecoPacienteUpsertWithWhereUniqueWithoutEnderecoInput | EnderecoPacienteUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: EnderecoPacienteCreateManyEnderecoInputEnvelope
    set?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    disconnect?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    delete?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    connect?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    update?: EnderecoPacienteUpdateWithWhereUniqueWithoutEnderecoInput | EnderecoPacienteUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: EnderecoPacienteUpdateManyWithWhereWithoutEnderecoInput | EnderecoPacienteUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: EnderecoPacienteScalarWhereInput | EnderecoPacienteScalarWhereInput[]
  }

  export type EnderecoPessoaRelacionadaUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<EnderecoPessoaRelacionadaCreateWithoutEnderecoInput, EnderecoPessoaRelacionadaUncheckedCreateWithoutEnderecoInput> | EnderecoPessoaRelacionadaCreateWithoutEnderecoInput[] | EnderecoPessoaRelacionadaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EnderecoPessoaRelacionadaCreateOrConnectWithoutEnderecoInput | EnderecoPessoaRelacionadaCreateOrConnectWithoutEnderecoInput[]
    upsert?: EnderecoPessoaRelacionadaUpsertWithWhereUniqueWithoutEnderecoInput | EnderecoPessoaRelacionadaUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: EnderecoPessoaRelacionadaCreateManyEnderecoInputEnvelope
    set?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    disconnect?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    delete?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    connect?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    update?: EnderecoPessoaRelacionadaUpdateWithWhereUniqueWithoutEnderecoInput | EnderecoPessoaRelacionadaUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: EnderecoPessoaRelacionadaUpdateManyWithWhereWithoutEnderecoInput | EnderecoPessoaRelacionadaUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: EnderecoPessoaRelacionadaScalarWhereInput | EnderecoPessoaRelacionadaScalarWhereInput[]
  }

  export type EnderecoProfissionalUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<EnderecoProfissionalCreateWithoutEnderecoInput, EnderecoProfissionalUncheckedCreateWithoutEnderecoInput> | EnderecoProfissionalCreateWithoutEnderecoInput[] | EnderecoProfissionalUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EnderecoProfissionalCreateOrConnectWithoutEnderecoInput | EnderecoProfissionalCreateOrConnectWithoutEnderecoInput[]
    upsert?: EnderecoProfissionalUpsertWithWhereUniqueWithoutEnderecoInput | EnderecoProfissionalUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: EnderecoProfissionalCreateManyEnderecoInputEnvelope
    set?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    disconnect?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    delete?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    connect?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    update?: EnderecoProfissionalUpdateWithWhereUniqueWithoutEnderecoInput | EnderecoProfissionalUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: EnderecoProfissionalUpdateManyWithWhereWithoutEnderecoInput | EnderecoProfissionalUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: EnderecoProfissionalScalarWhereInput | EnderecoProfissionalScalarWhereInput[]
  }

  export type EnderecoPacienteUncheckedUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<EnderecoPacienteCreateWithoutEnderecoInput, EnderecoPacienteUncheckedCreateWithoutEnderecoInput> | EnderecoPacienteCreateWithoutEnderecoInput[] | EnderecoPacienteUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EnderecoPacienteCreateOrConnectWithoutEnderecoInput | EnderecoPacienteCreateOrConnectWithoutEnderecoInput[]
    upsert?: EnderecoPacienteUpsertWithWhereUniqueWithoutEnderecoInput | EnderecoPacienteUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: EnderecoPacienteCreateManyEnderecoInputEnvelope
    set?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    disconnect?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    delete?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    connect?: EnderecoPacienteWhereUniqueInput | EnderecoPacienteWhereUniqueInput[]
    update?: EnderecoPacienteUpdateWithWhereUniqueWithoutEnderecoInput | EnderecoPacienteUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: EnderecoPacienteUpdateManyWithWhereWithoutEnderecoInput | EnderecoPacienteUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: EnderecoPacienteScalarWhereInput | EnderecoPacienteScalarWhereInput[]
  }

  export type EnderecoPessoaRelacionadaUncheckedUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<EnderecoPessoaRelacionadaCreateWithoutEnderecoInput, EnderecoPessoaRelacionadaUncheckedCreateWithoutEnderecoInput> | EnderecoPessoaRelacionadaCreateWithoutEnderecoInput[] | EnderecoPessoaRelacionadaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EnderecoPessoaRelacionadaCreateOrConnectWithoutEnderecoInput | EnderecoPessoaRelacionadaCreateOrConnectWithoutEnderecoInput[]
    upsert?: EnderecoPessoaRelacionadaUpsertWithWhereUniqueWithoutEnderecoInput | EnderecoPessoaRelacionadaUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: EnderecoPessoaRelacionadaCreateManyEnderecoInputEnvelope
    set?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    disconnect?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    delete?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    connect?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    update?: EnderecoPessoaRelacionadaUpdateWithWhereUniqueWithoutEnderecoInput | EnderecoPessoaRelacionadaUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: EnderecoPessoaRelacionadaUpdateManyWithWhereWithoutEnderecoInput | EnderecoPessoaRelacionadaUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: EnderecoPessoaRelacionadaScalarWhereInput | EnderecoPessoaRelacionadaScalarWhereInput[]
  }

  export type EnderecoProfissionalUncheckedUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<EnderecoProfissionalCreateWithoutEnderecoInput, EnderecoProfissionalUncheckedCreateWithoutEnderecoInput> | EnderecoProfissionalCreateWithoutEnderecoInput[] | EnderecoProfissionalUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: EnderecoProfissionalCreateOrConnectWithoutEnderecoInput | EnderecoProfissionalCreateOrConnectWithoutEnderecoInput[]
    upsert?: EnderecoProfissionalUpsertWithWhereUniqueWithoutEnderecoInput | EnderecoProfissionalUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: EnderecoProfissionalCreateManyEnderecoInputEnvelope
    set?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    disconnect?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    delete?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    connect?: EnderecoProfissionalWhereUniqueInput | EnderecoProfissionalWhereUniqueInput[]
    update?: EnderecoProfissionalUpdateWithWhereUniqueWithoutEnderecoInput | EnderecoProfissionalUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: EnderecoProfissionalUpdateManyWithWhereWithoutEnderecoInput | EnderecoProfissionalUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: EnderecoProfissionalScalarWhereInput | EnderecoProfissionalScalarWhereInput[]
  }

  export type EnderecoCreateNestedOneWithoutPacientesInput = {
    create?: XOR<EnderecoCreateWithoutPacientesInput, EnderecoUncheckedCreateWithoutPacientesInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutPacientesInput
    connect?: EnderecoWhereUniqueInput
  }

  export type PacienteCreateNestedOneWithoutEnderecosInput = {
    create?: XOR<PacienteCreateWithoutEnderecosInput, PacienteUncheckedCreateWithoutEnderecosInput>
    connectOrCreate?: PacienteCreateOrConnectWithoutEnderecosInput
    connect?: PacienteWhereUniqueInput
  }

  export type EnderecoUpdateOneRequiredWithoutPacientesNestedInput = {
    create?: XOR<EnderecoCreateWithoutPacientesInput, EnderecoUncheckedCreateWithoutPacientesInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutPacientesInput
    upsert?: EnderecoUpsertWithoutPacientesInput
    connect?: EnderecoWhereUniqueInput
    update?: XOR<XOR<EnderecoUpdateToOneWithWhereWithoutPacientesInput, EnderecoUpdateWithoutPacientesInput>, EnderecoUncheckedUpdateWithoutPacientesInput>
  }

  export type PacienteUpdateOneRequiredWithoutEnderecosNestedInput = {
    create?: XOR<PacienteCreateWithoutEnderecosInput, PacienteUncheckedCreateWithoutEnderecosInput>
    connectOrCreate?: PacienteCreateOrConnectWithoutEnderecosInput
    upsert?: PacienteUpsertWithoutEnderecosInput
    connect?: PacienteWhereUniqueInput
    update?: XOR<XOR<PacienteUpdateToOneWithWhereWithoutEnderecosInput, PacienteUpdateWithoutEnderecosInput>, PacienteUncheckedUpdateWithoutEnderecosInput>
  }

  export type EnderecoCreateNestedOneWithoutProfissionaisInput = {
    create?: XOR<EnderecoCreateWithoutProfissionaisInput, EnderecoUncheckedCreateWithoutProfissionaisInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutProfissionaisInput
    connect?: EnderecoWhereUniqueInput
  }

  export type ProfissionalCreateNestedOneWithoutEnderecosInput = {
    create?: XOR<ProfissionalCreateWithoutEnderecosInput, ProfissionalUncheckedCreateWithoutEnderecosInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutEnderecosInput
    connect?: ProfissionalWhereUniqueInput
  }

  export type EnderecoUpdateOneRequiredWithoutProfissionaisNestedInput = {
    create?: XOR<EnderecoCreateWithoutProfissionaisInput, EnderecoUncheckedCreateWithoutProfissionaisInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutProfissionaisInput
    upsert?: EnderecoUpsertWithoutProfissionaisInput
    connect?: EnderecoWhereUniqueInput
    update?: XOR<XOR<EnderecoUpdateToOneWithWhereWithoutProfissionaisInput, EnderecoUpdateWithoutProfissionaisInput>, EnderecoUncheckedUpdateWithoutProfissionaisInput>
  }

  export type ProfissionalUpdateOneRequiredWithoutEnderecosNestedInput = {
    create?: XOR<ProfissionalCreateWithoutEnderecosInput, ProfissionalUncheckedCreateWithoutEnderecosInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutEnderecosInput
    upsert?: ProfissionalUpsertWithoutEnderecosInput
    connect?: ProfissionalWhereUniqueInput
    update?: XOR<XOR<ProfissionalUpdateToOneWithWhereWithoutEnderecosInput, ProfissionalUpdateWithoutEnderecosInput>, ProfissionalUncheckedUpdateWithoutEnderecosInput>
  }

  export type ContatoPacienteCreateNestedManyWithoutContatoInput = {
    create?: XOR<ContatoPacienteCreateWithoutContatoInput, ContatoPacienteUncheckedCreateWithoutContatoInput> | ContatoPacienteCreateWithoutContatoInput[] | ContatoPacienteUncheckedCreateWithoutContatoInput[]
    connectOrCreate?: ContatoPacienteCreateOrConnectWithoutContatoInput | ContatoPacienteCreateOrConnectWithoutContatoInput[]
    createMany?: ContatoPacienteCreateManyContatoInputEnvelope
    connect?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
  }

  export type ContatoProfissionalCreateNestedManyWithoutContatoInput = {
    create?: XOR<ContatoProfissionalCreateWithoutContatoInput, ContatoProfissionalUncheckedCreateWithoutContatoInput> | ContatoProfissionalCreateWithoutContatoInput[] | ContatoProfissionalUncheckedCreateWithoutContatoInput[]
    connectOrCreate?: ContatoProfissionalCreateOrConnectWithoutContatoInput | ContatoProfissionalCreateOrConnectWithoutContatoInput[]
    createMany?: ContatoProfissionalCreateManyContatoInputEnvelope
    connect?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
  }

  export type ContatoPacienteUncheckedCreateNestedManyWithoutContatoInput = {
    create?: XOR<ContatoPacienteCreateWithoutContatoInput, ContatoPacienteUncheckedCreateWithoutContatoInput> | ContatoPacienteCreateWithoutContatoInput[] | ContatoPacienteUncheckedCreateWithoutContatoInput[]
    connectOrCreate?: ContatoPacienteCreateOrConnectWithoutContatoInput | ContatoPacienteCreateOrConnectWithoutContatoInput[]
    createMany?: ContatoPacienteCreateManyContatoInputEnvelope
    connect?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
  }

  export type ContatoProfissionalUncheckedCreateNestedManyWithoutContatoInput = {
    create?: XOR<ContatoProfissionalCreateWithoutContatoInput, ContatoProfissionalUncheckedCreateWithoutContatoInput> | ContatoProfissionalCreateWithoutContatoInput[] | ContatoProfissionalUncheckedCreateWithoutContatoInput[]
    connectOrCreate?: ContatoProfissionalCreateOrConnectWithoutContatoInput | ContatoProfissionalCreateOrConnectWithoutContatoInput[]
    createMany?: ContatoProfissionalCreateManyContatoInputEnvelope
    connect?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
  }

  export type EnumTipoFoneFieldUpdateOperationsInput = {
    set?: $Enums.TipoFone
  }

  export type ContatoPacienteUpdateManyWithoutContatoNestedInput = {
    create?: XOR<ContatoPacienteCreateWithoutContatoInput, ContatoPacienteUncheckedCreateWithoutContatoInput> | ContatoPacienteCreateWithoutContatoInput[] | ContatoPacienteUncheckedCreateWithoutContatoInput[]
    connectOrCreate?: ContatoPacienteCreateOrConnectWithoutContatoInput | ContatoPacienteCreateOrConnectWithoutContatoInput[]
    upsert?: ContatoPacienteUpsertWithWhereUniqueWithoutContatoInput | ContatoPacienteUpsertWithWhereUniqueWithoutContatoInput[]
    createMany?: ContatoPacienteCreateManyContatoInputEnvelope
    set?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    disconnect?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    delete?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    connect?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    update?: ContatoPacienteUpdateWithWhereUniqueWithoutContatoInput | ContatoPacienteUpdateWithWhereUniqueWithoutContatoInput[]
    updateMany?: ContatoPacienteUpdateManyWithWhereWithoutContatoInput | ContatoPacienteUpdateManyWithWhereWithoutContatoInput[]
    deleteMany?: ContatoPacienteScalarWhereInput | ContatoPacienteScalarWhereInput[]
  }

  export type ContatoProfissionalUpdateManyWithoutContatoNestedInput = {
    create?: XOR<ContatoProfissionalCreateWithoutContatoInput, ContatoProfissionalUncheckedCreateWithoutContatoInput> | ContatoProfissionalCreateWithoutContatoInput[] | ContatoProfissionalUncheckedCreateWithoutContatoInput[]
    connectOrCreate?: ContatoProfissionalCreateOrConnectWithoutContatoInput | ContatoProfissionalCreateOrConnectWithoutContatoInput[]
    upsert?: ContatoProfissionalUpsertWithWhereUniqueWithoutContatoInput | ContatoProfissionalUpsertWithWhereUniqueWithoutContatoInput[]
    createMany?: ContatoProfissionalCreateManyContatoInputEnvelope
    set?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    disconnect?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    delete?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    connect?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    update?: ContatoProfissionalUpdateWithWhereUniqueWithoutContatoInput | ContatoProfissionalUpdateWithWhereUniqueWithoutContatoInput[]
    updateMany?: ContatoProfissionalUpdateManyWithWhereWithoutContatoInput | ContatoProfissionalUpdateManyWithWhereWithoutContatoInput[]
    deleteMany?: ContatoProfissionalScalarWhereInput | ContatoProfissionalScalarWhereInput[]
  }

  export type ContatoPacienteUncheckedUpdateManyWithoutContatoNestedInput = {
    create?: XOR<ContatoPacienteCreateWithoutContatoInput, ContatoPacienteUncheckedCreateWithoutContatoInput> | ContatoPacienteCreateWithoutContatoInput[] | ContatoPacienteUncheckedCreateWithoutContatoInput[]
    connectOrCreate?: ContatoPacienteCreateOrConnectWithoutContatoInput | ContatoPacienteCreateOrConnectWithoutContatoInput[]
    upsert?: ContatoPacienteUpsertWithWhereUniqueWithoutContatoInput | ContatoPacienteUpsertWithWhereUniqueWithoutContatoInput[]
    createMany?: ContatoPacienteCreateManyContatoInputEnvelope
    set?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    disconnect?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    delete?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    connect?: ContatoPacienteWhereUniqueInput | ContatoPacienteWhereUniqueInput[]
    update?: ContatoPacienteUpdateWithWhereUniqueWithoutContatoInput | ContatoPacienteUpdateWithWhereUniqueWithoutContatoInput[]
    updateMany?: ContatoPacienteUpdateManyWithWhereWithoutContatoInput | ContatoPacienteUpdateManyWithWhereWithoutContatoInput[]
    deleteMany?: ContatoPacienteScalarWhereInput | ContatoPacienteScalarWhereInput[]
  }

  export type ContatoProfissionalUncheckedUpdateManyWithoutContatoNestedInput = {
    create?: XOR<ContatoProfissionalCreateWithoutContatoInput, ContatoProfissionalUncheckedCreateWithoutContatoInput> | ContatoProfissionalCreateWithoutContatoInput[] | ContatoProfissionalUncheckedCreateWithoutContatoInput[]
    connectOrCreate?: ContatoProfissionalCreateOrConnectWithoutContatoInput | ContatoProfissionalCreateOrConnectWithoutContatoInput[]
    upsert?: ContatoProfissionalUpsertWithWhereUniqueWithoutContatoInput | ContatoProfissionalUpsertWithWhereUniqueWithoutContatoInput[]
    createMany?: ContatoProfissionalCreateManyContatoInputEnvelope
    set?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    disconnect?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    delete?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    connect?: ContatoProfissionalWhereUniqueInput | ContatoProfissionalWhereUniqueInput[]
    update?: ContatoProfissionalUpdateWithWhereUniqueWithoutContatoInput | ContatoProfissionalUpdateWithWhereUniqueWithoutContatoInput[]
    updateMany?: ContatoProfissionalUpdateManyWithWhereWithoutContatoInput | ContatoProfissionalUpdateManyWithWhereWithoutContatoInput[]
    deleteMany?: ContatoProfissionalScalarWhereInput | ContatoProfissionalScalarWhereInput[]
  }

  export type ContatoCreateNestedOneWithoutPacientesInput = {
    create?: XOR<ContatoCreateWithoutPacientesInput, ContatoUncheckedCreateWithoutPacientesInput>
    connectOrCreate?: ContatoCreateOrConnectWithoutPacientesInput
    connect?: ContatoWhereUniqueInput
  }

  export type PacienteCreateNestedOneWithoutContatosInput = {
    create?: XOR<PacienteCreateWithoutContatosInput, PacienteUncheckedCreateWithoutContatosInput>
    connectOrCreate?: PacienteCreateOrConnectWithoutContatosInput
    connect?: PacienteWhereUniqueInput
  }

  export type ContatoUpdateOneRequiredWithoutPacientesNestedInput = {
    create?: XOR<ContatoCreateWithoutPacientesInput, ContatoUncheckedCreateWithoutPacientesInput>
    connectOrCreate?: ContatoCreateOrConnectWithoutPacientesInput
    upsert?: ContatoUpsertWithoutPacientesInput
    connect?: ContatoWhereUniqueInput
    update?: XOR<XOR<ContatoUpdateToOneWithWhereWithoutPacientesInput, ContatoUpdateWithoutPacientesInput>, ContatoUncheckedUpdateWithoutPacientesInput>
  }

  export type PacienteUpdateOneRequiredWithoutContatosNestedInput = {
    create?: XOR<PacienteCreateWithoutContatosInput, PacienteUncheckedCreateWithoutContatosInput>
    connectOrCreate?: PacienteCreateOrConnectWithoutContatosInput
    upsert?: PacienteUpsertWithoutContatosInput
    connect?: PacienteWhereUniqueInput
    update?: XOR<XOR<PacienteUpdateToOneWithWhereWithoutContatosInput, PacienteUpdateWithoutContatosInput>, PacienteUncheckedUpdateWithoutContatosInput>
  }

  export type ContatoCreateNestedOneWithoutProfissionaisInput = {
    create?: XOR<ContatoCreateWithoutProfissionaisInput, ContatoUncheckedCreateWithoutProfissionaisInput>
    connectOrCreate?: ContatoCreateOrConnectWithoutProfissionaisInput
    connect?: ContatoWhereUniqueInput
  }

  export type ProfissionalCreateNestedOneWithoutContatosInput = {
    create?: XOR<ProfissionalCreateWithoutContatosInput, ProfissionalUncheckedCreateWithoutContatosInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutContatosInput
    connect?: ProfissionalWhereUniqueInput
  }

  export type ContatoUpdateOneRequiredWithoutProfissionaisNestedInput = {
    create?: XOR<ContatoCreateWithoutProfissionaisInput, ContatoUncheckedCreateWithoutProfissionaisInput>
    connectOrCreate?: ContatoCreateOrConnectWithoutProfissionaisInput
    upsert?: ContatoUpsertWithoutProfissionaisInput
    connect?: ContatoWhereUniqueInput
    update?: XOR<XOR<ContatoUpdateToOneWithWhereWithoutProfissionaisInput, ContatoUpdateWithoutProfissionaisInput>, ContatoUncheckedUpdateWithoutProfissionaisInput>
  }

  export type ProfissionalUpdateOneRequiredWithoutContatosNestedInput = {
    create?: XOR<ProfissionalCreateWithoutContatosInput, ProfissionalUncheckedCreateWithoutContatosInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutContatosInput
    upsert?: ProfissionalUpsertWithoutContatosInput
    connect?: ProfissionalWhereUniqueInput
    update?: XOR<XOR<ProfissionalUpdateToOneWithWhereWithoutContatosInput, ProfissionalUpdateWithoutContatosInput>, ProfissionalUncheckedUpdateWithoutContatosInput>
  }

  export type AfericaoClinicaCreateNestedManyWithoutAtendimentoInput = {
    create?: XOR<AfericaoClinicaCreateWithoutAtendimentoInput, AfericaoClinicaUncheckedCreateWithoutAtendimentoInput> | AfericaoClinicaCreateWithoutAtendimentoInput[] | AfericaoClinicaUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: AfericaoClinicaCreateOrConnectWithoutAtendimentoInput | AfericaoClinicaCreateOrConnectWithoutAtendimentoInput[]
    createMany?: AfericaoClinicaCreateManyAtendimentoInputEnvelope
    connect?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
  }

  export type PacienteCreateNestedOneWithoutAtendimentosInput = {
    create?: XOR<PacienteCreateWithoutAtendimentosInput, PacienteUncheckedCreateWithoutAtendimentosInput>
    connectOrCreate?: PacienteCreateOrConnectWithoutAtendimentosInput
    connect?: PacienteWhereUniqueInput
  }

  export type ProfissionalCreateNestedOneWithoutAtendimentosInput = {
    create?: XOR<ProfissionalCreateWithoutAtendimentosInput, ProfissionalUncheckedCreateWithoutAtendimentosInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutAtendimentosInput
    connect?: ProfissionalWhereUniqueInput
  }

  export type EvaDorCreateNestedManyWithoutAtendimentoInput = {
    create?: XOR<EvaDorCreateWithoutAtendimentoInput, EvaDorUncheckedCreateWithoutAtendimentoInput> | EvaDorCreateWithoutAtendimentoInput[] | EvaDorUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: EvaDorCreateOrConnectWithoutAtendimentoInput | EvaDorCreateOrConnectWithoutAtendimentoInput[]
    createMany?: EvaDorCreateManyAtendimentoInputEnvelope
    connect?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
  }

  export type EvolucaoCreateNestedManyWithoutAtendimentoInput = {
    create?: XOR<EvolucaoCreateWithoutAtendimentoInput, EvolucaoUncheckedCreateWithoutAtendimentoInput> | EvolucaoCreateWithoutAtendimentoInput[] | EvolucaoUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutAtendimentoInput | EvolucaoCreateOrConnectWithoutAtendimentoInput[]
    createMany?: EvolucaoCreateManyAtendimentoInputEnvelope
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
  }

  export type GlasgowCreateNestedManyWithoutAtendimentoInput = {
    create?: XOR<GlasgowCreateWithoutAtendimentoInput, GlasgowUncheckedCreateWithoutAtendimentoInput> | GlasgowCreateWithoutAtendimentoInput[] | GlasgowUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: GlasgowCreateOrConnectWithoutAtendimentoInput | GlasgowCreateOrConnectWithoutAtendimentoInput[]
    createMany?: GlasgowCreateManyAtendimentoInputEnvelope
    connect?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
  }

  export type SinaisVitaisCreateNestedManyWithoutAtendimentoInput = {
    create?: XOR<SinaisVitaisCreateWithoutAtendimentoInput, SinaisVitaisUncheckedCreateWithoutAtendimentoInput> | SinaisVitaisCreateWithoutAtendimentoInput[] | SinaisVitaisUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: SinaisVitaisCreateOrConnectWithoutAtendimentoInput | SinaisVitaisCreateOrConnectWithoutAtendimentoInput[]
    createMany?: SinaisVitaisCreateManyAtendimentoInputEnvelope
    connect?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
  }

  export type AfericaoClinicaUncheckedCreateNestedManyWithoutAtendimentoInput = {
    create?: XOR<AfericaoClinicaCreateWithoutAtendimentoInput, AfericaoClinicaUncheckedCreateWithoutAtendimentoInput> | AfericaoClinicaCreateWithoutAtendimentoInput[] | AfericaoClinicaUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: AfericaoClinicaCreateOrConnectWithoutAtendimentoInput | AfericaoClinicaCreateOrConnectWithoutAtendimentoInput[]
    createMany?: AfericaoClinicaCreateManyAtendimentoInputEnvelope
    connect?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
  }

  export type EvaDorUncheckedCreateNestedManyWithoutAtendimentoInput = {
    create?: XOR<EvaDorCreateWithoutAtendimentoInput, EvaDorUncheckedCreateWithoutAtendimentoInput> | EvaDorCreateWithoutAtendimentoInput[] | EvaDorUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: EvaDorCreateOrConnectWithoutAtendimentoInput | EvaDorCreateOrConnectWithoutAtendimentoInput[]
    createMany?: EvaDorCreateManyAtendimentoInputEnvelope
    connect?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
  }

  export type EvolucaoUncheckedCreateNestedManyWithoutAtendimentoInput = {
    create?: XOR<EvolucaoCreateWithoutAtendimentoInput, EvolucaoUncheckedCreateWithoutAtendimentoInput> | EvolucaoCreateWithoutAtendimentoInput[] | EvolucaoUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutAtendimentoInput | EvolucaoCreateOrConnectWithoutAtendimentoInput[]
    createMany?: EvolucaoCreateManyAtendimentoInputEnvelope
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
  }

  export type GlasgowUncheckedCreateNestedManyWithoutAtendimentoInput = {
    create?: XOR<GlasgowCreateWithoutAtendimentoInput, GlasgowUncheckedCreateWithoutAtendimentoInput> | GlasgowCreateWithoutAtendimentoInput[] | GlasgowUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: GlasgowCreateOrConnectWithoutAtendimentoInput | GlasgowCreateOrConnectWithoutAtendimentoInput[]
    createMany?: GlasgowCreateManyAtendimentoInputEnvelope
    connect?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
  }

  export type SinaisVitaisUncheckedCreateNestedManyWithoutAtendimentoInput = {
    create?: XOR<SinaisVitaisCreateWithoutAtendimentoInput, SinaisVitaisUncheckedCreateWithoutAtendimentoInput> | SinaisVitaisCreateWithoutAtendimentoInput[] | SinaisVitaisUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: SinaisVitaisCreateOrConnectWithoutAtendimentoInput | SinaisVitaisCreateOrConnectWithoutAtendimentoInput[]
    createMany?: SinaisVitaisCreateManyAtendimentoInputEnvelope
    connect?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
  }

  export type AfericaoClinicaUpdateManyWithoutAtendimentoNestedInput = {
    create?: XOR<AfericaoClinicaCreateWithoutAtendimentoInput, AfericaoClinicaUncheckedCreateWithoutAtendimentoInput> | AfericaoClinicaCreateWithoutAtendimentoInput[] | AfericaoClinicaUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: AfericaoClinicaCreateOrConnectWithoutAtendimentoInput | AfericaoClinicaCreateOrConnectWithoutAtendimentoInput[]
    upsert?: AfericaoClinicaUpsertWithWhereUniqueWithoutAtendimentoInput | AfericaoClinicaUpsertWithWhereUniqueWithoutAtendimentoInput[]
    createMany?: AfericaoClinicaCreateManyAtendimentoInputEnvelope
    set?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    disconnect?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    delete?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    connect?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    update?: AfericaoClinicaUpdateWithWhereUniqueWithoutAtendimentoInput | AfericaoClinicaUpdateWithWhereUniqueWithoutAtendimentoInput[]
    updateMany?: AfericaoClinicaUpdateManyWithWhereWithoutAtendimentoInput | AfericaoClinicaUpdateManyWithWhereWithoutAtendimentoInput[]
    deleteMany?: AfericaoClinicaScalarWhereInput | AfericaoClinicaScalarWhereInput[]
  }

  export type PacienteUpdateOneRequiredWithoutAtendimentosNestedInput = {
    create?: XOR<PacienteCreateWithoutAtendimentosInput, PacienteUncheckedCreateWithoutAtendimentosInput>
    connectOrCreate?: PacienteCreateOrConnectWithoutAtendimentosInput
    upsert?: PacienteUpsertWithoutAtendimentosInput
    connect?: PacienteWhereUniqueInput
    update?: XOR<XOR<PacienteUpdateToOneWithWhereWithoutAtendimentosInput, PacienteUpdateWithoutAtendimentosInput>, PacienteUncheckedUpdateWithoutAtendimentosInput>
  }

  export type ProfissionalUpdateOneRequiredWithoutAtendimentosNestedInput = {
    create?: XOR<ProfissionalCreateWithoutAtendimentosInput, ProfissionalUncheckedCreateWithoutAtendimentosInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutAtendimentosInput
    upsert?: ProfissionalUpsertWithoutAtendimentosInput
    connect?: ProfissionalWhereUniqueInput
    update?: XOR<XOR<ProfissionalUpdateToOneWithWhereWithoutAtendimentosInput, ProfissionalUpdateWithoutAtendimentosInput>, ProfissionalUncheckedUpdateWithoutAtendimentosInput>
  }

  export type EvaDorUpdateManyWithoutAtendimentoNestedInput = {
    create?: XOR<EvaDorCreateWithoutAtendimentoInput, EvaDorUncheckedCreateWithoutAtendimentoInput> | EvaDorCreateWithoutAtendimentoInput[] | EvaDorUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: EvaDorCreateOrConnectWithoutAtendimentoInput | EvaDorCreateOrConnectWithoutAtendimentoInput[]
    upsert?: EvaDorUpsertWithWhereUniqueWithoutAtendimentoInput | EvaDorUpsertWithWhereUniqueWithoutAtendimentoInput[]
    createMany?: EvaDorCreateManyAtendimentoInputEnvelope
    set?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    disconnect?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    delete?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    connect?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    update?: EvaDorUpdateWithWhereUniqueWithoutAtendimentoInput | EvaDorUpdateWithWhereUniqueWithoutAtendimentoInput[]
    updateMany?: EvaDorUpdateManyWithWhereWithoutAtendimentoInput | EvaDorUpdateManyWithWhereWithoutAtendimentoInput[]
    deleteMany?: EvaDorScalarWhereInput | EvaDorScalarWhereInput[]
  }

  export type EvolucaoUpdateManyWithoutAtendimentoNestedInput = {
    create?: XOR<EvolucaoCreateWithoutAtendimentoInput, EvolucaoUncheckedCreateWithoutAtendimentoInput> | EvolucaoCreateWithoutAtendimentoInput[] | EvolucaoUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutAtendimentoInput | EvolucaoCreateOrConnectWithoutAtendimentoInput[]
    upsert?: EvolucaoUpsertWithWhereUniqueWithoutAtendimentoInput | EvolucaoUpsertWithWhereUniqueWithoutAtendimentoInput[]
    createMany?: EvolucaoCreateManyAtendimentoInputEnvelope
    set?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    disconnect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    delete?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    update?: EvolucaoUpdateWithWhereUniqueWithoutAtendimentoInput | EvolucaoUpdateWithWhereUniqueWithoutAtendimentoInput[]
    updateMany?: EvolucaoUpdateManyWithWhereWithoutAtendimentoInput | EvolucaoUpdateManyWithWhereWithoutAtendimentoInput[]
    deleteMany?: EvolucaoScalarWhereInput | EvolucaoScalarWhereInput[]
  }

  export type GlasgowUpdateManyWithoutAtendimentoNestedInput = {
    create?: XOR<GlasgowCreateWithoutAtendimentoInput, GlasgowUncheckedCreateWithoutAtendimentoInput> | GlasgowCreateWithoutAtendimentoInput[] | GlasgowUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: GlasgowCreateOrConnectWithoutAtendimentoInput | GlasgowCreateOrConnectWithoutAtendimentoInput[]
    upsert?: GlasgowUpsertWithWhereUniqueWithoutAtendimentoInput | GlasgowUpsertWithWhereUniqueWithoutAtendimentoInput[]
    createMany?: GlasgowCreateManyAtendimentoInputEnvelope
    set?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    disconnect?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    delete?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    connect?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    update?: GlasgowUpdateWithWhereUniqueWithoutAtendimentoInput | GlasgowUpdateWithWhereUniqueWithoutAtendimentoInput[]
    updateMany?: GlasgowUpdateManyWithWhereWithoutAtendimentoInput | GlasgowUpdateManyWithWhereWithoutAtendimentoInput[]
    deleteMany?: GlasgowScalarWhereInput | GlasgowScalarWhereInput[]
  }

  export type SinaisVitaisUpdateManyWithoutAtendimentoNestedInput = {
    create?: XOR<SinaisVitaisCreateWithoutAtendimentoInput, SinaisVitaisUncheckedCreateWithoutAtendimentoInput> | SinaisVitaisCreateWithoutAtendimentoInput[] | SinaisVitaisUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: SinaisVitaisCreateOrConnectWithoutAtendimentoInput | SinaisVitaisCreateOrConnectWithoutAtendimentoInput[]
    upsert?: SinaisVitaisUpsertWithWhereUniqueWithoutAtendimentoInput | SinaisVitaisUpsertWithWhereUniqueWithoutAtendimentoInput[]
    createMany?: SinaisVitaisCreateManyAtendimentoInputEnvelope
    set?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    disconnect?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    delete?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    connect?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    update?: SinaisVitaisUpdateWithWhereUniqueWithoutAtendimentoInput | SinaisVitaisUpdateWithWhereUniqueWithoutAtendimentoInput[]
    updateMany?: SinaisVitaisUpdateManyWithWhereWithoutAtendimentoInput | SinaisVitaisUpdateManyWithWhereWithoutAtendimentoInput[]
    deleteMany?: SinaisVitaisScalarWhereInput | SinaisVitaisScalarWhereInput[]
  }

  export type AfericaoClinicaUncheckedUpdateManyWithoutAtendimentoNestedInput = {
    create?: XOR<AfericaoClinicaCreateWithoutAtendimentoInput, AfericaoClinicaUncheckedCreateWithoutAtendimentoInput> | AfericaoClinicaCreateWithoutAtendimentoInput[] | AfericaoClinicaUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: AfericaoClinicaCreateOrConnectWithoutAtendimentoInput | AfericaoClinicaCreateOrConnectWithoutAtendimentoInput[]
    upsert?: AfericaoClinicaUpsertWithWhereUniqueWithoutAtendimentoInput | AfericaoClinicaUpsertWithWhereUniqueWithoutAtendimentoInput[]
    createMany?: AfericaoClinicaCreateManyAtendimentoInputEnvelope
    set?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    disconnect?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    delete?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    connect?: AfericaoClinicaWhereUniqueInput | AfericaoClinicaWhereUniqueInput[]
    update?: AfericaoClinicaUpdateWithWhereUniqueWithoutAtendimentoInput | AfericaoClinicaUpdateWithWhereUniqueWithoutAtendimentoInput[]
    updateMany?: AfericaoClinicaUpdateManyWithWhereWithoutAtendimentoInput | AfericaoClinicaUpdateManyWithWhereWithoutAtendimentoInput[]
    deleteMany?: AfericaoClinicaScalarWhereInput | AfericaoClinicaScalarWhereInput[]
  }

  export type EvaDorUncheckedUpdateManyWithoutAtendimentoNestedInput = {
    create?: XOR<EvaDorCreateWithoutAtendimentoInput, EvaDorUncheckedCreateWithoutAtendimentoInput> | EvaDorCreateWithoutAtendimentoInput[] | EvaDorUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: EvaDorCreateOrConnectWithoutAtendimentoInput | EvaDorCreateOrConnectWithoutAtendimentoInput[]
    upsert?: EvaDorUpsertWithWhereUniqueWithoutAtendimentoInput | EvaDorUpsertWithWhereUniqueWithoutAtendimentoInput[]
    createMany?: EvaDorCreateManyAtendimentoInputEnvelope
    set?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    disconnect?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    delete?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    connect?: EvaDorWhereUniqueInput | EvaDorWhereUniqueInput[]
    update?: EvaDorUpdateWithWhereUniqueWithoutAtendimentoInput | EvaDorUpdateWithWhereUniqueWithoutAtendimentoInput[]
    updateMany?: EvaDorUpdateManyWithWhereWithoutAtendimentoInput | EvaDorUpdateManyWithWhereWithoutAtendimentoInput[]
    deleteMany?: EvaDorScalarWhereInput | EvaDorScalarWhereInput[]
  }

  export type EvolucaoUncheckedUpdateManyWithoutAtendimentoNestedInput = {
    create?: XOR<EvolucaoCreateWithoutAtendimentoInput, EvolucaoUncheckedCreateWithoutAtendimentoInput> | EvolucaoCreateWithoutAtendimentoInput[] | EvolucaoUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutAtendimentoInput | EvolucaoCreateOrConnectWithoutAtendimentoInput[]
    upsert?: EvolucaoUpsertWithWhereUniqueWithoutAtendimentoInput | EvolucaoUpsertWithWhereUniqueWithoutAtendimentoInput[]
    createMany?: EvolucaoCreateManyAtendimentoInputEnvelope
    set?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    disconnect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    delete?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    update?: EvolucaoUpdateWithWhereUniqueWithoutAtendimentoInput | EvolucaoUpdateWithWhereUniqueWithoutAtendimentoInput[]
    updateMany?: EvolucaoUpdateManyWithWhereWithoutAtendimentoInput | EvolucaoUpdateManyWithWhereWithoutAtendimentoInput[]
    deleteMany?: EvolucaoScalarWhereInput | EvolucaoScalarWhereInput[]
  }

  export type GlasgowUncheckedUpdateManyWithoutAtendimentoNestedInput = {
    create?: XOR<GlasgowCreateWithoutAtendimentoInput, GlasgowUncheckedCreateWithoutAtendimentoInput> | GlasgowCreateWithoutAtendimentoInput[] | GlasgowUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: GlasgowCreateOrConnectWithoutAtendimentoInput | GlasgowCreateOrConnectWithoutAtendimentoInput[]
    upsert?: GlasgowUpsertWithWhereUniqueWithoutAtendimentoInput | GlasgowUpsertWithWhereUniqueWithoutAtendimentoInput[]
    createMany?: GlasgowCreateManyAtendimentoInputEnvelope
    set?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    disconnect?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    delete?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    connect?: GlasgowWhereUniqueInput | GlasgowWhereUniqueInput[]
    update?: GlasgowUpdateWithWhereUniqueWithoutAtendimentoInput | GlasgowUpdateWithWhereUniqueWithoutAtendimentoInput[]
    updateMany?: GlasgowUpdateManyWithWhereWithoutAtendimentoInput | GlasgowUpdateManyWithWhereWithoutAtendimentoInput[]
    deleteMany?: GlasgowScalarWhereInput | GlasgowScalarWhereInput[]
  }

  export type SinaisVitaisUncheckedUpdateManyWithoutAtendimentoNestedInput = {
    create?: XOR<SinaisVitaisCreateWithoutAtendimentoInput, SinaisVitaisUncheckedCreateWithoutAtendimentoInput> | SinaisVitaisCreateWithoutAtendimentoInput[] | SinaisVitaisUncheckedCreateWithoutAtendimentoInput[]
    connectOrCreate?: SinaisVitaisCreateOrConnectWithoutAtendimentoInput | SinaisVitaisCreateOrConnectWithoutAtendimentoInput[]
    upsert?: SinaisVitaisUpsertWithWhereUniqueWithoutAtendimentoInput | SinaisVitaisUpsertWithWhereUniqueWithoutAtendimentoInput[]
    createMany?: SinaisVitaisCreateManyAtendimentoInputEnvelope
    set?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    disconnect?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    delete?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    connect?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    update?: SinaisVitaisUpdateWithWhereUniqueWithoutAtendimentoInput | SinaisVitaisUpdateWithWhereUniqueWithoutAtendimentoInput[]
    updateMany?: SinaisVitaisUpdateManyWithWhereWithoutAtendimentoInput | SinaisVitaisUpdateManyWithWhereWithoutAtendimentoInput[]
    deleteMany?: SinaisVitaisScalarWhereInput | SinaisVitaisScalarWhereInput[]
  }

  export type AtendimentoCreateNestedOneWithoutEvolucoesInput = {
    create?: XOR<AtendimentoCreateWithoutEvolucoesInput, AtendimentoUncheckedCreateWithoutEvolucoesInput>
    connectOrCreate?: AtendimentoCreateOrConnectWithoutEvolucoesInput
    connect?: AtendimentoWhereUniqueInput
  }

  export type ProfissionalCreateNestedOneWithoutEvolucoesInput = {
    create?: XOR<ProfissionalCreateWithoutEvolucoesInput, ProfissionalUncheckedCreateWithoutEvolucoesInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutEvolucoesInput
    connect?: ProfissionalWhereUniqueInput
  }

  export type PacienteCreateNestedOneWithoutEvolucoesInput = {
    create?: XOR<PacienteCreateWithoutEvolucoesInput, PacienteUncheckedCreateWithoutEvolucoesInput>
    connectOrCreate?: PacienteCreateOrConnectWithoutEvolucoesInput
    connect?: PacienteWhereUniqueInput
  }

  export type TipoEvolucaoClinicaCreateNestedOneWithoutEvolucaosInput = {
    create?: XOR<TipoEvolucaoClinicaCreateWithoutEvolucaosInput, TipoEvolucaoClinicaUncheckedCreateWithoutEvolucaosInput>
    connectOrCreate?: TipoEvolucaoClinicaCreateOrConnectWithoutEvolucaosInput
    connect?: TipoEvolucaoClinicaWhereUniqueInput
  }

  export type EvolucaoCidCreateNestedManyWithoutEvolucaoInput = {
    create?: XOR<EvolucaoCidCreateWithoutEvolucaoInput, EvolucaoCidUncheckedCreateWithoutEvolucaoInput> | EvolucaoCidCreateWithoutEvolucaoInput[] | EvolucaoCidUncheckedCreateWithoutEvolucaoInput[]
    connectOrCreate?: EvolucaoCidCreateOrConnectWithoutEvolucaoInput | EvolucaoCidCreateOrConnectWithoutEvolucaoInput[]
    createMany?: EvolucaoCidCreateManyEvolucaoInputEnvelope
    connect?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
  }

  export type EvolucaoDsmCreateNestedManyWithoutEvolucaoInput = {
    create?: XOR<EvolucaoDsmCreateWithoutEvolucaoInput, EvolucaoDsmUncheckedCreateWithoutEvolucaoInput> | EvolucaoDsmCreateWithoutEvolucaoInput[] | EvolucaoDsmUncheckedCreateWithoutEvolucaoInput[]
    connectOrCreate?: EvolucaoDsmCreateOrConnectWithoutEvolucaoInput | EvolucaoDsmCreateOrConnectWithoutEvolucaoInput[]
    createMany?: EvolucaoDsmCreateManyEvolucaoInputEnvelope
    connect?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
  }

  export type EvolucaoCidUncheckedCreateNestedManyWithoutEvolucaoInput = {
    create?: XOR<EvolucaoCidCreateWithoutEvolucaoInput, EvolucaoCidUncheckedCreateWithoutEvolucaoInput> | EvolucaoCidCreateWithoutEvolucaoInput[] | EvolucaoCidUncheckedCreateWithoutEvolucaoInput[]
    connectOrCreate?: EvolucaoCidCreateOrConnectWithoutEvolucaoInput | EvolucaoCidCreateOrConnectWithoutEvolucaoInput[]
    createMany?: EvolucaoCidCreateManyEvolucaoInputEnvelope
    connect?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
  }

  export type EvolucaoDsmUncheckedCreateNestedManyWithoutEvolucaoInput = {
    create?: XOR<EvolucaoDsmCreateWithoutEvolucaoInput, EvolucaoDsmUncheckedCreateWithoutEvolucaoInput> | EvolucaoDsmCreateWithoutEvolucaoInput[] | EvolucaoDsmUncheckedCreateWithoutEvolucaoInput[]
    connectOrCreate?: EvolucaoDsmCreateOrConnectWithoutEvolucaoInput | EvolucaoDsmCreateOrConnectWithoutEvolucaoInput[]
    createMany?: EvolucaoDsmCreateManyEvolucaoInputEnvelope
    connect?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
  }

  export type AtendimentoUpdateOneRequiredWithoutEvolucoesNestedInput = {
    create?: XOR<AtendimentoCreateWithoutEvolucoesInput, AtendimentoUncheckedCreateWithoutEvolucoesInput>
    connectOrCreate?: AtendimentoCreateOrConnectWithoutEvolucoesInput
    upsert?: AtendimentoUpsertWithoutEvolucoesInput
    connect?: AtendimentoWhereUniqueInput
    update?: XOR<XOR<AtendimentoUpdateToOneWithWhereWithoutEvolucoesInput, AtendimentoUpdateWithoutEvolucoesInput>, AtendimentoUncheckedUpdateWithoutEvolucoesInput>
  }

  export type ProfissionalUpdateOneWithoutEvolucoesNestedInput = {
    create?: XOR<ProfissionalCreateWithoutEvolucoesInput, ProfissionalUncheckedCreateWithoutEvolucoesInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutEvolucoesInput
    upsert?: ProfissionalUpsertWithoutEvolucoesInput
    disconnect?: ProfissionalWhereInput | boolean
    delete?: ProfissionalWhereInput | boolean
    connect?: ProfissionalWhereUniqueInput
    update?: XOR<XOR<ProfissionalUpdateToOneWithWhereWithoutEvolucoesInput, ProfissionalUpdateWithoutEvolucoesInput>, ProfissionalUncheckedUpdateWithoutEvolucoesInput>
  }

  export type PacienteUpdateOneWithoutEvolucoesNestedInput = {
    create?: XOR<PacienteCreateWithoutEvolucoesInput, PacienteUncheckedCreateWithoutEvolucoesInput>
    connectOrCreate?: PacienteCreateOrConnectWithoutEvolucoesInput
    upsert?: PacienteUpsertWithoutEvolucoesInput
    disconnect?: PacienteWhereInput | boolean
    delete?: PacienteWhereInput | boolean
    connect?: PacienteWhereUniqueInput
    update?: XOR<XOR<PacienteUpdateToOneWithWhereWithoutEvolucoesInput, PacienteUpdateWithoutEvolucoesInput>, PacienteUncheckedUpdateWithoutEvolucoesInput>
  }

  export type TipoEvolucaoClinicaUpdateOneWithoutEvolucaosNestedInput = {
    create?: XOR<TipoEvolucaoClinicaCreateWithoutEvolucaosInput, TipoEvolucaoClinicaUncheckedCreateWithoutEvolucaosInput>
    connectOrCreate?: TipoEvolucaoClinicaCreateOrConnectWithoutEvolucaosInput
    upsert?: TipoEvolucaoClinicaUpsertWithoutEvolucaosInput
    disconnect?: TipoEvolucaoClinicaWhereInput | boolean
    delete?: TipoEvolucaoClinicaWhereInput | boolean
    connect?: TipoEvolucaoClinicaWhereUniqueInput
    update?: XOR<XOR<TipoEvolucaoClinicaUpdateToOneWithWhereWithoutEvolucaosInput, TipoEvolucaoClinicaUpdateWithoutEvolucaosInput>, TipoEvolucaoClinicaUncheckedUpdateWithoutEvolucaosInput>
  }

  export type EvolucaoCidUpdateManyWithoutEvolucaoNestedInput = {
    create?: XOR<EvolucaoCidCreateWithoutEvolucaoInput, EvolucaoCidUncheckedCreateWithoutEvolucaoInput> | EvolucaoCidCreateWithoutEvolucaoInput[] | EvolucaoCidUncheckedCreateWithoutEvolucaoInput[]
    connectOrCreate?: EvolucaoCidCreateOrConnectWithoutEvolucaoInput | EvolucaoCidCreateOrConnectWithoutEvolucaoInput[]
    upsert?: EvolucaoCidUpsertWithWhereUniqueWithoutEvolucaoInput | EvolucaoCidUpsertWithWhereUniqueWithoutEvolucaoInput[]
    createMany?: EvolucaoCidCreateManyEvolucaoInputEnvelope
    set?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    disconnect?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    delete?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    connect?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    update?: EvolucaoCidUpdateWithWhereUniqueWithoutEvolucaoInput | EvolucaoCidUpdateWithWhereUniqueWithoutEvolucaoInput[]
    updateMany?: EvolucaoCidUpdateManyWithWhereWithoutEvolucaoInput | EvolucaoCidUpdateManyWithWhereWithoutEvolucaoInput[]
    deleteMany?: EvolucaoCidScalarWhereInput | EvolucaoCidScalarWhereInput[]
  }

  export type EvolucaoDsmUpdateManyWithoutEvolucaoNestedInput = {
    create?: XOR<EvolucaoDsmCreateWithoutEvolucaoInput, EvolucaoDsmUncheckedCreateWithoutEvolucaoInput> | EvolucaoDsmCreateWithoutEvolucaoInput[] | EvolucaoDsmUncheckedCreateWithoutEvolucaoInput[]
    connectOrCreate?: EvolucaoDsmCreateOrConnectWithoutEvolucaoInput | EvolucaoDsmCreateOrConnectWithoutEvolucaoInput[]
    upsert?: EvolucaoDsmUpsertWithWhereUniqueWithoutEvolucaoInput | EvolucaoDsmUpsertWithWhereUniqueWithoutEvolucaoInput[]
    createMany?: EvolucaoDsmCreateManyEvolucaoInputEnvelope
    set?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    disconnect?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    delete?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    connect?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    update?: EvolucaoDsmUpdateWithWhereUniqueWithoutEvolucaoInput | EvolucaoDsmUpdateWithWhereUniqueWithoutEvolucaoInput[]
    updateMany?: EvolucaoDsmUpdateManyWithWhereWithoutEvolucaoInput | EvolucaoDsmUpdateManyWithWhereWithoutEvolucaoInput[]
    deleteMany?: EvolucaoDsmScalarWhereInput | EvolucaoDsmScalarWhereInput[]
  }

  export type EvolucaoCidUncheckedUpdateManyWithoutEvolucaoNestedInput = {
    create?: XOR<EvolucaoCidCreateWithoutEvolucaoInput, EvolucaoCidUncheckedCreateWithoutEvolucaoInput> | EvolucaoCidCreateWithoutEvolucaoInput[] | EvolucaoCidUncheckedCreateWithoutEvolucaoInput[]
    connectOrCreate?: EvolucaoCidCreateOrConnectWithoutEvolucaoInput | EvolucaoCidCreateOrConnectWithoutEvolucaoInput[]
    upsert?: EvolucaoCidUpsertWithWhereUniqueWithoutEvolucaoInput | EvolucaoCidUpsertWithWhereUniqueWithoutEvolucaoInput[]
    createMany?: EvolucaoCidCreateManyEvolucaoInputEnvelope
    set?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    disconnect?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    delete?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    connect?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    update?: EvolucaoCidUpdateWithWhereUniqueWithoutEvolucaoInput | EvolucaoCidUpdateWithWhereUniqueWithoutEvolucaoInput[]
    updateMany?: EvolucaoCidUpdateManyWithWhereWithoutEvolucaoInput | EvolucaoCidUpdateManyWithWhereWithoutEvolucaoInput[]
    deleteMany?: EvolucaoCidScalarWhereInput | EvolucaoCidScalarWhereInput[]
  }

  export type EvolucaoDsmUncheckedUpdateManyWithoutEvolucaoNestedInput = {
    create?: XOR<EvolucaoDsmCreateWithoutEvolucaoInput, EvolucaoDsmUncheckedCreateWithoutEvolucaoInput> | EvolucaoDsmCreateWithoutEvolucaoInput[] | EvolucaoDsmUncheckedCreateWithoutEvolucaoInput[]
    connectOrCreate?: EvolucaoDsmCreateOrConnectWithoutEvolucaoInput | EvolucaoDsmCreateOrConnectWithoutEvolucaoInput[]
    upsert?: EvolucaoDsmUpsertWithWhereUniqueWithoutEvolucaoInput | EvolucaoDsmUpsertWithWhereUniqueWithoutEvolucaoInput[]
    createMany?: EvolucaoDsmCreateManyEvolucaoInputEnvelope
    set?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    disconnect?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    delete?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    connect?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    update?: EvolucaoDsmUpdateWithWhereUniqueWithoutEvolucaoInput | EvolucaoDsmUpdateWithWhereUniqueWithoutEvolucaoInput[]
    updateMany?: EvolucaoDsmUpdateManyWithWhereWithoutEvolucaoInput | EvolucaoDsmUpdateManyWithWhereWithoutEvolucaoInput[]
    deleteMany?: EvolucaoDsmScalarWhereInput | EvolucaoDsmScalarWhereInput[]
  }

  export type EnderecoPessoaRelacionadaCreateNestedManyWithoutPessoaRelacionadaInput = {
    create?: XOR<EnderecoPessoaRelacionadaCreateWithoutPessoaRelacionadaInput, EnderecoPessoaRelacionadaUncheckedCreateWithoutPessoaRelacionadaInput> | EnderecoPessoaRelacionadaCreateWithoutPessoaRelacionadaInput[] | EnderecoPessoaRelacionadaUncheckedCreateWithoutPessoaRelacionadaInput[]
    connectOrCreate?: EnderecoPessoaRelacionadaCreateOrConnectWithoutPessoaRelacionadaInput | EnderecoPessoaRelacionadaCreateOrConnectWithoutPessoaRelacionadaInput[]
    createMany?: EnderecoPessoaRelacionadaCreateManyPessoaRelacionadaInputEnvelope
    connect?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
  }

  export type ParentescoPacienteCreateNestedManyWithoutPessoaRelacionadaInput = {
    create?: XOR<ParentescoPacienteCreateWithoutPessoaRelacionadaInput, ParentescoPacienteUncheckedCreateWithoutPessoaRelacionadaInput> | ParentescoPacienteCreateWithoutPessoaRelacionadaInput[] | ParentescoPacienteUncheckedCreateWithoutPessoaRelacionadaInput[]
    connectOrCreate?: ParentescoPacienteCreateOrConnectWithoutPessoaRelacionadaInput | ParentescoPacienteCreateOrConnectWithoutPessoaRelacionadaInput[]
    createMany?: ParentescoPacienteCreateManyPessoaRelacionadaInputEnvelope
    connect?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
  }

  export type EnderecoPessoaRelacionadaUncheckedCreateNestedManyWithoutPessoaRelacionadaInput = {
    create?: XOR<EnderecoPessoaRelacionadaCreateWithoutPessoaRelacionadaInput, EnderecoPessoaRelacionadaUncheckedCreateWithoutPessoaRelacionadaInput> | EnderecoPessoaRelacionadaCreateWithoutPessoaRelacionadaInput[] | EnderecoPessoaRelacionadaUncheckedCreateWithoutPessoaRelacionadaInput[]
    connectOrCreate?: EnderecoPessoaRelacionadaCreateOrConnectWithoutPessoaRelacionadaInput | EnderecoPessoaRelacionadaCreateOrConnectWithoutPessoaRelacionadaInput[]
    createMany?: EnderecoPessoaRelacionadaCreateManyPessoaRelacionadaInputEnvelope
    connect?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
  }

  export type ParentescoPacienteUncheckedCreateNestedManyWithoutPessoaRelacionadaInput = {
    create?: XOR<ParentescoPacienteCreateWithoutPessoaRelacionadaInput, ParentescoPacienteUncheckedCreateWithoutPessoaRelacionadaInput> | ParentescoPacienteCreateWithoutPessoaRelacionadaInput[] | ParentescoPacienteUncheckedCreateWithoutPessoaRelacionadaInput[]
    connectOrCreate?: ParentescoPacienteCreateOrConnectWithoutPessoaRelacionadaInput | ParentescoPacienteCreateOrConnectWithoutPessoaRelacionadaInput[]
    createMany?: ParentescoPacienteCreateManyPessoaRelacionadaInputEnvelope
    connect?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
  }

  export type EnderecoPessoaRelacionadaUpdateManyWithoutPessoaRelacionadaNestedInput = {
    create?: XOR<EnderecoPessoaRelacionadaCreateWithoutPessoaRelacionadaInput, EnderecoPessoaRelacionadaUncheckedCreateWithoutPessoaRelacionadaInput> | EnderecoPessoaRelacionadaCreateWithoutPessoaRelacionadaInput[] | EnderecoPessoaRelacionadaUncheckedCreateWithoutPessoaRelacionadaInput[]
    connectOrCreate?: EnderecoPessoaRelacionadaCreateOrConnectWithoutPessoaRelacionadaInput | EnderecoPessoaRelacionadaCreateOrConnectWithoutPessoaRelacionadaInput[]
    upsert?: EnderecoPessoaRelacionadaUpsertWithWhereUniqueWithoutPessoaRelacionadaInput | EnderecoPessoaRelacionadaUpsertWithWhereUniqueWithoutPessoaRelacionadaInput[]
    createMany?: EnderecoPessoaRelacionadaCreateManyPessoaRelacionadaInputEnvelope
    set?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    disconnect?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    delete?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    connect?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    update?: EnderecoPessoaRelacionadaUpdateWithWhereUniqueWithoutPessoaRelacionadaInput | EnderecoPessoaRelacionadaUpdateWithWhereUniqueWithoutPessoaRelacionadaInput[]
    updateMany?: EnderecoPessoaRelacionadaUpdateManyWithWhereWithoutPessoaRelacionadaInput | EnderecoPessoaRelacionadaUpdateManyWithWhereWithoutPessoaRelacionadaInput[]
    deleteMany?: EnderecoPessoaRelacionadaScalarWhereInput | EnderecoPessoaRelacionadaScalarWhereInput[]
  }

  export type ParentescoPacienteUpdateManyWithoutPessoaRelacionadaNestedInput = {
    create?: XOR<ParentescoPacienteCreateWithoutPessoaRelacionadaInput, ParentescoPacienteUncheckedCreateWithoutPessoaRelacionadaInput> | ParentescoPacienteCreateWithoutPessoaRelacionadaInput[] | ParentescoPacienteUncheckedCreateWithoutPessoaRelacionadaInput[]
    connectOrCreate?: ParentescoPacienteCreateOrConnectWithoutPessoaRelacionadaInput | ParentescoPacienteCreateOrConnectWithoutPessoaRelacionadaInput[]
    upsert?: ParentescoPacienteUpsertWithWhereUniqueWithoutPessoaRelacionadaInput | ParentescoPacienteUpsertWithWhereUniqueWithoutPessoaRelacionadaInput[]
    createMany?: ParentescoPacienteCreateManyPessoaRelacionadaInputEnvelope
    set?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    disconnect?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    delete?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    connect?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    update?: ParentescoPacienteUpdateWithWhereUniqueWithoutPessoaRelacionadaInput | ParentescoPacienteUpdateWithWhereUniqueWithoutPessoaRelacionadaInput[]
    updateMany?: ParentescoPacienteUpdateManyWithWhereWithoutPessoaRelacionadaInput | ParentescoPacienteUpdateManyWithWhereWithoutPessoaRelacionadaInput[]
    deleteMany?: ParentescoPacienteScalarWhereInput | ParentescoPacienteScalarWhereInput[]
  }

  export type EnderecoPessoaRelacionadaUncheckedUpdateManyWithoutPessoaRelacionadaNestedInput = {
    create?: XOR<EnderecoPessoaRelacionadaCreateWithoutPessoaRelacionadaInput, EnderecoPessoaRelacionadaUncheckedCreateWithoutPessoaRelacionadaInput> | EnderecoPessoaRelacionadaCreateWithoutPessoaRelacionadaInput[] | EnderecoPessoaRelacionadaUncheckedCreateWithoutPessoaRelacionadaInput[]
    connectOrCreate?: EnderecoPessoaRelacionadaCreateOrConnectWithoutPessoaRelacionadaInput | EnderecoPessoaRelacionadaCreateOrConnectWithoutPessoaRelacionadaInput[]
    upsert?: EnderecoPessoaRelacionadaUpsertWithWhereUniqueWithoutPessoaRelacionadaInput | EnderecoPessoaRelacionadaUpsertWithWhereUniqueWithoutPessoaRelacionadaInput[]
    createMany?: EnderecoPessoaRelacionadaCreateManyPessoaRelacionadaInputEnvelope
    set?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    disconnect?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    delete?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    connect?: EnderecoPessoaRelacionadaWhereUniqueInput | EnderecoPessoaRelacionadaWhereUniqueInput[]
    update?: EnderecoPessoaRelacionadaUpdateWithWhereUniqueWithoutPessoaRelacionadaInput | EnderecoPessoaRelacionadaUpdateWithWhereUniqueWithoutPessoaRelacionadaInput[]
    updateMany?: EnderecoPessoaRelacionadaUpdateManyWithWhereWithoutPessoaRelacionadaInput | EnderecoPessoaRelacionadaUpdateManyWithWhereWithoutPessoaRelacionadaInput[]
    deleteMany?: EnderecoPessoaRelacionadaScalarWhereInput | EnderecoPessoaRelacionadaScalarWhereInput[]
  }

  export type ParentescoPacienteUncheckedUpdateManyWithoutPessoaRelacionadaNestedInput = {
    create?: XOR<ParentescoPacienteCreateWithoutPessoaRelacionadaInput, ParentescoPacienteUncheckedCreateWithoutPessoaRelacionadaInput> | ParentescoPacienteCreateWithoutPessoaRelacionadaInput[] | ParentescoPacienteUncheckedCreateWithoutPessoaRelacionadaInput[]
    connectOrCreate?: ParentescoPacienteCreateOrConnectWithoutPessoaRelacionadaInput | ParentescoPacienteCreateOrConnectWithoutPessoaRelacionadaInput[]
    upsert?: ParentescoPacienteUpsertWithWhereUniqueWithoutPessoaRelacionadaInput | ParentescoPacienteUpsertWithWhereUniqueWithoutPessoaRelacionadaInput[]
    createMany?: ParentescoPacienteCreateManyPessoaRelacionadaInputEnvelope
    set?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    disconnect?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    delete?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    connect?: ParentescoPacienteWhereUniqueInput | ParentescoPacienteWhereUniqueInput[]
    update?: ParentescoPacienteUpdateWithWhereUniqueWithoutPessoaRelacionadaInput | ParentescoPacienteUpdateWithWhereUniqueWithoutPessoaRelacionadaInput[]
    updateMany?: ParentescoPacienteUpdateManyWithWhereWithoutPessoaRelacionadaInput | ParentescoPacienteUpdateManyWithWhereWithoutPessoaRelacionadaInput[]
    deleteMany?: ParentescoPacienteScalarWhereInput | ParentescoPacienteScalarWhereInput[]
  }

  export type PacienteCreateNestedOneWithoutParentescoPacientesInput = {
    create?: XOR<PacienteCreateWithoutParentescoPacientesInput, PacienteUncheckedCreateWithoutParentescoPacientesInput>
    connectOrCreate?: PacienteCreateOrConnectWithoutParentescoPacientesInput
    connect?: PacienteWhereUniqueInput
  }

  export type PessoaRelacionadaCreateNestedOneWithoutParentescosInput = {
    create?: XOR<PessoaRelacionadaCreateWithoutParentescosInput, PessoaRelacionadaUncheckedCreateWithoutParentescosInput>
    connectOrCreate?: PessoaRelacionadaCreateOrConnectWithoutParentescosInput
    connect?: PessoaRelacionadaWhereUniqueInput
  }

  export type EnumTipoParentescoFieldUpdateOperationsInput = {
    set?: $Enums.TipoParentesco
  }

  export type PacienteUpdateOneRequiredWithoutParentescoPacientesNestedInput = {
    create?: XOR<PacienteCreateWithoutParentescoPacientesInput, PacienteUncheckedCreateWithoutParentescoPacientesInput>
    connectOrCreate?: PacienteCreateOrConnectWithoutParentescoPacientesInput
    upsert?: PacienteUpsertWithoutParentescoPacientesInput
    connect?: PacienteWhereUniqueInput
    update?: XOR<XOR<PacienteUpdateToOneWithWhereWithoutParentescoPacientesInput, PacienteUpdateWithoutParentescoPacientesInput>, PacienteUncheckedUpdateWithoutParentescoPacientesInput>
  }

  export type PessoaRelacionadaUpdateOneRequiredWithoutParentescosNestedInput = {
    create?: XOR<PessoaRelacionadaCreateWithoutParentescosInput, PessoaRelacionadaUncheckedCreateWithoutParentescosInput>
    connectOrCreate?: PessoaRelacionadaCreateOrConnectWithoutParentescosInput
    upsert?: PessoaRelacionadaUpsertWithoutParentescosInput
    connect?: PessoaRelacionadaWhereUniqueInput
    update?: XOR<XOR<PessoaRelacionadaUpdateToOneWithWhereWithoutParentescosInput, PessoaRelacionadaUpdateWithoutParentescosInput>, PessoaRelacionadaUncheckedUpdateWithoutParentescosInput>
  }

  export type CidadeCreateNestedManyWithoutPaisInput = {
    create?: XOR<CidadeCreateWithoutPaisInput, CidadeUncheckedCreateWithoutPaisInput> | CidadeCreateWithoutPaisInput[] | CidadeUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: CidadeCreateOrConnectWithoutPaisInput | CidadeCreateOrConnectWithoutPaisInput[]
    createMany?: CidadeCreateManyPaisInputEnvelope
    connect?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
  }

  export type CidadeUncheckedCreateNestedManyWithoutPaisInput = {
    create?: XOR<CidadeCreateWithoutPaisInput, CidadeUncheckedCreateWithoutPaisInput> | CidadeCreateWithoutPaisInput[] | CidadeUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: CidadeCreateOrConnectWithoutPaisInput | CidadeCreateOrConnectWithoutPaisInput[]
    createMany?: CidadeCreateManyPaisInputEnvelope
    connect?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
  }

  export type CidadeUpdateManyWithoutPaisNestedInput = {
    create?: XOR<CidadeCreateWithoutPaisInput, CidadeUncheckedCreateWithoutPaisInput> | CidadeCreateWithoutPaisInput[] | CidadeUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: CidadeCreateOrConnectWithoutPaisInput | CidadeCreateOrConnectWithoutPaisInput[]
    upsert?: CidadeUpsertWithWhereUniqueWithoutPaisInput | CidadeUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: CidadeCreateManyPaisInputEnvelope
    set?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    disconnect?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    delete?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    connect?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    update?: CidadeUpdateWithWhereUniqueWithoutPaisInput | CidadeUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: CidadeUpdateManyWithWhereWithoutPaisInput | CidadeUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: CidadeScalarWhereInput | CidadeScalarWhereInput[]
  }

  export type CidadeUncheckedUpdateManyWithoutPaisNestedInput = {
    create?: XOR<CidadeCreateWithoutPaisInput, CidadeUncheckedCreateWithoutPaisInput> | CidadeCreateWithoutPaisInput[] | CidadeUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: CidadeCreateOrConnectWithoutPaisInput | CidadeCreateOrConnectWithoutPaisInput[]
    upsert?: CidadeUpsertWithWhereUniqueWithoutPaisInput | CidadeUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: CidadeCreateManyPaisInputEnvelope
    set?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    disconnect?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    delete?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    connect?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    update?: CidadeUpdateWithWhereUniqueWithoutPaisInput | CidadeUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: CidadeUpdateManyWithWhereWithoutPaisInput | CidadeUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: CidadeScalarWhereInput | CidadeScalarWhereInput[]
  }

  export type CidadeCreateNestedManyWithoutUfInput = {
    create?: XOR<CidadeCreateWithoutUfInput, CidadeUncheckedCreateWithoutUfInput> | CidadeCreateWithoutUfInput[] | CidadeUncheckedCreateWithoutUfInput[]
    connectOrCreate?: CidadeCreateOrConnectWithoutUfInput | CidadeCreateOrConnectWithoutUfInput[]
    createMany?: CidadeCreateManyUfInputEnvelope
    connect?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
  }

  export type CidadeUncheckedCreateNestedManyWithoutUfInput = {
    create?: XOR<CidadeCreateWithoutUfInput, CidadeUncheckedCreateWithoutUfInput> | CidadeCreateWithoutUfInput[] | CidadeUncheckedCreateWithoutUfInput[]
    connectOrCreate?: CidadeCreateOrConnectWithoutUfInput | CidadeCreateOrConnectWithoutUfInput[]
    createMany?: CidadeCreateManyUfInputEnvelope
    connect?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
  }

  export type CidadeUpdateManyWithoutUfNestedInput = {
    create?: XOR<CidadeCreateWithoutUfInput, CidadeUncheckedCreateWithoutUfInput> | CidadeCreateWithoutUfInput[] | CidadeUncheckedCreateWithoutUfInput[]
    connectOrCreate?: CidadeCreateOrConnectWithoutUfInput | CidadeCreateOrConnectWithoutUfInput[]
    upsert?: CidadeUpsertWithWhereUniqueWithoutUfInput | CidadeUpsertWithWhereUniqueWithoutUfInput[]
    createMany?: CidadeCreateManyUfInputEnvelope
    set?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    disconnect?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    delete?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    connect?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    update?: CidadeUpdateWithWhereUniqueWithoutUfInput | CidadeUpdateWithWhereUniqueWithoutUfInput[]
    updateMany?: CidadeUpdateManyWithWhereWithoutUfInput | CidadeUpdateManyWithWhereWithoutUfInput[]
    deleteMany?: CidadeScalarWhereInput | CidadeScalarWhereInput[]
  }

  export type CidadeUncheckedUpdateManyWithoutUfNestedInput = {
    create?: XOR<CidadeCreateWithoutUfInput, CidadeUncheckedCreateWithoutUfInput> | CidadeCreateWithoutUfInput[] | CidadeUncheckedCreateWithoutUfInput[]
    connectOrCreate?: CidadeCreateOrConnectWithoutUfInput | CidadeCreateOrConnectWithoutUfInput[]
    upsert?: CidadeUpsertWithWhereUniqueWithoutUfInput | CidadeUpsertWithWhereUniqueWithoutUfInput[]
    createMany?: CidadeCreateManyUfInputEnvelope
    set?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    disconnect?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    delete?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    connect?: CidadeWhereUniqueInput | CidadeWhereUniqueInput[]
    update?: CidadeUpdateWithWhereUniqueWithoutUfInput | CidadeUpdateWithWhereUniqueWithoutUfInput[]
    updateMany?: CidadeUpdateManyWithWhereWithoutUfInput | CidadeUpdateManyWithWhereWithoutUfInput[]
    deleteMany?: CidadeScalarWhereInput | CidadeScalarWhereInput[]
  }

  export type BairroCreateNestedManyWithoutCidadeInput = {
    create?: XOR<BairroCreateWithoutCidadeInput, BairroUncheckedCreateWithoutCidadeInput> | BairroCreateWithoutCidadeInput[] | BairroUncheckedCreateWithoutCidadeInput[]
    connectOrCreate?: BairroCreateOrConnectWithoutCidadeInput | BairroCreateOrConnectWithoutCidadeInput[]
    createMany?: BairroCreateManyCidadeInputEnvelope
    connect?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
  }

  export type PaisCreateNestedOneWithoutCidadesInput = {
    create?: XOR<PaisCreateWithoutCidadesInput, PaisUncheckedCreateWithoutCidadesInput>
    connectOrCreate?: PaisCreateOrConnectWithoutCidadesInput
    connect?: PaisWhereUniqueInput
  }

  export type UnidadeFederacaoCreateNestedOneWithoutCidadesInput = {
    create?: XOR<UnidadeFederacaoCreateWithoutCidadesInput, UnidadeFederacaoUncheckedCreateWithoutCidadesInput>
    connectOrCreate?: UnidadeFederacaoCreateOrConnectWithoutCidadesInput
    connect?: UnidadeFederacaoWhereUniqueInput
  }

  export type DistritoCreateNestedManyWithoutCidadeInput = {
    create?: XOR<DistritoCreateWithoutCidadeInput, DistritoUncheckedCreateWithoutCidadeInput> | DistritoCreateWithoutCidadeInput[] | DistritoUncheckedCreateWithoutCidadeInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutCidadeInput | DistritoCreateOrConnectWithoutCidadeInput[]
    createMany?: DistritoCreateManyCidadeInputEnvelope
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
  }

  export type EnderecoCreateNestedManyWithoutCidadeInput = {
    create?: XOR<EnderecoCreateWithoutCidadeInput, EnderecoUncheckedCreateWithoutCidadeInput> | EnderecoCreateWithoutCidadeInput[] | EnderecoUncheckedCreateWithoutCidadeInput[]
    connectOrCreate?: EnderecoCreateOrConnectWithoutCidadeInput | EnderecoCreateOrConnectWithoutCidadeInput[]
    createMany?: EnderecoCreateManyCidadeInputEnvelope
    connect?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
  }

  export type BairroUncheckedCreateNestedManyWithoutCidadeInput = {
    create?: XOR<BairroCreateWithoutCidadeInput, BairroUncheckedCreateWithoutCidadeInput> | BairroCreateWithoutCidadeInput[] | BairroUncheckedCreateWithoutCidadeInput[]
    connectOrCreate?: BairroCreateOrConnectWithoutCidadeInput | BairroCreateOrConnectWithoutCidadeInput[]
    createMany?: BairroCreateManyCidadeInputEnvelope
    connect?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
  }

  export type DistritoUncheckedCreateNestedManyWithoutCidadeInput = {
    create?: XOR<DistritoCreateWithoutCidadeInput, DistritoUncheckedCreateWithoutCidadeInput> | DistritoCreateWithoutCidadeInput[] | DistritoUncheckedCreateWithoutCidadeInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutCidadeInput | DistritoCreateOrConnectWithoutCidadeInput[]
    createMany?: DistritoCreateManyCidadeInputEnvelope
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
  }

  export type EnderecoUncheckedCreateNestedManyWithoutCidadeInput = {
    create?: XOR<EnderecoCreateWithoutCidadeInput, EnderecoUncheckedCreateWithoutCidadeInput> | EnderecoCreateWithoutCidadeInput[] | EnderecoUncheckedCreateWithoutCidadeInput[]
    connectOrCreate?: EnderecoCreateOrConnectWithoutCidadeInput | EnderecoCreateOrConnectWithoutCidadeInput[]
    createMany?: EnderecoCreateManyCidadeInputEnvelope
    connect?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
  }

  export type BairroUpdateManyWithoutCidadeNestedInput = {
    create?: XOR<BairroCreateWithoutCidadeInput, BairroUncheckedCreateWithoutCidadeInput> | BairroCreateWithoutCidadeInput[] | BairroUncheckedCreateWithoutCidadeInput[]
    connectOrCreate?: BairroCreateOrConnectWithoutCidadeInput | BairroCreateOrConnectWithoutCidadeInput[]
    upsert?: BairroUpsertWithWhereUniqueWithoutCidadeInput | BairroUpsertWithWhereUniqueWithoutCidadeInput[]
    createMany?: BairroCreateManyCidadeInputEnvelope
    set?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    disconnect?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    delete?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    connect?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    update?: BairroUpdateWithWhereUniqueWithoutCidadeInput | BairroUpdateWithWhereUniqueWithoutCidadeInput[]
    updateMany?: BairroUpdateManyWithWhereWithoutCidadeInput | BairroUpdateManyWithWhereWithoutCidadeInput[]
    deleteMany?: BairroScalarWhereInput | BairroScalarWhereInput[]
  }

  export type PaisUpdateOneRequiredWithoutCidadesNestedInput = {
    create?: XOR<PaisCreateWithoutCidadesInput, PaisUncheckedCreateWithoutCidadesInput>
    connectOrCreate?: PaisCreateOrConnectWithoutCidadesInput
    upsert?: PaisUpsertWithoutCidadesInput
    connect?: PaisWhereUniqueInput
    update?: XOR<XOR<PaisUpdateToOneWithWhereWithoutCidadesInput, PaisUpdateWithoutCidadesInput>, PaisUncheckedUpdateWithoutCidadesInput>
  }

  export type UnidadeFederacaoUpdateOneRequiredWithoutCidadesNestedInput = {
    create?: XOR<UnidadeFederacaoCreateWithoutCidadesInput, UnidadeFederacaoUncheckedCreateWithoutCidadesInput>
    connectOrCreate?: UnidadeFederacaoCreateOrConnectWithoutCidadesInput
    upsert?: UnidadeFederacaoUpsertWithoutCidadesInput
    connect?: UnidadeFederacaoWhereUniqueInput
    update?: XOR<XOR<UnidadeFederacaoUpdateToOneWithWhereWithoutCidadesInput, UnidadeFederacaoUpdateWithoutCidadesInput>, UnidadeFederacaoUncheckedUpdateWithoutCidadesInput>
  }

  export type DistritoUpdateManyWithoutCidadeNestedInput = {
    create?: XOR<DistritoCreateWithoutCidadeInput, DistritoUncheckedCreateWithoutCidadeInput> | DistritoCreateWithoutCidadeInput[] | DistritoUncheckedCreateWithoutCidadeInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutCidadeInput | DistritoCreateOrConnectWithoutCidadeInput[]
    upsert?: DistritoUpsertWithWhereUniqueWithoutCidadeInput | DistritoUpsertWithWhereUniqueWithoutCidadeInput[]
    createMany?: DistritoCreateManyCidadeInputEnvelope
    set?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    disconnect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    delete?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    update?: DistritoUpdateWithWhereUniqueWithoutCidadeInput | DistritoUpdateWithWhereUniqueWithoutCidadeInput[]
    updateMany?: DistritoUpdateManyWithWhereWithoutCidadeInput | DistritoUpdateManyWithWhereWithoutCidadeInput[]
    deleteMany?: DistritoScalarWhereInput | DistritoScalarWhereInput[]
  }

  export type EnderecoUpdateManyWithoutCidadeNestedInput = {
    create?: XOR<EnderecoCreateWithoutCidadeInput, EnderecoUncheckedCreateWithoutCidadeInput> | EnderecoCreateWithoutCidadeInput[] | EnderecoUncheckedCreateWithoutCidadeInput[]
    connectOrCreate?: EnderecoCreateOrConnectWithoutCidadeInput | EnderecoCreateOrConnectWithoutCidadeInput[]
    upsert?: EnderecoUpsertWithWhereUniqueWithoutCidadeInput | EnderecoUpsertWithWhereUniqueWithoutCidadeInput[]
    createMany?: EnderecoCreateManyCidadeInputEnvelope
    set?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    disconnect?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    delete?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    connect?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    update?: EnderecoUpdateWithWhereUniqueWithoutCidadeInput | EnderecoUpdateWithWhereUniqueWithoutCidadeInput[]
    updateMany?: EnderecoUpdateManyWithWhereWithoutCidadeInput | EnderecoUpdateManyWithWhereWithoutCidadeInput[]
    deleteMany?: EnderecoScalarWhereInput | EnderecoScalarWhereInput[]
  }

  export type BairroUncheckedUpdateManyWithoutCidadeNestedInput = {
    create?: XOR<BairroCreateWithoutCidadeInput, BairroUncheckedCreateWithoutCidadeInput> | BairroCreateWithoutCidadeInput[] | BairroUncheckedCreateWithoutCidadeInput[]
    connectOrCreate?: BairroCreateOrConnectWithoutCidadeInput | BairroCreateOrConnectWithoutCidadeInput[]
    upsert?: BairroUpsertWithWhereUniqueWithoutCidadeInput | BairroUpsertWithWhereUniqueWithoutCidadeInput[]
    createMany?: BairroCreateManyCidadeInputEnvelope
    set?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    disconnect?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    delete?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    connect?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    update?: BairroUpdateWithWhereUniqueWithoutCidadeInput | BairroUpdateWithWhereUniqueWithoutCidadeInput[]
    updateMany?: BairroUpdateManyWithWhereWithoutCidadeInput | BairroUpdateManyWithWhereWithoutCidadeInput[]
    deleteMany?: BairroScalarWhereInput | BairroScalarWhereInput[]
  }

  export type DistritoUncheckedUpdateManyWithoutCidadeNestedInput = {
    create?: XOR<DistritoCreateWithoutCidadeInput, DistritoUncheckedCreateWithoutCidadeInput> | DistritoCreateWithoutCidadeInput[] | DistritoUncheckedCreateWithoutCidadeInput[]
    connectOrCreate?: DistritoCreateOrConnectWithoutCidadeInput | DistritoCreateOrConnectWithoutCidadeInput[]
    upsert?: DistritoUpsertWithWhereUniqueWithoutCidadeInput | DistritoUpsertWithWhereUniqueWithoutCidadeInput[]
    createMany?: DistritoCreateManyCidadeInputEnvelope
    set?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    disconnect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    delete?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    connect?: DistritoWhereUniqueInput | DistritoWhereUniqueInput[]
    update?: DistritoUpdateWithWhereUniqueWithoutCidadeInput | DistritoUpdateWithWhereUniqueWithoutCidadeInput[]
    updateMany?: DistritoUpdateManyWithWhereWithoutCidadeInput | DistritoUpdateManyWithWhereWithoutCidadeInput[]
    deleteMany?: DistritoScalarWhereInput | DistritoScalarWhereInput[]
  }

  export type EnderecoUncheckedUpdateManyWithoutCidadeNestedInput = {
    create?: XOR<EnderecoCreateWithoutCidadeInput, EnderecoUncheckedCreateWithoutCidadeInput> | EnderecoCreateWithoutCidadeInput[] | EnderecoUncheckedCreateWithoutCidadeInput[]
    connectOrCreate?: EnderecoCreateOrConnectWithoutCidadeInput | EnderecoCreateOrConnectWithoutCidadeInput[]
    upsert?: EnderecoUpsertWithWhereUniqueWithoutCidadeInput | EnderecoUpsertWithWhereUniqueWithoutCidadeInput[]
    createMany?: EnderecoCreateManyCidadeInputEnvelope
    set?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    disconnect?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    delete?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    connect?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    update?: EnderecoUpdateWithWhereUniqueWithoutCidadeInput | EnderecoUpdateWithWhereUniqueWithoutCidadeInput[]
    updateMany?: EnderecoUpdateManyWithWhereWithoutCidadeInput | EnderecoUpdateManyWithWhereWithoutCidadeInput[]
    deleteMany?: EnderecoScalarWhereInput | EnderecoScalarWhereInput[]
  }

  export type PacienteCreateNestedManyWithoutEscolaridadeInput = {
    create?: XOR<PacienteCreateWithoutEscolaridadeInput, PacienteUncheckedCreateWithoutEscolaridadeInput> | PacienteCreateWithoutEscolaridadeInput[] | PacienteUncheckedCreateWithoutEscolaridadeInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutEscolaridadeInput | PacienteCreateOrConnectWithoutEscolaridadeInput[]
    createMany?: PacienteCreateManyEscolaridadeInputEnvelope
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
  }

  export type PacienteUncheckedCreateNestedManyWithoutEscolaridadeInput = {
    create?: XOR<PacienteCreateWithoutEscolaridadeInput, PacienteUncheckedCreateWithoutEscolaridadeInput> | PacienteCreateWithoutEscolaridadeInput[] | PacienteUncheckedCreateWithoutEscolaridadeInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutEscolaridadeInput | PacienteCreateOrConnectWithoutEscolaridadeInput[]
    createMany?: PacienteCreateManyEscolaridadeInputEnvelope
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
  }

  export type PacienteUpdateManyWithoutEscolaridadeNestedInput = {
    create?: XOR<PacienteCreateWithoutEscolaridadeInput, PacienteUncheckedCreateWithoutEscolaridadeInput> | PacienteCreateWithoutEscolaridadeInput[] | PacienteUncheckedCreateWithoutEscolaridadeInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutEscolaridadeInput | PacienteCreateOrConnectWithoutEscolaridadeInput[]
    upsert?: PacienteUpsertWithWhereUniqueWithoutEscolaridadeInput | PacienteUpsertWithWhereUniqueWithoutEscolaridadeInput[]
    createMany?: PacienteCreateManyEscolaridadeInputEnvelope
    set?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    disconnect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    delete?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    update?: PacienteUpdateWithWhereUniqueWithoutEscolaridadeInput | PacienteUpdateWithWhereUniqueWithoutEscolaridadeInput[]
    updateMany?: PacienteUpdateManyWithWhereWithoutEscolaridadeInput | PacienteUpdateManyWithWhereWithoutEscolaridadeInput[]
    deleteMany?: PacienteScalarWhereInput | PacienteScalarWhereInput[]
  }

  export type PacienteUncheckedUpdateManyWithoutEscolaridadeNestedInput = {
    create?: XOR<PacienteCreateWithoutEscolaridadeInput, PacienteUncheckedCreateWithoutEscolaridadeInput> | PacienteCreateWithoutEscolaridadeInput[] | PacienteUncheckedCreateWithoutEscolaridadeInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutEscolaridadeInput | PacienteCreateOrConnectWithoutEscolaridadeInput[]
    upsert?: PacienteUpsertWithWhereUniqueWithoutEscolaridadeInput | PacienteUpsertWithWhereUniqueWithoutEscolaridadeInput[]
    createMany?: PacienteCreateManyEscolaridadeInputEnvelope
    set?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    disconnect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    delete?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    update?: PacienteUpdateWithWhereUniqueWithoutEscolaridadeInput | PacienteUpdateWithWhereUniqueWithoutEscolaridadeInput[]
    updateMany?: PacienteUpdateManyWithWhereWithoutEscolaridadeInput | PacienteUpdateManyWithWhereWithoutEscolaridadeInput[]
    deleteMany?: PacienteScalarWhereInput | PacienteScalarWhereInput[]
  }

  export type PacienteCreateNestedManyWithoutOcupacaoInput = {
    create?: XOR<PacienteCreateWithoutOcupacaoInput, PacienteUncheckedCreateWithoutOcupacaoInput> | PacienteCreateWithoutOcupacaoInput[] | PacienteUncheckedCreateWithoutOcupacaoInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutOcupacaoInput | PacienteCreateOrConnectWithoutOcupacaoInput[]
    createMany?: PacienteCreateManyOcupacaoInputEnvelope
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
  }

  export type ProfissionalCreateNestedManyWithoutOcupacaoInput = {
    create?: XOR<ProfissionalCreateWithoutOcupacaoInput, ProfissionalUncheckedCreateWithoutOcupacaoInput> | ProfissionalCreateWithoutOcupacaoInput[] | ProfissionalUncheckedCreateWithoutOcupacaoInput[]
    connectOrCreate?: ProfissionalCreateOrConnectWithoutOcupacaoInput | ProfissionalCreateOrConnectWithoutOcupacaoInput[]
    createMany?: ProfissionalCreateManyOcupacaoInputEnvelope
    connect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
  }

  export type PacienteUncheckedCreateNestedManyWithoutOcupacaoInput = {
    create?: XOR<PacienteCreateWithoutOcupacaoInput, PacienteUncheckedCreateWithoutOcupacaoInput> | PacienteCreateWithoutOcupacaoInput[] | PacienteUncheckedCreateWithoutOcupacaoInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutOcupacaoInput | PacienteCreateOrConnectWithoutOcupacaoInput[]
    createMany?: PacienteCreateManyOcupacaoInputEnvelope
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
  }

  export type ProfissionalUncheckedCreateNestedManyWithoutOcupacaoInput = {
    create?: XOR<ProfissionalCreateWithoutOcupacaoInput, ProfissionalUncheckedCreateWithoutOcupacaoInput> | ProfissionalCreateWithoutOcupacaoInput[] | ProfissionalUncheckedCreateWithoutOcupacaoInput[]
    connectOrCreate?: ProfissionalCreateOrConnectWithoutOcupacaoInput | ProfissionalCreateOrConnectWithoutOcupacaoInput[]
    createMany?: ProfissionalCreateManyOcupacaoInputEnvelope
    connect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
  }

  export type PacienteUpdateManyWithoutOcupacaoNestedInput = {
    create?: XOR<PacienteCreateWithoutOcupacaoInput, PacienteUncheckedCreateWithoutOcupacaoInput> | PacienteCreateWithoutOcupacaoInput[] | PacienteUncheckedCreateWithoutOcupacaoInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutOcupacaoInput | PacienteCreateOrConnectWithoutOcupacaoInput[]
    upsert?: PacienteUpsertWithWhereUniqueWithoutOcupacaoInput | PacienteUpsertWithWhereUniqueWithoutOcupacaoInput[]
    createMany?: PacienteCreateManyOcupacaoInputEnvelope
    set?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    disconnect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    delete?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    update?: PacienteUpdateWithWhereUniqueWithoutOcupacaoInput | PacienteUpdateWithWhereUniqueWithoutOcupacaoInput[]
    updateMany?: PacienteUpdateManyWithWhereWithoutOcupacaoInput | PacienteUpdateManyWithWhereWithoutOcupacaoInput[]
    deleteMany?: PacienteScalarWhereInput | PacienteScalarWhereInput[]
  }

  export type ProfissionalUpdateManyWithoutOcupacaoNestedInput = {
    create?: XOR<ProfissionalCreateWithoutOcupacaoInput, ProfissionalUncheckedCreateWithoutOcupacaoInput> | ProfissionalCreateWithoutOcupacaoInput[] | ProfissionalUncheckedCreateWithoutOcupacaoInput[]
    connectOrCreate?: ProfissionalCreateOrConnectWithoutOcupacaoInput | ProfissionalCreateOrConnectWithoutOcupacaoInput[]
    upsert?: ProfissionalUpsertWithWhereUniqueWithoutOcupacaoInput | ProfissionalUpsertWithWhereUniqueWithoutOcupacaoInput[]
    createMany?: ProfissionalCreateManyOcupacaoInputEnvelope
    set?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    disconnect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    delete?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    connect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    update?: ProfissionalUpdateWithWhereUniqueWithoutOcupacaoInput | ProfissionalUpdateWithWhereUniqueWithoutOcupacaoInput[]
    updateMany?: ProfissionalUpdateManyWithWhereWithoutOcupacaoInput | ProfissionalUpdateManyWithWhereWithoutOcupacaoInput[]
    deleteMany?: ProfissionalScalarWhereInput | ProfissionalScalarWhereInput[]
  }

  export type PacienteUncheckedUpdateManyWithoutOcupacaoNestedInput = {
    create?: XOR<PacienteCreateWithoutOcupacaoInput, PacienteUncheckedCreateWithoutOcupacaoInput> | PacienteCreateWithoutOcupacaoInput[] | PacienteUncheckedCreateWithoutOcupacaoInput[]
    connectOrCreate?: PacienteCreateOrConnectWithoutOcupacaoInput | PacienteCreateOrConnectWithoutOcupacaoInput[]
    upsert?: PacienteUpsertWithWhereUniqueWithoutOcupacaoInput | PacienteUpsertWithWhereUniqueWithoutOcupacaoInput[]
    createMany?: PacienteCreateManyOcupacaoInputEnvelope
    set?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    disconnect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    delete?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    connect?: PacienteWhereUniqueInput | PacienteWhereUniqueInput[]
    update?: PacienteUpdateWithWhereUniqueWithoutOcupacaoInput | PacienteUpdateWithWhereUniqueWithoutOcupacaoInput[]
    updateMany?: PacienteUpdateManyWithWhereWithoutOcupacaoInput | PacienteUpdateManyWithWhereWithoutOcupacaoInput[]
    deleteMany?: PacienteScalarWhereInput | PacienteScalarWhereInput[]
  }

  export type ProfissionalUncheckedUpdateManyWithoutOcupacaoNestedInput = {
    create?: XOR<ProfissionalCreateWithoutOcupacaoInput, ProfissionalUncheckedCreateWithoutOcupacaoInput> | ProfissionalCreateWithoutOcupacaoInput[] | ProfissionalUncheckedCreateWithoutOcupacaoInput[]
    connectOrCreate?: ProfissionalCreateOrConnectWithoutOcupacaoInput | ProfissionalCreateOrConnectWithoutOcupacaoInput[]
    upsert?: ProfissionalUpsertWithWhereUniqueWithoutOcupacaoInput | ProfissionalUpsertWithWhereUniqueWithoutOcupacaoInput[]
    createMany?: ProfissionalCreateManyOcupacaoInputEnvelope
    set?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    disconnect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    delete?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    connect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    update?: ProfissionalUpdateWithWhereUniqueWithoutOcupacaoInput | ProfissionalUpdateWithWhereUniqueWithoutOcupacaoInput[]
    updateMany?: ProfissionalUpdateManyWithWhereWithoutOcupacaoInput | ProfissionalUpdateManyWithWhereWithoutOcupacaoInput[]
    deleteMany?: ProfissionalScalarWhereInput | ProfissionalScalarWhereInput[]
  }

  export type BairroCreateNestedManyWithoutDistritoInput = {
    create?: XOR<BairroCreateWithoutDistritoInput, BairroUncheckedCreateWithoutDistritoInput> | BairroCreateWithoutDistritoInput[] | BairroUncheckedCreateWithoutDistritoInput[]
    connectOrCreate?: BairroCreateOrConnectWithoutDistritoInput | BairroCreateOrConnectWithoutDistritoInput[]
    createMany?: BairroCreateManyDistritoInputEnvelope
    connect?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
  }

  export type CidadeCreateNestedOneWithoutDistritosInput = {
    create?: XOR<CidadeCreateWithoutDistritosInput, CidadeUncheckedCreateWithoutDistritosInput>
    connectOrCreate?: CidadeCreateOrConnectWithoutDistritosInput
    connect?: CidadeWhereUniqueInput
  }

  export type BairroUncheckedCreateNestedManyWithoutDistritoInput = {
    create?: XOR<BairroCreateWithoutDistritoInput, BairroUncheckedCreateWithoutDistritoInput> | BairroCreateWithoutDistritoInput[] | BairroUncheckedCreateWithoutDistritoInput[]
    connectOrCreate?: BairroCreateOrConnectWithoutDistritoInput | BairroCreateOrConnectWithoutDistritoInput[]
    createMany?: BairroCreateManyDistritoInputEnvelope
    connect?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
  }

  export type BairroUpdateManyWithoutDistritoNestedInput = {
    create?: XOR<BairroCreateWithoutDistritoInput, BairroUncheckedCreateWithoutDistritoInput> | BairroCreateWithoutDistritoInput[] | BairroUncheckedCreateWithoutDistritoInput[]
    connectOrCreate?: BairroCreateOrConnectWithoutDistritoInput | BairroCreateOrConnectWithoutDistritoInput[]
    upsert?: BairroUpsertWithWhereUniqueWithoutDistritoInput | BairroUpsertWithWhereUniqueWithoutDistritoInput[]
    createMany?: BairroCreateManyDistritoInputEnvelope
    set?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    disconnect?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    delete?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    connect?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    update?: BairroUpdateWithWhereUniqueWithoutDistritoInput | BairroUpdateWithWhereUniqueWithoutDistritoInput[]
    updateMany?: BairroUpdateManyWithWhereWithoutDistritoInput | BairroUpdateManyWithWhereWithoutDistritoInput[]
    deleteMany?: BairroScalarWhereInput | BairroScalarWhereInput[]
  }

  export type CidadeUpdateOneRequiredWithoutDistritosNestedInput = {
    create?: XOR<CidadeCreateWithoutDistritosInput, CidadeUncheckedCreateWithoutDistritosInput>
    connectOrCreate?: CidadeCreateOrConnectWithoutDistritosInput
    upsert?: CidadeUpsertWithoutDistritosInput
    connect?: CidadeWhereUniqueInput
    update?: XOR<XOR<CidadeUpdateToOneWithWhereWithoutDistritosInput, CidadeUpdateWithoutDistritosInput>, CidadeUncheckedUpdateWithoutDistritosInput>
  }

  export type BairroUncheckedUpdateManyWithoutDistritoNestedInput = {
    create?: XOR<BairroCreateWithoutDistritoInput, BairroUncheckedCreateWithoutDistritoInput> | BairroCreateWithoutDistritoInput[] | BairroUncheckedCreateWithoutDistritoInput[]
    connectOrCreate?: BairroCreateOrConnectWithoutDistritoInput | BairroCreateOrConnectWithoutDistritoInput[]
    upsert?: BairroUpsertWithWhereUniqueWithoutDistritoInput | BairroUpsertWithWhereUniqueWithoutDistritoInput[]
    createMany?: BairroCreateManyDistritoInputEnvelope
    set?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    disconnect?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    delete?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    connect?: BairroWhereUniqueInput | BairroWhereUniqueInput[]
    update?: BairroUpdateWithWhereUniqueWithoutDistritoInput | BairroUpdateWithWhereUniqueWithoutDistritoInput[]
    updateMany?: BairroUpdateManyWithWhereWithoutDistritoInput | BairroUpdateManyWithWhereWithoutDistritoInput[]
    deleteMany?: BairroScalarWhereInput | BairroScalarWhereInput[]
  }

  export type CidadeCreateNestedOneWithoutBairrosInput = {
    create?: XOR<CidadeCreateWithoutBairrosInput, CidadeUncheckedCreateWithoutBairrosInput>
    connectOrCreate?: CidadeCreateOrConnectWithoutBairrosInput
    connect?: CidadeWhereUniqueInput
  }

  export type DistritoCreateNestedOneWithoutBairrosInput = {
    create?: XOR<DistritoCreateWithoutBairrosInput, DistritoUncheckedCreateWithoutBairrosInput>
    connectOrCreate?: DistritoCreateOrConnectWithoutBairrosInput
    connect?: DistritoWhereUniqueInput
  }

  export type EnderecoCreateNestedManyWithoutBairroInput = {
    create?: XOR<EnderecoCreateWithoutBairroInput, EnderecoUncheckedCreateWithoutBairroInput> | EnderecoCreateWithoutBairroInput[] | EnderecoUncheckedCreateWithoutBairroInput[]
    connectOrCreate?: EnderecoCreateOrConnectWithoutBairroInput | EnderecoCreateOrConnectWithoutBairroInput[]
    createMany?: EnderecoCreateManyBairroInputEnvelope
    connect?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
  }

  export type EnderecoUncheckedCreateNestedManyWithoutBairroInput = {
    create?: XOR<EnderecoCreateWithoutBairroInput, EnderecoUncheckedCreateWithoutBairroInput> | EnderecoCreateWithoutBairroInput[] | EnderecoUncheckedCreateWithoutBairroInput[]
    connectOrCreate?: EnderecoCreateOrConnectWithoutBairroInput | EnderecoCreateOrConnectWithoutBairroInput[]
    createMany?: EnderecoCreateManyBairroInputEnvelope
    connect?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
  }

  export type CidadeUpdateOneRequiredWithoutBairrosNestedInput = {
    create?: XOR<CidadeCreateWithoutBairrosInput, CidadeUncheckedCreateWithoutBairrosInput>
    connectOrCreate?: CidadeCreateOrConnectWithoutBairrosInput
    upsert?: CidadeUpsertWithoutBairrosInput
    connect?: CidadeWhereUniqueInput
    update?: XOR<XOR<CidadeUpdateToOneWithWhereWithoutBairrosInput, CidadeUpdateWithoutBairrosInput>, CidadeUncheckedUpdateWithoutBairrosInput>
  }

  export type DistritoUpdateOneWithoutBairrosNestedInput = {
    create?: XOR<DistritoCreateWithoutBairrosInput, DistritoUncheckedCreateWithoutBairrosInput>
    connectOrCreate?: DistritoCreateOrConnectWithoutBairrosInput
    upsert?: DistritoUpsertWithoutBairrosInput
    disconnect?: DistritoWhereInput | boolean
    delete?: DistritoWhereInput | boolean
    connect?: DistritoWhereUniqueInput
    update?: XOR<XOR<DistritoUpdateToOneWithWhereWithoutBairrosInput, DistritoUpdateWithoutBairrosInput>, DistritoUncheckedUpdateWithoutBairrosInput>
  }

  export type EnderecoUpdateManyWithoutBairroNestedInput = {
    create?: XOR<EnderecoCreateWithoutBairroInput, EnderecoUncheckedCreateWithoutBairroInput> | EnderecoCreateWithoutBairroInput[] | EnderecoUncheckedCreateWithoutBairroInput[]
    connectOrCreate?: EnderecoCreateOrConnectWithoutBairroInput | EnderecoCreateOrConnectWithoutBairroInput[]
    upsert?: EnderecoUpsertWithWhereUniqueWithoutBairroInput | EnderecoUpsertWithWhereUniqueWithoutBairroInput[]
    createMany?: EnderecoCreateManyBairroInputEnvelope
    set?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    disconnect?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    delete?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    connect?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    update?: EnderecoUpdateWithWhereUniqueWithoutBairroInput | EnderecoUpdateWithWhereUniqueWithoutBairroInput[]
    updateMany?: EnderecoUpdateManyWithWhereWithoutBairroInput | EnderecoUpdateManyWithWhereWithoutBairroInput[]
    deleteMany?: EnderecoScalarWhereInput | EnderecoScalarWhereInput[]
  }

  export type EnderecoUncheckedUpdateManyWithoutBairroNestedInput = {
    create?: XOR<EnderecoCreateWithoutBairroInput, EnderecoUncheckedCreateWithoutBairroInput> | EnderecoCreateWithoutBairroInput[] | EnderecoUncheckedCreateWithoutBairroInput[]
    connectOrCreate?: EnderecoCreateOrConnectWithoutBairroInput | EnderecoCreateOrConnectWithoutBairroInput[]
    upsert?: EnderecoUpsertWithWhereUniqueWithoutBairroInput | EnderecoUpsertWithWhereUniqueWithoutBairroInput[]
    createMany?: EnderecoCreateManyBairroInputEnvelope
    set?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    disconnect?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    delete?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    connect?: EnderecoWhereUniqueInput | EnderecoWhereUniqueInput[]
    update?: EnderecoUpdateWithWhereUniqueWithoutBairroInput | EnderecoUpdateWithWhereUniqueWithoutBairroInput[]
    updateMany?: EnderecoUpdateManyWithWhereWithoutBairroInput | EnderecoUpdateManyWithWhereWithoutBairroInput[]
    deleteMany?: EnderecoScalarWhereInput | EnderecoScalarWhereInput[]
  }

  export type EnderecoCreateNestedOneWithoutEnderecoPessoaRelacionadasInput = {
    create?: XOR<EnderecoCreateWithoutEnderecoPessoaRelacionadasInput, EnderecoUncheckedCreateWithoutEnderecoPessoaRelacionadasInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutEnderecoPessoaRelacionadasInput
    connect?: EnderecoWhereUniqueInput
  }

  export type PessoaRelacionadaCreateNestedOneWithoutEnderecosInput = {
    create?: XOR<PessoaRelacionadaCreateWithoutEnderecosInput, PessoaRelacionadaUncheckedCreateWithoutEnderecosInput>
    connectOrCreate?: PessoaRelacionadaCreateOrConnectWithoutEnderecosInput
    connect?: PessoaRelacionadaWhereUniqueInput
  }

  export type EnderecoUpdateOneRequiredWithoutEnderecoPessoaRelacionadasNestedInput = {
    create?: XOR<EnderecoCreateWithoutEnderecoPessoaRelacionadasInput, EnderecoUncheckedCreateWithoutEnderecoPessoaRelacionadasInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutEnderecoPessoaRelacionadasInput
    upsert?: EnderecoUpsertWithoutEnderecoPessoaRelacionadasInput
    connect?: EnderecoWhereUniqueInput
    update?: XOR<XOR<EnderecoUpdateToOneWithWhereWithoutEnderecoPessoaRelacionadasInput, EnderecoUpdateWithoutEnderecoPessoaRelacionadasInput>, EnderecoUncheckedUpdateWithoutEnderecoPessoaRelacionadasInput>
  }

  export type PessoaRelacionadaUpdateOneRequiredWithoutEnderecosNestedInput = {
    create?: XOR<PessoaRelacionadaCreateWithoutEnderecosInput, PessoaRelacionadaUncheckedCreateWithoutEnderecosInput>
    connectOrCreate?: PessoaRelacionadaCreateOrConnectWithoutEnderecosInput
    upsert?: PessoaRelacionadaUpsertWithoutEnderecosInput
    connect?: PessoaRelacionadaWhereUniqueInput
    update?: XOR<XOR<PessoaRelacionadaUpdateToOneWithWhereWithoutEnderecosInput, PessoaRelacionadaUpdateWithoutEnderecosInput>, PessoaRelacionadaUncheckedUpdateWithoutEnderecosInput>
  }

  export type EvolucaoCidCreateNestedManyWithoutCidInput = {
    create?: XOR<EvolucaoCidCreateWithoutCidInput, EvolucaoCidUncheckedCreateWithoutCidInput> | EvolucaoCidCreateWithoutCidInput[] | EvolucaoCidUncheckedCreateWithoutCidInput[]
    connectOrCreate?: EvolucaoCidCreateOrConnectWithoutCidInput | EvolucaoCidCreateOrConnectWithoutCidInput[]
    createMany?: EvolucaoCidCreateManyCidInputEnvelope
    connect?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
  }

  export type EvolucaoCidUncheckedCreateNestedManyWithoutCidInput = {
    create?: XOR<EvolucaoCidCreateWithoutCidInput, EvolucaoCidUncheckedCreateWithoutCidInput> | EvolucaoCidCreateWithoutCidInput[] | EvolucaoCidUncheckedCreateWithoutCidInput[]
    connectOrCreate?: EvolucaoCidCreateOrConnectWithoutCidInput | EvolucaoCidCreateOrConnectWithoutCidInput[]
    createMany?: EvolucaoCidCreateManyCidInputEnvelope
    connect?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
  }

  export type EnumVersaoCidFieldUpdateOperationsInput = {
    set?: $Enums.VersaoCid
  }

  export type EvolucaoCidUpdateManyWithoutCidNestedInput = {
    create?: XOR<EvolucaoCidCreateWithoutCidInput, EvolucaoCidUncheckedCreateWithoutCidInput> | EvolucaoCidCreateWithoutCidInput[] | EvolucaoCidUncheckedCreateWithoutCidInput[]
    connectOrCreate?: EvolucaoCidCreateOrConnectWithoutCidInput | EvolucaoCidCreateOrConnectWithoutCidInput[]
    upsert?: EvolucaoCidUpsertWithWhereUniqueWithoutCidInput | EvolucaoCidUpsertWithWhereUniqueWithoutCidInput[]
    createMany?: EvolucaoCidCreateManyCidInputEnvelope
    set?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    disconnect?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    delete?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    connect?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    update?: EvolucaoCidUpdateWithWhereUniqueWithoutCidInput | EvolucaoCidUpdateWithWhereUniqueWithoutCidInput[]
    updateMany?: EvolucaoCidUpdateManyWithWhereWithoutCidInput | EvolucaoCidUpdateManyWithWhereWithoutCidInput[]
    deleteMany?: EvolucaoCidScalarWhereInput | EvolucaoCidScalarWhereInput[]
  }

  export type EvolucaoCidUncheckedUpdateManyWithoutCidNestedInput = {
    create?: XOR<EvolucaoCidCreateWithoutCidInput, EvolucaoCidUncheckedCreateWithoutCidInput> | EvolucaoCidCreateWithoutCidInput[] | EvolucaoCidUncheckedCreateWithoutCidInput[]
    connectOrCreate?: EvolucaoCidCreateOrConnectWithoutCidInput | EvolucaoCidCreateOrConnectWithoutCidInput[]
    upsert?: EvolucaoCidUpsertWithWhereUniqueWithoutCidInput | EvolucaoCidUpsertWithWhereUniqueWithoutCidInput[]
    createMany?: EvolucaoCidCreateManyCidInputEnvelope
    set?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    disconnect?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    delete?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    connect?: EvolucaoCidWhereUniqueInput | EvolucaoCidWhereUniqueInput[]
    update?: EvolucaoCidUpdateWithWhereUniqueWithoutCidInput | EvolucaoCidUpdateWithWhereUniqueWithoutCidInput[]
    updateMany?: EvolucaoCidUpdateManyWithWhereWithoutCidInput | EvolucaoCidUpdateManyWithWhereWithoutCidInput[]
    deleteMany?: EvolucaoCidScalarWhereInput | EvolucaoCidScalarWhereInput[]
  }

  export type EvolucaoDsmCreateNestedManyWithoutDsmInput = {
    create?: XOR<EvolucaoDsmCreateWithoutDsmInput, EvolucaoDsmUncheckedCreateWithoutDsmInput> | EvolucaoDsmCreateWithoutDsmInput[] | EvolucaoDsmUncheckedCreateWithoutDsmInput[]
    connectOrCreate?: EvolucaoDsmCreateOrConnectWithoutDsmInput | EvolucaoDsmCreateOrConnectWithoutDsmInput[]
    createMany?: EvolucaoDsmCreateManyDsmInputEnvelope
    connect?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
  }

  export type EvolucaoDsmUncheckedCreateNestedManyWithoutDsmInput = {
    create?: XOR<EvolucaoDsmCreateWithoutDsmInput, EvolucaoDsmUncheckedCreateWithoutDsmInput> | EvolucaoDsmCreateWithoutDsmInput[] | EvolucaoDsmUncheckedCreateWithoutDsmInput[]
    connectOrCreate?: EvolucaoDsmCreateOrConnectWithoutDsmInput | EvolucaoDsmCreateOrConnectWithoutDsmInput[]
    createMany?: EvolucaoDsmCreateManyDsmInputEnvelope
    connect?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
  }

  export type EnumVersaoDsmFieldUpdateOperationsInput = {
    set?: $Enums.VersaoDsm
  }

  export type EvolucaoDsmUpdateManyWithoutDsmNestedInput = {
    create?: XOR<EvolucaoDsmCreateWithoutDsmInput, EvolucaoDsmUncheckedCreateWithoutDsmInput> | EvolucaoDsmCreateWithoutDsmInput[] | EvolucaoDsmUncheckedCreateWithoutDsmInput[]
    connectOrCreate?: EvolucaoDsmCreateOrConnectWithoutDsmInput | EvolucaoDsmCreateOrConnectWithoutDsmInput[]
    upsert?: EvolucaoDsmUpsertWithWhereUniqueWithoutDsmInput | EvolucaoDsmUpsertWithWhereUniqueWithoutDsmInput[]
    createMany?: EvolucaoDsmCreateManyDsmInputEnvelope
    set?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    disconnect?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    delete?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    connect?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    update?: EvolucaoDsmUpdateWithWhereUniqueWithoutDsmInput | EvolucaoDsmUpdateWithWhereUniqueWithoutDsmInput[]
    updateMany?: EvolucaoDsmUpdateManyWithWhereWithoutDsmInput | EvolucaoDsmUpdateManyWithWhereWithoutDsmInput[]
    deleteMany?: EvolucaoDsmScalarWhereInput | EvolucaoDsmScalarWhereInput[]
  }

  export type EvolucaoDsmUncheckedUpdateManyWithoutDsmNestedInput = {
    create?: XOR<EvolucaoDsmCreateWithoutDsmInput, EvolucaoDsmUncheckedCreateWithoutDsmInput> | EvolucaoDsmCreateWithoutDsmInput[] | EvolucaoDsmUncheckedCreateWithoutDsmInput[]
    connectOrCreate?: EvolucaoDsmCreateOrConnectWithoutDsmInput | EvolucaoDsmCreateOrConnectWithoutDsmInput[]
    upsert?: EvolucaoDsmUpsertWithWhereUniqueWithoutDsmInput | EvolucaoDsmUpsertWithWhereUniqueWithoutDsmInput[]
    createMany?: EvolucaoDsmCreateManyDsmInputEnvelope
    set?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    disconnect?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    delete?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    connect?: EvolucaoDsmWhereUniqueInput | EvolucaoDsmWhereUniqueInput[]
    update?: EvolucaoDsmUpdateWithWhereUniqueWithoutDsmInput | EvolucaoDsmUpdateWithWhereUniqueWithoutDsmInput[]
    updateMany?: EvolucaoDsmUpdateManyWithWhereWithoutDsmInput | EvolucaoDsmUpdateManyWithWhereWithoutDsmInput[]
    deleteMany?: EvolucaoDsmScalarWhereInput | EvolucaoDsmScalarWhereInput[]
  }

  export type EvolucaoCreateNestedManyWithoutTipoEvolucaoClinicaInput = {
    create?: XOR<EvolucaoCreateWithoutTipoEvolucaoClinicaInput, EvolucaoUncheckedCreateWithoutTipoEvolucaoClinicaInput> | EvolucaoCreateWithoutTipoEvolucaoClinicaInput[] | EvolucaoUncheckedCreateWithoutTipoEvolucaoClinicaInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutTipoEvolucaoClinicaInput | EvolucaoCreateOrConnectWithoutTipoEvolucaoClinicaInput[]
    createMany?: EvolucaoCreateManyTipoEvolucaoClinicaInputEnvelope
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
  }

  export type EvolucaoUncheckedCreateNestedManyWithoutTipoEvolucaoClinicaInput = {
    create?: XOR<EvolucaoCreateWithoutTipoEvolucaoClinicaInput, EvolucaoUncheckedCreateWithoutTipoEvolucaoClinicaInput> | EvolucaoCreateWithoutTipoEvolucaoClinicaInput[] | EvolucaoUncheckedCreateWithoutTipoEvolucaoClinicaInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutTipoEvolucaoClinicaInput | EvolucaoCreateOrConnectWithoutTipoEvolucaoClinicaInput[]
    createMany?: EvolucaoCreateManyTipoEvolucaoClinicaInputEnvelope
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
  }

  export type EvolucaoUpdateManyWithoutTipoEvolucaoClinicaNestedInput = {
    create?: XOR<EvolucaoCreateWithoutTipoEvolucaoClinicaInput, EvolucaoUncheckedCreateWithoutTipoEvolucaoClinicaInput> | EvolucaoCreateWithoutTipoEvolucaoClinicaInput[] | EvolucaoUncheckedCreateWithoutTipoEvolucaoClinicaInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutTipoEvolucaoClinicaInput | EvolucaoCreateOrConnectWithoutTipoEvolucaoClinicaInput[]
    upsert?: EvolucaoUpsertWithWhereUniqueWithoutTipoEvolucaoClinicaInput | EvolucaoUpsertWithWhereUniqueWithoutTipoEvolucaoClinicaInput[]
    createMany?: EvolucaoCreateManyTipoEvolucaoClinicaInputEnvelope
    set?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    disconnect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    delete?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    update?: EvolucaoUpdateWithWhereUniqueWithoutTipoEvolucaoClinicaInput | EvolucaoUpdateWithWhereUniqueWithoutTipoEvolucaoClinicaInput[]
    updateMany?: EvolucaoUpdateManyWithWhereWithoutTipoEvolucaoClinicaInput | EvolucaoUpdateManyWithWhereWithoutTipoEvolucaoClinicaInput[]
    deleteMany?: EvolucaoScalarWhereInput | EvolucaoScalarWhereInput[]
  }

  export type EvolucaoUncheckedUpdateManyWithoutTipoEvolucaoClinicaNestedInput = {
    create?: XOR<EvolucaoCreateWithoutTipoEvolucaoClinicaInput, EvolucaoUncheckedCreateWithoutTipoEvolucaoClinicaInput> | EvolucaoCreateWithoutTipoEvolucaoClinicaInput[] | EvolucaoUncheckedCreateWithoutTipoEvolucaoClinicaInput[]
    connectOrCreate?: EvolucaoCreateOrConnectWithoutTipoEvolucaoClinicaInput | EvolucaoCreateOrConnectWithoutTipoEvolucaoClinicaInput[]
    upsert?: EvolucaoUpsertWithWhereUniqueWithoutTipoEvolucaoClinicaInput | EvolucaoUpsertWithWhereUniqueWithoutTipoEvolucaoClinicaInput[]
    createMany?: EvolucaoCreateManyTipoEvolucaoClinicaInputEnvelope
    set?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    disconnect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    delete?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    connect?: EvolucaoWhereUniqueInput | EvolucaoWhereUniqueInput[]
    update?: EvolucaoUpdateWithWhereUniqueWithoutTipoEvolucaoClinicaInput | EvolucaoUpdateWithWhereUniqueWithoutTipoEvolucaoClinicaInput[]
    updateMany?: EvolucaoUpdateManyWithWhereWithoutTipoEvolucaoClinicaInput | EvolucaoUpdateManyWithWhereWithoutTipoEvolucaoClinicaInput[]
    deleteMany?: EvolucaoScalarWhereInput | EvolucaoScalarWhereInput[]
  }

  export type CidCreateNestedOneWithoutEvolucaoCidsInput = {
    create?: XOR<CidCreateWithoutEvolucaoCidsInput, CidUncheckedCreateWithoutEvolucaoCidsInput>
    connectOrCreate?: CidCreateOrConnectWithoutEvolucaoCidsInput
    connect?: CidWhereUniqueInput
  }

  export type EvolucaoCreateNestedOneWithoutCidInput = {
    create?: XOR<EvolucaoCreateWithoutCidInput, EvolucaoUncheckedCreateWithoutCidInput>
    connectOrCreate?: EvolucaoCreateOrConnectWithoutCidInput
    connect?: EvolucaoWhereUniqueInput
  }

  export type CidUpdateOneRequiredWithoutEvolucaoCidsNestedInput = {
    create?: XOR<CidCreateWithoutEvolucaoCidsInput, CidUncheckedCreateWithoutEvolucaoCidsInput>
    connectOrCreate?: CidCreateOrConnectWithoutEvolucaoCidsInput
    upsert?: CidUpsertWithoutEvolucaoCidsInput
    connect?: CidWhereUniqueInput
    update?: XOR<XOR<CidUpdateToOneWithWhereWithoutEvolucaoCidsInput, CidUpdateWithoutEvolucaoCidsInput>, CidUncheckedUpdateWithoutEvolucaoCidsInput>
  }

  export type EvolucaoUpdateOneRequiredWithoutCidNestedInput = {
    create?: XOR<EvolucaoCreateWithoutCidInput, EvolucaoUncheckedCreateWithoutCidInput>
    connectOrCreate?: EvolucaoCreateOrConnectWithoutCidInput
    upsert?: EvolucaoUpsertWithoutCidInput
    connect?: EvolucaoWhereUniqueInput
    update?: XOR<XOR<EvolucaoUpdateToOneWithWhereWithoutCidInput, EvolucaoUpdateWithoutCidInput>, EvolucaoUncheckedUpdateWithoutCidInput>
  }

  export type DsmCreateNestedOneWithoutEvolucaoDsmsInput = {
    create?: XOR<DsmCreateWithoutEvolucaoDsmsInput, DsmUncheckedCreateWithoutEvolucaoDsmsInput>
    connectOrCreate?: DsmCreateOrConnectWithoutEvolucaoDsmsInput
    connect?: DsmWhereUniqueInput
  }

  export type EvolucaoCreateNestedOneWithoutDsmInput = {
    create?: XOR<EvolucaoCreateWithoutDsmInput, EvolucaoUncheckedCreateWithoutDsmInput>
    connectOrCreate?: EvolucaoCreateOrConnectWithoutDsmInput
    connect?: EvolucaoWhereUniqueInput
  }

  export type DsmUpdateOneRequiredWithoutEvolucaoDsmsNestedInput = {
    create?: XOR<DsmCreateWithoutEvolucaoDsmsInput, DsmUncheckedCreateWithoutEvolucaoDsmsInput>
    connectOrCreate?: DsmCreateOrConnectWithoutEvolucaoDsmsInput
    upsert?: DsmUpsertWithoutEvolucaoDsmsInput
    connect?: DsmWhereUniqueInput
    update?: XOR<XOR<DsmUpdateToOneWithWhereWithoutEvolucaoDsmsInput, DsmUpdateWithoutEvolucaoDsmsInput>, DsmUncheckedUpdateWithoutEvolucaoDsmsInput>
  }

  export type EvolucaoUpdateOneRequiredWithoutDsmNestedInput = {
    create?: XOR<EvolucaoCreateWithoutDsmInput, EvolucaoUncheckedCreateWithoutDsmInput>
    connectOrCreate?: EvolucaoCreateOrConnectWithoutDsmInput
    upsert?: EvolucaoUpsertWithoutDsmInput
    connect?: EvolucaoWhereUniqueInput
    update?: XOR<XOR<EvolucaoUpdateToOneWithWhereWithoutDsmInput, EvolucaoUpdateWithoutDsmInput>, EvolucaoUncheckedUpdateWithoutDsmInput>
  }

  export type AtendimentoCreateNestedOneWithoutSinaisVitaisInput = {
    create?: XOR<AtendimentoCreateWithoutSinaisVitaisInput, AtendimentoUncheckedCreateWithoutSinaisVitaisInput>
    connectOrCreate?: AtendimentoCreateOrConnectWithoutSinaisVitaisInput
    connect?: AtendimentoWhereUniqueInput
  }

  export type EscalaDorCreateNestedOneWithoutSinaisVitaisInput = {
    create?: XOR<EscalaDorCreateWithoutSinaisVitaisInput, EscalaDorUncheckedCreateWithoutSinaisVitaisInput>
    connectOrCreate?: EscalaDorCreateOrConnectWithoutSinaisVitaisInput
    connect?: EscalaDorWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableEnumPosicaoPacienteFieldUpdateOperationsInput = {
    set?: $Enums.PosicaoPaciente | null
  }

  export type NullableEnumOrigemAfericaoFieldUpdateOperationsInput = {
    set?: $Enums.OrigemAfericao | null
  }

  export type AtendimentoUpdateOneRequiredWithoutSinaisVitaisNestedInput = {
    create?: XOR<AtendimentoCreateWithoutSinaisVitaisInput, AtendimentoUncheckedCreateWithoutSinaisVitaisInput>
    connectOrCreate?: AtendimentoCreateOrConnectWithoutSinaisVitaisInput
    upsert?: AtendimentoUpsertWithoutSinaisVitaisInput
    connect?: AtendimentoWhereUniqueInput
    update?: XOR<XOR<AtendimentoUpdateToOneWithWhereWithoutSinaisVitaisInput, AtendimentoUpdateWithoutSinaisVitaisInput>, AtendimentoUncheckedUpdateWithoutSinaisVitaisInput>
  }

  export type EscalaDorUpdateOneWithoutSinaisVitaisNestedInput = {
    create?: XOR<EscalaDorCreateWithoutSinaisVitaisInput, EscalaDorUncheckedCreateWithoutSinaisVitaisInput>
    connectOrCreate?: EscalaDorCreateOrConnectWithoutSinaisVitaisInput
    upsert?: EscalaDorUpsertWithoutSinaisVitaisInput
    disconnect?: EscalaDorWhereInput | boolean
    delete?: EscalaDorWhereInput | boolean
    connect?: EscalaDorWhereUniqueInput
    update?: XOR<XOR<EscalaDorUpdateToOneWithWhereWithoutSinaisVitaisInput, EscalaDorUpdateWithoutSinaisVitaisInput>, EscalaDorUncheckedUpdateWithoutSinaisVitaisInput>
  }

  export type SinaisVitaisCreateNestedManyWithoutEscalaDorInput = {
    create?: XOR<SinaisVitaisCreateWithoutEscalaDorInput, SinaisVitaisUncheckedCreateWithoutEscalaDorInput> | SinaisVitaisCreateWithoutEscalaDorInput[] | SinaisVitaisUncheckedCreateWithoutEscalaDorInput[]
    connectOrCreate?: SinaisVitaisCreateOrConnectWithoutEscalaDorInput | SinaisVitaisCreateOrConnectWithoutEscalaDorInput[]
    createMany?: SinaisVitaisCreateManyEscalaDorInputEnvelope
    connect?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
  }

  export type SinaisVitaisUncheckedCreateNestedManyWithoutEscalaDorInput = {
    create?: XOR<SinaisVitaisCreateWithoutEscalaDorInput, SinaisVitaisUncheckedCreateWithoutEscalaDorInput> | SinaisVitaisCreateWithoutEscalaDorInput[] | SinaisVitaisUncheckedCreateWithoutEscalaDorInput[]
    connectOrCreate?: SinaisVitaisCreateOrConnectWithoutEscalaDorInput | SinaisVitaisCreateOrConnectWithoutEscalaDorInput[]
    createMany?: SinaisVitaisCreateManyEscalaDorInputEnvelope
    connect?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
  }

  export type SinaisVitaisUpdateManyWithoutEscalaDorNestedInput = {
    create?: XOR<SinaisVitaisCreateWithoutEscalaDorInput, SinaisVitaisUncheckedCreateWithoutEscalaDorInput> | SinaisVitaisCreateWithoutEscalaDorInput[] | SinaisVitaisUncheckedCreateWithoutEscalaDorInput[]
    connectOrCreate?: SinaisVitaisCreateOrConnectWithoutEscalaDorInput | SinaisVitaisCreateOrConnectWithoutEscalaDorInput[]
    upsert?: SinaisVitaisUpsertWithWhereUniqueWithoutEscalaDorInput | SinaisVitaisUpsertWithWhereUniqueWithoutEscalaDorInput[]
    createMany?: SinaisVitaisCreateManyEscalaDorInputEnvelope
    set?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    disconnect?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    delete?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    connect?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    update?: SinaisVitaisUpdateWithWhereUniqueWithoutEscalaDorInput | SinaisVitaisUpdateWithWhereUniqueWithoutEscalaDorInput[]
    updateMany?: SinaisVitaisUpdateManyWithWhereWithoutEscalaDorInput | SinaisVitaisUpdateManyWithWhereWithoutEscalaDorInput[]
    deleteMany?: SinaisVitaisScalarWhereInput | SinaisVitaisScalarWhereInput[]
  }

  export type SinaisVitaisUncheckedUpdateManyWithoutEscalaDorNestedInput = {
    create?: XOR<SinaisVitaisCreateWithoutEscalaDorInput, SinaisVitaisUncheckedCreateWithoutEscalaDorInput> | SinaisVitaisCreateWithoutEscalaDorInput[] | SinaisVitaisUncheckedCreateWithoutEscalaDorInput[]
    connectOrCreate?: SinaisVitaisCreateOrConnectWithoutEscalaDorInput | SinaisVitaisCreateOrConnectWithoutEscalaDorInput[]
    upsert?: SinaisVitaisUpsertWithWhereUniqueWithoutEscalaDorInput | SinaisVitaisUpsertWithWhereUniqueWithoutEscalaDorInput[]
    createMany?: SinaisVitaisCreateManyEscalaDorInputEnvelope
    set?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    disconnect?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    delete?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    connect?: SinaisVitaisWhereUniqueInput | SinaisVitaisWhereUniqueInput[]
    update?: SinaisVitaisUpdateWithWhereUniqueWithoutEscalaDorInput | SinaisVitaisUpdateWithWhereUniqueWithoutEscalaDorInput[]
    updateMany?: SinaisVitaisUpdateManyWithWhereWithoutEscalaDorInput | SinaisVitaisUpdateManyWithWhereWithoutEscalaDorInput[]
    deleteMany?: SinaisVitaisScalarWhereInput | SinaisVitaisScalarWhereInput[]
  }

  export type AtendimentoCreateNestedOneWithoutGlasgowsInput = {
    create?: XOR<AtendimentoCreateWithoutGlasgowsInput, AtendimentoUncheckedCreateWithoutGlasgowsInput>
    connectOrCreate?: AtendimentoCreateOrConnectWithoutGlasgowsInput
    connect?: AtendimentoWhereUniqueInput
  }

  export type ProfissionalCreateNestedOneWithoutGlasgowsInput = {
    create?: XOR<ProfissionalCreateWithoutGlasgowsInput, ProfissionalUncheckedCreateWithoutGlasgowsInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutGlasgowsInput
    connect?: ProfissionalWhereUniqueInput
  }

  export type AtendimentoUpdateOneRequiredWithoutGlasgowsNestedInput = {
    create?: XOR<AtendimentoCreateWithoutGlasgowsInput, AtendimentoUncheckedCreateWithoutGlasgowsInput>
    connectOrCreate?: AtendimentoCreateOrConnectWithoutGlasgowsInput
    upsert?: AtendimentoUpsertWithoutGlasgowsInput
    connect?: AtendimentoWhereUniqueInput
    update?: XOR<XOR<AtendimentoUpdateToOneWithWhereWithoutGlasgowsInput, AtendimentoUpdateWithoutGlasgowsInput>, AtendimentoUncheckedUpdateWithoutGlasgowsInput>
  }

  export type ProfissionalUpdateOneWithoutGlasgowsNestedInput = {
    create?: XOR<ProfissionalCreateWithoutGlasgowsInput, ProfissionalUncheckedCreateWithoutGlasgowsInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutGlasgowsInput
    upsert?: ProfissionalUpsertWithoutGlasgowsInput
    disconnect?: ProfissionalWhereInput | boolean
    delete?: ProfissionalWhereInput | boolean
    connect?: ProfissionalWhereUniqueInput
    update?: XOR<XOR<ProfissionalUpdateToOneWithWhereWithoutGlasgowsInput, ProfissionalUpdateWithoutGlasgowsInput>, ProfissionalUncheckedUpdateWithoutGlasgowsInput>
  }

  export type AtendimentoCreateNestedOneWithoutAfericoesClinicasInput = {
    create?: XOR<AtendimentoCreateWithoutAfericoesClinicasInput, AtendimentoUncheckedCreateWithoutAfericoesClinicasInput>
    connectOrCreate?: AtendimentoCreateOrConnectWithoutAfericoesClinicasInput
    connect?: AtendimentoWhereUniqueInput
  }

  export type ProfissionalCreateNestedOneWithoutAfericoesClinicasInput = {
    create?: XOR<ProfissionalCreateWithoutAfericoesClinicasInput, ProfissionalUncheckedCreateWithoutAfericoesClinicasInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutAfericoesClinicasInput
    connect?: ProfissionalWhereUniqueInput
  }

  export type AtendimentoUpdateOneRequiredWithoutAfericoesClinicasNestedInput = {
    create?: XOR<AtendimentoCreateWithoutAfericoesClinicasInput, AtendimentoUncheckedCreateWithoutAfericoesClinicasInput>
    connectOrCreate?: AtendimentoCreateOrConnectWithoutAfericoesClinicasInput
    upsert?: AtendimentoUpsertWithoutAfericoesClinicasInput
    connect?: AtendimentoWhereUniqueInput
    update?: XOR<XOR<AtendimentoUpdateToOneWithWhereWithoutAfericoesClinicasInput, AtendimentoUpdateWithoutAfericoesClinicasInput>, AtendimentoUncheckedUpdateWithoutAfericoesClinicasInput>
  }

  export type ProfissionalUpdateOneWithoutAfericoesClinicasNestedInput = {
    create?: XOR<ProfissionalCreateWithoutAfericoesClinicasInput, ProfissionalUncheckedCreateWithoutAfericoesClinicasInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutAfericoesClinicasInput
    upsert?: ProfissionalUpsertWithoutAfericoesClinicasInput
    disconnect?: ProfissionalWhereInput | boolean
    delete?: ProfissionalWhereInput | boolean
    connect?: ProfissionalWhereUniqueInput
    update?: XOR<XOR<ProfissionalUpdateToOneWithWhereWithoutAfericoesClinicasInput, ProfissionalUpdateWithoutAfericoesClinicasInput>, ProfissionalUncheckedUpdateWithoutAfericoesClinicasInput>
  }

  export type AtendimentoCreateNestedOneWithoutEvaDoresInput = {
    create?: XOR<AtendimentoCreateWithoutEvaDoresInput, AtendimentoUncheckedCreateWithoutEvaDoresInput>
    connectOrCreate?: AtendimentoCreateOrConnectWithoutEvaDoresInput
    connect?: AtendimentoWhereUniqueInput
  }

  export type ProfissionalCreateNestedOneWithoutEvaDoresInput = {
    create?: XOR<ProfissionalCreateWithoutEvaDoresInput, ProfissionalUncheckedCreateWithoutEvaDoresInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutEvaDoresInput
    connect?: ProfissionalWhereUniqueInput
  }

  export type AtendimentoUpdateOneRequiredWithoutEvaDoresNestedInput = {
    create?: XOR<AtendimentoCreateWithoutEvaDoresInput, AtendimentoUncheckedCreateWithoutEvaDoresInput>
    connectOrCreate?: AtendimentoCreateOrConnectWithoutEvaDoresInput
    upsert?: AtendimentoUpsertWithoutEvaDoresInput
    connect?: AtendimentoWhereUniqueInput
    update?: XOR<XOR<AtendimentoUpdateToOneWithWhereWithoutEvaDoresInput, AtendimentoUpdateWithoutEvaDoresInput>, AtendimentoUncheckedUpdateWithoutEvaDoresInput>
  }

  export type ProfissionalUpdateOneWithoutEvaDoresNestedInput = {
    create?: XOR<ProfissionalCreateWithoutEvaDoresInput, ProfissionalUncheckedCreateWithoutEvaDoresInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutEvaDoresInput
    upsert?: ProfissionalUpsertWithoutEvaDoresInput
    disconnect?: ProfissionalWhereInput | boolean
    delete?: ProfissionalWhereInput | boolean
    connect?: ProfissionalWhereUniqueInput
    update?: XOR<XOR<ProfissionalUpdateToOneWithWhereWithoutEvaDoresInput, ProfissionalUpdateWithoutEvaDoresInput>, ProfissionalUncheckedUpdateWithoutEvaDoresInput>
  }

  export type PacienteCreateNestedOneWithoutUsuarioAuthsInput = {
    create?: XOR<PacienteCreateWithoutUsuarioAuthsInput, PacienteUncheckedCreateWithoutUsuarioAuthsInput>
    connectOrCreate?: PacienteCreateOrConnectWithoutUsuarioAuthsInput
    connect?: PacienteWhereUniqueInput
  }

  export type MasterCreateNestedOneWithoutUsuarioAuthsInput = {
    create?: XOR<MasterCreateWithoutUsuarioAuthsInput, MasterUncheckedCreateWithoutUsuarioAuthsInput>
    connectOrCreate?: MasterCreateOrConnectWithoutUsuarioAuthsInput
    connect?: MasterWhereUniqueInput
  }

  export type ProfissionalCreateNestedOneWithoutUsuarioAuthsInput = {
    create?: XOR<ProfissionalCreateWithoutUsuarioAuthsInput, ProfissionalUncheckedCreateWithoutUsuarioAuthsInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutUsuarioAuthsInput
    connect?: ProfissionalWhereUniqueInput
  }

  export type EnumRoleAuthFieldUpdateOperationsInput = {
    set?: $Enums.RoleAuth
  }

  export type PacienteUpdateOneWithoutUsuarioAuthsNestedInput = {
    create?: XOR<PacienteCreateWithoutUsuarioAuthsInput, PacienteUncheckedCreateWithoutUsuarioAuthsInput>
    connectOrCreate?: PacienteCreateOrConnectWithoutUsuarioAuthsInput
    upsert?: PacienteUpsertWithoutUsuarioAuthsInput
    disconnect?: PacienteWhereInput | boolean
    delete?: PacienteWhereInput | boolean
    connect?: PacienteWhereUniqueInput
    update?: XOR<XOR<PacienteUpdateToOneWithWhereWithoutUsuarioAuthsInput, PacienteUpdateWithoutUsuarioAuthsInput>, PacienteUncheckedUpdateWithoutUsuarioAuthsInput>
  }

  export type MasterUpdateOneRequiredWithoutUsuarioAuthsNestedInput = {
    create?: XOR<MasterCreateWithoutUsuarioAuthsInput, MasterUncheckedCreateWithoutUsuarioAuthsInput>
    connectOrCreate?: MasterCreateOrConnectWithoutUsuarioAuthsInput
    upsert?: MasterUpsertWithoutUsuarioAuthsInput
    connect?: MasterWhereUniqueInput
    update?: XOR<XOR<MasterUpdateToOneWithWhereWithoutUsuarioAuthsInput, MasterUpdateWithoutUsuarioAuthsInput>, MasterUncheckedUpdateWithoutUsuarioAuthsInput>
  }

  export type ProfissionalUpdateOneWithoutUsuarioAuthsNestedInput = {
    create?: XOR<ProfissionalCreateWithoutUsuarioAuthsInput, ProfissionalUncheckedCreateWithoutUsuarioAuthsInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutUsuarioAuthsInput
    upsert?: ProfissionalUpsertWithoutUsuarioAuthsInput
    disconnect?: ProfissionalWhereInput | boolean
    delete?: ProfissionalWhereInput | boolean
    connect?: ProfissionalWhereUniqueInput
    update?: XOR<XOR<ProfissionalUpdateToOneWithWhereWithoutUsuarioAuthsInput, ProfissionalUpdateWithoutUsuarioAuthsInput>, ProfissionalUncheckedUpdateWithoutUsuarioAuthsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumSimNaoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SimNao | EnumSimNaoFieldRefInput<$PrismaModel> | null
    in?: $Enums.SimNao[] | ListEnumSimNaoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SimNao[] | ListEnumSimNaoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSimNaoNullableFilter<$PrismaModel> | $Enums.SimNao | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumSimNaoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimNao | EnumSimNaoFieldRefInput<$PrismaModel> | null
    in?: $Enums.SimNao[] | ListEnumSimNaoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SimNao[] | ListEnumSimNaoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSimNaoNullableWithAggregatesFilter<$PrismaModel> | $Enums.SimNao | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSimNaoNullableFilter<$PrismaModel>
    _max?: NestedEnumSimNaoNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSexoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexoNullableFilter<$PrismaModel> | $Enums.Sexo | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSexoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexoNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sexo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSexoNullableFilter<$PrismaModel>
    _max?: NestedEnumSexoNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumTipoFoneFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoFone | EnumTipoFoneFieldRefInput<$PrismaModel>
    in?: $Enums.TipoFone[] | ListEnumTipoFoneFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoFone[] | ListEnumTipoFoneFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoFoneFilter<$PrismaModel> | $Enums.TipoFone
  }

  export type NestedEnumTipoFoneWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoFone | EnumTipoFoneFieldRefInput<$PrismaModel>
    in?: $Enums.TipoFone[] | ListEnumTipoFoneFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoFone[] | ListEnumTipoFoneFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoFoneWithAggregatesFilter<$PrismaModel> | $Enums.TipoFone
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoFoneFilter<$PrismaModel>
    _max?: NestedEnumTipoFoneFilter<$PrismaModel>
  }

  export type NestedEnumTipoParentescoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoParentesco | EnumTipoParentescoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoParentesco[] | ListEnumTipoParentescoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoParentesco[] | ListEnumTipoParentescoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoParentescoFilter<$PrismaModel> | $Enums.TipoParentesco
  }

  export type NestedEnumTipoParentescoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoParentesco | EnumTipoParentescoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoParentesco[] | ListEnumTipoParentescoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoParentesco[] | ListEnumTipoParentescoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoParentescoWithAggregatesFilter<$PrismaModel> | $Enums.TipoParentesco
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoParentescoFilter<$PrismaModel>
    _max?: NestedEnumTipoParentescoFilter<$PrismaModel>
  }

  export type NestedEnumVersaoCidFilter<$PrismaModel = never> = {
    equals?: $Enums.VersaoCid | EnumVersaoCidFieldRefInput<$PrismaModel>
    in?: $Enums.VersaoCid[] | ListEnumVersaoCidFieldRefInput<$PrismaModel>
    notIn?: $Enums.VersaoCid[] | ListEnumVersaoCidFieldRefInput<$PrismaModel>
    not?: NestedEnumVersaoCidFilter<$PrismaModel> | $Enums.VersaoCid
  }

  export type NestedEnumVersaoCidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VersaoCid | EnumVersaoCidFieldRefInput<$PrismaModel>
    in?: $Enums.VersaoCid[] | ListEnumVersaoCidFieldRefInput<$PrismaModel>
    notIn?: $Enums.VersaoCid[] | ListEnumVersaoCidFieldRefInput<$PrismaModel>
    not?: NestedEnumVersaoCidWithAggregatesFilter<$PrismaModel> | $Enums.VersaoCid
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVersaoCidFilter<$PrismaModel>
    _max?: NestedEnumVersaoCidFilter<$PrismaModel>
  }

  export type NestedEnumVersaoDsmFilter<$PrismaModel = never> = {
    equals?: $Enums.VersaoDsm | EnumVersaoDsmFieldRefInput<$PrismaModel>
    in?: $Enums.VersaoDsm[] | ListEnumVersaoDsmFieldRefInput<$PrismaModel>
    notIn?: $Enums.VersaoDsm[] | ListEnumVersaoDsmFieldRefInput<$PrismaModel>
    not?: NestedEnumVersaoDsmFilter<$PrismaModel> | $Enums.VersaoDsm
  }

  export type NestedEnumVersaoDsmWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VersaoDsm | EnumVersaoDsmFieldRefInput<$PrismaModel>
    in?: $Enums.VersaoDsm[] | ListEnumVersaoDsmFieldRefInput<$PrismaModel>
    notIn?: $Enums.VersaoDsm[] | ListEnumVersaoDsmFieldRefInput<$PrismaModel>
    not?: NestedEnumVersaoDsmWithAggregatesFilter<$PrismaModel> | $Enums.VersaoDsm
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVersaoDsmFilter<$PrismaModel>
    _max?: NestedEnumVersaoDsmFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumPosicaoPacienteNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PosicaoPaciente | EnumPosicaoPacienteFieldRefInput<$PrismaModel> | null
    in?: $Enums.PosicaoPaciente[] | ListEnumPosicaoPacienteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PosicaoPaciente[] | ListEnumPosicaoPacienteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPosicaoPacienteNullableFilter<$PrismaModel> | $Enums.PosicaoPaciente | null
  }

  export type NestedEnumOrigemAfericaoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrigemAfericao | EnumOrigemAfericaoFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrigemAfericao[] | ListEnumOrigemAfericaoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrigemAfericao[] | ListEnumOrigemAfericaoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrigemAfericaoNullableFilter<$PrismaModel> | $Enums.OrigemAfericao | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumPosicaoPacienteNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PosicaoPaciente | EnumPosicaoPacienteFieldRefInput<$PrismaModel> | null
    in?: $Enums.PosicaoPaciente[] | ListEnumPosicaoPacienteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PosicaoPaciente[] | ListEnumPosicaoPacienteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPosicaoPacienteNullableWithAggregatesFilter<$PrismaModel> | $Enums.PosicaoPaciente | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPosicaoPacienteNullableFilter<$PrismaModel>
    _max?: NestedEnumPosicaoPacienteNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrigemAfericaoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrigemAfericao | EnumOrigemAfericaoFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrigemAfericao[] | ListEnumOrigemAfericaoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrigemAfericao[] | ListEnumOrigemAfericaoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrigemAfericaoNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrigemAfericao | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrigemAfericaoNullableFilter<$PrismaModel>
    _max?: NestedEnumOrigemAfericaoNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRoleAuthFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleAuth | EnumRoleAuthFieldRefInput<$PrismaModel>
    in?: $Enums.RoleAuth[] | ListEnumRoleAuthFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleAuth[] | ListEnumRoleAuthFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleAuthFilter<$PrismaModel> | $Enums.RoleAuth
  }

  export type NestedEnumRoleAuthWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleAuth | EnumRoleAuthFieldRefInput<$PrismaModel>
    in?: $Enums.RoleAuth[] | ListEnumRoleAuthFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleAuth[] | ListEnumRoleAuthFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleAuthWithAggregatesFilter<$PrismaModel> | $Enums.RoleAuth
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleAuthFilter<$PrismaModel>
    _max?: NestedEnumRoleAuthFilter<$PrismaModel>
  }

  export type PacienteCreateWithoutMasterInput = {
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    atendimentos?: AtendimentoCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoCreateNestedManyWithoutPacienteInput
    escolaridade?: EscolaridadeCreateNestedOneWithoutPacientesInput
    ocupacao?: OcupacaoCreateNestedOneWithoutPacientesInput
    parentescoPacientes?: ParentescoPacienteCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutPacienteInput
  }

  export type PacienteUncheckedCreateWithoutMasterInput = {
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    cdEscolaridade?: number | null
    cdOcupacao?: number | null
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutPacienteInput
    parentescoPacientes?: ParentescoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type PacienteCreateOrConnectWithoutMasterInput = {
    where: PacienteWhereUniqueInput
    create: XOR<PacienteCreateWithoutMasterInput, PacienteUncheckedCreateWithoutMasterInput>
  }

  export type PacienteCreateManyMasterInputEnvelope = {
    data: PacienteCreateManyMasterInput | PacienteCreateManyMasterInput[]
    skipDuplicates?: boolean
  }

  export type ProfissionalCreateWithoutMasterInput = {
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowCreateNestedManyWithoutProfissionalInput
    ocupacao?: OcupacaoCreateNestedOneWithoutProfissionalsInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalUncheckedCreateWithoutMasterInput = {
    id?: number
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    cdOcupacao?: number | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutProfissionalInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalCreateOrConnectWithoutMasterInput = {
    where: ProfissionalWhereUniqueInput
    create: XOR<ProfissionalCreateWithoutMasterInput, ProfissionalUncheckedCreateWithoutMasterInput>
  }

  export type ProfissionalCreateManyMasterInputEnvelope = {
    data: ProfissionalCreateManyMasterInput | ProfissionalCreateManyMasterInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioAuthCreateWithoutMasterInput = {
    email: string
    senhaHash: string
    role?: $Enums.RoleAuth
    paciente?: PacienteCreateNestedOneWithoutUsuarioAuthsInput
    profissional?: ProfissionalCreateNestedOneWithoutUsuarioAuthsInput
  }

  export type UsuarioAuthUncheckedCreateWithoutMasterInput = {
    id?: number
    email: string
    senhaHash: string
    role?: $Enums.RoleAuth
    cdProfissional?: number | null
    cdPaciente?: number | null
  }

  export type UsuarioAuthCreateOrConnectWithoutMasterInput = {
    where: UsuarioAuthWhereUniqueInput
    create: XOR<UsuarioAuthCreateWithoutMasterInput, UsuarioAuthUncheckedCreateWithoutMasterInput>
  }

  export type UsuarioAuthCreateManyMasterInputEnvelope = {
    data: UsuarioAuthCreateManyMasterInput | UsuarioAuthCreateManyMasterInput[]
    skipDuplicates?: boolean
  }

  export type PacienteUpsertWithWhereUniqueWithoutMasterInput = {
    where: PacienteWhereUniqueInput
    update: XOR<PacienteUpdateWithoutMasterInput, PacienteUncheckedUpdateWithoutMasterInput>
    create: XOR<PacienteCreateWithoutMasterInput, PacienteUncheckedCreateWithoutMasterInput>
  }

  export type PacienteUpdateWithWhereUniqueWithoutMasterInput = {
    where: PacienteWhereUniqueInput
    data: XOR<PacienteUpdateWithoutMasterInput, PacienteUncheckedUpdateWithoutMasterInput>
  }

  export type PacienteUpdateManyWithWhereWithoutMasterInput = {
    where: PacienteScalarWhereInput
    data: XOR<PacienteUpdateManyMutationInput, PacienteUncheckedUpdateManyWithoutMasterInput>
  }

  export type PacienteScalarWhereInput = {
    AND?: PacienteScalarWhereInput | PacienteScalarWhereInput[]
    OR?: PacienteScalarWhereInput[]
    NOT?: PacienteScalarWhereInput | PacienteScalarWhereInput[]
    cdMaster?: IntFilter<"Paciente"> | number
    cdPaciente?: IntFilter<"Paciente"> | number
    nome?: StringFilter<"Paciente"> | string
    sexo?: EnumSexoNullableFilter<"Paciente"> | $Enums.Sexo | null
    dtNascimento?: DateTimeNullableFilter<"Paciente"> | Date | string | null
    stInativo?: EnumSimNaoNullableFilter<"Paciente"> | $Enums.SimNao | null
    cdEscolaridade?: IntNullableFilter<"Paciente"> | number | null
    cdOcupacao?: IntNullableFilter<"Paciente"> | number | null
  }

  export type ProfissionalUpsertWithWhereUniqueWithoutMasterInput = {
    where: ProfissionalWhereUniqueInput
    update: XOR<ProfissionalUpdateWithoutMasterInput, ProfissionalUncheckedUpdateWithoutMasterInput>
    create: XOR<ProfissionalCreateWithoutMasterInput, ProfissionalUncheckedCreateWithoutMasterInput>
  }

  export type ProfissionalUpdateWithWhereUniqueWithoutMasterInput = {
    where: ProfissionalWhereUniqueInput
    data: XOR<ProfissionalUpdateWithoutMasterInput, ProfissionalUncheckedUpdateWithoutMasterInput>
  }

  export type ProfissionalUpdateManyWithWhereWithoutMasterInput = {
    where: ProfissionalScalarWhereInput
    data: XOR<ProfissionalUpdateManyMutationInput, ProfissionalUncheckedUpdateManyWithoutMasterInput>
  }

  export type ProfissionalScalarWhereInput = {
    AND?: ProfissionalScalarWhereInput | ProfissionalScalarWhereInput[]
    OR?: ProfissionalScalarWhereInput[]
    NOT?: ProfissionalScalarWhereInput | ProfissionalScalarWhereInput[]
    id?: IntFilter<"Profissional"> | number
    cdMaster?: IntFilter<"Profissional"> | number
    nome?: StringFilter<"Profissional"> | string
    sexo?: EnumSexoNullableFilter<"Profissional"> | $Enums.Sexo | null
    conselho?: StringNullableFilter<"Profissional"> | string | null
    stInativo?: EnumSimNaoNullableFilter<"Profissional"> | $Enums.SimNao | null
    cdOcupacao?: IntNullableFilter<"Profissional"> | number | null
  }

  export type UsuarioAuthUpsertWithWhereUniqueWithoutMasterInput = {
    where: UsuarioAuthWhereUniqueInput
    update: XOR<UsuarioAuthUpdateWithoutMasterInput, UsuarioAuthUncheckedUpdateWithoutMasterInput>
    create: XOR<UsuarioAuthCreateWithoutMasterInput, UsuarioAuthUncheckedCreateWithoutMasterInput>
  }

  export type UsuarioAuthUpdateWithWhereUniqueWithoutMasterInput = {
    where: UsuarioAuthWhereUniqueInput
    data: XOR<UsuarioAuthUpdateWithoutMasterInput, UsuarioAuthUncheckedUpdateWithoutMasterInput>
  }

  export type UsuarioAuthUpdateManyWithWhereWithoutMasterInput = {
    where: UsuarioAuthScalarWhereInput
    data: XOR<UsuarioAuthUpdateManyMutationInput, UsuarioAuthUncheckedUpdateManyWithoutMasterInput>
  }

  export type UsuarioAuthScalarWhereInput = {
    AND?: UsuarioAuthScalarWhereInput | UsuarioAuthScalarWhereInput[]
    OR?: UsuarioAuthScalarWhereInput[]
    NOT?: UsuarioAuthScalarWhereInput | UsuarioAuthScalarWhereInput[]
    id?: IntFilter<"UsuarioAuth"> | number
    cdMaster?: IntFilter<"UsuarioAuth"> | number
    email?: StringFilter<"UsuarioAuth"> | string
    senhaHash?: StringFilter<"UsuarioAuth"> | string
    role?: EnumRoleAuthFilter<"UsuarioAuth"> | $Enums.RoleAuth
    cdProfissional?: IntNullableFilter<"UsuarioAuth"> | number | null
    cdPaciente?: IntNullableFilter<"UsuarioAuth"> | number | null
  }

  export type AtendimentoCreateWithoutPacienteInput = {
    data: Date | string
    observacao?: string | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutAtendimentoInput
    profissional: ProfissionalCreateNestedOneWithoutAtendimentosInput
    evaDores?: EvaDorCreateNestedManyWithoutAtendimentoInput
    evolucoes?: EvolucaoCreateNestedManyWithoutAtendimentoInput
    glasgows?: GlasgowCreateNestedManyWithoutAtendimentoInput
    sinaisVitais?: SinaisVitaisCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoUncheckedCreateWithoutPacienteInput = {
    id?: number
    cdProfissional: number
    data: Date | string
    observacao?: string | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutAtendimentoInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutAtendimentoInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutAtendimentoInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutAtendimentoInput
    sinaisVitais?: SinaisVitaisUncheckedCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoCreateOrConnectWithoutPacienteInput = {
    where: AtendimentoWhereUniqueInput
    create: XOR<AtendimentoCreateWithoutPacienteInput, AtendimentoUncheckedCreateWithoutPacienteInput>
  }

  export type AtendimentoCreateManyPacienteInputEnvelope = {
    data: AtendimentoCreateManyPacienteInput | AtendimentoCreateManyPacienteInput[]
    skipDuplicates?: boolean
  }

  export type ContatoPacienteCreateWithoutPacienteInput = {
    contato: ContatoCreateNestedOneWithoutPacientesInput
  }

  export type ContatoPacienteUncheckedCreateWithoutPacienteInput = {
    id?: number
    cdContato: number
  }

  export type ContatoPacienteCreateOrConnectWithoutPacienteInput = {
    where: ContatoPacienteWhereUniqueInput
    create: XOR<ContatoPacienteCreateWithoutPacienteInput, ContatoPacienteUncheckedCreateWithoutPacienteInput>
  }

  export type ContatoPacienteCreateManyPacienteInputEnvelope = {
    data: ContatoPacienteCreateManyPacienteInput | ContatoPacienteCreateManyPacienteInput[]
    skipDuplicates?: boolean
  }

  export type EnderecoPacienteCreateWithoutPacienteInput = {
    endereco: EnderecoCreateNestedOneWithoutPacientesInput
  }

  export type EnderecoPacienteUncheckedCreateWithoutPacienteInput = {
    id?: number
    cdEndereco: number
  }

  export type EnderecoPacienteCreateOrConnectWithoutPacienteInput = {
    where: EnderecoPacienteWhereUniqueInput
    create: XOR<EnderecoPacienteCreateWithoutPacienteInput, EnderecoPacienteUncheckedCreateWithoutPacienteInput>
  }

  export type EnderecoPacienteCreateManyPacienteInputEnvelope = {
    data: EnderecoPacienteCreateManyPacienteInput | EnderecoPacienteCreateManyPacienteInput[]
    skipDuplicates?: boolean
  }

  export type EvolucaoCreateWithoutPacienteInput = {
    data: Date | string
    texto: string
    atendimento: AtendimentoCreateNestedOneWithoutEvolucoesInput
    profissional?: ProfissionalCreateNestedOneWithoutEvolucoesInput
    tipoEvolucaoClinica?: TipoEvolucaoClinicaCreateNestedOneWithoutEvolucaosInput
    cid?: EvolucaoCidCreateNestedManyWithoutEvolucaoInput
    dsm?: EvolucaoDsmCreateNestedManyWithoutEvolucaoInput
  }

  export type EvolucaoUncheckedCreateWithoutPacienteInput = {
    id?: number
    cdAtendimento: number
    cdProfissional?: number | null
    data: Date | string
    texto: string
    tipoEvolucaoClinicaId?: number | null
    cid?: EvolucaoCidUncheckedCreateNestedManyWithoutEvolucaoInput
    dsm?: EvolucaoDsmUncheckedCreateNestedManyWithoutEvolucaoInput
  }

  export type EvolucaoCreateOrConnectWithoutPacienteInput = {
    where: EvolucaoWhereUniqueInput
    create: XOR<EvolucaoCreateWithoutPacienteInput, EvolucaoUncheckedCreateWithoutPacienteInput>
  }

  export type EvolucaoCreateManyPacienteInputEnvelope = {
    data: EvolucaoCreateManyPacienteInput | EvolucaoCreateManyPacienteInput[]
    skipDuplicates?: boolean
  }

  export type EscolaridadeCreateWithoutPacientesInput = {
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type EscolaridadeUncheckedCreateWithoutPacientesInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type EscolaridadeCreateOrConnectWithoutPacientesInput = {
    where: EscolaridadeWhereUniqueInput
    create: XOR<EscolaridadeCreateWithoutPacientesInput, EscolaridadeUncheckedCreateWithoutPacientesInput>
  }

  export type MasterCreateWithoutPacientesInput = {
    nome: string
    dtCadastro?: Date | string
    stInativo?: $Enums.SimNao | null
    profissionais?: ProfissionalCreateNestedManyWithoutMasterInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutMasterInput
  }

  export type MasterUncheckedCreateWithoutPacientesInput = {
    id?: number
    nome: string
    dtCadastro?: Date | string
    stInativo?: $Enums.SimNao | null
    profissionais?: ProfissionalUncheckedCreateNestedManyWithoutMasterInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutMasterInput
  }

  export type MasterCreateOrConnectWithoutPacientesInput = {
    where: MasterWhereUniqueInput
    create: XOR<MasterCreateWithoutPacientesInput, MasterUncheckedCreateWithoutPacientesInput>
  }

  export type OcupacaoCreateWithoutPacientesInput = {
    descricao: string
    cbo?: string | null
    stInativo?: $Enums.SimNao | null
    profissionals?: ProfissionalCreateNestedManyWithoutOcupacaoInput
  }

  export type OcupacaoUncheckedCreateWithoutPacientesInput = {
    id?: number
    descricao: string
    cbo?: string | null
    stInativo?: $Enums.SimNao | null
    profissionals?: ProfissionalUncheckedCreateNestedManyWithoutOcupacaoInput
  }

  export type OcupacaoCreateOrConnectWithoutPacientesInput = {
    where: OcupacaoWhereUniqueInput
    create: XOR<OcupacaoCreateWithoutPacientesInput, OcupacaoUncheckedCreateWithoutPacientesInput>
  }

  export type ParentescoPacienteCreateWithoutPacienteInput = {
    parentesco: $Enums.TipoParentesco
    pessoaRelacionada: PessoaRelacionadaCreateNestedOneWithoutParentescosInput
  }

  export type ParentescoPacienteUncheckedCreateWithoutPacienteInput = {
    id?: number
    cdPessoa: number
    parentesco: $Enums.TipoParentesco
  }

  export type ParentescoPacienteCreateOrConnectWithoutPacienteInput = {
    where: ParentescoPacienteWhereUniqueInput
    create: XOR<ParentescoPacienteCreateWithoutPacienteInput, ParentescoPacienteUncheckedCreateWithoutPacienteInput>
  }

  export type ParentescoPacienteCreateManyPacienteInputEnvelope = {
    data: ParentescoPacienteCreateManyPacienteInput | ParentescoPacienteCreateManyPacienteInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioAuthCreateWithoutPacienteInput = {
    email: string
    senhaHash: string
    role?: $Enums.RoleAuth
    master: MasterCreateNestedOneWithoutUsuarioAuthsInput
    profissional?: ProfissionalCreateNestedOneWithoutUsuarioAuthsInput
  }

  export type UsuarioAuthUncheckedCreateWithoutPacienteInput = {
    id?: number
    email: string
    senhaHash: string
    role?: $Enums.RoleAuth
    cdProfissional?: number | null
  }

  export type UsuarioAuthCreateOrConnectWithoutPacienteInput = {
    where: UsuarioAuthWhereUniqueInput
    create: XOR<UsuarioAuthCreateWithoutPacienteInput, UsuarioAuthUncheckedCreateWithoutPacienteInput>
  }

  export type UsuarioAuthCreateManyPacienteInputEnvelope = {
    data: UsuarioAuthCreateManyPacienteInput | UsuarioAuthCreateManyPacienteInput[]
    skipDuplicates?: boolean
  }

  export type AtendimentoUpsertWithWhereUniqueWithoutPacienteInput = {
    where: AtendimentoWhereUniqueInput
    update: XOR<AtendimentoUpdateWithoutPacienteInput, AtendimentoUncheckedUpdateWithoutPacienteInput>
    create: XOR<AtendimentoCreateWithoutPacienteInput, AtendimentoUncheckedCreateWithoutPacienteInput>
  }

  export type AtendimentoUpdateWithWhereUniqueWithoutPacienteInput = {
    where: AtendimentoWhereUniqueInput
    data: XOR<AtendimentoUpdateWithoutPacienteInput, AtendimentoUncheckedUpdateWithoutPacienteInput>
  }

  export type AtendimentoUpdateManyWithWhereWithoutPacienteInput = {
    where: AtendimentoScalarWhereInput
    data: XOR<AtendimentoUpdateManyMutationInput, AtendimentoUncheckedUpdateManyWithoutPacienteInput>
  }

  export type AtendimentoScalarWhereInput = {
    AND?: AtendimentoScalarWhereInput | AtendimentoScalarWhereInput[]
    OR?: AtendimentoScalarWhereInput[]
    NOT?: AtendimentoScalarWhereInput | AtendimentoScalarWhereInput[]
    id?: IntFilter<"Atendimento"> | number
    cdMaster?: IntFilter<"Atendimento"> | number
    cdPaciente?: IntFilter<"Atendimento"> | number
    cdProfissional?: IntFilter<"Atendimento"> | number
    data?: DateTimeFilter<"Atendimento"> | Date | string
    observacao?: StringNullableFilter<"Atendimento"> | string | null
  }

  export type ContatoPacienteUpsertWithWhereUniqueWithoutPacienteInput = {
    where: ContatoPacienteWhereUniqueInput
    update: XOR<ContatoPacienteUpdateWithoutPacienteInput, ContatoPacienteUncheckedUpdateWithoutPacienteInput>
    create: XOR<ContatoPacienteCreateWithoutPacienteInput, ContatoPacienteUncheckedCreateWithoutPacienteInput>
  }

  export type ContatoPacienteUpdateWithWhereUniqueWithoutPacienteInput = {
    where: ContatoPacienteWhereUniqueInput
    data: XOR<ContatoPacienteUpdateWithoutPacienteInput, ContatoPacienteUncheckedUpdateWithoutPacienteInput>
  }

  export type ContatoPacienteUpdateManyWithWhereWithoutPacienteInput = {
    where: ContatoPacienteScalarWhereInput
    data: XOR<ContatoPacienteUpdateManyMutationInput, ContatoPacienteUncheckedUpdateManyWithoutPacienteInput>
  }

  export type ContatoPacienteScalarWhereInput = {
    AND?: ContatoPacienteScalarWhereInput | ContatoPacienteScalarWhereInput[]
    OR?: ContatoPacienteScalarWhereInput[]
    NOT?: ContatoPacienteScalarWhereInput | ContatoPacienteScalarWhereInput[]
    id?: IntFilter<"ContatoPaciente"> | number
    cdMaster?: IntFilter<"ContatoPaciente"> | number
    cdPaciente?: IntFilter<"ContatoPaciente"> | number
    cdContato?: IntFilter<"ContatoPaciente"> | number
  }

  export type EnderecoPacienteUpsertWithWhereUniqueWithoutPacienteInput = {
    where: EnderecoPacienteWhereUniqueInput
    update: XOR<EnderecoPacienteUpdateWithoutPacienteInput, EnderecoPacienteUncheckedUpdateWithoutPacienteInput>
    create: XOR<EnderecoPacienteCreateWithoutPacienteInput, EnderecoPacienteUncheckedCreateWithoutPacienteInput>
  }

  export type EnderecoPacienteUpdateWithWhereUniqueWithoutPacienteInput = {
    where: EnderecoPacienteWhereUniqueInput
    data: XOR<EnderecoPacienteUpdateWithoutPacienteInput, EnderecoPacienteUncheckedUpdateWithoutPacienteInput>
  }

  export type EnderecoPacienteUpdateManyWithWhereWithoutPacienteInput = {
    where: EnderecoPacienteScalarWhereInput
    data: XOR<EnderecoPacienteUpdateManyMutationInput, EnderecoPacienteUncheckedUpdateManyWithoutPacienteInput>
  }

  export type EnderecoPacienteScalarWhereInput = {
    AND?: EnderecoPacienteScalarWhereInput | EnderecoPacienteScalarWhereInput[]
    OR?: EnderecoPacienteScalarWhereInput[]
    NOT?: EnderecoPacienteScalarWhereInput | EnderecoPacienteScalarWhereInput[]
    id?: IntFilter<"EnderecoPaciente"> | number
    cdMaster?: IntFilter<"EnderecoPaciente"> | number
    cdPaciente?: IntFilter<"EnderecoPaciente"> | number
    cdEndereco?: IntFilter<"EnderecoPaciente"> | number
  }

  export type EvolucaoUpsertWithWhereUniqueWithoutPacienteInput = {
    where: EvolucaoWhereUniqueInput
    update: XOR<EvolucaoUpdateWithoutPacienteInput, EvolucaoUncheckedUpdateWithoutPacienteInput>
    create: XOR<EvolucaoCreateWithoutPacienteInput, EvolucaoUncheckedCreateWithoutPacienteInput>
  }

  export type EvolucaoUpdateWithWhereUniqueWithoutPacienteInput = {
    where: EvolucaoWhereUniqueInput
    data: XOR<EvolucaoUpdateWithoutPacienteInput, EvolucaoUncheckedUpdateWithoutPacienteInput>
  }

  export type EvolucaoUpdateManyWithWhereWithoutPacienteInput = {
    where: EvolucaoScalarWhereInput
    data: XOR<EvolucaoUpdateManyMutationInput, EvolucaoUncheckedUpdateManyWithoutPacienteInput>
  }

  export type EvolucaoScalarWhereInput = {
    AND?: EvolucaoScalarWhereInput | EvolucaoScalarWhereInput[]
    OR?: EvolucaoScalarWhereInput[]
    NOT?: EvolucaoScalarWhereInput | EvolucaoScalarWhereInput[]
    id?: IntFilter<"Evolucao"> | number
    cdAtendimento?: IntFilter<"Evolucao"> | number
    cdProfissional?: IntNullableFilter<"Evolucao"> | number | null
    data?: DateTimeFilter<"Evolucao"> | Date | string
    texto?: StringFilter<"Evolucao"> | string
    pacienteCdMaster?: IntNullableFilter<"Evolucao"> | number | null
    pacienteCdPaciente?: IntNullableFilter<"Evolucao"> | number | null
    tipoEvolucaoClinicaId?: IntNullableFilter<"Evolucao"> | number | null
  }

  export type EscolaridadeUpsertWithoutPacientesInput = {
    update: XOR<EscolaridadeUpdateWithoutPacientesInput, EscolaridadeUncheckedUpdateWithoutPacientesInput>
    create: XOR<EscolaridadeCreateWithoutPacientesInput, EscolaridadeUncheckedCreateWithoutPacientesInput>
    where?: EscolaridadeWhereInput
  }

  export type EscolaridadeUpdateToOneWithWhereWithoutPacientesInput = {
    where?: EscolaridadeWhereInput
    data: XOR<EscolaridadeUpdateWithoutPacientesInput, EscolaridadeUncheckedUpdateWithoutPacientesInput>
  }

  export type EscolaridadeUpdateWithoutPacientesInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type EscolaridadeUncheckedUpdateWithoutPacientesInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type MasterUpsertWithoutPacientesInput = {
    update: XOR<MasterUpdateWithoutPacientesInput, MasterUncheckedUpdateWithoutPacientesInput>
    create: XOR<MasterCreateWithoutPacientesInput, MasterUncheckedCreateWithoutPacientesInput>
    where?: MasterWhereInput
  }

  export type MasterUpdateToOneWithWhereWithoutPacientesInput = {
    where?: MasterWhereInput
    data: XOR<MasterUpdateWithoutPacientesInput, MasterUncheckedUpdateWithoutPacientesInput>
  }

  export type MasterUpdateWithoutPacientesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    dtCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    profissionais?: ProfissionalUpdateManyWithoutMasterNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutMasterNestedInput
  }

  export type MasterUncheckedUpdateWithoutPacientesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dtCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    profissionais?: ProfissionalUncheckedUpdateManyWithoutMasterNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type OcupacaoUpsertWithoutPacientesInput = {
    update: XOR<OcupacaoUpdateWithoutPacientesInput, OcupacaoUncheckedUpdateWithoutPacientesInput>
    create: XOR<OcupacaoCreateWithoutPacientesInput, OcupacaoUncheckedCreateWithoutPacientesInput>
    where?: OcupacaoWhereInput
  }

  export type OcupacaoUpdateToOneWithWhereWithoutPacientesInput = {
    where?: OcupacaoWhereInput
    data: XOR<OcupacaoUpdateWithoutPacientesInput, OcupacaoUncheckedUpdateWithoutPacientesInput>
  }

  export type OcupacaoUpdateWithoutPacientesInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    cbo?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    profissionals?: ProfissionalUpdateManyWithoutOcupacaoNestedInput
  }

  export type OcupacaoUncheckedUpdateWithoutPacientesInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    cbo?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    profissionals?: ProfissionalUncheckedUpdateManyWithoutOcupacaoNestedInput
  }

  export type ParentescoPacienteUpsertWithWhereUniqueWithoutPacienteInput = {
    where: ParentescoPacienteWhereUniqueInput
    update: XOR<ParentescoPacienteUpdateWithoutPacienteInput, ParentescoPacienteUncheckedUpdateWithoutPacienteInput>
    create: XOR<ParentescoPacienteCreateWithoutPacienteInput, ParentescoPacienteUncheckedCreateWithoutPacienteInput>
  }

  export type ParentescoPacienteUpdateWithWhereUniqueWithoutPacienteInput = {
    where: ParentescoPacienteWhereUniqueInput
    data: XOR<ParentescoPacienteUpdateWithoutPacienteInput, ParentescoPacienteUncheckedUpdateWithoutPacienteInput>
  }

  export type ParentescoPacienteUpdateManyWithWhereWithoutPacienteInput = {
    where: ParentescoPacienteScalarWhereInput
    data: XOR<ParentescoPacienteUpdateManyMutationInput, ParentescoPacienteUncheckedUpdateManyWithoutPacienteInput>
  }

  export type ParentescoPacienteScalarWhereInput = {
    AND?: ParentescoPacienteScalarWhereInput | ParentescoPacienteScalarWhereInput[]
    OR?: ParentescoPacienteScalarWhereInput[]
    NOT?: ParentescoPacienteScalarWhereInput | ParentescoPacienteScalarWhereInput[]
    id?: IntFilter<"ParentescoPaciente"> | number
    cdMaster?: IntFilter<"ParentescoPaciente"> | number
    cdPaciente?: IntFilter<"ParentescoPaciente"> | number
    cdPessoa?: IntFilter<"ParentescoPaciente"> | number
    parentesco?: EnumTipoParentescoFilter<"ParentescoPaciente"> | $Enums.TipoParentesco
  }

  export type UsuarioAuthUpsertWithWhereUniqueWithoutPacienteInput = {
    where: UsuarioAuthWhereUniqueInput
    update: XOR<UsuarioAuthUpdateWithoutPacienteInput, UsuarioAuthUncheckedUpdateWithoutPacienteInput>
    create: XOR<UsuarioAuthCreateWithoutPacienteInput, UsuarioAuthUncheckedCreateWithoutPacienteInput>
  }

  export type UsuarioAuthUpdateWithWhereUniqueWithoutPacienteInput = {
    where: UsuarioAuthWhereUniqueInput
    data: XOR<UsuarioAuthUpdateWithoutPacienteInput, UsuarioAuthUncheckedUpdateWithoutPacienteInput>
  }

  export type UsuarioAuthUpdateManyWithWhereWithoutPacienteInput = {
    where: UsuarioAuthScalarWhereInput
    data: XOR<UsuarioAuthUpdateManyMutationInput, UsuarioAuthUncheckedUpdateManyWithoutPacienteInput>
  }

  export type AfericaoClinicaCreateWithoutProfissionalInput = {
    escala: string
    idRegistro: number
    data?: Date | string
    atendimento: AtendimentoCreateNestedOneWithoutAfericoesClinicasInput
  }

  export type AfericaoClinicaUncheckedCreateWithoutProfissionalInput = {
    id?: number
    cdAtendimento: number
    escala: string
    idRegistro: number
    data?: Date | string
  }

  export type AfericaoClinicaCreateOrConnectWithoutProfissionalInput = {
    where: AfericaoClinicaWhereUniqueInput
    create: XOR<AfericaoClinicaCreateWithoutProfissionalInput, AfericaoClinicaUncheckedCreateWithoutProfissionalInput>
  }

  export type AfericaoClinicaCreateManyProfissionalInputEnvelope = {
    data: AfericaoClinicaCreateManyProfissionalInput | AfericaoClinicaCreateManyProfissionalInput[]
    skipDuplicates?: boolean
  }

  export type AtendimentoCreateWithoutProfissionalInput = {
    data: Date | string
    observacao?: string | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutAtendimentoInput
    paciente: PacienteCreateNestedOneWithoutAtendimentosInput
    evaDores?: EvaDorCreateNestedManyWithoutAtendimentoInput
    evolucoes?: EvolucaoCreateNestedManyWithoutAtendimentoInput
    glasgows?: GlasgowCreateNestedManyWithoutAtendimentoInput
    sinaisVitais?: SinaisVitaisCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoUncheckedCreateWithoutProfissionalInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    data: Date | string
    observacao?: string | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutAtendimentoInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutAtendimentoInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutAtendimentoInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutAtendimentoInput
    sinaisVitais?: SinaisVitaisUncheckedCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoCreateOrConnectWithoutProfissionalInput = {
    where: AtendimentoWhereUniqueInput
    create: XOR<AtendimentoCreateWithoutProfissionalInput, AtendimentoUncheckedCreateWithoutProfissionalInput>
  }

  export type AtendimentoCreateManyProfissionalInputEnvelope = {
    data: AtendimentoCreateManyProfissionalInput | AtendimentoCreateManyProfissionalInput[]
    skipDuplicates?: boolean
  }

  export type ContatoProfissionalCreateWithoutProfissionalInput = {
    contato: ContatoCreateNestedOneWithoutProfissionaisInput
  }

  export type ContatoProfissionalUncheckedCreateWithoutProfissionalInput = {
    id?: number
    cdContato: number
  }

  export type ContatoProfissionalCreateOrConnectWithoutProfissionalInput = {
    where: ContatoProfissionalWhereUniqueInput
    create: XOR<ContatoProfissionalCreateWithoutProfissionalInput, ContatoProfissionalUncheckedCreateWithoutProfissionalInput>
  }

  export type ContatoProfissionalCreateManyProfissionalInputEnvelope = {
    data: ContatoProfissionalCreateManyProfissionalInput | ContatoProfissionalCreateManyProfissionalInput[]
    skipDuplicates?: boolean
  }

  export type EnderecoProfissionalCreateWithoutProfissionalInput = {
    endereco: EnderecoCreateNestedOneWithoutProfissionaisInput
  }

  export type EnderecoProfissionalUncheckedCreateWithoutProfissionalInput = {
    id?: number
    cdEndereco: number
  }

  export type EnderecoProfissionalCreateOrConnectWithoutProfissionalInput = {
    where: EnderecoProfissionalWhereUniqueInput
    create: XOR<EnderecoProfissionalCreateWithoutProfissionalInput, EnderecoProfissionalUncheckedCreateWithoutProfissionalInput>
  }

  export type EnderecoProfissionalCreateManyProfissionalInputEnvelope = {
    data: EnderecoProfissionalCreateManyProfissionalInput | EnderecoProfissionalCreateManyProfissionalInput[]
    skipDuplicates?: boolean
  }

  export type EvaDorCreateWithoutProfissionalInput = {
    data?: Date | string
    valor: number
    observacao?: string | null
    atendimento: AtendimentoCreateNestedOneWithoutEvaDoresInput
  }

  export type EvaDorUncheckedCreateWithoutProfissionalInput = {
    id?: number
    cdAtendimento: number
    data?: Date | string
    valor: number
    observacao?: string | null
  }

  export type EvaDorCreateOrConnectWithoutProfissionalInput = {
    where: EvaDorWhereUniqueInput
    create: XOR<EvaDorCreateWithoutProfissionalInput, EvaDorUncheckedCreateWithoutProfissionalInput>
  }

  export type EvaDorCreateManyProfissionalInputEnvelope = {
    data: EvaDorCreateManyProfissionalInput | EvaDorCreateManyProfissionalInput[]
    skipDuplicates?: boolean
  }

  export type EvolucaoCreateWithoutProfissionalInput = {
    data: Date | string
    texto: string
    atendimento: AtendimentoCreateNestedOneWithoutEvolucoesInput
    paciente?: PacienteCreateNestedOneWithoutEvolucoesInput
    tipoEvolucaoClinica?: TipoEvolucaoClinicaCreateNestedOneWithoutEvolucaosInput
    cid?: EvolucaoCidCreateNestedManyWithoutEvolucaoInput
    dsm?: EvolucaoDsmCreateNestedManyWithoutEvolucaoInput
  }

  export type EvolucaoUncheckedCreateWithoutProfissionalInput = {
    id?: number
    cdAtendimento: number
    data: Date | string
    texto: string
    pacienteCdMaster?: number | null
    pacienteCdPaciente?: number | null
    tipoEvolucaoClinicaId?: number | null
    cid?: EvolucaoCidUncheckedCreateNestedManyWithoutEvolucaoInput
    dsm?: EvolucaoDsmUncheckedCreateNestedManyWithoutEvolucaoInput
  }

  export type EvolucaoCreateOrConnectWithoutProfissionalInput = {
    where: EvolucaoWhereUniqueInput
    create: XOR<EvolucaoCreateWithoutProfissionalInput, EvolucaoUncheckedCreateWithoutProfissionalInput>
  }

  export type EvolucaoCreateManyProfissionalInputEnvelope = {
    data: EvolucaoCreateManyProfissionalInput | EvolucaoCreateManyProfissionalInput[]
    skipDuplicates?: boolean
  }

  export type GlasgowCreateWithoutProfissionalInput = {
    data?: Date | string
    ocular: number
    verbal: number
    motora: number
    total: number
    observacao?: string | null
    atendimento: AtendimentoCreateNestedOneWithoutGlasgowsInput
  }

  export type GlasgowUncheckedCreateWithoutProfissionalInput = {
    id?: number
    cdAtendimento: number
    data?: Date | string
    ocular: number
    verbal: number
    motora: number
    total: number
    observacao?: string | null
  }

  export type GlasgowCreateOrConnectWithoutProfissionalInput = {
    where: GlasgowWhereUniqueInput
    create: XOR<GlasgowCreateWithoutProfissionalInput, GlasgowUncheckedCreateWithoutProfissionalInput>
  }

  export type GlasgowCreateManyProfissionalInputEnvelope = {
    data: GlasgowCreateManyProfissionalInput | GlasgowCreateManyProfissionalInput[]
    skipDuplicates?: boolean
  }

  export type MasterCreateWithoutProfissionaisInput = {
    nome: string
    dtCadastro?: Date | string
    stInativo?: $Enums.SimNao | null
    pacientes?: PacienteCreateNestedManyWithoutMasterInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutMasterInput
  }

  export type MasterUncheckedCreateWithoutProfissionaisInput = {
    id?: number
    nome: string
    dtCadastro?: Date | string
    stInativo?: $Enums.SimNao | null
    pacientes?: PacienteUncheckedCreateNestedManyWithoutMasterInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutMasterInput
  }

  export type MasterCreateOrConnectWithoutProfissionaisInput = {
    where: MasterWhereUniqueInput
    create: XOR<MasterCreateWithoutProfissionaisInput, MasterUncheckedCreateWithoutProfissionaisInput>
  }

  export type OcupacaoCreateWithoutProfissionalsInput = {
    descricao: string
    cbo?: string | null
    stInativo?: $Enums.SimNao | null
    pacientes?: PacienteCreateNestedManyWithoutOcupacaoInput
  }

  export type OcupacaoUncheckedCreateWithoutProfissionalsInput = {
    id?: number
    descricao: string
    cbo?: string | null
    stInativo?: $Enums.SimNao | null
    pacientes?: PacienteUncheckedCreateNestedManyWithoutOcupacaoInput
  }

  export type OcupacaoCreateOrConnectWithoutProfissionalsInput = {
    where: OcupacaoWhereUniqueInput
    create: XOR<OcupacaoCreateWithoutProfissionalsInput, OcupacaoUncheckedCreateWithoutProfissionalsInput>
  }

  export type UsuarioAuthCreateWithoutProfissionalInput = {
    email: string
    senhaHash: string
    role?: $Enums.RoleAuth
    paciente?: PacienteCreateNestedOneWithoutUsuarioAuthsInput
    master: MasterCreateNestedOneWithoutUsuarioAuthsInput
  }

  export type UsuarioAuthUncheckedCreateWithoutProfissionalInput = {
    id?: number
    cdMaster: number
    email: string
    senhaHash: string
    role?: $Enums.RoleAuth
    cdPaciente?: number | null
  }

  export type UsuarioAuthCreateOrConnectWithoutProfissionalInput = {
    where: UsuarioAuthWhereUniqueInput
    create: XOR<UsuarioAuthCreateWithoutProfissionalInput, UsuarioAuthUncheckedCreateWithoutProfissionalInput>
  }

  export type UsuarioAuthCreateManyProfissionalInputEnvelope = {
    data: UsuarioAuthCreateManyProfissionalInput | UsuarioAuthCreateManyProfissionalInput[]
    skipDuplicates?: boolean
  }

  export type AfericaoClinicaUpsertWithWhereUniqueWithoutProfissionalInput = {
    where: AfericaoClinicaWhereUniqueInput
    update: XOR<AfericaoClinicaUpdateWithoutProfissionalInput, AfericaoClinicaUncheckedUpdateWithoutProfissionalInput>
    create: XOR<AfericaoClinicaCreateWithoutProfissionalInput, AfericaoClinicaUncheckedCreateWithoutProfissionalInput>
  }

  export type AfericaoClinicaUpdateWithWhereUniqueWithoutProfissionalInput = {
    where: AfericaoClinicaWhereUniqueInput
    data: XOR<AfericaoClinicaUpdateWithoutProfissionalInput, AfericaoClinicaUncheckedUpdateWithoutProfissionalInput>
  }

  export type AfericaoClinicaUpdateManyWithWhereWithoutProfissionalInput = {
    where: AfericaoClinicaScalarWhereInput
    data: XOR<AfericaoClinicaUpdateManyMutationInput, AfericaoClinicaUncheckedUpdateManyWithoutProfissionalInput>
  }

  export type AfericaoClinicaScalarWhereInput = {
    AND?: AfericaoClinicaScalarWhereInput | AfericaoClinicaScalarWhereInput[]
    OR?: AfericaoClinicaScalarWhereInput[]
    NOT?: AfericaoClinicaScalarWhereInput | AfericaoClinicaScalarWhereInput[]
    id?: IntFilter<"AfericaoClinica"> | number
    cdAtendimento?: IntFilter<"AfericaoClinica"> | number
    cdProfissional?: IntNullableFilter<"AfericaoClinica"> | number | null
    escala?: StringFilter<"AfericaoClinica"> | string
    idRegistro?: IntFilter<"AfericaoClinica"> | number
    data?: DateTimeFilter<"AfericaoClinica"> | Date | string
  }

  export type AtendimentoUpsertWithWhereUniqueWithoutProfissionalInput = {
    where: AtendimentoWhereUniqueInput
    update: XOR<AtendimentoUpdateWithoutProfissionalInput, AtendimentoUncheckedUpdateWithoutProfissionalInput>
    create: XOR<AtendimentoCreateWithoutProfissionalInput, AtendimentoUncheckedCreateWithoutProfissionalInput>
  }

  export type AtendimentoUpdateWithWhereUniqueWithoutProfissionalInput = {
    where: AtendimentoWhereUniqueInput
    data: XOR<AtendimentoUpdateWithoutProfissionalInput, AtendimentoUncheckedUpdateWithoutProfissionalInput>
  }

  export type AtendimentoUpdateManyWithWhereWithoutProfissionalInput = {
    where: AtendimentoScalarWhereInput
    data: XOR<AtendimentoUpdateManyMutationInput, AtendimentoUncheckedUpdateManyWithoutProfissionalInput>
  }

  export type ContatoProfissionalUpsertWithWhereUniqueWithoutProfissionalInput = {
    where: ContatoProfissionalWhereUniqueInput
    update: XOR<ContatoProfissionalUpdateWithoutProfissionalInput, ContatoProfissionalUncheckedUpdateWithoutProfissionalInput>
    create: XOR<ContatoProfissionalCreateWithoutProfissionalInput, ContatoProfissionalUncheckedCreateWithoutProfissionalInput>
  }

  export type ContatoProfissionalUpdateWithWhereUniqueWithoutProfissionalInput = {
    where: ContatoProfissionalWhereUniqueInput
    data: XOR<ContatoProfissionalUpdateWithoutProfissionalInput, ContatoProfissionalUncheckedUpdateWithoutProfissionalInput>
  }

  export type ContatoProfissionalUpdateManyWithWhereWithoutProfissionalInput = {
    where: ContatoProfissionalScalarWhereInput
    data: XOR<ContatoProfissionalUpdateManyMutationInput, ContatoProfissionalUncheckedUpdateManyWithoutProfissionalInput>
  }

  export type ContatoProfissionalScalarWhereInput = {
    AND?: ContatoProfissionalScalarWhereInput | ContatoProfissionalScalarWhereInput[]
    OR?: ContatoProfissionalScalarWhereInput[]
    NOT?: ContatoProfissionalScalarWhereInput | ContatoProfissionalScalarWhereInput[]
    id?: IntFilter<"ContatoProfissional"> | number
    cdProf?: IntFilter<"ContatoProfissional"> | number
    cdContato?: IntFilter<"ContatoProfissional"> | number
  }

  export type EnderecoProfissionalUpsertWithWhereUniqueWithoutProfissionalInput = {
    where: EnderecoProfissionalWhereUniqueInput
    update: XOR<EnderecoProfissionalUpdateWithoutProfissionalInput, EnderecoProfissionalUncheckedUpdateWithoutProfissionalInput>
    create: XOR<EnderecoProfissionalCreateWithoutProfissionalInput, EnderecoProfissionalUncheckedCreateWithoutProfissionalInput>
  }

  export type EnderecoProfissionalUpdateWithWhereUniqueWithoutProfissionalInput = {
    where: EnderecoProfissionalWhereUniqueInput
    data: XOR<EnderecoProfissionalUpdateWithoutProfissionalInput, EnderecoProfissionalUncheckedUpdateWithoutProfissionalInput>
  }

  export type EnderecoProfissionalUpdateManyWithWhereWithoutProfissionalInput = {
    where: EnderecoProfissionalScalarWhereInput
    data: XOR<EnderecoProfissionalUpdateManyMutationInput, EnderecoProfissionalUncheckedUpdateManyWithoutProfissionalInput>
  }

  export type EnderecoProfissionalScalarWhereInput = {
    AND?: EnderecoProfissionalScalarWhereInput | EnderecoProfissionalScalarWhereInput[]
    OR?: EnderecoProfissionalScalarWhereInput[]
    NOT?: EnderecoProfissionalScalarWhereInput | EnderecoProfissionalScalarWhereInput[]
    id?: IntFilter<"EnderecoProfissional"> | number
    cdProf?: IntFilter<"EnderecoProfissional"> | number
    cdEndereco?: IntFilter<"EnderecoProfissional"> | number
  }

  export type EvaDorUpsertWithWhereUniqueWithoutProfissionalInput = {
    where: EvaDorWhereUniqueInput
    update: XOR<EvaDorUpdateWithoutProfissionalInput, EvaDorUncheckedUpdateWithoutProfissionalInput>
    create: XOR<EvaDorCreateWithoutProfissionalInput, EvaDorUncheckedCreateWithoutProfissionalInput>
  }

  export type EvaDorUpdateWithWhereUniqueWithoutProfissionalInput = {
    where: EvaDorWhereUniqueInput
    data: XOR<EvaDorUpdateWithoutProfissionalInput, EvaDorUncheckedUpdateWithoutProfissionalInput>
  }

  export type EvaDorUpdateManyWithWhereWithoutProfissionalInput = {
    where: EvaDorScalarWhereInput
    data: XOR<EvaDorUpdateManyMutationInput, EvaDorUncheckedUpdateManyWithoutProfissionalInput>
  }

  export type EvaDorScalarWhereInput = {
    AND?: EvaDorScalarWhereInput | EvaDorScalarWhereInput[]
    OR?: EvaDorScalarWhereInput[]
    NOT?: EvaDorScalarWhereInput | EvaDorScalarWhereInput[]
    id?: IntFilter<"EvaDor"> | number
    cdAtendimento?: IntFilter<"EvaDor"> | number
    cdProfissional?: IntNullableFilter<"EvaDor"> | number | null
    data?: DateTimeFilter<"EvaDor"> | Date | string
    valor?: IntFilter<"EvaDor"> | number
    observacao?: StringNullableFilter<"EvaDor"> | string | null
  }

  export type EvolucaoUpsertWithWhereUniqueWithoutProfissionalInput = {
    where: EvolucaoWhereUniqueInput
    update: XOR<EvolucaoUpdateWithoutProfissionalInput, EvolucaoUncheckedUpdateWithoutProfissionalInput>
    create: XOR<EvolucaoCreateWithoutProfissionalInput, EvolucaoUncheckedCreateWithoutProfissionalInput>
  }

  export type EvolucaoUpdateWithWhereUniqueWithoutProfissionalInput = {
    where: EvolucaoWhereUniqueInput
    data: XOR<EvolucaoUpdateWithoutProfissionalInput, EvolucaoUncheckedUpdateWithoutProfissionalInput>
  }

  export type EvolucaoUpdateManyWithWhereWithoutProfissionalInput = {
    where: EvolucaoScalarWhereInput
    data: XOR<EvolucaoUpdateManyMutationInput, EvolucaoUncheckedUpdateManyWithoutProfissionalInput>
  }

  export type GlasgowUpsertWithWhereUniqueWithoutProfissionalInput = {
    where: GlasgowWhereUniqueInput
    update: XOR<GlasgowUpdateWithoutProfissionalInput, GlasgowUncheckedUpdateWithoutProfissionalInput>
    create: XOR<GlasgowCreateWithoutProfissionalInput, GlasgowUncheckedCreateWithoutProfissionalInput>
  }

  export type GlasgowUpdateWithWhereUniqueWithoutProfissionalInput = {
    where: GlasgowWhereUniqueInput
    data: XOR<GlasgowUpdateWithoutProfissionalInput, GlasgowUncheckedUpdateWithoutProfissionalInput>
  }

  export type GlasgowUpdateManyWithWhereWithoutProfissionalInput = {
    where: GlasgowScalarWhereInput
    data: XOR<GlasgowUpdateManyMutationInput, GlasgowUncheckedUpdateManyWithoutProfissionalInput>
  }

  export type GlasgowScalarWhereInput = {
    AND?: GlasgowScalarWhereInput | GlasgowScalarWhereInput[]
    OR?: GlasgowScalarWhereInput[]
    NOT?: GlasgowScalarWhereInput | GlasgowScalarWhereInput[]
    id?: IntFilter<"Glasgow"> | number
    cdAtendimento?: IntFilter<"Glasgow"> | number
    cdProfissional?: IntNullableFilter<"Glasgow"> | number | null
    data?: DateTimeFilter<"Glasgow"> | Date | string
    ocular?: IntFilter<"Glasgow"> | number
    verbal?: IntFilter<"Glasgow"> | number
    motora?: IntFilter<"Glasgow"> | number
    total?: IntFilter<"Glasgow"> | number
    observacao?: StringNullableFilter<"Glasgow"> | string | null
  }

  export type MasterUpsertWithoutProfissionaisInput = {
    update: XOR<MasterUpdateWithoutProfissionaisInput, MasterUncheckedUpdateWithoutProfissionaisInput>
    create: XOR<MasterCreateWithoutProfissionaisInput, MasterUncheckedCreateWithoutProfissionaisInput>
    where?: MasterWhereInput
  }

  export type MasterUpdateToOneWithWhereWithoutProfissionaisInput = {
    where?: MasterWhereInput
    data: XOR<MasterUpdateWithoutProfissionaisInput, MasterUncheckedUpdateWithoutProfissionaisInput>
  }

  export type MasterUpdateWithoutProfissionaisInput = {
    nome?: StringFieldUpdateOperationsInput | string
    dtCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: PacienteUpdateManyWithoutMasterNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutMasterNestedInput
  }

  export type MasterUncheckedUpdateWithoutProfissionaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dtCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: PacienteUncheckedUpdateManyWithoutMasterNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type OcupacaoUpsertWithoutProfissionalsInput = {
    update: XOR<OcupacaoUpdateWithoutProfissionalsInput, OcupacaoUncheckedUpdateWithoutProfissionalsInput>
    create: XOR<OcupacaoCreateWithoutProfissionalsInput, OcupacaoUncheckedCreateWithoutProfissionalsInput>
    where?: OcupacaoWhereInput
  }

  export type OcupacaoUpdateToOneWithWhereWithoutProfissionalsInput = {
    where?: OcupacaoWhereInput
    data: XOR<OcupacaoUpdateWithoutProfissionalsInput, OcupacaoUncheckedUpdateWithoutProfissionalsInput>
  }

  export type OcupacaoUpdateWithoutProfissionalsInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    cbo?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: PacienteUpdateManyWithoutOcupacaoNestedInput
  }

  export type OcupacaoUncheckedUpdateWithoutProfissionalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    cbo?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: PacienteUncheckedUpdateManyWithoutOcupacaoNestedInput
  }

  export type UsuarioAuthUpsertWithWhereUniqueWithoutProfissionalInput = {
    where: UsuarioAuthWhereUniqueInput
    update: XOR<UsuarioAuthUpdateWithoutProfissionalInput, UsuarioAuthUncheckedUpdateWithoutProfissionalInput>
    create: XOR<UsuarioAuthCreateWithoutProfissionalInput, UsuarioAuthUncheckedCreateWithoutProfissionalInput>
  }

  export type UsuarioAuthUpdateWithWhereUniqueWithoutProfissionalInput = {
    where: UsuarioAuthWhereUniqueInput
    data: XOR<UsuarioAuthUpdateWithoutProfissionalInput, UsuarioAuthUncheckedUpdateWithoutProfissionalInput>
  }

  export type UsuarioAuthUpdateManyWithWhereWithoutProfissionalInput = {
    where: UsuarioAuthScalarWhereInput
    data: XOR<UsuarioAuthUpdateManyMutationInput, UsuarioAuthUncheckedUpdateManyWithoutProfissionalInput>
  }

  export type BairroCreateWithoutEnderecosInput = {
    descricao: string
    stInativo?: $Enums.SimNao | null
    cidade: CidadeCreateNestedOneWithoutBairrosInput
    distrito?: DistritoCreateNestedOneWithoutBairrosInput
  }

  export type BairroUncheckedCreateWithoutEnderecosInput = {
    id?: number
    cdDistrito?: number | null
    cdCidade: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type BairroCreateOrConnectWithoutEnderecosInput = {
    where: BairroWhereUniqueInput
    create: XOR<BairroCreateWithoutEnderecosInput, BairroUncheckedCreateWithoutEnderecosInput>
  }

  export type CidadeCreateWithoutEnderecosInput = {
    descricao: string
    cepGeral?: string | null
    cdIbge?: number | null
    stInativo?: $Enums.SimNao | null
    bairros?: BairroCreateNestedManyWithoutCidadeInput
    pais: PaisCreateNestedOneWithoutCidadesInput
    uf: UnidadeFederacaoCreateNestedOneWithoutCidadesInput
    distritos?: DistritoCreateNestedManyWithoutCidadeInput
  }

  export type CidadeUncheckedCreateWithoutEnderecosInput = {
    id?: number
    descricao: string
    cdUf: string
    cdPais: number
    cepGeral?: string | null
    cdIbge?: number | null
    stInativo?: $Enums.SimNao | null
    bairros?: BairroUncheckedCreateNestedManyWithoutCidadeInput
    distritos?: DistritoUncheckedCreateNestedManyWithoutCidadeInput
  }

  export type CidadeCreateOrConnectWithoutEnderecosInput = {
    where: CidadeWhereUniqueInput
    create: XOR<CidadeCreateWithoutEnderecosInput, CidadeUncheckedCreateWithoutEnderecosInput>
  }

  export type EnderecoPacienteCreateWithoutEnderecoInput = {
    paciente: PacienteCreateNestedOneWithoutEnderecosInput
  }

  export type EnderecoPacienteUncheckedCreateWithoutEnderecoInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
  }

  export type EnderecoPacienteCreateOrConnectWithoutEnderecoInput = {
    where: EnderecoPacienteWhereUniqueInput
    create: XOR<EnderecoPacienteCreateWithoutEnderecoInput, EnderecoPacienteUncheckedCreateWithoutEnderecoInput>
  }

  export type EnderecoPacienteCreateManyEnderecoInputEnvelope = {
    data: EnderecoPacienteCreateManyEnderecoInput | EnderecoPacienteCreateManyEnderecoInput[]
    skipDuplicates?: boolean
  }

  export type EnderecoPessoaRelacionadaCreateWithoutEnderecoInput = {
    pessoaRelacionada: PessoaRelacionadaCreateNestedOneWithoutEnderecosInput
  }

  export type EnderecoPessoaRelacionadaUncheckedCreateWithoutEnderecoInput = {
    id?: number
    cdPessoa: number
  }

  export type EnderecoPessoaRelacionadaCreateOrConnectWithoutEnderecoInput = {
    where: EnderecoPessoaRelacionadaWhereUniqueInput
    create: XOR<EnderecoPessoaRelacionadaCreateWithoutEnderecoInput, EnderecoPessoaRelacionadaUncheckedCreateWithoutEnderecoInput>
  }

  export type EnderecoPessoaRelacionadaCreateManyEnderecoInputEnvelope = {
    data: EnderecoPessoaRelacionadaCreateManyEnderecoInput | EnderecoPessoaRelacionadaCreateManyEnderecoInput[]
    skipDuplicates?: boolean
  }

  export type EnderecoProfissionalCreateWithoutEnderecoInput = {
    profissional: ProfissionalCreateNestedOneWithoutEnderecosInput
  }

  export type EnderecoProfissionalUncheckedCreateWithoutEnderecoInput = {
    id?: number
    cdProf: number
  }

  export type EnderecoProfissionalCreateOrConnectWithoutEnderecoInput = {
    where: EnderecoProfissionalWhereUniqueInput
    create: XOR<EnderecoProfissionalCreateWithoutEnderecoInput, EnderecoProfissionalUncheckedCreateWithoutEnderecoInput>
  }

  export type EnderecoProfissionalCreateManyEnderecoInputEnvelope = {
    data: EnderecoProfissionalCreateManyEnderecoInput | EnderecoProfissionalCreateManyEnderecoInput[]
    skipDuplicates?: boolean
  }

  export type BairroUpsertWithoutEnderecosInput = {
    update: XOR<BairroUpdateWithoutEnderecosInput, BairroUncheckedUpdateWithoutEnderecosInput>
    create: XOR<BairroCreateWithoutEnderecosInput, BairroUncheckedCreateWithoutEnderecosInput>
    where?: BairroWhereInput
  }

  export type BairroUpdateToOneWithWhereWithoutEnderecosInput = {
    where?: BairroWhereInput
    data: XOR<BairroUpdateWithoutEnderecosInput, BairroUncheckedUpdateWithoutEnderecosInput>
  }

  export type BairroUpdateWithoutEnderecosInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cidade?: CidadeUpdateOneRequiredWithoutBairrosNestedInput
    distrito?: DistritoUpdateOneWithoutBairrosNestedInput
  }

  export type BairroUncheckedUpdateWithoutEnderecosInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdDistrito?: NullableIntFieldUpdateOperationsInput | number | null
    cdCidade?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type CidadeUpsertWithoutEnderecosInput = {
    update: XOR<CidadeUpdateWithoutEnderecosInput, CidadeUncheckedUpdateWithoutEnderecosInput>
    create: XOR<CidadeCreateWithoutEnderecosInput, CidadeUncheckedCreateWithoutEnderecosInput>
    where?: CidadeWhereInput
  }

  export type CidadeUpdateToOneWithWhereWithoutEnderecosInput = {
    where?: CidadeWhereInput
    data: XOR<CidadeUpdateWithoutEnderecosInput, CidadeUncheckedUpdateWithoutEnderecosInput>
  }

  export type CidadeUpdateWithoutEnderecosInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairros?: BairroUpdateManyWithoutCidadeNestedInput
    pais?: PaisUpdateOneRequiredWithoutCidadesNestedInput
    uf?: UnidadeFederacaoUpdateOneRequiredWithoutCidadesNestedInput
    distritos?: DistritoUpdateManyWithoutCidadeNestedInput
  }

  export type CidadeUncheckedUpdateWithoutEnderecosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    cdUf?: StringFieldUpdateOperationsInput | string
    cdPais?: IntFieldUpdateOperationsInput | number
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairros?: BairroUncheckedUpdateManyWithoutCidadeNestedInput
    distritos?: DistritoUncheckedUpdateManyWithoutCidadeNestedInput
  }

  export type EnderecoPacienteUpsertWithWhereUniqueWithoutEnderecoInput = {
    where: EnderecoPacienteWhereUniqueInput
    update: XOR<EnderecoPacienteUpdateWithoutEnderecoInput, EnderecoPacienteUncheckedUpdateWithoutEnderecoInput>
    create: XOR<EnderecoPacienteCreateWithoutEnderecoInput, EnderecoPacienteUncheckedCreateWithoutEnderecoInput>
  }

  export type EnderecoPacienteUpdateWithWhereUniqueWithoutEnderecoInput = {
    where: EnderecoPacienteWhereUniqueInput
    data: XOR<EnderecoPacienteUpdateWithoutEnderecoInput, EnderecoPacienteUncheckedUpdateWithoutEnderecoInput>
  }

  export type EnderecoPacienteUpdateManyWithWhereWithoutEnderecoInput = {
    where: EnderecoPacienteScalarWhereInput
    data: XOR<EnderecoPacienteUpdateManyMutationInput, EnderecoPacienteUncheckedUpdateManyWithoutEnderecoInput>
  }

  export type EnderecoPessoaRelacionadaUpsertWithWhereUniqueWithoutEnderecoInput = {
    where: EnderecoPessoaRelacionadaWhereUniqueInput
    update: XOR<EnderecoPessoaRelacionadaUpdateWithoutEnderecoInput, EnderecoPessoaRelacionadaUncheckedUpdateWithoutEnderecoInput>
    create: XOR<EnderecoPessoaRelacionadaCreateWithoutEnderecoInput, EnderecoPessoaRelacionadaUncheckedCreateWithoutEnderecoInput>
  }

  export type EnderecoPessoaRelacionadaUpdateWithWhereUniqueWithoutEnderecoInput = {
    where: EnderecoPessoaRelacionadaWhereUniqueInput
    data: XOR<EnderecoPessoaRelacionadaUpdateWithoutEnderecoInput, EnderecoPessoaRelacionadaUncheckedUpdateWithoutEnderecoInput>
  }

  export type EnderecoPessoaRelacionadaUpdateManyWithWhereWithoutEnderecoInput = {
    where: EnderecoPessoaRelacionadaScalarWhereInput
    data: XOR<EnderecoPessoaRelacionadaUpdateManyMutationInput, EnderecoPessoaRelacionadaUncheckedUpdateManyWithoutEnderecoInput>
  }

  export type EnderecoPessoaRelacionadaScalarWhereInput = {
    AND?: EnderecoPessoaRelacionadaScalarWhereInput | EnderecoPessoaRelacionadaScalarWhereInput[]
    OR?: EnderecoPessoaRelacionadaScalarWhereInput[]
    NOT?: EnderecoPessoaRelacionadaScalarWhereInput | EnderecoPessoaRelacionadaScalarWhereInput[]
    id?: IntFilter<"EnderecoPessoaRelacionada"> | number
    cdPessoa?: IntFilter<"EnderecoPessoaRelacionada"> | number
    cdEndereco?: IntFilter<"EnderecoPessoaRelacionada"> | number
  }

  export type EnderecoProfissionalUpsertWithWhereUniqueWithoutEnderecoInput = {
    where: EnderecoProfissionalWhereUniqueInput
    update: XOR<EnderecoProfissionalUpdateWithoutEnderecoInput, EnderecoProfissionalUncheckedUpdateWithoutEnderecoInput>
    create: XOR<EnderecoProfissionalCreateWithoutEnderecoInput, EnderecoProfissionalUncheckedCreateWithoutEnderecoInput>
  }

  export type EnderecoProfissionalUpdateWithWhereUniqueWithoutEnderecoInput = {
    where: EnderecoProfissionalWhereUniqueInput
    data: XOR<EnderecoProfissionalUpdateWithoutEnderecoInput, EnderecoProfissionalUncheckedUpdateWithoutEnderecoInput>
  }

  export type EnderecoProfissionalUpdateManyWithWhereWithoutEnderecoInput = {
    where: EnderecoProfissionalScalarWhereInput
    data: XOR<EnderecoProfissionalUpdateManyMutationInput, EnderecoProfissionalUncheckedUpdateManyWithoutEnderecoInput>
  }

  export type EnderecoCreateWithoutPacientesInput = {
    logradouro: string
    numero?: string | null
    complemento?: string | null
    cep: string
    stInativo?: $Enums.SimNao | null
    bairro: BairroCreateNestedOneWithoutEnderecosInput
    cidade: CidadeCreateNestedOneWithoutEnderecosInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaCreateNestedManyWithoutEnderecoInput
    profissionais?: EnderecoProfissionalCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoUncheckedCreateWithoutPacientesInput = {
    id?: number
    logradouro: string
    numero?: string | null
    complemento?: string | null
    cdBairro: number
    cdCidade: number
    cep: string
    stInativo?: $Enums.SimNao | null
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaUncheckedCreateNestedManyWithoutEnderecoInput
    profissionais?: EnderecoProfissionalUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoCreateOrConnectWithoutPacientesInput = {
    where: EnderecoWhereUniqueInput
    create: XOR<EnderecoCreateWithoutPacientesInput, EnderecoUncheckedCreateWithoutPacientesInput>
  }

  export type PacienteCreateWithoutEnderecosInput = {
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    atendimentos?: AtendimentoCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoCreateNestedManyWithoutPacienteInput
    escolaridade?: EscolaridadeCreateNestedOneWithoutPacientesInput
    master: MasterCreateNestedOneWithoutPacientesInput
    ocupacao?: OcupacaoCreateNestedOneWithoutPacientesInput
    parentescoPacientes?: ParentescoPacienteCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutPacienteInput
  }

  export type PacienteUncheckedCreateWithoutEnderecosInput = {
    cdMaster: number
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    cdEscolaridade?: number | null
    cdOcupacao?: number | null
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutPacienteInput
    parentescoPacientes?: ParentescoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type PacienteCreateOrConnectWithoutEnderecosInput = {
    where: PacienteWhereUniqueInput
    create: XOR<PacienteCreateWithoutEnderecosInput, PacienteUncheckedCreateWithoutEnderecosInput>
  }

  export type EnderecoUpsertWithoutPacientesInput = {
    update: XOR<EnderecoUpdateWithoutPacientesInput, EnderecoUncheckedUpdateWithoutPacientesInput>
    create: XOR<EnderecoCreateWithoutPacientesInput, EnderecoUncheckedCreateWithoutPacientesInput>
    where?: EnderecoWhereInput
  }

  export type EnderecoUpdateToOneWithWhereWithoutPacientesInput = {
    where?: EnderecoWhereInput
    data: XOR<EnderecoUpdateWithoutPacientesInput, EnderecoUncheckedUpdateWithoutPacientesInput>
  }

  export type EnderecoUpdateWithoutPacientesInput = {
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairro?: BairroUpdateOneRequiredWithoutEnderecosNestedInput
    cidade?: CidadeUpdateOneRequiredWithoutEnderecosNestedInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaUpdateManyWithoutEnderecoNestedInput
    profissionais?: EnderecoProfissionalUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateWithoutPacientesInput = {
    id?: IntFieldUpdateOperationsInput | number
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cdBairro?: IntFieldUpdateOperationsInput | number
    cdCidade?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaUncheckedUpdateManyWithoutEnderecoNestedInput
    profissionais?: EnderecoProfissionalUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type PacienteUpsertWithoutEnderecosInput = {
    update: XOR<PacienteUpdateWithoutEnderecosInput, PacienteUncheckedUpdateWithoutEnderecosInput>
    create: XOR<PacienteCreateWithoutEnderecosInput, PacienteUncheckedCreateWithoutEnderecosInput>
    where?: PacienteWhereInput
  }

  export type PacienteUpdateToOneWithWhereWithoutEnderecosInput = {
    where?: PacienteWhereInput
    data: XOR<PacienteUpdateWithoutEnderecosInput, PacienteUncheckedUpdateWithoutEnderecosInput>
  }

  export type PacienteUpdateWithoutEnderecosInput = {
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    atendimentos?: AtendimentoUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutPacienteNestedInput
    escolaridade?: EscolaridadeUpdateOneWithoutPacientesNestedInput
    master?: MasterUpdateOneRequiredWithoutPacientesNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutPacientesNestedInput
    parentescoPacientes?: ParentescoPacienteUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateWithoutEnderecosInput = {
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdEscolaridade?: NullableIntFieldUpdateOperationsInput | number | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutPacienteNestedInput
    parentescoPacientes?: ParentescoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type EnderecoCreateWithoutProfissionaisInput = {
    logradouro: string
    numero?: string | null
    complemento?: string | null
    cep: string
    stInativo?: $Enums.SimNao | null
    bairro: BairroCreateNestedOneWithoutEnderecosInput
    cidade: CidadeCreateNestedOneWithoutEnderecosInput
    pacientes?: EnderecoPacienteCreateNestedManyWithoutEnderecoInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoUncheckedCreateWithoutProfissionaisInput = {
    id?: number
    logradouro: string
    numero?: string | null
    complemento?: string | null
    cdBairro: number
    cdCidade: number
    cep: string
    stInativo?: $Enums.SimNao | null
    pacientes?: EnderecoPacienteUncheckedCreateNestedManyWithoutEnderecoInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoCreateOrConnectWithoutProfissionaisInput = {
    where: EnderecoWhereUniqueInput
    create: XOR<EnderecoCreateWithoutProfissionaisInput, EnderecoUncheckedCreateWithoutProfissionaisInput>
  }

  export type ProfissionalCreateWithoutEnderecosInput = {
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowCreateNestedManyWithoutProfissionalInput
    master: MasterCreateNestedOneWithoutProfissionaisInput
    ocupacao?: OcupacaoCreateNestedOneWithoutProfissionalsInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalUncheckedCreateWithoutEnderecosInput = {
    id?: number
    cdMaster: number
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    cdOcupacao?: number | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutProfissionalInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalCreateOrConnectWithoutEnderecosInput = {
    where: ProfissionalWhereUniqueInput
    create: XOR<ProfissionalCreateWithoutEnderecosInput, ProfissionalUncheckedCreateWithoutEnderecosInput>
  }

  export type EnderecoUpsertWithoutProfissionaisInput = {
    update: XOR<EnderecoUpdateWithoutProfissionaisInput, EnderecoUncheckedUpdateWithoutProfissionaisInput>
    create: XOR<EnderecoCreateWithoutProfissionaisInput, EnderecoUncheckedCreateWithoutProfissionaisInput>
    where?: EnderecoWhereInput
  }

  export type EnderecoUpdateToOneWithWhereWithoutProfissionaisInput = {
    where?: EnderecoWhereInput
    data: XOR<EnderecoUpdateWithoutProfissionaisInput, EnderecoUncheckedUpdateWithoutProfissionaisInput>
  }

  export type EnderecoUpdateWithoutProfissionaisInput = {
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairro?: BairroUpdateOneRequiredWithoutEnderecosNestedInput
    cidade?: CidadeUpdateOneRequiredWithoutEnderecosNestedInput
    pacientes?: EnderecoPacienteUpdateManyWithoutEnderecoNestedInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateWithoutProfissionaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cdBairro?: IntFieldUpdateOperationsInput | number
    cdCidade?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: EnderecoPacienteUncheckedUpdateManyWithoutEnderecoNestedInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type ProfissionalUpsertWithoutEnderecosInput = {
    update: XOR<ProfissionalUpdateWithoutEnderecosInput, ProfissionalUncheckedUpdateWithoutEnderecosInput>
    create: XOR<ProfissionalCreateWithoutEnderecosInput, ProfissionalUncheckedCreateWithoutEnderecosInput>
    where?: ProfissionalWhereInput
  }

  export type ProfissionalUpdateToOneWithWhereWithoutEnderecosInput = {
    where?: ProfissionalWhereInput
    data: XOR<ProfissionalUpdateWithoutEnderecosInput, ProfissionalUncheckedUpdateWithoutEnderecosInput>
  }

  export type ProfissionalUpdateWithoutEnderecosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUpdateManyWithoutProfissionalNestedInput
    master?: MasterUpdateOneRequiredWithoutProfissionaisNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutProfissionalsNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutProfissionalNestedInput
  }

  export type ProfissionalUncheckedUpdateWithoutEnderecosInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutProfissionalNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutProfissionalNestedInput
  }

  export type ContatoPacienteCreateWithoutContatoInput = {
    paciente: PacienteCreateNestedOneWithoutContatosInput
  }

  export type ContatoPacienteUncheckedCreateWithoutContatoInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
  }

  export type ContatoPacienteCreateOrConnectWithoutContatoInput = {
    where: ContatoPacienteWhereUniqueInput
    create: XOR<ContatoPacienteCreateWithoutContatoInput, ContatoPacienteUncheckedCreateWithoutContatoInput>
  }

  export type ContatoPacienteCreateManyContatoInputEnvelope = {
    data: ContatoPacienteCreateManyContatoInput | ContatoPacienteCreateManyContatoInput[]
    skipDuplicates?: boolean
  }

  export type ContatoProfissionalCreateWithoutContatoInput = {
    profissional: ProfissionalCreateNestedOneWithoutContatosInput
  }

  export type ContatoProfissionalUncheckedCreateWithoutContatoInput = {
    id?: number
    cdProf: number
  }

  export type ContatoProfissionalCreateOrConnectWithoutContatoInput = {
    where: ContatoProfissionalWhereUniqueInput
    create: XOR<ContatoProfissionalCreateWithoutContatoInput, ContatoProfissionalUncheckedCreateWithoutContatoInput>
  }

  export type ContatoProfissionalCreateManyContatoInputEnvelope = {
    data: ContatoProfissionalCreateManyContatoInput | ContatoProfissionalCreateManyContatoInput[]
    skipDuplicates?: boolean
  }

  export type ContatoPacienteUpsertWithWhereUniqueWithoutContatoInput = {
    where: ContatoPacienteWhereUniqueInput
    update: XOR<ContatoPacienteUpdateWithoutContatoInput, ContatoPacienteUncheckedUpdateWithoutContatoInput>
    create: XOR<ContatoPacienteCreateWithoutContatoInput, ContatoPacienteUncheckedCreateWithoutContatoInput>
  }

  export type ContatoPacienteUpdateWithWhereUniqueWithoutContatoInput = {
    where: ContatoPacienteWhereUniqueInput
    data: XOR<ContatoPacienteUpdateWithoutContatoInput, ContatoPacienteUncheckedUpdateWithoutContatoInput>
  }

  export type ContatoPacienteUpdateManyWithWhereWithoutContatoInput = {
    where: ContatoPacienteScalarWhereInput
    data: XOR<ContatoPacienteUpdateManyMutationInput, ContatoPacienteUncheckedUpdateManyWithoutContatoInput>
  }

  export type ContatoProfissionalUpsertWithWhereUniqueWithoutContatoInput = {
    where: ContatoProfissionalWhereUniqueInput
    update: XOR<ContatoProfissionalUpdateWithoutContatoInput, ContatoProfissionalUncheckedUpdateWithoutContatoInput>
    create: XOR<ContatoProfissionalCreateWithoutContatoInput, ContatoProfissionalUncheckedCreateWithoutContatoInput>
  }

  export type ContatoProfissionalUpdateWithWhereUniqueWithoutContatoInput = {
    where: ContatoProfissionalWhereUniqueInput
    data: XOR<ContatoProfissionalUpdateWithoutContatoInput, ContatoProfissionalUncheckedUpdateWithoutContatoInput>
  }

  export type ContatoProfissionalUpdateManyWithWhereWithoutContatoInput = {
    where: ContatoProfissionalScalarWhereInput
    data: XOR<ContatoProfissionalUpdateManyMutationInput, ContatoProfissionalUncheckedUpdateManyWithoutContatoInput>
  }

  export type ContatoCreateWithoutPacientesInput = {
    tipo: $Enums.TipoFone
    numero: string
    stInativo?: $Enums.SimNao | null
    profissionais?: ContatoProfissionalCreateNestedManyWithoutContatoInput
  }

  export type ContatoUncheckedCreateWithoutPacientesInput = {
    id?: number
    tipo: $Enums.TipoFone
    numero: string
    stInativo?: $Enums.SimNao | null
    profissionais?: ContatoProfissionalUncheckedCreateNestedManyWithoutContatoInput
  }

  export type ContatoCreateOrConnectWithoutPacientesInput = {
    where: ContatoWhereUniqueInput
    create: XOR<ContatoCreateWithoutPacientesInput, ContatoUncheckedCreateWithoutPacientesInput>
  }

  export type PacienteCreateWithoutContatosInput = {
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    atendimentos?: AtendimentoCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoCreateNestedManyWithoutPacienteInput
    escolaridade?: EscolaridadeCreateNestedOneWithoutPacientesInput
    master: MasterCreateNestedOneWithoutPacientesInput
    ocupacao?: OcupacaoCreateNestedOneWithoutPacientesInput
    parentescoPacientes?: ParentescoPacienteCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutPacienteInput
  }

  export type PacienteUncheckedCreateWithoutContatosInput = {
    cdMaster: number
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    cdEscolaridade?: number | null
    cdOcupacao?: number | null
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutPacienteInput
    parentescoPacientes?: ParentescoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type PacienteCreateOrConnectWithoutContatosInput = {
    where: PacienteWhereUniqueInput
    create: XOR<PacienteCreateWithoutContatosInput, PacienteUncheckedCreateWithoutContatosInput>
  }

  export type ContatoUpsertWithoutPacientesInput = {
    update: XOR<ContatoUpdateWithoutPacientesInput, ContatoUncheckedUpdateWithoutPacientesInput>
    create: XOR<ContatoCreateWithoutPacientesInput, ContatoUncheckedCreateWithoutPacientesInput>
    where?: ContatoWhereInput
  }

  export type ContatoUpdateToOneWithWhereWithoutPacientesInput = {
    where?: ContatoWhereInput
    data: XOR<ContatoUpdateWithoutPacientesInput, ContatoUncheckedUpdateWithoutPacientesInput>
  }

  export type ContatoUpdateWithoutPacientesInput = {
    tipo?: EnumTipoFoneFieldUpdateOperationsInput | $Enums.TipoFone
    numero?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    profissionais?: ContatoProfissionalUpdateManyWithoutContatoNestedInput
  }

  export type ContatoUncheckedUpdateWithoutPacientesInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoFoneFieldUpdateOperationsInput | $Enums.TipoFone
    numero?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    profissionais?: ContatoProfissionalUncheckedUpdateManyWithoutContatoNestedInput
  }

  export type PacienteUpsertWithoutContatosInput = {
    update: XOR<PacienteUpdateWithoutContatosInput, PacienteUncheckedUpdateWithoutContatosInput>
    create: XOR<PacienteCreateWithoutContatosInput, PacienteUncheckedCreateWithoutContatosInput>
    where?: PacienteWhereInput
  }

  export type PacienteUpdateToOneWithWhereWithoutContatosInput = {
    where?: PacienteWhereInput
    data: XOR<PacienteUpdateWithoutContatosInput, PacienteUncheckedUpdateWithoutContatosInput>
  }

  export type PacienteUpdateWithoutContatosInput = {
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    atendimentos?: AtendimentoUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutPacienteNestedInput
    escolaridade?: EscolaridadeUpdateOneWithoutPacientesNestedInput
    master?: MasterUpdateOneRequiredWithoutPacientesNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutPacientesNestedInput
    parentescoPacientes?: ParentescoPacienteUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateWithoutContatosInput = {
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdEscolaridade?: NullableIntFieldUpdateOperationsInput | number | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutPacienteNestedInput
    parentescoPacientes?: ParentescoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type ContatoCreateWithoutProfissionaisInput = {
    tipo: $Enums.TipoFone
    numero: string
    stInativo?: $Enums.SimNao | null
    pacientes?: ContatoPacienteCreateNestedManyWithoutContatoInput
  }

  export type ContatoUncheckedCreateWithoutProfissionaisInput = {
    id?: number
    tipo: $Enums.TipoFone
    numero: string
    stInativo?: $Enums.SimNao | null
    pacientes?: ContatoPacienteUncheckedCreateNestedManyWithoutContatoInput
  }

  export type ContatoCreateOrConnectWithoutProfissionaisInput = {
    where: ContatoWhereUniqueInput
    create: XOR<ContatoCreateWithoutProfissionaisInput, ContatoUncheckedCreateWithoutProfissionaisInput>
  }

  export type ProfissionalCreateWithoutContatosInput = {
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowCreateNestedManyWithoutProfissionalInput
    master: MasterCreateNestedOneWithoutProfissionaisInput
    ocupacao?: OcupacaoCreateNestedOneWithoutProfissionalsInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalUncheckedCreateWithoutContatosInput = {
    id?: number
    cdMaster: number
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    cdOcupacao?: number | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutProfissionalInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalCreateOrConnectWithoutContatosInput = {
    where: ProfissionalWhereUniqueInput
    create: XOR<ProfissionalCreateWithoutContatosInput, ProfissionalUncheckedCreateWithoutContatosInput>
  }

  export type ContatoUpsertWithoutProfissionaisInput = {
    update: XOR<ContatoUpdateWithoutProfissionaisInput, ContatoUncheckedUpdateWithoutProfissionaisInput>
    create: XOR<ContatoCreateWithoutProfissionaisInput, ContatoUncheckedCreateWithoutProfissionaisInput>
    where?: ContatoWhereInput
  }

  export type ContatoUpdateToOneWithWhereWithoutProfissionaisInput = {
    where?: ContatoWhereInput
    data: XOR<ContatoUpdateWithoutProfissionaisInput, ContatoUncheckedUpdateWithoutProfissionaisInput>
  }

  export type ContatoUpdateWithoutProfissionaisInput = {
    tipo?: EnumTipoFoneFieldUpdateOperationsInput | $Enums.TipoFone
    numero?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: ContatoPacienteUpdateManyWithoutContatoNestedInput
  }

  export type ContatoUncheckedUpdateWithoutProfissionaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoFoneFieldUpdateOperationsInput | $Enums.TipoFone
    numero?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: ContatoPacienteUncheckedUpdateManyWithoutContatoNestedInput
  }

  export type ProfissionalUpsertWithoutContatosInput = {
    update: XOR<ProfissionalUpdateWithoutContatosInput, ProfissionalUncheckedUpdateWithoutContatosInput>
    create: XOR<ProfissionalCreateWithoutContatosInput, ProfissionalUncheckedCreateWithoutContatosInput>
    where?: ProfissionalWhereInput
  }

  export type ProfissionalUpdateToOneWithWhereWithoutContatosInput = {
    where?: ProfissionalWhereInput
    data: XOR<ProfissionalUpdateWithoutContatosInput, ProfissionalUncheckedUpdateWithoutContatosInput>
  }

  export type ProfissionalUpdateWithoutContatosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUpdateManyWithoutProfissionalNestedInput
    master?: MasterUpdateOneRequiredWithoutProfissionaisNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutProfissionalsNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutProfissionalNestedInput
  }

  export type ProfissionalUncheckedUpdateWithoutContatosInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutProfissionalNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutProfissionalNestedInput
  }

  export type AfericaoClinicaCreateWithoutAtendimentoInput = {
    escala: string
    idRegistro: number
    data?: Date | string
    profissional?: ProfissionalCreateNestedOneWithoutAfericoesClinicasInput
  }

  export type AfericaoClinicaUncheckedCreateWithoutAtendimentoInput = {
    id?: number
    cdProfissional?: number | null
    escala: string
    idRegistro: number
    data?: Date | string
  }

  export type AfericaoClinicaCreateOrConnectWithoutAtendimentoInput = {
    where: AfericaoClinicaWhereUniqueInput
    create: XOR<AfericaoClinicaCreateWithoutAtendimentoInput, AfericaoClinicaUncheckedCreateWithoutAtendimentoInput>
  }

  export type AfericaoClinicaCreateManyAtendimentoInputEnvelope = {
    data: AfericaoClinicaCreateManyAtendimentoInput | AfericaoClinicaCreateManyAtendimentoInput[]
    skipDuplicates?: boolean
  }

  export type PacienteCreateWithoutAtendimentosInput = {
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    contatos?: ContatoPacienteCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoCreateNestedManyWithoutPacienteInput
    escolaridade?: EscolaridadeCreateNestedOneWithoutPacientesInput
    master: MasterCreateNestedOneWithoutPacientesInput
    ocupacao?: OcupacaoCreateNestedOneWithoutPacientesInput
    parentescoPacientes?: ParentescoPacienteCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutPacienteInput
  }

  export type PacienteUncheckedCreateWithoutAtendimentosInput = {
    cdMaster: number
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    cdEscolaridade?: number | null
    cdOcupacao?: number | null
    contatos?: ContatoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutPacienteInput
    parentescoPacientes?: ParentescoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type PacienteCreateOrConnectWithoutAtendimentosInput = {
    where: PacienteWhereUniqueInput
    create: XOR<PacienteCreateWithoutAtendimentosInput, PacienteUncheckedCreateWithoutAtendimentosInput>
  }

  export type ProfissionalCreateWithoutAtendimentosInput = {
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowCreateNestedManyWithoutProfissionalInput
    master: MasterCreateNestedOneWithoutProfissionaisInput
    ocupacao?: OcupacaoCreateNestedOneWithoutProfissionalsInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalUncheckedCreateWithoutAtendimentosInput = {
    id?: number
    cdMaster: number
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    cdOcupacao?: number | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutProfissionalInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalCreateOrConnectWithoutAtendimentosInput = {
    where: ProfissionalWhereUniqueInput
    create: XOR<ProfissionalCreateWithoutAtendimentosInput, ProfissionalUncheckedCreateWithoutAtendimentosInput>
  }

  export type EvaDorCreateWithoutAtendimentoInput = {
    data?: Date | string
    valor: number
    observacao?: string | null
    profissional?: ProfissionalCreateNestedOneWithoutEvaDoresInput
  }

  export type EvaDorUncheckedCreateWithoutAtendimentoInput = {
    id?: number
    cdProfissional?: number | null
    data?: Date | string
    valor: number
    observacao?: string | null
  }

  export type EvaDorCreateOrConnectWithoutAtendimentoInput = {
    where: EvaDorWhereUniqueInput
    create: XOR<EvaDorCreateWithoutAtendimentoInput, EvaDorUncheckedCreateWithoutAtendimentoInput>
  }

  export type EvaDorCreateManyAtendimentoInputEnvelope = {
    data: EvaDorCreateManyAtendimentoInput | EvaDorCreateManyAtendimentoInput[]
    skipDuplicates?: boolean
  }

  export type EvolucaoCreateWithoutAtendimentoInput = {
    data: Date | string
    texto: string
    profissional?: ProfissionalCreateNestedOneWithoutEvolucoesInput
    paciente?: PacienteCreateNestedOneWithoutEvolucoesInput
    tipoEvolucaoClinica?: TipoEvolucaoClinicaCreateNestedOneWithoutEvolucaosInput
    cid?: EvolucaoCidCreateNestedManyWithoutEvolucaoInput
    dsm?: EvolucaoDsmCreateNestedManyWithoutEvolucaoInput
  }

  export type EvolucaoUncheckedCreateWithoutAtendimentoInput = {
    id?: number
    cdProfissional?: number | null
    data: Date | string
    texto: string
    pacienteCdMaster?: number | null
    pacienteCdPaciente?: number | null
    tipoEvolucaoClinicaId?: number | null
    cid?: EvolucaoCidUncheckedCreateNestedManyWithoutEvolucaoInput
    dsm?: EvolucaoDsmUncheckedCreateNestedManyWithoutEvolucaoInput
  }

  export type EvolucaoCreateOrConnectWithoutAtendimentoInput = {
    where: EvolucaoWhereUniqueInput
    create: XOR<EvolucaoCreateWithoutAtendimentoInput, EvolucaoUncheckedCreateWithoutAtendimentoInput>
  }

  export type EvolucaoCreateManyAtendimentoInputEnvelope = {
    data: EvolucaoCreateManyAtendimentoInput | EvolucaoCreateManyAtendimentoInput[]
    skipDuplicates?: boolean
  }

  export type GlasgowCreateWithoutAtendimentoInput = {
    data?: Date | string
    ocular: number
    verbal: number
    motora: number
    total: number
    observacao?: string | null
    profissional?: ProfissionalCreateNestedOneWithoutGlasgowsInput
  }

  export type GlasgowUncheckedCreateWithoutAtendimentoInput = {
    id?: number
    cdProfissional?: number | null
    data?: Date | string
    ocular: number
    verbal: number
    motora: number
    total: number
    observacao?: string | null
  }

  export type GlasgowCreateOrConnectWithoutAtendimentoInput = {
    where: GlasgowWhereUniqueInput
    create: XOR<GlasgowCreateWithoutAtendimentoInput, GlasgowUncheckedCreateWithoutAtendimentoInput>
  }

  export type GlasgowCreateManyAtendimentoInputEnvelope = {
    data: GlasgowCreateManyAtendimentoInput | GlasgowCreateManyAtendimentoInput[]
    skipDuplicates?: boolean
  }

  export type SinaisVitaisCreateWithoutAtendimentoInput = {
    data?: Date | string
    paSistolica?: number | null
    paDiastolica?: number | null
    fc?: number | null
    fr?: number | null
    temperatura?: Decimal | DecimalJsLike | number | string | null
    spo2?: number | null
    peso?: Decimal | DecimalJsLike | number | string | null
    altura?: Decimal | DecimalJsLike | number | string | null
    imc?: Decimal | DecimalJsLike | number | string | null
    dor?: number | null
    posicao?: $Enums.PosicaoPaciente | null
    origem?: $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
    escalaDor?: EscalaDorCreateNestedOneWithoutSinaisVitaisInput
  }

  export type SinaisVitaisUncheckedCreateWithoutAtendimentoInput = {
    id?: number
    data?: Date | string
    paSistolica?: number | null
    paDiastolica?: number | null
    fc?: number | null
    fr?: number | null
    temperatura?: Decimal | DecimalJsLike | number | string | null
    spo2?: number | null
    peso?: Decimal | DecimalJsLike | number | string | null
    altura?: Decimal | DecimalJsLike | number | string | null
    imc?: Decimal | DecimalJsLike | number | string | null
    dor?: number | null
    escalaDorId?: number | null
    posicao?: $Enums.PosicaoPaciente | null
    origem?: $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SinaisVitaisCreateOrConnectWithoutAtendimentoInput = {
    where: SinaisVitaisWhereUniqueInput
    create: XOR<SinaisVitaisCreateWithoutAtendimentoInput, SinaisVitaisUncheckedCreateWithoutAtendimentoInput>
  }

  export type SinaisVitaisCreateManyAtendimentoInputEnvelope = {
    data: SinaisVitaisCreateManyAtendimentoInput | SinaisVitaisCreateManyAtendimentoInput[]
    skipDuplicates?: boolean
  }

  export type AfericaoClinicaUpsertWithWhereUniqueWithoutAtendimentoInput = {
    where: AfericaoClinicaWhereUniqueInput
    update: XOR<AfericaoClinicaUpdateWithoutAtendimentoInput, AfericaoClinicaUncheckedUpdateWithoutAtendimentoInput>
    create: XOR<AfericaoClinicaCreateWithoutAtendimentoInput, AfericaoClinicaUncheckedCreateWithoutAtendimentoInput>
  }

  export type AfericaoClinicaUpdateWithWhereUniqueWithoutAtendimentoInput = {
    where: AfericaoClinicaWhereUniqueInput
    data: XOR<AfericaoClinicaUpdateWithoutAtendimentoInput, AfericaoClinicaUncheckedUpdateWithoutAtendimentoInput>
  }

  export type AfericaoClinicaUpdateManyWithWhereWithoutAtendimentoInput = {
    where: AfericaoClinicaScalarWhereInput
    data: XOR<AfericaoClinicaUpdateManyMutationInput, AfericaoClinicaUncheckedUpdateManyWithoutAtendimentoInput>
  }

  export type PacienteUpsertWithoutAtendimentosInput = {
    update: XOR<PacienteUpdateWithoutAtendimentosInput, PacienteUncheckedUpdateWithoutAtendimentosInput>
    create: XOR<PacienteCreateWithoutAtendimentosInput, PacienteUncheckedCreateWithoutAtendimentosInput>
    where?: PacienteWhereInput
  }

  export type PacienteUpdateToOneWithWhereWithoutAtendimentosInput = {
    where?: PacienteWhereInput
    data: XOR<PacienteUpdateWithoutAtendimentosInput, PacienteUncheckedUpdateWithoutAtendimentosInput>
  }

  export type PacienteUpdateWithoutAtendimentosInput = {
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    contatos?: ContatoPacienteUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutPacienteNestedInput
    escolaridade?: EscolaridadeUpdateOneWithoutPacientesNestedInput
    master?: MasterUpdateOneRequiredWithoutPacientesNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutPacientesNestedInput
    parentescoPacientes?: ParentescoPacienteUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateWithoutAtendimentosInput = {
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdEscolaridade?: NullableIntFieldUpdateOperationsInput | number | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    contatos?: ContatoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutPacienteNestedInput
    parentescoPacientes?: ParentescoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type ProfissionalUpsertWithoutAtendimentosInput = {
    update: XOR<ProfissionalUpdateWithoutAtendimentosInput, ProfissionalUncheckedUpdateWithoutAtendimentosInput>
    create: XOR<ProfissionalCreateWithoutAtendimentosInput, ProfissionalUncheckedCreateWithoutAtendimentosInput>
    where?: ProfissionalWhereInput
  }

  export type ProfissionalUpdateToOneWithWhereWithoutAtendimentosInput = {
    where?: ProfissionalWhereInput
    data: XOR<ProfissionalUpdateWithoutAtendimentosInput, ProfissionalUncheckedUpdateWithoutAtendimentosInput>
  }

  export type ProfissionalUpdateWithoutAtendimentosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUpdateManyWithoutProfissionalNestedInput
    master?: MasterUpdateOneRequiredWithoutProfissionaisNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutProfissionalsNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutProfissionalNestedInput
  }

  export type ProfissionalUncheckedUpdateWithoutAtendimentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutProfissionalNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutProfissionalNestedInput
  }

  export type EvaDorUpsertWithWhereUniqueWithoutAtendimentoInput = {
    where: EvaDorWhereUniqueInput
    update: XOR<EvaDorUpdateWithoutAtendimentoInput, EvaDorUncheckedUpdateWithoutAtendimentoInput>
    create: XOR<EvaDorCreateWithoutAtendimentoInput, EvaDorUncheckedCreateWithoutAtendimentoInput>
  }

  export type EvaDorUpdateWithWhereUniqueWithoutAtendimentoInput = {
    where: EvaDorWhereUniqueInput
    data: XOR<EvaDorUpdateWithoutAtendimentoInput, EvaDorUncheckedUpdateWithoutAtendimentoInput>
  }

  export type EvaDorUpdateManyWithWhereWithoutAtendimentoInput = {
    where: EvaDorScalarWhereInput
    data: XOR<EvaDorUpdateManyMutationInput, EvaDorUncheckedUpdateManyWithoutAtendimentoInput>
  }

  export type EvolucaoUpsertWithWhereUniqueWithoutAtendimentoInput = {
    where: EvolucaoWhereUniqueInput
    update: XOR<EvolucaoUpdateWithoutAtendimentoInput, EvolucaoUncheckedUpdateWithoutAtendimentoInput>
    create: XOR<EvolucaoCreateWithoutAtendimentoInput, EvolucaoUncheckedCreateWithoutAtendimentoInput>
  }

  export type EvolucaoUpdateWithWhereUniqueWithoutAtendimentoInput = {
    where: EvolucaoWhereUniqueInput
    data: XOR<EvolucaoUpdateWithoutAtendimentoInput, EvolucaoUncheckedUpdateWithoutAtendimentoInput>
  }

  export type EvolucaoUpdateManyWithWhereWithoutAtendimentoInput = {
    where: EvolucaoScalarWhereInput
    data: XOR<EvolucaoUpdateManyMutationInput, EvolucaoUncheckedUpdateManyWithoutAtendimentoInput>
  }

  export type GlasgowUpsertWithWhereUniqueWithoutAtendimentoInput = {
    where: GlasgowWhereUniqueInput
    update: XOR<GlasgowUpdateWithoutAtendimentoInput, GlasgowUncheckedUpdateWithoutAtendimentoInput>
    create: XOR<GlasgowCreateWithoutAtendimentoInput, GlasgowUncheckedCreateWithoutAtendimentoInput>
  }

  export type GlasgowUpdateWithWhereUniqueWithoutAtendimentoInput = {
    where: GlasgowWhereUniqueInput
    data: XOR<GlasgowUpdateWithoutAtendimentoInput, GlasgowUncheckedUpdateWithoutAtendimentoInput>
  }

  export type GlasgowUpdateManyWithWhereWithoutAtendimentoInput = {
    where: GlasgowScalarWhereInput
    data: XOR<GlasgowUpdateManyMutationInput, GlasgowUncheckedUpdateManyWithoutAtendimentoInput>
  }

  export type SinaisVitaisUpsertWithWhereUniqueWithoutAtendimentoInput = {
    where: SinaisVitaisWhereUniqueInput
    update: XOR<SinaisVitaisUpdateWithoutAtendimentoInput, SinaisVitaisUncheckedUpdateWithoutAtendimentoInput>
    create: XOR<SinaisVitaisCreateWithoutAtendimentoInput, SinaisVitaisUncheckedCreateWithoutAtendimentoInput>
  }

  export type SinaisVitaisUpdateWithWhereUniqueWithoutAtendimentoInput = {
    where: SinaisVitaisWhereUniqueInput
    data: XOR<SinaisVitaisUpdateWithoutAtendimentoInput, SinaisVitaisUncheckedUpdateWithoutAtendimentoInput>
  }

  export type SinaisVitaisUpdateManyWithWhereWithoutAtendimentoInput = {
    where: SinaisVitaisScalarWhereInput
    data: XOR<SinaisVitaisUpdateManyMutationInput, SinaisVitaisUncheckedUpdateManyWithoutAtendimentoInput>
  }

  export type SinaisVitaisScalarWhereInput = {
    AND?: SinaisVitaisScalarWhereInput | SinaisVitaisScalarWhereInput[]
    OR?: SinaisVitaisScalarWhereInput[]
    NOT?: SinaisVitaisScalarWhereInput | SinaisVitaisScalarWhereInput[]
    id?: IntFilter<"SinaisVitais"> | number
    cdAtendimento?: IntFilter<"SinaisVitais"> | number
    data?: DateTimeFilter<"SinaisVitais"> | Date | string
    paSistolica?: IntNullableFilter<"SinaisVitais"> | number | null
    paDiastolica?: IntNullableFilter<"SinaisVitais"> | number | null
    fc?: IntNullableFilter<"SinaisVitais"> | number | null
    fr?: IntNullableFilter<"SinaisVitais"> | number | null
    temperatura?: DecimalNullableFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    spo2?: IntNullableFilter<"SinaisVitais"> | number | null
    peso?: DecimalNullableFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    altura?: DecimalNullableFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    imc?: DecimalNullableFilter<"SinaisVitais"> | Decimal | DecimalJsLike | number | string | null
    dor?: IntNullableFilter<"SinaisVitais"> | number | null
    escalaDorId?: IntNullableFilter<"SinaisVitais"> | number | null
    posicao?: EnumPosicaoPacienteNullableFilter<"SinaisVitais"> | $Enums.PosicaoPaciente | null
    origem?: EnumOrigemAfericaoNullableFilter<"SinaisVitais"> | $Enums.OrigemAfericao | null
    metadataRaw?: JsonNullableFilter<"SinaisVitais">
  }

  export type AtendimentoCreateWithoutEvolucoesInput = {
    data: Date | string
    observacao?: string | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutAtendimentoInput
    paciente: PacienteCreateNestedOneWithoutAtendimentosInput
    profissional: ProfissionalCreateNestedOneWithoutAtendimentosInput
    evaDores?: EvaDorCreateNestedManyWithoutAtendimentoInput
    glasgows?: GlasgowCreateNestedManyWithoutAtendimentoInput
    sinaisVitais?: SinaisVitaisCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoUncheckedCreateWithoutEvolucoesInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    cdProfissional: number
    data: Date | string
    observacao?: string | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutAtendimentoInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutAtendimentoInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutAtendimentoInput
    sinaisVitais?: SinaisVitaisUncheckedCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoCreateOrConnectWithoutEvolucoesInput = {
    where: AtendimentoWhereUniqueInput
    create: XOR<AtendimentoCreateWithoutEvolucoesInput, AtendimentoUncheckedCreateWithoutEvolucoesInput>
  }

  export type ProfissionalCreateWithoutEvolucoesInput = {
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowCreateNestedManyWithoutProfissionalInput
    master: MasterCreateNestedOneWithoutProfissionaisInput
    ocupacao?: OcupacaoCreateNestedOneWithoutProfissionalsInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalUncheckedCreateWithoutEvolucoesInput = {
    id?: number
    cdMaster: number
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    cdOcupacao?: number | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutProfissionalInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalCreateOrConnectWithoutEvolucoesInput = {
    where: ProfissionalWhereUniqueInput
    create: XOR<ProfissionalCreateWithoutEvolucoesInput, ProfissionalUncheckedCreateWithoutEvolucoesInput>
  }

  export type PacienteCreateWithoutEvolucoesInput = {
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    atendimentos?: AtendimentoCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteCreateNestedManyWithoutPacienteInput
    escolaridade?: EscolaridadeCreateNestedOneWithoutPacientesInput
    master: MasterCreateNestedOneWithoutPacientesInput
    ocupacao?: OcupacaoCreateNestedOneWithoutPacientesInput
    parentescoPacientes?: ParentescoPacienteCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutPacienteInput
  }

  export type PacienteUncheckedCreateWithoutEvolucoesInput = {
    cdMaster: number
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    cdEscolaridade?: number | null
    cdOcupacao?: number | null
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    parentescoPacientes?: ParentescoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type PacienteCreateOrConnectWithoutEvolucoesInput = {
    where: PacienteWhereUniqueInput
    create: XOR<PacienteCreateWithoutEvolucoesInput, PacienteUncheckedCreateWithoutEvolucoesInput>
  }

  export type TipoEvolucaoClinicaCreateWithoutEvolucaosInput = {
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type TipoEvolucaoClinicaUncheckedCreateWithoutEvolucaosInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type TipoEvolucaoClinicaCreateOrConnectWithoutEvolucaosInput = {
    where: TipoEvolucaoClinicaWhereUniqueInput
    create: XOR<TipoEvolucaoClinicaCreateWithoutEvolucaosInput, TipoEvolucaoClinicaUncheckedCreateWithoutEvolucaosInput>
  }

  export type EvolucaoCidCreateWithoutEvolucaoInput = {
    cid: CidCreateNestedOneWithoutEvolucaoCidsInput
  }

  export type EvolucaoCidUncheckedCreateWithoutEvolucaoInput = {
    id?: number
    cdCid: number
  }

  export type EvolucaoCidCreateOrConnectWithoutEvolucaoInput = {
    where: EvolucaoCidWhereUniqueInput
    create: XOR<EvolucaoCidCreateWithoutEvolucaoInput, EvolucaoCidUncheckedCreateWithoutEvolucaoInput>
  }

  export type EvolucaoCidCreateManyEvolucaoInputEnvelope = {
    data: EvolucaoCidCreateManyEvolucaoInput | EvolucaoCidCreateManyEvolucaoInput[]
    skipDuplicates?: boolean
  }

  export type EvolucaoDsmCreateWithoutEvolucaoInput = {
    dsm: DsmCreateNestedOneWithoutEvolucaoDsmsInput
  }

  export type EvolucaoDsmUncheckedCreateWithoutEvolucaoInput = {
    id?: number
    cdDsm: number
  }

  export type EvolucaoDsmCreateOrConnectWithoutEvolucaoInput = {
    where: EvolucaoDsmWhereUniqueInput
    create: XOR<EvolucaoDsmCreateWithoutEvolucaoInput, EvolucaoDsmUncheckedCreateWithoutEvolucaoInput>
  }

  export type EvolucaoDsmCreateManyEvolucaoInputEnvelope = {
    data: EvolucaoDsmCreateManyEvolucaoInput | EvolucaoDsmCreateManyEvolucaoInput[]
    skipDuplicates?: boolean
  }

  export type AtendimentoUpsertWithoutEvolucoesInput = {
    update: XOR<AtendimentoUpdateWithoutEvolucoesInput, AtendimentoUncheckedUpdateWithoutEvolucoesInput>
    create: XOR<AtendimentoCreateWithoutEvolucoesInput, AtendimentoUncheckedCreateWithoutEvolucoesInput>
    where?: AtendimentoWhereInput
  }

  export type AtendimentoUpdateToOneWithWhereWithoutEvolucoesInput = {
    where?: AtendimentoWhereInput
    data: XOR<AtendimentoUpdateWithoutEvolucoesInput, AtendimentoUncheckedUpdateWithoutEvolucoesInput>
  }

  export type AtendimentoUpdateWithoutEvolucoesInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutAtendimentoNestedInput
    paciente?: PacienteUpdateOneRequiredWithoutAtendimentosNestedInput
    profissional?: ProfissionalUpdateOneRequiredWithoutAtendimentosNestedInput
    evaDores?: EvaDorUpdateManyWithoutAtendimentoNestedInput
    glasgows?: GlasgowUpdateManyWithoutAtendimentoNestedInput
    sinaisVitais?: SinaisVitaisUpdateManyWithoutAtendimentoNestedInput
  }

  export type AtendimentoUncheckedUpdateWithoutEvolucoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    cdProfissional?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutAtendimentoNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutAtendimentoNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutAtendimentoNestedInput
    sinaisVitais?: SinaisVitaisUncheckedUpdateManyWithoutAtendimentoNestedInput
  }

  export type ProfissionalUpsertWithoutEvolucoesInput = {
    update: XOR<ProfissionalUpdateWithoutEvolucoesInput, ProfissionalUncheckedUpdateWithoutEvolucoesInput>
    create: XOR<ProfissionalCreateWithoutEvolucoesInput, ProfissionalUncheckedCreateWithoutEvolucoesInput>
    where?: ProfissionalWhereInput
  }

  export type ProfissionalUpdateToOneWithWhereWithoutEvolucoesInput = {
    where?: ProfissionalWhereInput
    data: XOR<ProfissionalUpdateWithoutEvolucoesInput, ProfissionalUncheckedUpdateWithoutEvolucoesInput>
  }

  export type ProfissionalUpdateWithoutEvolucoesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUpdateManyWithoutProfissionalNestedInput
    master?: MasterUpdateOneRequiredWithoutProfissionaisNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutProfissionalsNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutProfissionalNestedInput
  }

  export type ProfissionalUncheckedUpdateWithoutEvolucoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutProfissionalNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutProfissionalNestedInput
  }

  export type PacienteUpsertWithoutEvolucoesInput = {
    update: XOR<PacienteUpdateWithoutEvolucoesInput, PacienteUncheckedUpdateWithoutEvolucoesInput>
    create: XOR<PacienteCreateWithoutEvolucoesInput, PacienteUncheckedCreateWithoutEvolucoesInput>
    where?: PacienteWhereInput
  }

  export type PacienteUpdateToOneWithWhereWithoutEvolucoesInput = {
    where?: PacienteWhereInput
    data: XOR<PacienteUpdateWithoutEvolucoesInput, PacienteUncheckedUpdateWithoutEvolucoesInput>
  }

  export type PacienteUpdateWithoutEvolucoesInput = {
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    atendimentos?: AtendimentoUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUpdateManyWithoutPacienteNestedInput
    escolaridade?: EscolaridadeUpdateOneWithoutPacientesNestedInput
    master?: MasterUpdateOneRequiredWithoutPacientesNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutPacientesNestedInput
    parentescoPacientes?: ParentescoPacienteUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateWithoutEvolucoesInput = {
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdEscolaridade?: NullableIntFieldUpdateOperationsInput | number | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    parentescoPacientes?: ParentescoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type TipoEvolucaoClinicaUpsertWithoutEvolucaosInput = {
    update: XOR<TipoEvolucaoClinicaUpdateWithoutEvolucaosInput, TipoEvolucaoClinicaUncheckedUpdateWithoutEvolucaosInput>
    create: XOR<TipoEvolucaoClinicaCreateWithoutEvolucaosInput, TipoEvolucaoClinicaUncheckedCreateWithoutEvolucaosInput>
    where?: TipoEvolucaoClinicaWhereInput
  }

  export type TipoEvolucaoClinicaUpdateToOneWithWhereWithoutEvolucaosInput = {
    where?: TipoEvolucaoClinicaWhereInput
    data: XOR<TipoEvolucaoClinicaUpdateWithoutEvolucaosInput, TipoEvolucaoClinicaUncheckedUpdateWithoutEvolucaosInput>
  }

  export type TipoEvolucaoClinicaUpdateWithoutEvolucaosInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type TipoEvolucaoClinicaUncheckedUpdateWithoutEvolucaosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type EvolucaoCidUpsertWithWhereUniqueWithoutEvolucaoInput = {
    where: EvolucaoCidWhereUniqueInput
    update: XOR<EvolucaoCidUpdateWithoutEvolucaoInput, EvolucaoCidUncheckedUpdateWithoutEvolucaoInput>
    create: XOR<EvolucaoCidCreateWithoutEvolucaoInput, EvolucaoCidUncheckedCreateWithoutEvolucaoInput>
  }

  export type EvolucaoCidUpdateWithWhereUniqueWithoutEvolucaoInput = {
    where: EvolucaoCidWhereUniqueInput
    data: XOR<EvolucaoCidUpdateWithoutEvolucaoInput, EvolucaoCidUncheckedUpdateWithoutEvolucaoInput>
  }

  export type EvolucaoCidUpdateManyWithWhereWithoutEvolucaoInput = {
    where: EvolucaoCidScalarWhereInput
    data: XOR<EvolucaoCidUpdateManyMutationInput, EvolucaoCidUncheckedUpdateManyWithoutEvolucaoInput>
  }

  export type EvolucaoCidScalarWhereInput = {
    AND?: EvolucaoCidScalarWhereInput | EvolucaoCidScalarWhereInput[]
    OR?: EvolucaoCidScalarWhereInput[]
    NOT?: EvolucaoCidScalarWhereInput | EvolucaoCidScalarWhereInput[]
    id?: IntFilter<"EvolucaoCid"> | number
    cdEvolucao?: IntFilter<"EvolucaoCid"> | number
    cdCid?: IntFilter<"EvolucaoCid"> | number
  }

  export type EvolucaoDsmUpsertWithWhereUniqueWithoutEvolucaoInput = {
    where: EvolucaoDsmWhereUniqueInput
    update: XOR<EvolucaoDsmUpdateWithoutEvolucaoInput, EvolucaoDsmUncheckedUpdateWithoutEvolucaoInput>
    create: XOR<EvolucaoDsmCreateWithoutEvolucaoInput, EvolucaoDsmUncheckedCreateWithoutEvolucaoInput>
  }

  export type EvolucaoDsmUpdateWithWhereUniqueWithoutEvolucaoInput = {
    where: EvolucaoDsmWhereUniqueInput
    data: XOR<EvolucaoDsmUpdateWithoutEvolucaoInput, EvolucaoDsmUncheckedUpdateWithoutEvolucaoInput>
  }

  export type EvolucaoDsmUpdateManyWithWhereWithoutEvolucaoInput = {
    where: EvolucaoDsmScalarWhereInput
    data: XOR<EvolucaoDsmUpdateManyMutationInput, EvolucaoDsmUncheckedUpdateManyWithoutEvolucaoInput>
  }

  export type EvolucaoDsmScalarWhereInput = {
    AND?: EvolucaoDsmScalarWhereInput | EvolucaoDsmScalarWhereInput[]
    OR?: EvolucaoDsmScalarWhereInput[]
    NOT?: EvolucaoDsmScalarWhereInput | EvolucaoDsmScalarWhereInput[]
    id?: IntFilter<"EvolucaoDsm"> | number
    cdEvolucao?: IntFilter<"EvolucaoDsm"> | number
    cdDsm?: IntFilter<"EvolucaoDsm"> | number
  }

  export type EnderecoPessoaRelacionadaCreateWithoutPessoaRelacionadaInput = {
    endereco: EnderecoCreateNestedOneWithoutEnderecoPessoaRelacionadasInput
  }

  export type EnderecoPessoaRelacionadaUncheckedCreateWithoutPessoaRelacionadaInput = {
    id?: number
    cdEndereco: number
  }

  export type EnderecoPessoaRelacionadaCreateOrConnectWithoutPessoaRelacionadaInput = {
    where: EnderecoPessoaRelacionadaWhereUniqueInput
    create: XOR<EnderecoPessoaRelacionadaCreateWithoutPessoaRelacionadaInput, EnderecoPessoaRelacionadaUncheckedCreateWithoutPessoaRelacionadaInput>
  }

  export type EnderecoPessoaRelacionadaCreateManyPessoaRelacionadaInputEnvelope = {
    data: EnderecoPessoaRelacionadaCreateManyPessoaRelacionadaInput | EnderecoPessoaRelacionadaCreateManyPessoaRelacionadaInput[]
    skipDuplicates?: boolean
  }

  export type ParentescoPacienteCreateWithoutPessoaRelacionadaInput = {
    parentesco: $Enums.TipoParentesco
    paciente: PacienteCreateNestedOneWithoutParentescoPacientesInput
  }

  export type ParentescoPacienteUncheckedCreateWithoutPessoaRelacionadaInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    parentesco: $Enums.TipoParentesco
  }

  export type ParentescoPacienteCreateOrConnectWithoutPessoaRelacionadaInput = {
    where: ParentescoPacienteWhereUniqueInput
    create: XOR<ParentescoPacienteCreateWithoutPessoaRelacionadaInput, ParentescoPacienteUncheckedCreateWithoutPessoaRelacionadaInput>
  }

  export type ParentescoPacienteCreateManyPessoaRelacionadaInputEnvelope = {
    data: ParentescoPacienteCreateManyPessoaRelacionadaInput | ParentescoPacienteCreateManyPessoaRelacionadaInput[]
    skipDuplicates?: boolean
  }

  export type EnderecoPessoaRelacionadaUpsertWithWhereUniqueWithoutPessoaRelacionadaInput = {
    where: EnderecoPessoaRelacionadaWhereUniqueInput
    update: XOR<EnderecoPessoaRelacionadaUpdateWithoutPessoaRelacionadaInput, EnderecoPessoaRelacionadaUncheckedUpdateWithoutPessoaRelacionadaInput>
    create: XOR<EnderecoPessoaRelacionadaCreateWithoutPessoaRelacionadaInput, EnderecoPessoaRelacionadaUncheckedCreateWithoutPessoaRelacionadaInput>
  }

  export type EnderecoPessoaRelacionadaUpdateWithWhereUniqueWithoutPessoaRelacionadaInput = {
    where: EnderecoPessoaRelacionadaWhereUniqueInput
    data: XOR<EnderecoPessoaRelacionadaUpdateWithoutPessoaRelacionadaInput, EnderecoPessoaRelacionadaUncheckedUpdateWithoutPessoaRelacionadaInput>
  }

  export type EnderecoPessoaRelacionadaUpdateManyWithWhereWithoutPessoaRelacionadaInput = {
    where: EnderecoPessoaRelacionadaScalarWhereInput
    data: XOR<EnderecoPessoaRelacionadaUpdateManyMutationInput, EnderecoPessoaRelacionadaUncheckedUpdateManyWithoutPessoaRelacionadaInput>
  }

  export type ParentescoPacienteUpsertWithWhereUniqueWithoutPessoaRelacionadaInput = {
    where: ParentescoPacienteWhereUniqueInput
    update: XOR<ParentescoPacienteUpdateWithoutPessoaRelacionadaInput, ParentescoPacienteUncheckedUpdateWithoutPessoaRelacionadaInput>
    create: XOR<ParentescoPacienteCreateWithoutPessoaRelacionadaInput, ParentescoPacienteUncheckedCreateWithoutPessoaRelacionadaInput>
  }

  export type ParentescoPacienteUpdateWithWhereUniqueWithoutPessoaRelacionadaInput = {
    where: ParentescoPacienteWhereUniqueInput
    data: XOR<ParentescoPacienteUpdateWithoutPessoaRelacionadaInput, ParentescoPacienteUncheckedUpdateWithoutPessoaRelacionadaInput>
  }

  export type ParentescoPacienteUpdateManyWithWhereWithoutPessoaRelacionadaInput = {
    where: ParentescoPacienteScalarWhereInput
    data: XOR<ParentescoPacienteUpdateManyMutationInput, ParentescoPacienteUncheckedUpdateManyWithoutPessoaRelacionadaInput>
  }

  export type PacienteCreateWithoutParentescoPacientesInput = {
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    atendimentos?: AtendimentoCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoCreateNestedManyWithoutPacienteInput
    escolaridade?: EscolaridadeCreateNestedOneWithoutPacientesInput
    master: MasterCreateNestedOneWithoutPacientesInput
    ocupacao?: OcupacaoCreateNestedOneWithoutPacientesInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutPacienteInput
  }

  export type PacienteUncheckedCreateWithoutParentescoPacientesInput = {
    cdMaster: number
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    cdEscolaridade?: number | null
    cdOcupacao?: number | null
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type PacienteCreateOrConnectWithoutParentescoPacientesInput = {
    where: PacienteWhereUniqueInput
    create: XOR<PacienteCreateWithoutParentescoPacientesInput, PacienteUncheckedCreateWithoutParentescoPacientesInput>
  }

  export type PessoaRelacionadaCreateWithoutParentescosInput = {
    nome: string
    telefone?: string | null
    stInativo?: $Enums.SimNao | null
    enderecos?: EnderecoPessoaRelacionadaCreateNestedManyWithoutPessoaRelacionadaInput
  }

  export type PessoaRelacionadaUncheckedCreateWithoutParentescosInput = {
    id?: number
    nome: string
    telefone?: string | null
    stInativo?: $Enums.SimNao | null
    enderecos?: EnderecoPessoaRelacionadaUncheckedCreateNestedManyWithoutPessoaRelacionadaInput
  }

  export type PessoaRelacionadaCreateOrConnectWithoutParentescosInput = {
    where: PessoaRelacionadaWhereUniqueInput
    create: XOR<PessoaRelacionadaCreateWithoutParentescosInput, PessoaRelacionadaUncheckedCreateWithoutParentescosInput>
  }

  export type PacienteUpsertWithoutParentescoPacientesInput = {
    update: XOR<PacienteUpdateWithoutParentescoPacientesInput, PacienteUncheckedUpdateWithoutParentescoPacientesInput>
    create: XOR<PacienteCreateWithoutParentescoPacientesInput, PacienteUncheckedCreateWithoutParentescoPacientesInput>
    where?: PacienteWhereInput
  }

  export type PacienteUpdateToOneWithWhereWithoutParentescoPacientesInput = {
    where?: PacienteWhereInput
    data: XOR<PacienteUpdateWithoutParentescoPacientesInput, PacienteUncheckedUpdateWithoutParentescoPacientesInput>
  }

  export type PacienteUpdateWithoutParentescoPacientesInput = {
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    atendimentos?: AtendimentoUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutPacienteNestedInput
    escolaridade?: EscolaridadeUpdateOneWithoutPacientesNestedInput
    master?: MasterUpdateOneRequiredWithoutPacientesNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutPacientesNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateWithoutParentescoPacientesInput = {
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdEscolaridade?: NullableIntFieldUpdateOperationsInput | number | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type PessoaRelacionadaUpsertWithoutParentescosInput = {
    update: XOR<PessoaRelacionadaUpdateWithoutParentescosInput, PessoaRelacionadaUncheckedUpdateWithoutParentescosInput>
    create: XOR<PessoaRelacionadaCreateWithoutParentescosInput, PessoaRelacionadaUncheckedCreateWithoutParentescosInput>
    where?: PessoaRelacionadaWhereInput
  }

  export type PessoaRelacionadaUpdateToOneWithWhereWithoutParentescosInput = {
    where?: PessoaRelacionadaWhereInput
    data: XOR<PessoaRelacionadaUpdateWithoutParentescosInput, PessoaRelacionadaUncheckedUpdateWithoutParentescosInput>
  }

  export type PessoaRelacionadaUpdateWithoutParentescosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    enderecos?: EnderecoPessoaRelacionadaUpdateManyWithoutPessoaRelacionadaNestedInput
  }

  export type PessoaRelacionadaUncheckedUpdateWithoutParentescosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    enderecos?: EnderecoPessoaRelacionadaUncheckedUpdateManyWithoutPessoaRelacionadaNestedInput
  }

  export type CidadeCreateWithoutPaisInput = {
    descricao: string
    cepGeral?: string | null
    cdIbge?: number | null
    stInativo?: $Enums.SimNao | null
    bairros?: BairroCreateNestedManyWithoutCidadeInput
    uf: UnidadeFederacaoCreateNestedOneWithoutCidadesInput
    distritos?: DistritoCreateNestedManyWithoutCidadeInput
    enderecos?: EnderecoCreateNestedManyWithoutCidadeInput
  }

  export type CidadeUncheckedCreateWithoutPaisInput = {
    id?: number
    descricao: string
    cdUf: string
    cepGeral?: string | null
    cdIbge?: number | null
    stInativo?: $Enums.SimNao | null
    bairros?: BairroUncheckedCreateNestedManyWithoutCidadeInput
    distritos?: DistritoUncheckedCreateNestedManyWithoutCidadeInput
    enderecos?: EnderecoUncheckedCreateNestedManyWithoutCidadeInput
  }

  export type CidadeCreateOrConnectWithoutPaisInput = {
    where: CidadeWhereUniqueInput
    create: XOR<CidadeCreateWithoutPaisInput, CidadeUncheckedCreateWithoutPaisInput>
  }

  export type CidadeCreateManyPaisInputEnvelope = {
    data: CidadeCreateManyPaisInput | CidadeCreateManyPaisInput[]
    skipDuplicates?: boolean
  }

  export type CidadeUpsertWithWhereUniqueWithoutPaisInput = {
    where: CidadeWhereUniqueInput
    update: XOR<CidadeUpdateWithoutPaisInput, CidadeUncheckedUpdateWithoutPaisInput>
    create: XOR<CidadeCreateWithoutPaisInput, CidadeUncheckedCreateWithoutPaisInput>
  }

  export type CidadeUpdateWithWhereUniqueWithoutPaisInput = {
    where: CidadeWhereUniqueInput
    data: XOR<CidadeUpdateWithoutPaisInput, CidadeUncheckedUpdateWithoutPaisInput>
  }

  export type CidadeUpdateManyWithWhereWithoutPaisInput = {
    where: CidadeScalarWhereInput
    data: XOR<CidadeUpdateManyMutationInput, CidadeUncheckedUpdateManyWithoutPaisInput>
  }

  export type CidadeScalarWhereInput = {
    AND?: CidadeScalarWhereInput | CidadeScalarWhereInput[]
    OR?: CidadeScalarWhereInput[]
    NOT?: CidadeScalarWhereInput | CidadeScalarWhereInput[]
    id?: IntFilter<"Cidade"> | number
    descricao?: StringFilter<"Cidade"> | string
    cdUf?: StringFilter<"Cidade"> | string
    cdPais?: IntFilter<"Cidade"> | number
    cepGeral?: StringNullableFilter<"Cidade"> | string | null
    cdIbge?: IntNullableFilter<"Cidade"> | number | null
    stInativo?: EnumSimNaoNullableFilter<"Cidade"> | $Enums.SimNao | null
  }

  export type CidadeCreateWithoutUfInput = {
    descricao: string
    cepGeral?: string | null
    cdIbge?: number | null
    stInativo?: $Enums.SimNao | null
    bairros?: BairroCreateNestedManyWithoutCidadeInput
    pais: PaisCreateNestedOneWithoutCidadesInput
    distritos?: DistritoCreateNestedManyWithoutCidadeInput
    enderecos?: EnderecoCreateNestedManyWithoutCidadeInput
  }

  export type CidadeUncheckedCreateWithoutUfInput = {
    id?: number
    descricao: string
    cdPais: number
    cepGeral?: string | null
    cdIbge?: number | null
    stInativo?: $Enums.SimNao | null
    bairros?: BairroUncheckedCreateNestedManyWithoutCidadeInput
    distritos?: DistritoUncheckedCreateNestedManyWithoutCidadeInput
    enderecos?: EnderecoUncheckedCreateNestedManyWithoutCidadeInput
  }

  export type CidadeCreateOrConnectWithoutUfInput = {
    where: CidadeWhereUniqueInput
    create: XOR<CidadeCreateWithoutUfInput, CidadeUncheckedCreateWithoutUfInput>
  }

  export type CidadeCreateManyUfInputEnvelope = {
    data: CidadeCreateManyUfInput | CidadeCreateManyUfInput[]
    skipDuplicates?: boolean
  }

  export type CidadeUpsertWithWhereUniqueWithoutUfInput = {
    where: CidadeWhereUniqueInput
    update: XOR<CidadeUpdateWithoutUfInput, CidadeUncheckedUpdateWithoutUfInput>
    create: XOR<CidadeCreateWithoutUfInput, CidadeUncheckedCreateWithoutUfInput>
  }

  export type CidadeUpdateWithWhereUniqueWithoutUfInput = {
    where: CidadeWhereUniqueInput
    data: XOR<CidadeUpdateWithoutUfInput, CidadeUncheckedUpdateWithoutUfInput>
  }

  export type CidadeUpdateManyWithWhereWithoutUfInput = {
    where: CidadeScalarWhereInput
    data: XOR<CidadeUpdateManyMutationInput, CidadeUncheckedUpdateManyWithoutUfInput>
  }

  export type BairroCreateWithoutCidadeInput = {
    descricao: string
    stInativo?: $Enums.SimNao | null
    distrito?: DistritoCreateNestedOneWithoutBairrosInput
    enderecos?: EnderecoCreateNestedManyWithoutBairroInput
  }

  export type BairroUncheckedCreateWithoutCidadeInput = {
    id?: number
    cdDistrito?: number | null
    descricao: string
    stInativo?: $Enums.SimNao | null
    enderecos?: EnderecoUncheckedCreateNestedManyWithoutBairroInput
  }

  export type BairroCreateOrConnectWithoutCidadeInput = {
    where: BairroWhereUniqueInput
    create: XOR<BairroCreateWithoutCidadeInput, BairroUncheckedCreateWithoutCidadeInput>
  }

  export type BairroCreateManyCidadeInputEnvelope = {
    data: BairroCreateManyCidadeInput | BairroCreateManyCidadeInput[]
    skipDuplicates?: boolean
  }

  export type PaisCreateWithoutCidadesInput = {
    descricao: string
    nacionalidade?: string | null
    cdIbge?: number | null
  }

  export type PaisUncheckedCreateWithoutCidadesInput = {
    id?: number
    descricao: string
    nacionalidade?: string | null
    cdIbge?: number | null
  }

  export type PaisCreateOrConnectWithoutCidadesInput = {
    where: PaisWhereUniqueInput
    create: XOR<PaisCreateWithoutCidadesInput, PaisUncheckedCreateWithoutCidadesInput>
  }

  export type UnidadeFederacaoCreateWithoutCidadesInput = {
    id: string
    descricao: string
    cdIbge?: number | null
  }

  export type UnidadeFederacaoUncheckedCreateWithoutCidadesInput = {
    id: string
    descricao: string
    cdIbge?: number | null
  }

  export type UnidadeFederacaoCreateOrConnectWithoutCidadesInput = {
    where: UnidadeFederacaoWhereUniqueInput
    create: XOR<UnidadeFederacaoCreateWithoutCidadesInput, UnidadeFederacaoUncheckedCreateWithoutCidadesInput>
  }

  export type DistritoCreateWithoutCidadeInput = {
    descricao: string
    stInativo?: $Enums.SimNao | null
    bairros?: BairroCreateNestedManyWithoutDistritoInput
  }

  export type DistritoUncheckedCreateWithoutCidadeInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
    bairros?: BairroUncheckedCreateNestedManyWithoutDistritoInput
  }

  export type DistritoCreateOrConnectWithoutCidadeInput = {
    where: DistritoWhereUniqueInput
    create: XOR<DistritoCreateWithoutCidadeInput, DistritoUncheckedCreateWithoutCidadeInput>
  }

  export type DistritoCreateManyCidadeInputEnvelope = {
    data: DistritoCreateManyCidadeInput | DistritoCreateManyCidadeInput[]
    skipDuplicates?: boolean
  }

  export type EnderecoCreateWithoutCidadeInput = {
    logradouro: string
    numero?: string | null
    complemento?: string | null
    cep: string
    stInativo?: $Enums.SimNao | null
    bairro: BairroCreateNestedOneWithoutEnderecosInput
    pacientes?: EnderecoPacienteCreateNestedManyWithoutEnderecoInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaCreateNestedManyWithoutEnderecoInput
    profissionais?: EnderecoProfissionalCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoUncheckedCreateWithoutCidadeInput = {
    id?: number
    logradouro: string
    numero?: string | null
    complemento?: string | null
    cdBairro: number
    cep: string
    stInativo?: $Enums.SimNao | null
    pacientes?: EnderecoPacienteUncheckedCreateNestedManyWithoutEnderecoInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaUncheckedCreateNestedManyWithoutEnderecoInput
    profissionais?: EnderecoProfissionalUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoCreateOrConnectWithoutCidadeInput = {
    where: EnderecoWhereUniqueInput
    create: XOR<EnderecoCreateWithoutCidadeInput, EnderecoUncheckedCreateWithoutCidadeInput>
  }

  export type EnderecoCreateManyCidadeInputEnvelope = {
    data: EnderecoCreateManyCidadeInput | EnderecoCreateManyCidadeInput[]
    skipDuplicates?: boolean
  }

  export type BairroUpsertWithWhereUniqueWithoutCidadeInput = {
    where: BairroWhereUniqueInput
    update: XOR<BairroUpdateWithoutCidadeInput, BairroUncheckedUpdateWithoutCidadeInput>
    create: XOR<BairroCreateWithoutCidadeInput, BairroUncheckedCreateWithoutCidadeInput>
  }

  export type BairroUpdateWithWhereUniqueWithoutCidadeInput = {
    where: BairroWhereUniqueInput
    data: XOR<BairroUpdateWithoutCidadeInput, BairroUncheckedUpdateWithoutCidadeInput>
  }

  export type BairroUpdateManyWithWhereWithoutCidadeInput = {
    where: BairroScalarWhereInput
    data: XOR<BairroUpdateManyMutationInput, BairroUncheckedUpdateManyWithoutCidadeInput>
  }

  export type BairroScalarWhereInput = {
    AND?: BairroScalarWhereInput | BairroScalarWhereInput[]
    OR?: BairroScalarWhereInput[]
    NOT?: BairroScalarWhereInput | BairroScalarWhereInput[]
    id?: IntFilter<"Bairro"> | number
    cdDistrito?: IntNullableFilter<"Bairro"> | number | null
    cdCidade?: IntFilter<"Bairro"> | number
    descricao?: StringFilter<"Bairro"> | string
    stInativo?: EnumSimNaoNullableFilter<"Bairro"> | $Enums.SimNao | null
  }

  export type PaisUpsertWithoutCidadesInput = {
    update: XOR<PaisUpdateWithoutCidadesInput, PaisUncheckedUpdateWithoutCidadesInput>
    create: XOR<PaisCreateWithoutCidadesInput, PaisUncheckedCreateWithoutCidadesInput>
    where?: PaisWhereInput
  }

  export type PaisUpdateToOneWithWhereWithoutCidadesInput = {
    where?: PaisWhereInput
    data: XOR<PaisUpdateWithoutCidadesInput, PaisUncheckedUpdateWithoutCidadesInput>
  }

  export type PaisUpdateWithoutCidadesInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    nacionalidade?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaisUncheckedUpdateWithoutCidadesInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    nacionalidade?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UnidadeFederacaoUpsertWithoutCidadesInput = {
    update: XOR<UnidadeFederacaoUpdateWithoutCidadesInput, UnidadeFederacaoUncheckedUpdateWithoutCidadesInput>
    create: XOR<UnidadeFederacaoCreateWithoutCidadesInput, UnidadeFederacaoUncheckedCreateWithoutCidadesInput>
    where?: UnidadeFederacaoWhereInput
  }

  export type UnidadeFederacaoUpdateToOneWithWhereWithoutCidadesInput = {
    where?: UnidadeFederacaoWhereInput
    data: XOR<UnidadeFederacaoUpdateWithoutCidadesInput, UnidadeFederacaoUncheckedUpdateWithoutCidadesInput>
  }

  export type UnidadeFederacaoUpdateWithoutCidadesInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UnidadeFederacaoUncheckedUpdateWithoutCidadesInput = {
    id?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DistritoUpsertWithWhereUniqueWithoutCidadeInput = {
    where: DistritoWhereUniqueInput
    update: XOR<DistritoUpdateWithoutCidadeInput, DistritoUncheckedUpdateWithoutCidadeInput>
    create: XOR<DistritoCreateWithoutCidadeInput, DistritoUncheckedCreateWithoutCidadeInput>
  }

  export type DistritoUpdateWithWhereUniqueWithoutCidadeInput = {
    where: DistritoWhereUniqueInput
    data: XOR<DistritoUpdateWithoutCidadeInput, DistritoUncheckedUpdateWithoutCidadeInput>
  }

  export type DistritoUpdateManyWithWhereWithoutCidadeInput = {
    where: DistritoScalarWhereInput
    data: XOR<DistritoUpdateManyMutationInput, DistritoUncheckedUpdateManyWithoutCidadeInput>
  }

  export type DistritoScalarWhereInput = {
    AND?: DistritoScalarWhereInput | DistritoScalarWhereInput[]
    OR?: DistritoScalarWhereInput[]
    NOT?: DistritoScalarWhereInput | DistritoScalarWhereInput[]
    id?: IntFilter<"Distrito"> | number
    cdCidade?: IntFilter<"Distrito"> | number
    descricao?: StringFilter<"Distrito"> | string
    stInativo?: EnumSimNaoNullableFilter<"Distrito"> | $Enums.SimNao | null
  }

  export type EnderecoUpsertWithWhereUniqueWithoutCidadeInput = {
    where: EnderecoWhereUniqueInput
    update: XOR<EnderecoUpdateWithoutCidadeInput, EnderecoUncheckedUpdateWithoutCidadeInput>
    create: XOR<EnderecoCreateWithoutCidadeInput, EnderecoUncheckedCreateWithoutCidadeInput>
  }

  export type EnderecoUpdateWithWhereUniqueWithoutCidadeInput = {
    where: EnderecoWhereUniqueInput
    data: XOR<EnderecoUpdateWithoutCidadeInput, EnderecoUncheckedUpdateWithoutCidadeInput>
  }

  export type EnderecoUpdateManyWithWhereWithoutCidadeInput = {
    where: EnderecoScalarWhereInput
    data: XOR<EnderecoUpdateManyMutationInput, EnderecoUncheckedUpdateManyWithoutCidadeInput>
  }

  export type EnderecoScalarWhereInput = {
    AND?: EnderecoScalarWhereInput | EnderecoScalarWhereInput[]
    OR?: EnderecoScalarWhereInput[]
    NOT?: EnderecoScalarWhereInput | EnderecoScalarWhereInput[]
    id?: IntFilter<"Endereco"> | number
    logradouro?: StringFilter<"Endereco"> | string
    numero?: StringNullableFilter<"Endereco"> | string | null
    complemento?: StringNullableFilter<"Endereco"> | string | null
    cdBairro?: IntFilter<"Endereco"> | number
    cdCidade?: IntFilter<"Endereco"> | number
    cep?: StringFilter<"Endereco"> | string
    stInativo?: EnumSimNaoNullableFilter<"Endereco"> | $Enums.SimNao | null
  }

  export type PacienteCreateWithoutEscolaridadeInput = {
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    atendimentos?: AtendimentoCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoCreateNestedManyWithoutPacienteInput
    master: MasterCreateNestedOneWithoutPacientesInput
    ocupacao?: OcupacaoCreateNestedOneWithoutPacientesInput
    parentescoPacientes?: ParentescoPacienteCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutPacienteInput
  }

  export type PacienteUncheckedCreateWithoutEscolaridadeInput = {
    cdMaster: number
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    cdOcupacao?: number | null
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutPacienteInput
    parentescoPacientes?: ParentescoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type PacienteCreateOrConnectWithoutEscolaridadeInput = {
    where: PacienteWhereUniqueInput
    create: XOR<PacienteCreateWithoutEscolaridadeInput, PacienteUncheckedCreateWithoutEscolaridadeInput>
  }

  export type PacienteCreateManyEscolaridadeInputEnvelope = {
    data: PacienteCreateManyEscolaridadeInput | PacienteCreateManyEscolaridadeInput[]
    skipDuplicates?: boolean
  }

  export type PacienteUpsertWithWhereUniqueWithoutEscolaridadeInput = {
    where: PacienteWhereUniqueInput
    update: XOR<PacienteUpdateWithoutEscolaridadeInput, PacienteUncheckedUpdateWithoutEscolaridadeInput>
    create: XOR<PacienteCreateWithoutEscolaridadeInput, PacienteUncheckedCreateWithoutEscolaridadeInput>
  }

  export type PacienteUpdateWithWhereUniqueWithoutEscolaridadeInput = {
    where: PacienteWhereUniqueInput
    data: XOR<PacienteUpdateWithoutEscolaridadeInput, PacienteUncheckedUpdateWithoutEscolaridadeInput>
  }

  export type PacienteUpdateManyWithWhereWithoutEscolaridadeInput = {
    where: PacienteScalarWhereInput
    data: XOR<PacienteUpdateManyMutationInput, PacienteUncheckedUpdateManyWithoutEscolaridadeInput>
  }

  export type PacienteCreateWithoutOcupacaoInput = {
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    atendimentos?: AtendimentoCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoCreateNestedManyWithoutPacienteInput
    escolaridade?: EscolaridadeCreateNestedOneWithoutPacientesInput
    master: MasterCreateNestedOneWithoutPacientesInput
    parentescoPacientes?: ParentescoPacienteCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutPacienteInput
  }

  export type PacienteUncheckedCreateWithoutOcupacaoInput = {
    cdMaster: number
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    cdEscolaridade?: number | null
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutPacienteInput
    parentescoPacientes?: ParentescoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type PacienteCreateOrConnectWithoutOcupacaoInput = {
    where: PacienteWhereUniqueInput
    create: XOR<PacienteCreateWithoutOcupacaoInput, PacienteUncheckedCreateWithoutOcupacaoInput>
  }

  export type PacienteCreateManyOcupacaoInputEnvelope = {
    data: PacienteCreateManyOcupacaoInput | PacienteCreateManyOcupacaoInput[]
    skipDuplicates?: boolean
  }

  export type ProfissionalCreateWithoutOcupacaoInput = {
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowCreateNestedManyWithoutProfissionalInput
    master: MasterCreateNestedOneWithoutProfissionaisInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalUncheckedCreateWithoutOcupacaoInput = {
    id?: number
    cdMaster: number
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutProfissionalInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalCreateOrConnectWithoutOcupacaoInput = {
    where: ProfissionalWhereUniqueInput
    create: XOR<ProfissionalCreateWithoutOcupacaoInput, ProfissionalUncheckedCreateWithoutOcupacaoInput>
  }

  export type ProfissionalCreateManyOcupacaoInputEnvelope = {
    data: ProfissionalCreateManyOcupacaoInput | ProfissionalCreateManyOcupacaoInput[]
    skipDuplicates?: boolean
  }

  export type PacienteUpsertWithWhereUniqueWithoutOcupacaoInput = {
    where: PacienteWhereUniqueInput
    update: XOR<PacienteUpdateWithoutOcupacaoInput, PacienteUncheckedUpdateWithoutOcupacaoInput>
    create: XOR<PacienteCreateWithoutOcupacaoInput, PacienteUncheckedCreateWithoutOcupacaoInput>
  }

  export type PacienteUpdateWithWhereUniqueWithoutOcupacaoInput = {
    where: PacienteWhereUniqueInput
    data: XOR<PacienteUpdateWithoutOcupacaoInput, PacienteUncheckedUpdateWithoutOcupacaoInput>
  }

  export type PacienteUpdateManyWithWhereWithoutOcupacaoInput = {
    where: PacienteScalarWhereInput
    data: XOR<PacienteUpdateManyMutationInput, PacienteUncheckedUpdateManyWithoutOcupacaoInput>
  }

  export type ProfissionalUpsertWithWhereUniqueWithoutOcupacaoInput = {
    where: ProfissionalWhereUniqueInput
    update: XOR<ProfissionalUpdateWithoutOcupacaoInput, ProfissionalUncheckedUpdateWithoutOcupacaoInput>
    create: XOR<ProfissionalCreateWithoutOcupacaoInput, ProfissionalUncheckedCreateWithoutOcupacaoInput>
  }

  export type ProfissionalUpdateWithWhereUniqueWithoutOcupacaoInput = {
    where: ProfissionalWhereUniqueInput
    data: XOR<ProfissionalUpdateWithoutOcupacaoInput, ProfissionalUncheckedUpdateWithoutOcupacaoInput>
  }

  export type ProfissionalUpdateManyWithWhereWithoutOcupacaoInput = {
    where: ProfissionalScalarWhereInput
    data: XOR<ProfissionalUpdateManyMutationInput, ProfissionalUncheckedUpdateManyWithoutOcupacaoInput>
  }

  export type BairroCreateWithoutDistritoInput = {
    descricao: string
    stInativo?: $Enums.SimNao | null
    cidade: CidadeCreateNestedOneWithoutBairrosInput
    enderecos?: EnderecoCreateNestedManyWithoutBairroInput
  }

  export type BairroUncheckedCreateWithoutDistritoInput = {
    id?: number
    cdCidade: number
    descricao: string
    stInativo?: $Enums.SimNao | null
    enderecos?: EnderecoUncheckedCreateNestedManyWithoutBairroInput
  }

  export type BairroCreateOrConnectWithoutDistritoInput = {
    where: BairroWhereUniqueInput
    create: XOR<BairroCreateWithoutDistritoInput, BairroUncheckedCreateWithoutDistritoInput>
  }

  export type BairroCreateManyDistritoInputEnvelope = {
    data: BairroCreateManyDistritoInput | BairroCreateManyDistritoInput[]
    skipDuplicates?: boolean
  }

  export type CidadeCreateWithoutDistritosInput = {
    descricao: string
    cepGeral?: string | null
    cdIbge?: number | null
    stInativo?: $Enums.SimNao | null
    bairros?: BairroCreateNestedManyWithoutCidadeInput
    pais: PaisCreateNestedOneWithoutCidadesInput
    uf: UnidadeFederacaoCreateNestedOneWithoutCidadesInput
    enderecos?: EnderecoCreateNestedManyWithoutCidadeInput
  }

  export type CidadeUncheckedCreateWithoutDistritosInput = {
    id?: number
    descricao: string
    cdUf: string
    cdPais: number
    cepGeral?: string | null
    cdIbge?: number | null
    stInativo?: $Enums.SimNao | null
    bairros?: BairroUncheckedCreateNestedManyWithoutCidadeInput
    enderecos?: EnderecoUncheckedCreateNestedManyWithoutCidadeInput
  }

  export type CidadeCreateOrConnectWithoutDistritosInput = {
    where: CidadeWhereUniqueInput
    create: XOR<CidadeCreateWithoutDistritosInput, CidadeUncheckedCreateWithoutDistritosInput>
  }

  export type BairroUpsertWithWhereUniqueWithoutDistritoInput = {
    where: BairroWhereUniqueInput
    update: XOR<BairroUpdateWithoutDistritoInput, BairroUncheckedUpdateWithoutDistritoInput>
    create: XOR<BairroCreateWithoutDistritoInput, BairroUncheckedCreateWithoutDistritoInput>
  }

  export type BairroUpdateWithWhereUniqueWithoutDistritoInput = {
    where: BairroWhereUniqueInput
    data: XOR<BairroUpdateWithoutDistritoInput, BairroUncheckedUpdateWithoutDistritoInput>
  }

  export type BairroUpdateManyWithWhereWithoutDistritoInput = {
    where: BairroScalarWhereInput
    data: XOR<BairroUpdateManyMutationInput, BairroUncheckedUpdateManyWithoutDistritoInput>
  }

  export type CidadeUpsertWithoutDistritosInput = {
    update: XOR<CidadeUpdateWithoutDistritosInput, CidadeUncheckedUpdateWithoutDistritosInput>
    create: XOR<CidadeCreateWithoutDistritosInput, CidadeUncheckedCreateWithoutDistritosInput>
    where?: CidadeWhereInput
  }

  export type CidadeUpdateToOneWithWhereWithoutDistritosInput = {
    where?: CidadeWhereInput
    data: XOR<CidadeUpdateWithoutDistritosInput, CidadeUncheckedUpdateWithoutDistritosInput>
  }

  export type CidadeUpdateWithoutDistritosInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairros?: BairroUpdateManyWithoutCidadeNestedInput
    pais?: PaisUpdateOneRequiredWithoutCidadesNestedInput
    uf?: UnidadeFederacaoUpdateOneRequiredWithoutCidadesNestedInput
    enderecos?: EnderecoUpdateManyWithoutCidadeNestedInput
  }

  export type CidadeUncheckedUpdateWithoutDistritosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    cdUf?: StringFieldUpdateOperationsInput | string
    cdPais?: IntFieldUpdateOperationsInput | number
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairros?: BairroUncheckedUpdateManyWithoutCidadeNestedInput
    enderecos?: EnderecoUncheckedUpdateManyWithoutCidadeNestedInput
  }

  export type CidadeCreateWithoutBairrosInput = {
    descricao: string
    cepGeral?: string | null
    cdIbge?: number | null
    stInativo?: $Enums.SimNao | null
    pais: PaisCreateNestedOneWithoutCidadesInput
    uf: UnidadeFederacaoCreateNestedOneWithoutCidadesInput
    distritos?: DistritoCreateNestedManyWithoutCidadeInput
    enderecos?: EnderecoCreateNestedManyWithoutCidadeInput
  }

  export type CidadeUncheckedCreateWithoutBairrosInput = {
    id?: number
    descricao: string
    cdUf: string
    cdPais: number
    cepGeral?: string | null
    cdIbge?: number | null
    stInativo?: $Enums.SimNao | null
    distritos?: DistritoUncheckedCreateNestedManyWithoutCidadeInput
    enderecos?: EnderecoUncheckedCreateNestedManyWithoutCidadeInput
  }

  export type CidadeCreateOrConnectWithoutBairrosInput = {
    where: CidadeWhereUniqueInput
    create: XOR<CidadeCreateWithoutBairrosInput, CidadeUncheckedCreateWithoutBairrosInput>
  }

  export type DistritoCreateWithoutBairrosInput = {
    descricao: string
    stInativo?: $Enums.SimNao | null
    cidade: CidadeCreateNestedOneWithoutDistritosInput
  }

  export type DistritoUncheckedCreateWithoutBairrosInput = {
    id?: number
    cdCidade: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type DistritoCreateOrConnectWithoutBairrosInput = {
    where: DistritoWhereUniqueInput
    create: XOR<DistritoCreateWithoutBairrosInput, DistritoUncheckedCreateWithoutBairrosInput>
  }

  export type EnderecoCreateWithoutBairroInput = {
    logradouro: string
    numero?: string | null
    complemento?: string | null
    cep: string
    stInativo?: $Enums.SimNao | null
    cidade: CidadeCreateNestedOneWithoutEnderecosInput
    pacientes?: EnderecoPacienteCreateNestedManyWithoutEnderecoInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaCreateNestedManyWithoutEnderecoInput
    profissionais?: EnderecoProfissionalCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoUncheckedCreateWithoutBairroInput = {
    id?: number
    logradouro: string
    numero?: string | null
    complemento?: string | null
    cdCidade: number
    cep: string
    stInativo?: $Enums.SimNao | null
    pacientes?: EnderecoPacienteUncheckedCreateNestedManyWithoutEnderecoInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaUncheckedCreateNestedManyWithoutEnderecoInput
    profissionais?: EnderecoProfissionalUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoCreateOrConnectWithoutBairroInput = {
    where: EnderecoWhereUniqueInput
    create: XOR<EnderecoCreateWithoutBairroInput, EnderecoUncheckedCreateWithoutBairroInput>
  }

  export type EnderecoCreateManyBairroInputEnvelope = {
    data: EnderecoCreateManyBairroInput | EnderecoCreateManyBairroInput[]
    skipDuplicates?: boolean
  }

  export type CidadeUpsertWithoutBairrosInput = {
    update: XOR<CidadeUpdateWithoutBairrosInput, CidadeUncheckedUpdateWithoutBairrosInput>
    create: XOR<CidadeCreateWithoutBairrosInput, CidadeUncheckedCreateWithoutBairrosInput>
    where?: CidadeWhereInput
  }

  export type CidadeUpdateToOneWithWhereWithoutBairrosInput = {
    where?: CidadeWhereInput
    data: XOR<CidadeUpdateWithoutBairrosInput, CidadeUncheckedUpdateWithoutBairrosInput>
  }

  export type CidadeUpdateWithoutBairrosInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pais?: PaisUpdateOneRequiredWithoutCidadesNestedInput
    uf?: UnidadeFederacaoUpdateOneRequiredWithoutCidadesNestedInput
    distritos?: DistritoUpdateManyWithoutCidadeNestedInput
    enderecos?: EnderecoUpdateManyWithoutCidadeNestedInput
  }

  export type CidadeUncheckedUpdateWithoutBairrosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    cdUf?: StringFieldUpdateOperationsInput | string
    cdPais?: IntFieldUpdateOperationsInput | number
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    distritos?: DistritoUncheckedUpdateManyWithoutCidadeNestedInput
    enderecos?: EnderecoUncheckedUpdateManyWithoutCidadeNestedInput
  }

  export type DistritoUpsertWithoutBairrosInput = {
    update: XOR<DistritoUpdateWithoutBairrosInput, DistritoUncheckedUpdateWithoutBairrosInput>
    create: XOR<DistritoCreateWithoutBairrosInput, DistritoUncheckedCreateWithoutBairrosInput>
    where?: DistritoWhereInput
  }

  export type DistritoUpdateToOneWithWhereWithoutBairrosInput = {
    where?: DistritoWhereInput
    data: XOR<DistritoUpdateWithoutBairrosInput, DistritoUncheckedUpdateWithoutBairrosInput>
  }

  export type DistritoUpdateWithoutBairrosInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cidade?: CidadeUpdateOneRequiredWithoutDistritosNestedInput
  }

  export type DistritoUncheckedUpdateWithoutBairrosInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdCidade?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type EnderecoUpsertWithWhereUniqueWithoutBairroInput = {
    where: EnderecoWhereUniqueInput
    update: XOR<EnderecoUpdateWithoutBairroInput, EnderecoUncheckedUpdateWithoutBairroInput>
    create: XOR<EnderecoCreateWithoutBairroInput, EnderecoUncheckedCreateWithoutBairroInput>
  }

  export type EnderecoUpdateWithWhereUniqueWithoutBairroInput = {
    where: EnderecoWhereUniqueInput
    data: XOR<EnderecoUpdateWithoutBairroInput, EnderecoUncheckedUpdateWithoutBairroInput>
  }

  export type EnderecoUpdateManyWithWhereWithoutBairroInput = {
    where: EnderecoScalarWhereInput
    data: XOR<EnderecoUpdateManyMutationInput, EnderecoUncheckedUpdateManyWithoutBairroInput>
  }

  export type EnderecoCreateWithoutEnderecoPessoaRelacionadasInput = {
    logradouro: string
    numero?: string | null
    complemento?: string | null
    cep: string
    stInativo?: $Enums.SimNao | null
    bairro: BairroCreateNestedOneWithoutEnderecosInput
    cidade: CidadeCreateNestedOneWithoutEnderecosInput
    pacientes?: EnderecoPacienteCreateNestedManyWithoutEnderecoInput
    profissionais?: EnderecoProfissionalCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoUncheckedCreateWithoutEnderecoPessoaRelacionadasInput = {
    id?: number
    logradouro: string
    numero?: string | null
    complemento?: string | null
    cdBairro: number
    cdCidade: number
    cep: string
    stInativo?: $Enums.SimNao | null
    pacientes?: EnderecoPacienteUncheckedCreateNestedManyWithoutEnderecoInput
    profissionais?: EnderecoProfissionalUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoCreateOrConnectWithoutEnderecoPessoaRelacionadasInput = {
    where: EnderecoWhereUniqueInput
    create: XOR<EnderecoCreateWithoutEnderecoPessoaRelacionadasInput, EnderecoUncheckedCreateWithoutEnderecoPessoaRelacionadasInput>
  }

  export type PessoaRelacionadaCreateWithoutEnderecosInput = {
    nome: string
    telefone?: string | null
    stInativo?: $Enums.SimNao | null
    parentescos?: ParentescoPacienteCreateNestedManyWithoutPessoaRelacionadaInput
  }

  export type PessoaRelacionadaUncheckedCreateWithoutEnderecosInput = {
    id?: number
    nome: string
    telefone?: string | null
    stInativo?: $Enums.SimNao | null
    parentescos?: ParentescoPacienteUncheckedCreateNestedManyWithoutPessoaRelacionadaInput
  }

  export type PessoaRelacionadaCreateOrConnectWithoutEnderecosInput = {
    where: PessoaRelacionadaWhereUniqueInput
    create: XOR<PessoaRelacionadaCreateWithoutEnderecosInput, PessoaRelacionadaUncheckedCreateWithoutEnderecosInput>
  }

  export type EnderecoUpsertWithoutEnderecoPessoaRelacionadasInput = {
    update: XOR<EnderecoUpdateWithoutEnderecoPessoaRelacionadasInput, EnderecoUncheckedUpdateWithoutEnderecoPessoaRelacionadasInput>
    create: XOR<EnderecoCreateWithoutEnderecoPessoaRelacionadasInput, EnderecoUncheckedCreateWithoutEnderecoPessoaRelacionadasInput>
    where?: EnderecoWhereInput
  }

  export type EnderecoUpdateToOneWithWhereWithoutEnderecoPessoaRelacionadasInput = {
    where?: EnderecoWhereInput
    data: XOR<EnderecoUpdateWithoutEnderecoPessoaRelacionadasInput, EnderecoUncheckedUpdateWithoutEnderecoPessoaRelacionadasInput>
  }

  export type EnderecoUpdateWithoutEnderecoPessoaRelacionadasInput = {
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairro?: BairroUpdateOneRequiredWithoutEnderecosNestedInput
    cidade?: CidadeUpdateOneRequiredWithoutEnderecosNestedInput
    pacientes?: EnderecoPacienteUpdateManyWithoutEnderecoNestedInput
    profissionais?: EnderecoProfissionalUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateWithoutEnderecoPessoaRelacionadasInput = {
    id?: IntFieldUpdateOperationsInput | number
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cdBairro?: IntFieldUpdateOperationsInput | number
    cdCidade?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: EnderecoPacienteUncheckedUpdateManyWithoutEnderecoNestedInput
    profissionais?: EnderecoProfissionalUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type PessoaRelacionadaUpsertWithoutEnderecosInput = {
    update: XOR<PessoaRelacionadaUpdateWithoutEnderecosInput, PessoaRelacionadaUncheckedUpdateWithoutEnderecosInput>
    create: XOR<PessoaRelacionadaCreateWithoutEnderecosInput, PessoaRelacionadaUncheckedCreateWithoutEnderecosInput>
    where?: PessoaRelacionadaWhereInput
  }

  export type PessoaRelacionadaUpdateToOneWithWhereWithoutEnderecosInput = {
    where?: PessoaRelacionadaWhereInput
    data: XOR<PessoaRelacionadaUpdateWithoutEnderecosInput, PessoaRelacionadaUncheckedUpdateWithoutEnderecosInput>
  }

  export type PessoaRelacionadaUpdateWithoutEnderecosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    parentescos?: ParentescoPacienteUpdateManyWithoutPessoaRelacionadaNestedInput
  }

  export type PessoaRelacionadaUncheckedUpdateWithoutEnderecosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    parentescos?: ParentescoPacienteUncheckedUpdateManyWithoutPessoaRelacionadaNestedInput
  }

  export type EvolucaoCidCreateWithoutCidInput = {
    evolucao: EvolucaoCreateNestedOneWithoutCidInput
  }

  export type EvolucaoCidUncheckedCreateWithoutCidInput = {
    id?: number
    cdEvolucao: number
  }

  export type EvolucaoCidCreateOrConnectWithoutCidInput = {
    where: EvolucaoCidWhereUniqueInput
    create: XOR<EvolucaoCidCreateWithoutCidInput, EvolucaoCidUncheckedCreateWithoutCidInput>
  }

  export type EvolucaoCidCreateManyCidInputEnvelope = {
    data: EvolucaoCidCreateManyCidInput | EvolucaoCidCreateManyCidInput[]
    skipDuplicates?: boolean
  }

  export type EvolucaoCidUpsertWithWhereUniqueWithoutCidInput = {
    where: EvolucaoCidWhereUniqueInput
    update: XOR<EvolucaoCidUpdateWithoutCidInput, EvolucaoCidUncheckedUpdateWithoutCidInput>
    create: XOR<EvolucaoCidCreateWithoutCidInput, EvolucaoCidUncheckedCreateWithoutCidInput>
  }

  export type EvolucaoCidUpdateWithWhereUniqueWithoutCidInput = {
    where: EvolucaoCidWhereUniqueInput
    data: XOR<EvolucaoCidUpdateWithoutCidInput, EvolucaoCidUncheckedUpdateWithoutCidInput>
  }

  export type EvolucaoCidUpdateManyWithWhereWithoutCidInput = {
    where: EvolucaoCidScalarWhereInput
    data: XOR<EvolucaoCidUpdateManyMutationInput, EvolucaoCidUncheckedUpdateManyWithoutCidInput>
  }

  export type EvolucaoDsmCreateWithoutDsmInput = {
    evolucao: EvolucaoCreateNestedOneWithoutDsmInput
  }

  export type EvolucaoDsmUncheckedCreateWithoutDsmInput = {
    id?: number
    cdEvolucao: number
  }

  export type EvolucaoDsmCreateOrConnectWithoutDsmInput = {
    where: EvolucaoDsmWhereUniqueInput
    create: XOR<EvolucaoDsmCreateWithoutDsmInput, EvolucaoDsmUncheckedCreateWithoutDsmInput>
  }

  export type EvolucaoDsmCreateManyDsmInputEnvelope = {
    data: EvolucaoDsmCreateManyDsmInput | EvolucaoDsmCreateManyDsmInput[]
    skipDuplicates?: boolean
  }

  export type EvolucaoDsmUpsertWithWhereUniqueWithoutDsmInput = {
    where: EvolucaoDsmWhereUniqueInput
    update: XOR<EvolucaoDsmUpdateWithoutDsmInput, EvolucaoDsmUncheckedUpdateWithoutDsmInput>
    create: XOR<EvolucaoDsmCreateWithoutDsmInput, EvolucaoDsmUncheckedCreateWithoutDsmInput>
  }

  export type EvolucaoDsmUpdateWithWhereUniqueWithoutDsmInput = {
    where: EvolucaoDsmWhereUniqueInput
    data: XOR<EvolucaoDsmUpdateWithoutDsmInput, EvolucaoDsmUncheckedUpdateWithoutDsmInput>
  }

  export type EvolucaoDsmUpdateManyWithWhereWithoutDsmInput = {
    where: EvolucaoDsmScalarWhereInput
    data: XOR<EvolucaoDsmUpdateManyMutationInput, EvolucaoDsmUncheckedUpdateManyWithoutDsmInput>
  }

  export type EvolucaoCreateWithoutTipoEvolucaoClinicaInput = {
    data: Date | string
    texto: string
    atendimento: AtendimentoCreateNestedOneWithoutEvolucoesInput
    profissional?: ProfissionalCreateNestedOneWithoutEvolucoesInput
    paciente?: PacienteCreateNestedOneWithoutEvolucoesInput
    cid?: EvolucaoCidCreateNestedManyWithoutEvolucaoInput
    dsm?: EvolucaoDsmCreateNestedManyWithoutEvolucaoInput
  }

  export type EvolucaoUncheckedCreateWithoutTipoEvolucaoClinicaInput = {
    id?: number
    cdAtendimento: number
    cdProfissional?: number | null
    data: Date | string
    texto: string
    pacienteCdMaster?: number | null
    pacienteCdPaciente?: number | null
    cid?: EvolucaoCidUncheckedCreateNestedManyWithoutEvolucaoInput
    dsm?: EvolucaoDsmUncheckedCreateNestedManyWithoutEvolucaoInput
  }

  export type EvolucaoCreateOrConnectWithoutTipoEvolucaoClinicaInput = {
    where: EvolucaoWhereUniqueInput
    create: XOR<EvolucaoCreateWithoutTipoEvolucaoClinicaInput, EvolucaoUncheckedCreateWithoutTipoEvolucaoClinicaInput>
  }

  export type EvolucaoCreateManyTipoEvolucaoClinicaInputEnvelope = {
    data: EvolucaoCreateManyTipoEvolucaoClinicaInput | EvolucaoCreateManyTipoEvolucaoClinicaInput[]
    skipDuplicates?: boolean
  }

  export type EvolucaoUpsertWithWhereUniqueWithoutTipoEvolucaoClinicaInput = {
    where: EvolucaoWhereUniqueInput
    update: XOR<EvolucaoUpdateWithoutTipoEvolucaoClinicaInput, EvolucaoUncheckedUpdateWithoutTipoEvolucaoClinicaInput>
    create: XOR<EvolucaoCreateWithoutTipoEvolucaoClinicaInput, EvolucaoUncheckedCreateWithoutTipoEvolucaoClinicaInput>
  }

  export type EvolucaoUpdateWithWhereUniqueWithoutTipoEvolucaoClinicaInput = {
    where: EvolucaoWhereUniqueInput
    data: XOR<EvolucaoUpdateWithoutTipoEvolucaoClinicaInput, EvolucaoUncheckedUpdateWithoutTipoEvolucaoClinicaInput>
  }

  export type EvolucaoUpdateManyWithWhereWithoutTipoEvolucaoClinicaInput = {
    where: EvolucaoScalarWhereInput
    data: XOR<EvolucaoUpdateManyMutationInput, EvolucaoUncheckedUpdateManyWithoutTipoEvolucaoClinicaInput>
  }

  export type CidCreateWithoutEvolucaoCidsInput = {
    codigo: string
    descricao: string
    versao: $Enums.VersaoCid
    stInativo?: $Enums.SimNao | null
  }

  export type CidUncheckedCreateWithoutEvolucaoCidsInput = {
    id?: number
    codigo: string
    descricao: string
    versao: $Enums.VersaoCid
    stInativo?: $Enums.SimNao | null
  }

  export type CidCreateOrConnectWithoutEvolucaoCidsInput = {
    where: CidWhereUniqueInput
    create: XOR<CidCreateWithoutEvolucaoCidsInput, CidUncheckedCreateWithoutEvolucaoCidsInput>
  }

  export type EvolucaoCreateWithoutCidInput = {
    data: Date | string
    texto: string
    atendimento: AtendimentoCreateNestedOneWithoutEvolucoesInput
    profissional?: ProfissionalCreateNestedOneWithoutEvolucoesInput
    paciente?: PacienteCreateNestedOneWithoutEvolucoesInput
    tipoEvolucaoClinica?: TipoEvolucaoClinicaCreateNestedOneWithoutEvolucaosInput
    dsm?: EvolucaoDsmCreateNestedManyWithoutEvolucaoInput
  }

  export type EvolucaoUncheckedCreateWithoutCidInput = {
    id?: number
    cdAtendimento: number
    cdProfissional?: number | null
    data: Date | string
    texto: string
    pacienteCdMaster?: number | null
    pacienteCdPaciente?: number | null
    tipoEvolucaoClinicaId?: number | null
    dsm?: EvolucaoDsmUncheckedCreateNestedManyWithoutEvolucaoInput
  }

  export type EvolucaoCreateOrConnectWithoutCidInput = {
    where: EvolucaoWhereUniqueInput
    create: XOR<EvolucaoCreateWithoutCidInput, EvolucaoUncheckedCreateWithoutCidInput>
  }

  export type CidUpsertWithoutEvolucaoCidsInput = {
    update: XOR<CidUpdateWithoutEvolucaoCidsInput, CidUncheckedUpdateWithoutEvolucaoCidsInput>
    create: XOR<CidCreateWithoutEvolucaoCidsInput, CidUncheckedCreateWithoutEvolucaoCidsInput>
    where?: CidWhereInput
  }

  export type CidUpdateToOneWithWhereWithoutEvolucaoCidsInput = {
    where?: CidWhereInput
    data: XOR<CidUpdateWithoutEvolucaoCidsInput, CidUncheckedUpdateWithoutEvolucaoCidsInput>
  }

  export type CidUpdateWithoutEvolucaoCidsInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    versao?: EnumVersaoCidFieldUpdateOperationsInput | $Enums.VersaoCid
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type CidUncheckedUpdateWithoutEvolucaoCidsInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    versao?: EnumVersaoCidFieldUpdateOperationsInput | $Enums.VersaoCid
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type EvolucaoUpsertWithoutCidInput = {
    update: XOR<EvolucaoUpdateWithoutCidInput, EvolucaoUncheckedUpdateWithoutCidInput>
    create: XOR<EvolucaoCreateWithoutCidInput, EvolucaoUncheckedCreateWithoutCidInput>
    where?: EvolucaoWhereInput
  }

  export type EvolucaoUpdateToOneWithWhereWithoutCidInput = {
    where?: EvolucaoWhereInput
    data: XOR<EvolucaoUpdateWithoutCidInput, EvolucaoUncheckedUpdateWithoutCidInput>
  }

  export type EvolucaoUpdateWithoutCidInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    atendimento?: AtendimentoUpdateOneRequiredWithoutEvolucoesNestedInput
    profissional?: ProfissionalUpdateOneWithoutEvolucoesNestedInput
    paciente?: PacienteUpdateOneWithoutEvolucoesNestedInput
    tipoEvolucaoClinica?: TipoEvolucaoClinicaUpdateOneWithoutEvolucaosNestedInput
    dsm?: EvolucaoDsmUpdateManyWithoutEvolucaoNestedInput
  }

  export type EvolucaoUncheckedUpdateWithoutCidInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    pacienteCdMaster?: NullableIntFieldUpdateOperationsInput | number | null
    pacienteCdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
    tipoEvolucaoClinicaId?: NullableIntFieldUpdateOperationsInput | number | null
    dsm?: EvolucaoDsmUncheckedUpdateManyWithoutEvolucaoNestedInput
  }

  export type DsmCreateWithoutEvolucaoDsmsInput = {
    codigo: string
    descricao: string
    versao: $Enums.VersaoDsm
    stInativo?: $Enums.SimNao | null
  }

  export type DsmUncheckedCreateWithoutEvolucaoDsmsInput = {
    id?: number
    codigo: string
    descricao: string
    versao: $Enums.VersaoDsm
    stInativo?: $Enums.SimNao | null
  }

  export type DsmCreateOrConnectWithoutEvolucaoDsmsInput = {
    where: DsmWhereUniqueInput
    create: XOR<DsmCreateWithoutEvolucaoDsmsInput, DsmUncheckedCreateWithoutEvolucaoDsmsInput>
  }

  export type EvolucaoCreateWithoutDsmInput = {
    data: Date | string
    texto: string
    atendimento: AtendimentoCreateNestedOneWithoutEvolucoesInput
    profissional?: ProfissionalCreateNestedOneWithoutEvolucoesInput
    paciente?: PacienteCreateNestedOneWithoutEvolucoesInput
    tipoEvolucaoClinica?: TipoEvolucaoClinicaCreateNestedOneWithoutEvolucaosInput
    cid?: EvolucaoCidCreateNestedManyWithoutEvolucaoInput
  }

  export type EvolucaoUncheckedCreateWithoutDsmInput = {
    id?: number
    cdAtendimento: number
    cdProfissional?: number | null
    data: Date | string
    texto: string
    pacienteCdMaster?: number | null
    pacienteCdPaciente?: number | null
    tipoEvolucaoClinicaId?: number | null
    cid?: EvolucaoCidUncheckedCreateNestedManyWithoutEvolucaoInput
  }

  export type EvolucaoCreateOrConnectWithoutDsmInput = {
    where: EvolucaoWhereUniqueInput
    create: XOR<EvolucaoCreateWithoutDsmInput, EvolucaoUncheckedCreateWithoutDsmInput>
  }

  export type DsmUpsertWithoutEvolucaoDsmsInput = {
    update: XOR<DsmUpdateWithoutEvolucaoDsmsInput, DsmUncheckedUpdateWithoutEvolucaoDsmsInput>
    create: XOR<DsmCreateWithoutEvolucaoDsmsInput, DsmUncheckedCreateWithoutEvolucaoDsmsInput>
    where?: DsmWhereInput
  }

  export type DsmUpdateToOneWithWhereWithoutEvolucaoDsmsInput = {
    where?: DsmWhereInput
    data: XOR<DsmUpdateWithoutEvolucaoDsmsInput, DsmUncheckedUpdateWithoutEvolucaoDsmsInput>
  }

  export type DsmUpdateWithoutEvolucaoDsmsInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    versao?: EnumVersaoDsmFieldUpdateOperationsInput | $Enums.VersaoDsm
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type DsmUncheckedUpdateWithoutEvolucaoDsmsInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    versao?: EnumVersaoDsmFieldUpdateOperationsInput | $Enums.VersaoDsm
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type EvolucaoUpsertWithoutDsmInput = {
    update: XOR<EvolucaoUpdateWithoutDsmInput, EvolucaoUncheckedUpdateWithoutDsmInput>
    create: XOR<EvolucaoCreateWithoutDsmInput, EvolucaoUncheckedCreateWithoutDsmInput>
    where?: EvolucaoWhereInput
  }

  export type EvolucaoUpdateToOneWithWhereWithoutDsmInput = {
    where?: EvolucaoWhereInput
    data: XOR<EvolucaoUpdateWithoutDsmInput, EvolucaoUncheckedUpdateWithoutDsmInput>
  }

  export type EvolucaoUpdateWithoutDsmInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    atendimento?: AtendimentoUpdateOneRequiredWithoutEvolucoesNestedInput
    profissional?: ProfissionalUpdateOneWithoutEvolucoesNestedInput
    paciente?: PacienteUpdateOneWithoutEvolucoesNestedInput
    tipoEvolucaoClinica?: TipoEvolucaoClinicaUpdateOneWithoutEvolucaosNestedInput
    cid?: EvolucaoCidUpdateManyWithoutEvolucaoNestedInput
  }

  export type EvolucaoUncheckedUpdateWithoutDsmInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    pacienteCdMaster?: NullableIntFieldUpdateOperationsInput | number | null
    pacienteCdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
    tipoEvolucaoClinicaId?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: EvolucaoCidUncheckedUpdateManyWithoutEvolucaoNestedInput
  }

  export type AtendimentoCreateWithoutSinaisVitaisInput = {
    data: Date | string
    observacao?: string | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutAtendimentoInput
    paciente: PacienteCreateNestedOneWithoutAtendimentosInput
    profissional: ProfissionalCreateNestedOneWithoutAtendimentosInput
    evaDores?: EvaDorCreateNestedManyWithoutAtendimentoInput
    evolucoes?: EvolucaoCreateNestedManyWithoutAtendimentoInput
    glasgows?: GlasgowCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoUncheckedCreateWithoutSinaisVitaisInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    cdProfissional: number
    data: Date | string
    observacao?: string | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutAtendimentoInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutAtendimentoInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutAtendimentoInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoCreateOrConnectWithoutSinaisVitaisInput = {
    where: AtendimentoWhereUniqueInput
    create: XOR<AtendimentoCreateWithoutSinaisVitaisInput, AtendimentoUncheckedCreateWithoutSinaisVitaisInput>
  }

  export type EscalaDorCreateWithoutSinaisVitaisInput = {
    nome: string
    descricao?: string | null
  }

  export type EscalaDorUncheckedCreateWithoutSinaisVitaisInput = {
    id?: number
    nome: string
    descricao?: string | null
  }

  export type EscalaDorCreateOrConnectWithoutSinaisVitaisInput = {
    where: EscalaDorWhereUniqueInput
    create: XOR<EscalaDorCreateWithoutSinaisVitaisInput, EscalaDorUncheckedCreateWithoutSinaisVitaisInput>
  }

  export type AtendimentoUpsertWithoutSinaisVitaisInput = {
    update: XOR<AtendimentoUpdateWithoutSinaisVitaisInput, AtendimentoUncheckedUpdateWithoutSinaisVitaisInput>
    create: XOR<AtendimentoCreateWithoutSinaisVitaisInput, AtendimentoUncheckedCreateWithoutSinaisVitaisInput>
    where?: AtendimentoWhereInput
  }

  export type AtendimentoUpdateToOneWithWhereWithoutSinaisVitaisInput = {
    where?: AtendimentoWhereInput
    data: XOR<AtendimentoUpdateWithoutSinaisVitaisInput, AtendimentoUncheckedUpdateWithoutSinaisVitaisInput>
  }

  export type AtendimentoUpdateWithoutSinaisVitaisInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutAtendimentoNestedInput
    paciente?: PacienteUpdateOneRequiredWithoutAtendimentosNestedInput
    profissional?: ProfissionalUpdateOneRequiredWithoutAtendimentosNestedInput
    evaDores?: EvaDorUpdateManyWithoutAtendimentoNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutAtendimentoNestedInput
    glasgows?: GlasgowUpdateManyWithoutAtendimentoNestedInput
  }

  export type AtendimentoUncheckedUpdateWithoutSinaisVitaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    cdProfissional?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutAtendimentoNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutAtendimentoNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutAtendimentoNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutAtendimentoNestedInput
  }

  export type EscalaDorUpsertWithoutSinaisVitaisInput = {
    update: XOR<EscalaDorUpdateWithoutSinaisVitaisInput, EscalaDorUncheckedUpdateWithoutSinaisVitaisInput>
    create: XOR<EscalaDorCreateWithoutSinaisVitaisInput, EscalaDorUncheckedCreateWithoutSinaisVitaisInput>
    where?: EscalaDorWhereInput
  }

  export type EscalaDorUpdateToOneWithWhereWithoutSinaisVitaisInput = {
    where?: EscalaDorWhereInput
    data: XOR<EscalaDorUpdateWithoutSinaisVitaisInput, EscalaDorUncheckedUpdateWithoutSinaisVitaisInput>
  }

  export type EscalaDorUpdateWithoutSinaisVitaisInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EscalaDorUncheckedUpdateWithoutSinaisVitaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SinaisVitaisCreateWithoutEscalaDorInput = {
    data?: Date | string
    paSistolica?: number | null
    paDiastolica?: number | null
    fc?: number | null
    fr?: number | null
    temperatura?: Decimal | DecimalJsLike | number | string | null
    spo2?: number | null
    peso?: Decimal | DecimalJsLike | number | string | null
    altura?: Decimal | DecimalJsLike | number | string | null
    imc?: Decimal | DecimalJsLike | number | string | null
    dor?: number | null
    posicao?: $Enums.PosicaoPaciente | null
    origem?: $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
    atendimento: AtendimentoCreateNestedOneWithoutSinaisVitaisInput
  }

  export type SinaisVitaisUncheckedCreateWithoutEscalaDorInput = {
    id?: number
    cdAtendimento: number
    data?: Date | string
    paSistolica?: number | null
    paDiastolica?: number | null
    fc?: number | null
    fr?: number | null
    temperatura?: Decimal | DecimalJsLike | number | string | null
    spo2?: number | null
    peso?: Decimal | DecimalJsLike | number | string | null
    altura?: Decimal | DecimalJsLike | number | string | null
    imc?: Decimal | DecimalJsLike | number | string | null
    dor?: number | null
    posicao?: $Enums.PosicaoPaciente | null
    origem?: $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SinaisVitaisCreateOrConnectWithoutEscalaDorInput = {
    where: SinaisVitaisWhereUniqueInput
    create: XOR<SinaisVitaisCreateWithoutEscalaDorInput, SinaisVitaisUncheckedCreateWithoutEscalaDorInput>
  }

  export type SinaisVitaisCreateManyEscalaDorInputEnvelope = {
    data: SinaisVitaisCreateManyEscalaDorInput | SinaisVitaisCreateManyEscalaDorInput[]
    skipDuplicates?: boolean
  }

  export type SinaisVitaisUpsertWithWhereUniqueWithoutEscalaDorInput = {
    where: SinaisVitaisWhereUniqueInput
    update: XOR<SinaisVitaisUpdateWithoutEscalaDorInput, SinaisVitaisUncheckedUpdateWithoutEscalaDorInput>
    create: XOR<SinaisVitaisCreateWithoutEscalaDorInput, SinaisVitaisUncheckedCreateWithoutEscalaDorInput>
  }

  export type SinaisVitaisUpdateWithWhereUniqueWithoutEscalaDorInput = {
    where: SinaisVitaisWhereUniqueInput
    data: XOR<SinaisVitaisUpdateWithoutEscalaDorInput, SinaisVitaisUncheckedUpdateWithoutEscalaDorInput>
  }

  export type SinaisVitaisUpdateManyWithWhereWithoutEscalaDorInput = {
    where: SinaisVitaisScalarWhereInput
    data: XOR<SinaisVitaisUpdateManyMutationInput, SinaisVitaisUncheckedUpdateManyWithoutEscalaDorInput>
  }

  export type AtendimentoCreateWithoutGlasgowsInput = {
    data: Date | string
    observacao?: string | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutAtendimentoInput
    paciente: PacienteCreateNestedOneWithoutAtendimentosInput
    profissional: ProfissionalCreateNestedOneWithoutAtendimentosInput
    evaDores?: EvaDorCreateNestedManyWithoutAtendimentoInput
    evolucoes?: EvolucaoCreateNestedManyWithoutAtendimentoInput
    sinaisVitais?: SinaisVitaisCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoUncheckedCreateWithoutGlasgowsInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    cdProfissional: number
    data: Date | string
    observacao?: string | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutAtendimentoInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutAtendimentoInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutAtendimentoInput
    sinaisVitais?: SinaisVitaisUncheckedCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoCreateOrConnectWithoutGlasgowsInput = {
    where: AtendimentoWhereUniqueInput
    create: XOR<AtendimentoCreateWithoutGlasgowsInput, AtendimentoUncheckedCreateWithoutGlasgowsInput>
  }

  export type ProfissionalCreateWithoutGlasgowsInput = {
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoCreateNestedManyWithoutProfissionalInput
    master: MasterCreateNestedOneWithoutProfissionaisInput
    ocupacao?: OcupacaoCreateNestedOneWithoutProfissionalsInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalUncheckedCreateWithoutGlasgowsInput = {
    id?: number
    cdMaster: number
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    cdOcupacao?: number | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutProfissionalInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalCreateOrConnectWithoutGlasgowsInput = {
    where: ProfissionalWhereUniqueInput
    create: XOR<ProfissionalCreateWithoutGlasgowsInput, ProfissionalUncheckedCreateWithoutGlasgowsInput>
  }

  export type AtendimentoUpsertWithoutGlasgowsInput = {
    update: XOR<AtendimentoUpdateWithoutGlasgowsInput, AtendimentoUncheckedUpdateWithoutGlasgowsInput>
    create: XOR<AtendimentoCreateWithoutGlasgowsInput, AtendimentoUncheckedCreateWithoutGlasgowsInput>
    where?: AtendimentoWhereInput
  }

  export type AtendimentoUpdateToOneWithWhereWithoutGlasgowsInput = {
    where?: AtendimentoWhereInput
    data: XOR<AtendimentoUpdateWithoutGlasgowsInput, AtendimentoUncheckedUpdateWithoutGlasgowsInput>
  }

  export type AtendimentoUpdateWithoutGlasgowsInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutAtendimentoNestedInput
    paciente?: PacienteUpdateOneRequiredWithoutAtendimentosNestedInput
    profissional?: ProfissionalUpdateOneRequiredWithoutAtendimentosNestedInput
    evaDores?: EvaDorUpdateManyWithoutAtendimentoNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutAtendimentoNestedInput
    sinaisVitais?: SinaisVitaisUpdateManyWithoutAtendimentoNestedInput
  }

  export type AtendimentoUncheckedUpdateWithoutGlasgowsInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    cdProfissional?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutAtendimentoNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutAtendimentoNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutAtendimentoNestedInput
    sinaisVitais?: SinaisVitaisUncheckedUpdateManyWithoutAtendimentoNestedInput
  }

  export type ProfissionalUpsertWithoutGlasgowsInput = {
    update: XOR<ProfissionalUpdateWithoutGlasgowsInput, ProfissionalUncheckedUpdateWithoutGlasgowsInput>
    create: XOR<ProfissionalCreateWithoutGlasgowsInput, ProfissionalUncheckedCreateWithoutGlasgowsInput>
    where?: ProfissionalWhereInput
  }

  export type ProfissionalUpdateToOneWithWhereWithoutGlasgowsInput = {
    where?: ProfissionalWhereInput
    data: XOR<ProfissionalUpdateWithoutGlasgowsInput, ProfissionalUncheckedUpdateWithoutGlasgowsInput>
  }

  export type ProfissionalUpdateWithoutGlasgowsInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutProfissionalNestedInput
    master?: MasterUpdateOneRequiredWithoutProfissionaisNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutProfissionalsNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutProfissionalNestedInput
  }

  export type ProfissionalUncheckedUpdateWithoutGlasgowsInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutProfissionalNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutProfissionalNestedInput
  }

  export type AtendimentoCreateWithoutAfericoesClinicasInput = {
    data: Date | string
    observacao?: string | null
    paciente: PacienteCreateNestedOneWithoutAtendimentosInput
    profissional: ProfissionalCreateNestedOneWithoutAtendimentosInput
    evaDores?: EvaDorCreateNestedManyWithoutAtendimentoInput
    evolucoes?: EvolucaoCreateNestedManyWithoutAtendimentoInput
    glasgows?: GlasgowCreateNestedManyWithoutAtendimentoInput
    sinaisVitais?: SinaisVitaisCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoUncheckedCreateWithoutAfericoesClinicasInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    cdProfissional: number
    data: Date | string
    observacao?: string | null
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutAtendimentoInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutAtendimentoInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutAtendimentoInput
    sinaisVitais?: SinaisVitaisUncheckedCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoCreateOrConnectWithoutAfericoesClinicasInput = {
    where: AtendimentoWhereUniqueInput
    create: XOR<AtendimentoCreateWithoutAfericoesClinicasInput, AtendimentoUncheckedCreateWithoutAfericoesClinicasInput>
  }

  export type ProfissionalCreateWithoutAfericoesClinicasInput = {
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    atendimentos?: AtendimentoCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowCreateNestedManyWithoutProfissionalInput
    master: MasterCreateNestedOneWithoutProfissionaisInput
    ocupacao?: OcupacaoCreateNestedOneWithoutProfissionalsInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalUncheckedCreateWithoutAfericoesClinicasInput = {
    id?: number
    cdMaster: number
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    cdOcupacao?: number | null
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutProfissionalInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalCreateOrConnectWithoutAfericoesClinicasInput = {
    where: ProfissionalWhereUniqueInput
    create: XOR<ProfissionalCreateWithoutAfericoesClinicasInput, ProfissionalUncheckedCreateWithoutAfericoesClinicasInput>
  }

  export type AtendimentoUpsertWithoutAfericoesClinicasInput = {
    update: XOR<AtendimentoUpdateWithoutAfericoesClinicasInput, AtendimentoUncheckedUpdateWithoutAfericoesClinicasInput>
    create: XOR<AtendimentoCreateWithoutAfericoesClinicasInput, AtendimentoUncheckedCreateWithoutAfericoesClinicasInput>
    where?: AtendimentoWhereInput
  }

  export type AtendimentoUpdateToOneWithWhereWithoutAfericoesClinicasInput = {
    where?: AtendimentoWhereInput
    data: XOR<AtendimentoUpdateWithoutAfericoesClinicasInput, AtendimentoUncheckedUpdateWithoutAfericoesClinicasInput>
  }

  export type AtendimentoUpdateWithoutAfericoesClinicasInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    paciente?: PacienteUpdateOneRequiredWithoutAtendimentosNestedInput
    profissional?: ProfissionalUpdateOneRequiredWithoutAtendimentosNestedInput
    evaDores?: EvaDorUpdateManyWithoutAtendimentoNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutAtendimentoNestedInput
    glasgows?: GlasgowUpdateManyWithoutAtendimentoNestedInput
    sinaisVitais?: SinaisVitaisUpdateManyWithoutAtendimentoNestedInput
  }

  export type AtendimentoUncheckedUpdateWithoutAfericoesClinicasInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    cdProfissional?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    evaDores?: EvaDorUncheckedUpdateManyWithoutAtendimentoNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutAtendimentoNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutAtendimentoNestedInput
    sinaisVitais?: SinaisVitaisUncheckedUpdateManyWithoutAtendimentoNestedInput
  }

  export type ProfissionalUpsertWithoutAfericoesClinicasInput = {
    update: XOR<ProfissionalUpdateWithoutAfericoesClinicasInput, ProfissionalUncheckedUpdateWithoutAfericoesClinicasInput>
    create: XOR<ProfissionalCreateWithoutAfericoesClinicasInput, ProfissionalUncheckedCreateWithoutAfericoesClinicasInput>
    where?: ProfissionalWhereInput
  }

  export type ProfissionalUpdateToOneWithWhereWithoutAfericoesClinicasInput = {
    where?: ProfissionalWhereInput
    data: XOR<ProfissionalUpdateWithoutAfericoesClinicasInput, ProfissionalUncheckedUpdateWithoutAfericoesClinicasInput>
  }

  export type ProfissionalUpdateWithoutAfericoesClinicasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    atendimentos?: AtendimentoUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUpdateManyWithoutProfissionalNestedInput
    master?: MasterUpdateOneRequiredWithoutProfissionaisNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutProfissionalsNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutProfissionalNestedInput
  }

  export type ProfissionalUncheckedUpdateWithoutAfericoesClinicasInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutProfissionalNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutProfissionalNestedInput
  }

  export type AtendimentoCreateWithoutEvaDoresInput = {
    data: Date | string
    observacao?: string | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutAtendimentoInput
    paciente: PacienteCreateNestedOneWithoutAtendimentosInput
    profissional: ProfissionalCreateNestedOneWithoutAtendimentosInput
    evolucoes?: EvolucaoCreateNestedManyWithoutAtendimentoInput
    glasgows?: GlasgowCreateNestedManyWithoutAtendimentoInput
    sinaisVitais?: SinaisVitaisCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoUncheckedCreateWithoutEvaDoresInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    cdProfissional: number
    data: Date | string
    observacao?: string | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutAtendimentoInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutAtendimentoInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutAtendimentoInput
    sinaisVitais?: SinaisVitaisUncheckedCreateNestedManyWithoutAtendimentoInput
  }

  export type AtendimentoCreateOrConnectWithoutEvaDoresInput = {
    where: AtendimentoWhereUniqueInput
    create: XOR<AtendimentoCreateWithoutEvaDoresInput, AtendimentoUncheckedCreateWithoutEvaDoresInput>
  }

  export type ProfissionalCreateWithoutEvaDoresInput = {
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowCreateNestedManyWithoutProfissionalInput
    master: MasterCreateNestedOneWithoutProfissionaisInput
    ocupacao?: OcupacaoCreateNestedOneWithoutProfissionalsInput
    usuarioAuths?: UsuarioAuthCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalUncheckedCreateWithoutEvaDoresInput = {
    id?: number
    cdMaster: number
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    cdOcupacao?: number | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutProfissionalInput
    usuarioAuths?: UsuarioAuthUncheckedCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalCreateOrConnectWithoutEvaDoresInput = {
    where: ProfissionalWhereUniqueInput
    create: XOR<ProfissionalCreateWithoutEvaDoresInput, ProfissionalUncheckedCreateWithoutEvaDoresInput>
  }

  export type AtendimentoUpsertWithoutEvaDoresInput = {
    update: XOR<AtendimentoUpdateWithoutEvaDoresInput, AtendimentoUncheckedUpdateWithoutEvaDoresInput>
    create: XOR<AtendimentoCreateWithoutEvaDoresInput, AtendimentoUncheckedCreateWithoutEvaDoresInput>
    where?: AtendimentoWhereInput
  }

  export type AtendimentoUpdateToOneWithWhereWithoutEvaDoresInput = {
    where?: AtendimentoWhereInput
    data: XOR<AtendimentoUpdateWithoutEvaDoresInput, AtendimentoUncheckedUpdateWithoutEvaDoresInput>
  }

  export type AtendimentoUpdateWithoutEvaDoresInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutAtendimentoNestedInput
    paciente?: PacienteUpdateOneRequiredWithoutAtendimentosNestedInput
    profissional?: ProfissionalUpdateOneRequiredWithoutAtendimentosNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutAtendimentoNestedInput
    glasgows?: GlasgowUpdateManyWithoutAtendimentoNestedInput
    sinaisVitais?: SinaisVitaisUpdateManyWithoutAtendimentoNestedInput
  }

  export type AtendimentoUncheckedUpdateWithoutEvaDoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    cdProfissional?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutAtendimentoNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutAtendimentoNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutAtendimentoNestedInput
    sinaisVitais?: SinaisVitaisUncheckedUpdateManyWithoutAtendimentoNestedInput
  }

  export type ProfissionalUpsertWithoutEvaDoresInput = {
    update: XOR<ProfissionalUpdateWithoutEvaDoresInput, ProfissionalUncheckedUpdateWithoutEvaDoresInput>
    create: XOR<ProfissionalCreateWithoutEvaDoresInput, ProfissionalUncheckedCreateWithoutEvaDoresInput>
    where?: ProfissionalWhereInput
  }

  export type ProfissionalUpdateToOneWithWhereWithoutEvaDoresInput = {
    where?: ProfissionalWhereInput
    data: XOR<ProfissionalUpdateWithoutEvaDoresInput, ProfissionalUncheckedUpdateWithoutEvaDoresInput>
  }

  export type ProfissionalUpdateWithoutEvaDoresInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUpdateManyWithoutProfissionalNestedInput
    master?: MasterUpdateOneRequiredWithoutProfissionaisNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutProfissionalsNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutProfissionalNestedInput
  }

  export type ProfissionalUncheckedUpdateWithoutEvaDoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutProfissionalNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutProfissionalNestedInput
  }

  export type PacienteCreateWithoutUsuarioAuthsInput = {
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    atendimentos?: AtendimentoCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoCreateNestedManyWithoutPacienteInput
    escolaridade?: EscolaridadeCreateNestedOneWithoutPacientesInput
    master: MasterCreateNestedOneWithoutPacientesInput
    ocupacao?: OcupacaoCreateNestedOneWithoutPacientesInput
    parentescoPacientes?: ParentescoPacienteCreateNestedManyWithoutPacienteInput
  }

  export type PacienteUncheckedCreateWithoutUsuarioAuthsInput = {
    cdMaster: number
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    cdEscolaridade?: number | null
    cdOcupacao?: number | null
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutPacienteInput
    contatos?: ContatoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    enderecos?: EnderecoPacienteUncheckedCreateNestedManyWithoutPacienteInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutPacienteInput
    parentescoPacientes?: ParentescoPacienteUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type PacienteCreateOrConnectWithoutUsuarioAuthsInput = {
    where: PacienteWhereUniqueInput
    create: XOR<PacienteCreateWithoutUsuarioAuthsInput, PacienteUncheckedCreateWithoutUsuarioAuthsInput>
  }

  export type MasterCreateWithoutUsuarioAuthsInput = {
    nome: string
    dtCadastro?: Date | string
    stInativo?: $Enums.SimNao | null
    pacientes?: PacienteCreateNestedManyWithoutMasterInput
    profissionais?: ProfissionalCreateNestedManyWithoutMasterInput
  }

  export type MasterUncheckedCreateWithoutUsuarioAuthsInput = {
    id?: number
    nome: string
    dtCadastro?: Date | string
    stInativo?: $Enums.SimNao | null
    pacientes?: PacienteUncheckedCreateNestedManyWithoutMasterInput
    profissionais?: ProfissionalUncheckedCreateNestedManyWithoutMasterInput
  }

  export type MasterCreateOrConnectWithoutUsuarioAuthsInput = {
    where: MasterWhereUniqueInput
    create: XOR<MasterCreateWithoutUsuarioAuthsInput, MasterUncheckedCreateWithoutUsuarioAuthsInput>
  }

  export type ProfissionalCreateWithoutUsuarioAuthsInput = {
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowCreateNestedManyWithoutProfissionalInput
    master: MasterCreateNestedOneWithoutProfissionaisInput
    ocupacao?: OcupacaoCreateNestedOneWithoutProfissionalsInput
  }

  export type ProfissionalUncheckedCreateWithoutUsuarioAuthsInput = {
    id?: number
    cdMaster: number
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    cdOcupacao?: number | null
    afericoesClinicas?: AfericaoClinicaUncheckedCreateNestedManyWithoutProfissionalInput
    atendimentos?: AtendimentoUncheckedCreateNestedManyWithoutProfissionalInput
    contatos?: ContatoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    enderecos?: EnderecoProfissionalUncheckedCreateNestedManyWithoutProfissionalInput
    evaDores?: EvaDorUncheckedCreateNestedManyWithoutProfissionalInput
    evolucoes?: EvolucaoUncheckedCreateNestedManyWithoutProfissionalInput
    glasgows?: GlasgowUncheckedCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalCreateOrConnectWithoutUsuarioAuthsInput = {
    where: ProfissionalWhereUniqueInput
    create: XOR<ProfissionalCreateWithoutUsuarioAuthsInput, ProfissionalUncheckedCreateWithoutUsuarioAuthsInput>
  }

  export type PacienteUpsertWithoutUsuarioAuthsInput = {
    update: XOR<PacienteUpdateWithoutUsuarioAuthsInput, PacienteUncheckedUpdateWithoutUsuarioAuthsInput>
    create: XOR<PacienteCreateWithoutUsuarioAuthsInput, PacienteUncheckedCreateWithoutUsuarioAuthsInput>
    where?: PacienteWhereInput
  }

  export type PacienteUpdateToOneWithWhereWithoutUsuarioAuthsInput = {
    where?: PacienteWhereInput
    data: XOR<PacienteUpdateWithoutUsuarioAuthsInput, PacienteUncheckedUpdateWithoutUsuarioAuthsInput>
  }

  export type PacienteUpdateWithoutUsuarioAuthsInput = {
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    atendimentos?: AtendimentoUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutPacienteNestedInput
    escolaridade?: EscolaridadeUpdateOneWithoutPacientesNestedInput
    master?: MasterUpdateOneRequiredWithoutPacientesNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutPacientesNestedInput
    parentescoPacientes?: ParentescoPacienteUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateWithoutUsuarioAuthsInput = {
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdEscolaridade?: NullableIntFieldUpdateOperationsInput | number | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutPacienteNestedInput
    parentescoPacientes?: ParentescoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type MasterUpsertWithoutUsuarioAuthsInput = {
    update: XOR<MasterUpdateWithoutUsuarioAuthsInput, MasterUncheckedUpdateWithoutUsuarioAuthsInput>
    create: XOR<MasterCreateWithoutUsuarioAuthsInput, MasterUncheckedCreateWithoutUsuarioAuthsInput>
    where?: MasterWhereInput
  }

  export type MasterUpdateToOneWithWhereWithoutUsuarioAuthsInput = {
    where?: MasterWhereInput
    data: XOR<MasterUpdateWithoutUsuarioAuthsInput, MasterUncheckedUpdateWithoutUsuarioAuthsInput>
  }

  export type MasterUpdateWithoutUsuarioAuthsInput = {
    nome?: StringFieldUpdateOperationsInput | string
    dtCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: PacienteUpdateManyWithoutMasterNestedInput
    profissionais?: ProfissionalUpdateManyWithoutMasterNestedInput
  }

  export type MasterUncheckedUpdateWithoutUsuarioAuthsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dtCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: PacienteUncheckedUpdateManyWithoutMasterNestedInput
    profissionais?: ProfissionalUncheckedUpdateManyWithoutMasterNestedInput
  }

  export type ProfissionalUpsertWithoutUsuarioAuthsInput = {
    update: XOR<ProfissionalUpdateWithoutUsuarioAuthsInput, ProfissionalUncheckedUpdateWithoutUsuarioAuthsInput>
    create: XOR<ProfissionalCreateWithoutUsuarioAuthsInput, ProfissionalUncheckedCreateWithoutUsuarioAuthsInput>
    where?: ProfissionalWhereInput
  }

  export type ProfissionalUpdateToOneWithWhereWithoutUsuarioAuthsInput = {
    where?: ProfissionalWhereInput
    data: XOR<ProfissionalUpdateWithoutUsuarioAuthsInput, ProfissionalUncheckedUpdateWithoutUsuarioAuthsInput>
  }

  export type ProfissionalUpdateWithoutUsuarioAuthsInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUpdateManyWithoutProfissionalNestedInput
    master?: MasterUpdateOneRequiredWithoutProfissionaisNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutProfissionalsNestedInput
  }

  export type ProfissionalUncheckedUpdateWithoutUsuarioAuthsInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutProfissionalNestedInput
  }

  export type PacienteCreateManyMasterInput = {
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    cdEscolaridade?: number | null
    cdOcupacao?: number | null
  }

  export type ProfissionalCreateManyMasterInput = {
    id?: number
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
    cdOcupacao?: number | null
  }

  export type UsuarioAuthCreateManyMasterInput = {
    id?: number
    email: string
    senhaHash: string
    role?: $Enums.RoleAuth
    cdProfissional?: number | null
    cdPaciente?: number | null
  }

  export type PacienteUpdateWithoutMasterInput = {
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    atendimentos?: AtendimentoUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutPacienteNestedInput
    escolaridade?: EscolaridadeUpdateOneWithoutPacientesNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutPacientesNestedInput
    parentescoPacientes?: ParentescoPacienteUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateWithoutMasterInput = {
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdEscolaridade?: NullableIntFieldUpdateOperationsInput | number | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutPacienteNestedInput
    parentescoPacientes?: ParentescoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateManyWithoutMasterInput = {
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdEscolaridade?: NullableIntFieldUpdateOperationsInput | number | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfissionalUpdateWithoutMasterInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUpdateManyWithoutProfissionalNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutProfissionalsNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutProfissionalNestedInput
  }

  export type ProfissionalUncheckedUpdateWithoutMasterInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutProfissionalNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutProfissionalNestedInput
  }

  export type ProfissionalUncheckedUpdateManyWithoutMasterInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsuarioAuthUpdateWithoutMasterInput = {
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAuthFieldUpdateOperationsInput | $Enums.RoleAuth
    paciente?: PacienteUpdateOneWithoutUsuarioAuthsNestedInput
    profissional?: ProfissionalUpdateOneWithoutUsuarioAuthsNestedInput
  }

  export type UsuarioAuthUncheckedUpdateWithoutMasterInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAuthFieldUpdateOperationsInput | $Enums.RoleAuth
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    cdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsuarioAuthUncheckedUpdateManyWithoutMasterInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAuthFieldUpdateOperationsInput | $Enums.RoleAuth
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    cdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AtendimentoCreateManyPacienteInput = {
    id?: number
    cdProfissional: number
    data: Date | string
    observacao?: string | null
  }

  export type ContatoPacienteCreateManyPacienteInput = {
    id?: number
    cdContato: number
  }

  export type EnderecoPacienteCreateManyPacienteInput = {
    id?: number
    cdEndereco: number
  }

  export type EvolucaoCreateManyPacienteInput = {
    id?: number
    cdAtendimento: number
    cdProfissional?: number | null
    data: Date | string
    texto: string
    tipoEvolucaoClinicaId?: number | null
  }

  export type ParentescoPacienteCreateManyPacienteInput = {
    id?: number
    cdPessoa: number
    parentesco: $Enums.TipoParentesco
  }

  export type UsuarioAuthCreateManyPacienteInput = {
    id?: number
    email: string
    senhaHash: string
    role?: $Enums.RoleAuth
    cdProfissional?: number | null
  }

  export type AtendimentoUpdateWithoutPacienteInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutAtendimentoNestedInput
    profissional?: ProfissionalUpdateOneRequiredWithoutAtendimentosNestedInput
    evaDores?: EvaDorUpdateManyWithoutAtendimentoNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutAtendimentoNestedInput
    glasgows?: GlasgowUpdateManyWithoutAtendimentoNestedInput
    sinaisVitais?: SinaisVitaisUpdateManyWithoutAtendimentoNestedInput
  }

  export type AtendimentoUncheckedUpdateWithoutPacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProfissional?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutAtendimentoNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutAtendimentoNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutAtendimentoNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutAtendimentoNestedInput
    sinaisVitais?: SinaisVitaisUncheckedUpdateManyWithoutAtendimentoNestedInput
  }

  export type AtendimentoUncheckedUpdateManyWithoutPacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProfissional?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContatoPacienteUpdateWithoutPacienteInput = {
    contato?: ContatoUpdateOneRequiredWithoutPacientesNestedInput
  }

  export type ContatoPacienteUncheckedUpdateWithoutPacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdContato?: IntFieldUpdateOperationsInput | number
  }

  export type ContatoPacienteUncheckedUpdateManyWithoutPacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdContato?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoPacienteUpdateWithoutPacienteInput = {
    endereco?: EnderecoUpdateOneRequiredWithoutPacientesNestedInput
  }

  export type EnderecoPacienteUncheckedUpdateWithoutPacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdEndereco?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoPacienteUncheckedUpdateManyWithoutPacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdEndereco?: IntFieldUpdateOperationsInput | number
  }

  export type EvolucaoUpdateWithoutPacienteInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    atendimento?: AtendimentoUpdateOneRequiredWithoutEvolucoesNestedInput
    profissional?: ProfissionalUpdateOneWithoutEvolucoesNestedInput
    tipoEvolucaoClinica?: TipoEvolucaoClinicaUpdateOneWithoutEvolucaosNestedInput
    cid?: EvolucaoCidUpdateManyWithoutEvolucaoNestedInput
    dsm?: EvolucaoDsmUpdateManyWithoutEvolucaoNestedInput
  }

  export type EvolucaoUncheckedUpdateWithoutPacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    tipoEvolucaoClinicaId?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: EvolucaoCidUncheckedUpdateManyWithoutEvolucaoNestedInput
    dsm?: EvolucaoDsmUncheckedUpdateManyWithoutEvolucaoNestedInput
  }

  export type EvolucaoUncheckedUpdateManyWithoutPacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    tipoEvolucaoClinicaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ParentescoPacienteUpdateWithoutPacienteInput = {
    parentesco?: EnumTipoParentescoFieldUpdateOperationsInput | $Enums.TipoParentesco
    pessoaRelacionada?: PessoaRelacionadaUpdateOneRequiredWithoutParentescosNestedInput
  }

  export type ParentescoPacienteUncheckedUpdateWithoutPacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdPessoa?: IntFieldUpdateOperationsInput | number
    parentesco?: EnumTipoParentescoFieldUpdateOperationsInput | $Enums.TipoParentesco
  }

  export type ParentescoPacienteUncheckedUpdateManyWithoutPacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdPessoa?: IntFieldUpdateOperationsInput | number
    parentesco?: EnumTipoParentescoFieldUpdateOperationsInput | $Enums.TipoParentesco
  }

  export type UsuarioAuthUpdateWithoutPacienteInput = {
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAuthFieldUpdateOperationsInput | $Enums.RoleAuth
    master?: MasterUpdateOneRequiredWithoutUsuarioAuthsNestedInput
    profissional?: ProfissionalUpdateOneWithoutUsuarioAuthsNestedInput
  }

  export type UsuarioAuthUncheckedUpdateWithoutPacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAuthFieldUpdateOperationsInput | $Enums.RoleAuth
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsuarioAuthUncheckedUpdateManyWithoutPacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAuthFieldUpdateOperationsInput | $Enums.RoleAuth
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AfericaoClinicaCreateManyProfissionalInput = {
    id?: number
    cdAtendimento: number
    escala: string
    idRegistro: number
    data?: Date | string
  }

  export type AtendimentoCreateManyProfissionalInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    data: Date | string
    observacao?: string | null
  }

  export type ContatoProfissionalCreateManyProfissionalInput = {
    id?: number
    cdContato: number
  }

  export type EnderecoProfissionalCreateManyProfissionalInput = {
    id?: number
    cdEndereco: number
  }

  export type EvaDorCreateManyProfissionalInput = {
    id?: number
    cdAtendimento: number
    data?: Date | string
    valor: number
    observacao?: string | null
  }

  export type EvolucaoCreateManyProfissionalInput = {
    id?: number
    cdAtendimento: number
    data: Date | string
    texto: string
    pacienteCdMaster?: number | null
    pacienteCdPaciente?: number | null
    tipoEvolucaoClinicaId?: number | null
  }

  export type GlasgowCreateManyProfissionalInput = {
    id?: number
    cdAtendimento: number
    data?: Date | string
    ocular: number
    verbal: number
    motora: number
    total: number
    observacao?: string | null
  }

  export type UsuarioAuthCreateManyProfissionalInput = {
    id?: number
    cdMaster: number
    email: string
    senhaHash: string
    role?: $Enums.RoleAuth
    cdPaciente?: number | null
  }

  export type AfericaoClinicaUpdateWithoutProfissionalInput = {
    escala?: StringFieldUpdateOperationsInput | string
    idRegistro?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    atendimento?: AtendimentoUpdateOneRequiredWithoutAfericoesClinicasNestedInput
  }

  export type AfericaoClinicaUncheckedUpdateWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    escala?: StringFieldUpdateOperationsInput | string
    idRegistro?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AfericaoClinicaUncheckedUpdateManyWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    escala?: StringFieldUpdateOperationsInput | string
    idRegistro?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AtendimentoUpdateWithoutProfissionalInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutAtendimentoNestedInput
    paciente?: PacienteUpdateOneRequiredWithoutAtendimentosNestedInput
    evaDores?: EvaDorUpdateManyWithoutAtendimentoNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutAtendimentoNestedInput
    glasgows?: GlasgowUpdateManyWithoutAtendimentoNestedInput
    sinaisVitais?: SinaisVitaisUpdateManyWithoutAtendimentoNestedInput
  }

  export type AtendimentoUncheckedUpdateWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutAtendimentoNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutAtendimentoNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutAtendimentoNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutAtendimentoNestedInput
    sinaisVitais?: SinaisVitaisUncheckedUpdateManyWithoutAtendimentoNestedInput
  }

  export type AtendimentoUncheckedUpdateManyWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContatoProfissionalUpdateWithoutProfissionalInput = {
    contato?: ContatoUpdateOneRequiredWithoutProfissionaisNestedInput
  }

  export type ContatoProfissionalUncheckedUpdateWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdContato?: IntFieldUpdateOperationsInput | number
  }

  export type ContatoProfissionalUncheckedUpdateManyWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdContato?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoProfissionalUpdateWithoutProfissionalInput = {
    endereco?: EnderecoUpdateOneRequiredWithoutProfissionaisNestedInput
  }

  export type EnderecoProfissionalUncheckedUpdateWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdEndereco?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoProfissionalUncheckedUpdateManyWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdEndereco?: IntFieldUpdateOperationsInput | number
  }

  export type EvaDorUpdateWithoutProfissionalInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    atendimento?: AtendimentoUpdateOneRequiredWithoutEvaDoresNestedInput
  }

  export type EvaDorUncheckedUpdateWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvaDorUncheckedUpdateManyWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvolucaoUpdateWithoutProfissionalInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    atendimento?: AtendimentoUpdateOneRequiredWithoutEvolucoesNestedInput
    paciente?: PacienteUpdateOneWithoutEvolucoesNestedInput
    tipoEvolucaoClinica?: TipoEvolucaoClinicaUpdateOneWithoutEvolucaosNestedInput
    cid?: EvolucaoCidUpdateManyWithoutEvolucaoNestedInput
    dsm?: EvolucaoDsmUpdateManyWithoutEvolucaoNestedInput
  }

  export type EvolucaoUncheckedUpdateWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    pacienteCdMaster?: NullableIntFieldUpdateOperationsInput | number | null
    pacienteCdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
    tipoEvolucaoClinicaId?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: EvolucaoCidUncheckedUpdateManyWithoutEvolucaoNestedInput
    dsm?: EvolucaoDsmUncheckedUpdateManyWithoutEvolucaoNestedInput
  }

  export type EvolucaoUncheckedUpdateManyWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    pacienteCdMaster?: NullableIntFieldUpdateOperationsInput | number | null
    pacienteCdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
    tipoEvolucaoClinicaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GlasgowUpdateWithoutProfissionalInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    ocular?: IntFieldUpdateOperationsInput | number
    verbal?: IntFieldUpdateOperationsInput | number
    motora?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    atendimento?: AtendimentoUpdateOneRequiredWithoutGlasgowsNestedInput
  }

  export type GlasgowUncheckedUpdateWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    ocular?: IntFieldUpdateOperationsInput | number
    verbal?: IntFieldUpdateOperationsInput | number
    motora?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GlasgowUncheckedUpdateManyWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    ocular?: IntFieldUpdateOperationsInput | number
    verbal?: IntFieldUpdateOperationsInput | number
    motora?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuarioAuthUpdateWithoutProfissionalInput = {
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAuthFieldUpdateOperationsInput | $Enums.RoleAuth
    paciente?: PacienteUpdateOneWithoutUsuarioAuthsNestedInput
    master?: MasterUpdateOneRequiredWithoutUsuarioAuthsNestedInput
  }

  export type UsuarioAuthUncheckedUpdateWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAuthFieldUpdateOperationsInput | $Enums.RoleAuth
    cdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsuarioAuthUncheckedUpdateManyWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleAuthFieldUpdateOperationsInput | $Enums.RoleAuth
    cdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EnderecoPacienteCreateManyEnderecoInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
  }

  export type EnderecoPessoaRelacionadaCreateManyEnderecoInput = {
    id?: number
    cdPessoa: number
  }

  export type EnderecoProfissionalCreateManyEnderecoInput = {
    id?: number
    cdProf: number
  }

  export type EnderecoPacienteUpdateWithoutEnderecoInput = {
    paciente?: PacienteUpdateOneRequiredWithoutEnderecosNestedInput
  }

  export type EnderecoPacienteUncheckedUpdateWithoutEnderecoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoPacienteUncheckedUpdateManyWithoutEnderecoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoPessoaRelacionadaUpdateWithoutEnderecoInput = {
    pessoaRelacionada?: PessoaRelacionadaUpdateOneRequiredWithoutEnderecosNestedInput
  }

  export type EnderecoPessoaRelacionadaUncheckedUpdateWithoutEnderecoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdPessoa?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoPessoaRelacionadaUncheckedUpdateManyWithoutEnderecoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdPessoa?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoProfissionalUpdateWithoutEnderecoInput = {
    profissional?: ProfissionalUpdateOneRequiredWithoutEnderecosNestedInput
  }

  export type EnderecoProfissionalUncheckedUpdateWithoutEnderecoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProf?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoProfissionalUncheckedUpdateManyWithoutEnderecoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProf?: IntFieldUpdateOperationsInput | number
  }

  export type ContatoPacienteCreateManyContatoInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
  }

  export type ContatoProfissionalCreateManyContatoInput = {
    id?: number
    cdProf: number
  }

  export type ContatoPacienteUpdateWithoutContatoInput = {
    paciente?: PacienteUpdateOneRequiredWithoutContatosNestedInput
  }

  export type ContatoPacienteUncheckedUpdateWithoutContatoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
  }

  export type ContatoPacienteUncheckedUpdateManyWithoutContatoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
  }

  export type ContatoProfissionalUpdateWithoutContatoInput = {
    profissional?: ProfissionalUpdateOneRequiredWithoutContatosNestedInput
  }

  export type ContatoProfissionalUncheckedUpdateWithoutContatoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProf?: IntFieldUpdateOperationsInput | number
  }

  export type ContatoProfissionalUncheckedUpdateManyWithoutContatoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProf?: IntFieldUpdateOperationsInput | number
  }

  export type AfericaoClinicaCreateManyAtendimentoInput = {
    id?: number
    cdProfissional?: number | null
    escala: string
    idRegistro: number
    data?: Date | string
  }

  export type EvaDorCreateManyAtendimentoInput = {
    id?: number
    cdProfissional?: number | null
    data?: Date | string
    valor: number
    observacao?: string | null
  }

  export type EvolucaoCreateManyAtendimentoInput = {
    id?: number
    cdProfissional?: number | null
    data: Date | string
    texto: string
    pacienteCdMaster?: number | null
    pacienteCdPaciente?: number | null
    tipoEvolucaoClinicaId?: number | null
  }

  export type GlasgowCreateManyAtendimentoInput = {
    id?: number
    cdProfissional?: number | null
    data?: Date | string
    ocular: number
    verbal: number
    motora: number
    total: number
    observacao?: string | null
  }

  export type SinaisVitaisCreateManyAtendimentoInput = {
    id?: number
    data?: Date | string
    paSistolica?: number | null
    paDiastolica?: number | null
    fc?: number | null
    fr?: number | null
    temperatura?: Decimal | DecimalJsLike | number | string | null
    spo2?: number | null
    peso?: Decimal | DecimalJsLike | number | string | null
    altura?: Decimal | DecimalJsLike | number | string | null
    imc?: Decimal | DecimalJsLike | number | string | null
    dor?: number | null
    escalaDorId?: number | null
    posicao?: $Enums.PosicaoPaciente | null
    origem?: $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AfericaoClinicaUpdateWithoutAtendimentoInput = {
    escala?: StringFieldUpdateOperationsInput | string
    idRegistro?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    profissional?: ProfissionalUpdateOneWithoutAfericoesClinicasNestedInput
  }

  export type AfericaoClinicaUncheckedUpdateWithoutAtendimentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    escala?: StringFieldUpdateOperationsInput | string
    idRegistro?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AfericaoClinicaUncheckedUpdateManyWithoutAtendimentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    escala?: StringFieldUpdateOperationsInput | string
    idRegistro?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaDorUpdateWithoutAtendimentoInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    profissional?: ProfissionalUpdateOneWithoutEvaDoresNestedInput
  }

  export type EvaDorUncheckedUpdateWithoutAtendimentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvaDorUncheckedUpdateManyWithoutAtendimentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvolucaoUpdateWithoutAtendimentoInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    profissional?: ProfissionalUpdateOneWithoutEvolucoesNestedInput
    paciente?: PacienteUpdateOneWithoutEvolucoesNestedInput
    tipoEvolucaoClinica?: TipoEvolucaoClinicaUpdateOneWithoutEvolucaosNestedInput
    cid?: EvolucaoCidUpdateManyWithoutEvolucaoNestedInput
    dsm?: EvolucaoDsmUpdateManyWithoutEvolucaoNestedInput
  }

  export type EvolucaoUncheckedUpdateWithoutAtendimentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    pacienteCdMaster?: NullableIntFieldUpdateOperationsInput | number | null
    pacienteCdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
    tipoEvolucaoClinicaId?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: EvolucaoCidUncheckedUpdateManyWithoutEvolucaoNestedInput
    dsm?: EvolucaoDsmUncheckedUpdateManyWithoutEvolucaoNestedInput
  }

  export type EvolucaoUncheckedUpdateManyWithoutAtendimentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    pacienteCdMaster?: NullableIntFieldUpdateOperationsInput | number | null
    pacienteCdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
    tipoEvolucaoClinicaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GlasgowUpdateWithoutAtendimentoInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    ocular?: IntFieldUpdateOperationsInput | number
    verbal?: IntFieldUpdateOperationsInput | number
    motora?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    profissional?: ProfissionalUpdateOneWithoutGlasgowsNestedInput
  }

  export type GlasgowUncheckedUpdateWithoutAtendimentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    ocular?: IntFieldUpdateOperationsInput | number
    verbal?: IntFieldUpdateOperationsInput | number
    motora?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GlasgowUncheckedUpdateManyWithoutAtendimentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    ocular?: IntFieldUpdateOperationsInput | number
    verbal?: IntFieldUpdateOperationsInput | number
    motora?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SinaisVitaisUpdateWithoutAtendimentoInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    paSistolica?: NullableIntFieldUpdateOperationsInput | number | null
    paDiastolica?: NullableIntFieldUpdateOperationsInput | number | null
    fc?: NullableIntFieldUpdateOperationsInput | number | null
    fr?: NullableIntFieldUpdateOperationsInput | number | null
    temperatura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    altura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dor?: NullableIntFieldUpdateOperationsInput | number | null
    posicao?: NullableEnumPosicaoPacienteFieldUpdateOperationsInput | $Enums.PosicaoPaciente | null
    origem?: NullableEnumOrigemAfericaoFieldUpdateOperationsInput | $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
    escalaDor?: EscalaDorUpdateOneWithoutSinaisVitaisNestedInput
  }

  export type SinaisVitaisUncheckedUpdateWithoutAtendimentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    paSistolica?: NullableIntFieldUpdateOperationsInput | number | null
    paDiastolica?: NullableIntFieldUpdateOperationsInput | number | null
    fc?: NullableIntFieldUpdateOperationsInput | number | null
    fr?: NullableIntFieldUpdateOperationsInput | number | null
    temperatura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    altura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dor?: NullableIntFieldUpdateOperationsInput | number | null
    escalaDorId?: NullableIntFieldUpdateOperationsInput | number | null
    posicao?: NullableEnumPosicaoPacienteFieldUpdateOperationsInput | $Enums.PosicaoPaciente | null
    origem?: NullableEnumOrigemAfericaoFieldUpdateOperationsInput | $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SinaisVitaisUncheckedUpdateManyWithoutAtendimentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    paSistolica?: NullableIntFieldUpdateOperationsInput | number | null
    paDiastolica?: NullableIntFieldUpdateOperationsInput | number | null
    fc?: NullableIntFieldUpdateOperationsInput | number | null
    fr?: NullableIntFieldUpdateOperationsInput | number | null
    temperatura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    altura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dor?: NullableIntFieldUpdateOperationsInput | number | null
    escalaDorId?: NullableIntFieldUpdateOperationsInput | number | null
    posicao?: NullableEnumPosicaoPacienteFieldUpdateOperationsInput | $Enums.PosicaoPaciente | null
    origem?: NullableEnumOrigemAfericaoFieldUpdateOperationsInput | $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EvolucaoCidCreateManyEvolucaoInput = {
    id?: number
    cdCid: number
  }

  export type EvolucaoDsmCreateManyEvolucaoInput = {
    id?: number
    cdDsm: number
  }

  export type EvolucaoCidUpdateWithoutEvolucaoInput = {
    cid?: CidUpdateOneRequiredWithoutEvolucaoCidsNestedInput
  }

  export type EvolucaoCidUncheckedUpdateWithoutEvolucaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdCid?: IntFieldUpdateOperationsInput | number
  }

  export type EvolucaoCidUncheckedUpdateManyWithoutEvolucaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdCid?: IntFieldUpdateOperationsInput | number
  }

  export type EvolucaoDsmUpdateWithoutEvolucaoInput = {
    dsm?: DsmUpdateOneRequiredWithoutEvolucaoDsmsNestedInput
  }

  export type EvolucaoDsmUncheckedUpdateWithoutEvolucaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdDsm?: IntFieldUpdateOperationsInput | number
  }

  export type EvolucaoDsmUncheckedUpdateManyWithoutEvolucaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdDsm?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoPessoaRelacionadaCreateManyPessoaRelacionadaInput = {
    id?: number
    cdEndereco: number
  }

  export type ParentescoPacienteCreateManyPessoaRelacionadaInput = {
    id?: number
    cdMaster: number
    cdPaciente: number
    parentesco: $Enums.TipoParentesco
  }

  export type EnderecoPessoaRelacionadaUpdateWithoutPessoaRelacionadaInput = {
    endereco?: EnderecoUpdateOneRequiredWithoutEnderecoPessoaRelacionadasNestedInput
  }

  export type EnderecoPessoaRelacionadaUncheckedUpdateWithoutPessoaRelacionadaInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdEndereco?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoPessoaRelacionadaUncheckedUpdateManyWithoutPessoaRelacionadaInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdEndereco?: IntFieldUpdateOperationsInput | number
  }

  export type ParentescoPacienteUpdateWithoutPessoaRelacionadaInput = {
    parentesco?: EnumTipoParentescoFieldUpdateOperationsInput | $Enums.TipoParentesco
    paciente?: PacienteUpdateOneRequiredWithoutParentescoPacientesNestedInput
  }

  export type ParentescoPacienteUncheckedUpdateWithoutPessoaRelacionadaInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    parentesco?: EnumTipoParentescoFieldUpdateOperationsInput | $Enums.TipoParentesco
  }

  export type ParentescoPacienteUncheckedUpdateManyWithoutPessoaRelacionadaInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    parentesco?: EnumTipoParentescoFieldUpdateOperationsInput | $Enums.TipoParentesco
  }

  export type CidadeCreateManyPaisInput = {
    id?: number
    descricao: string
    cdUf: string
    cepGeral?: string | null
    cdIbge?: number | null
    stInativo?: $Enums.SimNao | null
  }

  export type CidadeUpdateWithoutPaisInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairros?: BairroUpdateManyWithoutCidadeNestedInput
    uf?: UnidadeFederacaoUpdateOneRequiredWithoutCidadesNestedInput
    distritos?: DistritoUpdateManyWithoutCidadeNestedInput
    enderecos?: EnderecoUpdateManyWithoutCidadeNestedInput
  }

  export type CidadeUncheckedUpdateWithoutPaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    cdUf?: StringFieldUpdateOperationsInput | string
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairros?: BairroUncheckedUpdateManyWithoutCidadeNestedInput
    distritos?: DistritoUncheckedUpdateManyWithoutCidadeNestedInput
    enderecos?: EnderecoUncheckedUpdateManyWithoutCidadeNestedInput
  }

  export type CidadeUncheckedUpdateManyWithoutPaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    cdUf?: StringFieldUpdateOperationsInput | string
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type CidadeCreateManyUfInput = {
    id?: number
    descricao: string
    cdPais: number
    cepGeral?: string | null
    cdIbge?: number | null
    stInativo?: $Enums.SimNao | null
  }

  export type CidadeUpdateWithoutUfInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairros?: BairroUpdateManyWithoutCidadeNestedInput
    pais?: PaisUpdateOneRequiredWithoutCidadesNestedInput
    distritos?: DistritoUpdateManyWithoutCidadeNestedInput
    enderecos?: EnderecoUpdateManyWithoutCidadeNestedInput
  }

  export type CidadeUncheckedUpdateWithoutUfInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    cdPais?: IntFieldUpdateOperationsInput | number
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairros?: BairroUncheckedUpdateManyWithoutCidadeNestedInput
    distritos?: DistritoUncheckedUpdateManyWithoutCidadeNestedInput
    enderecos?: EnderecoUncheckedUpdateManyWithoutCidadeNestedInput
  }

  export type CidadeUncheckedUpdateManyWithoutUfInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    cdPais?: IntFieldUpdateOperationsInput | number
    cepGeral?: NullableStringFieldUpdateOperationsInput | string | null
    cdIbge?: NullableIntFieldUpdateOperationsInput | number | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type BairroCreateManyCidadeInput = {
    id?: number
    cdDistrito?: number | null
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type DistritoCreateManyCidadeInput = {
    id?: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type EnderecoCreateManyCidadeInput = {
    id?: number
    logradouro: string
    numero?: string | null
    complemento?: string | null
    cdBairro: number
    cep: string
    stInativo?: $Enums.SimNao | null
  }

  export type BairroUpdateWithoutCidadeInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    distrito?: DistritoUpdateOneWithoutBairrosNestedInput
    enderecos?: EnderecoUpdateManyWithoutBairroNestedInput
  }

  export type BairroUncheckedUpdateWithoutCidadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdDistrito?: NullableIntFieldUpdateOperationsInput | number | null
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    enderecos?: EnderecoUncheckedUpdateManyWithoutBairroNestedInput
  }

  export type BairroUncheckedUpdateManyWithoutCidadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdDistrito?: NullableIntFieldUpdateOperationsInput | number | null
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type DistritoUpdateWithoutCidadeInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairros?: BairroUpdateManyWithoutDistritoNestedInput
  }

  export type DistritoUncheckedUpdateWithoutCidadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairros?: BairroUncheckedUpdateManyWithoutDistritoNestedInput
  }

  export type DistritoUncheckedUpdateManyWithoutCidadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type EnderecoUpdateWithoutCidadeInput = {
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    bairro?: BairroUpdateOneRequiredWithoutEnderecosNestedInput
    pacientes?: EnderecoPacienteUpdateManyWithoutEnderecoNestedInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaUpdateManyWithoutEnderecoNestedInput
    profissionais?: EnderecoProfissionalUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateWithoutCidadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cdBairro?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: EnderecoPacienteUncheckedUpdateManyWithoutEnderecoNestedInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaUncheckedUpdateManyWithoutEnderecoNestedInput
    profissionais?: EnderecoProfissionalUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateManyWithoutCidadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cdBairro?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type PacienteCreateManyEscolaridadeInput = {
    cdMaster: number
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    cdOcupacao?: number | null
  }

  export type PacienteUpdateWithoutEscolaridadeInput = {
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    atendimentos?: AtendimentoUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutPacienteNestedInput
    master?: MasterUpdateOneRequiredWithoutPacientesNestedInput
    ocupacao?: OcupacaoUpdateOneWithoutPacientesNestedInput
    parentescoPacientes?: ParentescoPacienteUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateWithoutEscolaridadeInput = {
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutPacienteNestedInput
    parentescoPacientes?: ParentescoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateManyWithoutEscolaridadeInput = {
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdOcupacao?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PacienteCreateManyOcupacaoInput = {
    cdMaster: number
    cdPaciente: number
    nome: string
    sexo?: $Enums.Sexo | null
    dtNascimento?: Date | string | null
    stInativo?: $Enums.SimNao | null
    cdEscolaridade?: number | null
  }

  export type ProfissionalCreateManyOcupacaoInput = {
    id?: number
    cdMaster: number
    nome: string
    sexo?: $Enums.Sexo | null
    conselho?: string | null
    stInativo?: $Enums.SimNao | null
  }

  export type PacienteUpdateWithoutOcupacaoInput = {
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    atendimentos?: AtendimentoUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutPacienteNestedInput
    escolaridade?: EscolaridadeUpdateOneWithoutPacientesNestedInput
    master?: MasterUpdateOneRequiredWithoutPacientesNestedInput
    parentescoPacientes?: ParentescoPacienteUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateWithoutOcupacaoInput = {
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdEscolaridade?: NullableIntFieldUpdateOperationsInput | number | null
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutPacienteNestedInput
    contatos?: ContatoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    enderecos?: EnderecoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutPacienteNestedInput
    parentescoPacientes?: ParentescoPacienteUncheckedUpdateManyWithoutPacienteNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type PacienteUncheckedUpdateManyWithoutOcupacaoInput = {
    cdMaster?: IntFieldUpdateOperationsInput | number
    cdPaciente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    dtNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cdEscolaridade?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfissionalUpdateWithoutOcupacaoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUpdateManyWithoutProfissionalNestedInput
    master?: MasterUpdateOneRequiredWithoutProfissionaisNestedInput
    usuarioAuths?: UsuarioAuthUpdateManyWithoutProfissionalNestedInput
  }

  export type ProfissionalUncheckedUpdateWithoutOcupacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    afericoesClinicas?: AfericaoClinicaUncheckedUpdateManyWithoutProfissionalNestedInput
    atendimentos?: AtendimentoUncheckedUpdateManyWithoutProfissionalNestedInput
    contatos?: ContatoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    enderecos?: EnderecoProfissionalUncheckedUpdateManyWithoutProfissionalNestedInput
    evaDores?: EvaDorUncheckedUpdateManyWithoutProfissionalNestedInput
    evolucoes?: EvolucaoUncheckedUpdateManyWithoutProfissionalNestedInput
    glasgows?: GlasgowUncheckedUpdateManyWithoutProfissionalNestedInput
    usuarioAuths?: UsuarioAuthUncheckedUpdateManyWithoutProfissionalNestedInput
  }

  export type ProfissionalUncheckedUpdateManyWithoutOcupacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdMaster?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    conselho?: NullableStringFieldUpdateOperationsInput | string | null
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type BairroCreateManyDistritoInput = {
    id?: number
    cdCidade: number
    descricao: string
    stInativo?: $Enums.SimNao | null
  }

  export type BairroUpdateWithoutDistritoInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cidade?: CidadeUpdateOneRequiredWithoutBairrosNestedInput
    enderecos?: EnderecoUpdateManyWithoutBairroNestedInput
  }

  export type BairroUncheckedUpdateWithoutDistritoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdCidade?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    enderecos?: EnderecoUncheckedUpdateManyWithoutBairroNestedInput
  }

  export type BairroUncheckedUpdateManyWithoutDistritoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdCidade?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type EnderecoCreateManyBairroInput = {
    id?: number
    logradouro: string
    numero?: string | null
    complemento?: string | null
    cdCidade: number
    cep: string
    stInativo?: $Enums.SimNao | null
  }

  export type EnderecoUpdateWithoutBairroInput = {
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    cidade?: CidadeUpdateOneRequiredWithoutEnderecosNestedInput
    pacientes?: EnderecoPacienteUpdateManyWithoutEnderecoNestedInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaUpdateManyWithoutEnderecoNestedInput
    profissionais?: EnderecoProfissionalUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateWithoutBairroInput = {
    id?: IntFieldUpdateOperationsInput | number
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cdCidade?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
    pacientes?: EnderecoPacienteUncheckedUpdateManyWithoutEnderecoNestedInput
    enderecoPessoaRelacionadas?: EnderecoPessoaRelacionadaUncheckedUpdateManyWithoutEnderecoNestedInput
    profissionais?: EnderecoProfissionalUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateManyWithoutBairroInput = {
    id?: IntFieldUpdateOperationsInput | number
    logradouro?: StringFieldUpdateOperationsInput | string
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cdCidade?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    stInativo?: NullableEnumSimNaoFieldUpdateOperationsInput | $Enums.SimNao | null
  }

  export type EvolucaoCidCreateManyCidInput = {
    id?: number
    cdEvolucao: number
  }

  export type EvolucaoCidUpdateWithoutCidInput = {
    evolucao?: EvolucaoUpdateOneRequiredWithoutCidNestedInput
  }

  export type EvolucaoCidUncheckedUpdateWithoutCidInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdEvolucao?: IntFieldUpdateOperationsInput | number
  }

  export type EvolucaoCidUncheckedUpdateManyWithoutCidInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdEvolucao?: IntFieldUpdateOperationsInput | number
  }

  export type EvolucaoDsmCreateManyDsmInput = {
    id?: number
    cdEvolucao: number
  }

  export type EvolucaoDsmUpdateWithoutDsmInput = {
    evolucao?: EvolucaoUpdateOneRequiredWithoutDsmNestedInput
  }

  export type EvolucaoDsmUncheckedUpdateWithoutDsmInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdEvolucao?: IntFieldUpdateOperationsInput | number
  }

  export type EvolucaoDsmUncheckedUpdateManyWithoutDsmInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdEvolucao?: IntFieldUpdateOperationsInput | number
  }

  export type EvolucaoCreateManyTipoEvolucaoClinicaInput = {
    id?: number
    cdAtendimento: number
    cdProfissional?: number | null
    data: Date | string
    texto: string
    pacienteCdMaster?: number | null
    pacienteCdPaciente?: number | null
  }

  export type EvolucaoUpdateWithoutTipoEvolucaoClinicaInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    atendimento?: AtendimentoUpdateOneRequiredWithoutEvolucoesNestedInput
    profissional?: ProfissionalUpdateOneWithoutEvolucoesNestedInput
    paciente?: PacienteUpdateOneWithoutEvolucoesNestedInput
    cid?: EvolucaoCidUpdateManyWithoutEvolucaoNestedInput
    dsm?: EvolucaoDsmUpdateManyWithoutEvolucaoNestedInput
  }

  export type EvolucaoUncheckedUpdateWithoutTipoEvolucaoClinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    pacienteCdMaster?: NullableIntFieldUpdateOperationsInput | number | null
    pacienteCdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
    cid?: EvolucaoCidUncheckedUpdateManyWithoutEvolucaoNestedInput
    dsm?: EvolucaoDsmUncheckedUpdateManyWithoutEvolucaoNestedInput
  }

  export type EvolucaoUncheckedUpdateManyWithoutTipoEvolucaoClinicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    cdProfissional?: NullableIntFieldUpdateOperationsInput | number | null
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    texto?: StringFieldUpdateOperationsInput | string
    pacienteCdMaster?: NullableIntFieldUpdateOperationsInput | number | null
    pacienteCdPaciente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SinaisVitaisCreateManyEscalaDorInput = {
    id?: number
    cdAtendimento: number
    data?: Date | string
    paSistolica?: number | null
    paDiastolica?: number | null
    fc?: number | null
    fr?: number | null
    temperatura?: Decimal | DecimalJsLike | number | string | null
    spo2?: number | null
    peso?: Decimal | DecimalJsLike | number | string | null
    altura?: Decimal | DecimalJsLike | number | string | null
    imc?: Decimal | DecimalJsLike | number | string | null
    dor?: number | null
    posicao?: $Enums.PosicaoPaciente | null
    origem?: $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SinaisVitaisUpdateWithoutEscalaDorInput = {
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    paSistolica?: NullableIntFieldUpdateOperationsInput | number | null
    paDiastolica?: NullableIntFieldUpdateOperationsInput | number | null
    fc?: NullableIntFieldUpdateOperationsInput | number | null
    fr?: NullableIntFieldUpdateOperationsInput | number | null
    temperatura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    altura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dor?: NullableIntFieldUpdateOperationsInput | number | null
    posicao?: NullableEnumPosicaoPacienteFieldUpdateOperationsInput | $Enums.PosicaoPaciente | null
    origem?: NullableEnumOrigemAfericaoFieldUpdateOperationsInput | $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
    atendimento?: AtendimentoUpdateOneRequiredWithoutSinaisVitaisNestedInput
  }

  export type SinaisVitaisUncheckedUpdateWithoutEscalaDorInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    paSistolica?: NullableIntFieldUpdateOperationsInput | number | null
    paDiastolica?: NullableIntFieldUpdateOperationsInput | number | null
    fc?: NullableIntFieldUpdateOperationsInput | number | null
    fr?: NullableIntFieldUpdateOperationsInput | number | null
    temperatura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    altura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dor?: NullableIntFieldUpdateOperationsInput | number | null
    posicao?: NullableEnumPosicaoPacienteFieldUpdateOperationsInput | $Enums.PosicaoPaciente | null
    origem?: NullableEnumOrigemAfericaoFieldUpdateOperationsInput | $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SinaisVitaisUncheckedUpdateManyWithoutEscalaDorInput = {
    id?: IntFieldUpdateOperationsInput | number
    cdAtendimento?: IntFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    paSistolica?: NullableIntFieldUpdateOperationsInput | number | null
    paDiastolica?: NullableIntFieldUpdateOperationsInput | number | null
    fc?: NullableIntFieldUpdateOperationsInput | number | null
    fr?: NullableIntFieldUpdateOperationsInput | number | null
    temperatura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spo2?: NullableIntFieldUpdateOperationsInput | number | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    altura?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    imc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dor?: NullableIntFieldUpdateOperationsInput | number | null
    posicao?: NullableEnumPosicaoPacienteFieldUpdateOperationsInput | $Enums.PosicaoPaciente | null
    origem?: NullableEnumOrigemAfericaoFieldUpdateOperationsInput | $Enums.OrigemAfericao | null
    metadataRaw?: NullableJsonNullValueInput | InputJsonValue
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}